---
title: 無伺服器架構考量-無伺服器應用程式
description: 了解記錄、 追蹤與診斷的架構從狀態管理和調整，永續性儲存體的無伺服器應用程式的挑戰。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: b12a09c0fcef7e7ff954a3f959fb9e3080a6e859
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/10/2018
ms.locfileid: "53155060"
---
# <a name="serverless-architecture-considerations"></a><span data-ttu-id="a8218-103">無伺服器架構考量</span><span class="sxs-lookup"><span data-stu-id="a8218-103">Serverless architecture considerations</span></span>

<span data-ttu-id="a8218-104">採用無伺服器架構會帶來一些難題有待克服。</span><span class="sxs-lookup"><span data-stu-id="a8218-104">Adopting a serverless architecture does come with certain challenges.</span></span> <span data-ttu-id="a8218-105">本節將探討一些常見的考量来留意。</span><span class="sxs-lookup"><span data-stu-id="a8218-105">This section explores some of the more common considerations to be aware of.</span></span> <span data-ttu-id="a8218-106">所有這些挑戰都有解決方案。</span><span class="sxs-lookup"><span data-stu-id="a8218-106">All of these challenges have solutions.</span></span> <span data-ttu-id="a8218-107">如同所有的架構選擇，決定一伺不應該設定成只之後仔細地考量的優缺點。</span><span class="sxs-lookup"><span data-stu-id="a8218-107">As with all architecture choices, the decision to go serverless should be made only after carefully considering the pros and cons.</span></span> <span data-ttu-id="a8218-108">根據您的應用程式的需求，您可以決定的無伺服器的實作不是正確的解決方案，對於某些元件。</span><span class="sxs-lookup"><span data-stu-id="a8218-108">Depending on the needs of your application, you may decide a serverless implementation isn't the right solution for certain components.</span></span>

## <a name="managing-state"></a><span data-ttu-id="a8218-109">管理狀態</span><span class="sxs-lookup"><span data-stu-id="a8218-109">Managing state</span></span>

<span data-ttu-id="a8218-110">無伺服器函式，如同一般的微服務是無狀態的預設值。</span><span class="sxs-lookup"><span data-stu-id="a8218-110">Serverless functions, as with microservices in general, are stateless by default.</span></span> <span data-ttu-id="a8218-111">避免狀態是暫時的以相應放大，並提供恢復功能，而不需要集中的失敗點會啟用無伺服器。</span><span class="sxs-lookup"><span data-stu-id="a8218-111">Avoiding state enables serverless to be ephemeral, to scale out, and to provide resiliency without a central point of failure.</span></span> <span data-ttu-id="a8218-112">在某些情況下，商務程序會要求狀態。</span><span class="sxs-lookup"><span data-stu-id="a8218-112">In some circumstances, business processes require state.</span></span> <span data-ttu-id="a8218-113">如果您的程序需要狀態，您會有兩個選項。</span><span class="sxs-lookup"><span data-stu-id="a8218-113">If your process requires state, you have two options.</span></span> <span data-ttu-id="a8218-114">您可以採用無伺服器，比其他模型，或與提供狀態的個別服務的互動。</span><span class="sxs-lookup"><span data-stu-id="a8218-114">You can adopt a model other than serverless, or interact with a separate service that provides state.</span></span> <span data-ttu-id="a8218-115">新增狀態可以讓方案和讓它更難標尺，以及可能會建立單一失敗點。</span><span class="sxs-lookup"><span data-stu-id="a8218-115">Adding state can complicate the solution and make it harder to scale, and potentially create a single point of failure.</span></span> <span data-ttu-id="a8218-116">請仔細考慮您的函式是否絕對需要的狀態。</span><span class="sxs-lookup"><span data-stu-id="a8218-116">Carefully consider whether your function absolutely requires state.</span></span> <span data-ttu-id="a8218-117">如果答案為 「 是 」，判斷是否仍然合理實作使用無伺服器。</span><span class="sxs-lookup"><span data-stu-id="a8218-117">If the answer is "yes," determine whether it still makes sense to implement it with serverless.</span></span>

<span data-ttu-id="a8218-118">有數個解決方案來採用狀態，而不會危害的無伺服器的優點。</span><span class="sxs-lookup"><span data-stu-id="a8218-118">There are several solutions to adopt state without compromising the benefits of serverless.</span></span> <span data-ttu-id="a8218-119">一些較受歡迎的解決方案包括：</span><span class="sxs-lookup"><span data-stu-id="a8218-119">Some of the more popular solutions include:</span></span>

* <span data-ttu-id="a8218-120">使用暫存資料存放區或分散式快取，例如 Redis</span><span class="sxs-lookup"><span data-stu-id="a8218-120">Use a temporary data store or distributed cache, like Redis</span></span>
* <span data-ttu-id="a8218-121">將狀態儲存在資料庫中，例如 SQL 或 CosmosDB</span><span class="sxs-lookup"><span data-stu-id="a8218-121">Store state in a database, like SQL or CosmosDB</span></span>
* <span data-ttu-id="a8218-122">透過工作流程引擎，例如 durable functions 中處理狀態</span><span class="sxs-lookup"><span data-stu-id="a8218-122">Handle state through a workflow engine like durable functions</span></span>

<span data-ttu-id="a8218-123">重點是，您應該留意您正在考慮要實作使用無伺服器的處理序內的任何狀態管理的需求。</span><span class="sxs-lookup"><span data-stu-id="a8218-123">The bottom line is that you should be aware of the need for any state management within processes you're considering to implement with serverless.</span></span>

## <a name="long-running-processes"></a><span data-ttu-id="a8218-124">長時間執行的程序</span><span class="sxs-lookup"><span data-stu-id="a8218-124">Long-running processes</span></span>

<span data-ttu-id="a8218-125">無伺服器眾多益處依賴在暫時的處理程序。</span><span class="sxs-lookup"><span data-stu-id="a8218-125">Many benefits of serverless rely on the processes being ephemeral.</span></span> <span data-ttu-id="a8218-126">簡短的執行的時間，簡化無伺服器的提供者，以便釋出資源，在主機的函式結束和共用函式一樣。</span><span class="sxs-lookup"><span data-stu-id="a8218-126">Short run times make it easier for the serverless provider to free up resources as functions end and share functions across hosts.</span></span> <span data-ttu-id="a8218-127">大部分雲端提供者限制您的函式可以執行為大約 10 分鐘的時間總計。</span><span class="sxs-lookup"><span data-stu-id="a8218-127">Most cloud providers limit the total time your function can run to around 10 minutes.</span></span> <span data-ttu-id="a8218-128">如果您的程序可能要花較長，您可以考慮的替代實作。</span><span class="sxs-lookup"><span data-stu-id="a8218-128">If your process may take longer, you might consider an alternative implementation.</span></span>

<span data-ttu-id="a8218-129">有幾個例外狀況和解決方案。</span><span class="sxs-lookup"><span data-stu-id="a8218-129">There are a few exceptions and solutions.</span></span> <span data-ttu-id="a8218-130">其中一個解決方案可能是您的程序分成較小個別採取較少的時間執行的元件。</span><span class="sxs-lookup"><span data-stu-id="a8218-130">One solution may be to break your process into smaller components that individually take less time to run.</span></span> <span data-ttu-id="a8218-131">如果您的處理序執行長時間因為相依性，您也可以考慮使用長期函式類似的解決方案的非同步工作流程。</span><span class="sxs-lookup"><span data-stu-id="a8218-131">If your process runs long because of dependencies, you can also consider an asynchronous workflow using a solution like durable functions.</span></span> <span data-ttu-id="a8218-132">長期函式會暫停，並等候在外部處理序完成時，維護您的程序的狀態。</span><span class="sxs-lookup"><span data-stu-id="a8218-132">Durable functions pause and maintain the state of your process while it's waiting on an external process to finish.</span></span> <span data-ttu-id="a8218-133">非同步處理可減少實際的處理程序執行的時間。</span><span class="sxs-lookup"><span data-stu-id="a8218-133">Asynchronous handling reduces the time the actual process runs.</span></span>

## <a name="startup-time"></a><span data-ttu-id="a8218-134">啟動時間</span><span class="sxs-lookup"><span data-stu-id="a8218-134">Startup time</span></span>

<span data-ttu-id="a8218-135">與無伺服器實作的一個潛在問題是啟動時間。</span><span class="sxs-lookup"><span data-stu-id="a8218-135">One potential concern with serverless implementations is startup time.</span></span> <span data-ttu-id="a8218-136">為了節省資源，許多無伺服器的提供者會建立 「 依需求。 」 的基礎結構</span><span class="sxs-lookup"><span data-stu-id="a8218-136">To conserve resources, many serverless providers create infrastructure "on demand."</span></span> <span data-ttu-id="a8218-137">在一段時間之後觸發無伺服器函式時，以裝載函式的資源可能需要建立或重新啟動。</span><span class="sxs-lookup"><span data-stu-id="a8218-137">When a serverless function is triggered after a period of time, the resources to host the function may need to be created or restarted.</span></span> <span data-ttu-id="a8218-138">在某些情況下，冷啟動可能會導致延遲數秒。</span><span class="sxs-lookup"><span data-stu-id="a8218-138">In some situations, cold starts may result in delays of several seconds.</span></span> <span data-ttu-id="a8218-139">啟動時間是根據提供者和服務層級而異。</span><span class="sxs-lookup"><span data-stu-id="a8218-139">Startup time varies across providers and service levels.</span></span> <span data-ttu-id="a8218-140">如果一定要減少應用程式的成功，則需要有位址啟動時間的幾個方法。</span><span class="sxs-lookup"><span data-stu-id="a8218-140">There are a few approaches to address startup time if it's important to minimize for the success of the app.</span></span>

* <span data-ttu-id="a8218-141">某些提供者可讓使用者支付保證 「 永遠開啟 」 基礎結構的服務層級。</span><span class="sxs-lookup"><span data-stu-id="a8218-141">Some providers allow users to pay for service levels that guarantee infrastructure is "always on".</span></span>
* <span data-ttu-id="a8218-142">實作為 keep-alive 機制 (ping 的端點，將"甦醒狀態 」)。</span><span class="sxs-lookup"><span data-stu-id="a8218-142">Implement a keep-alive mechanism (ping the endpoint to keep it "awake").</span></span>
* <span data-ttu-id="a8218-143">使用 Kubernetes 等的協調流程使用 （因此分內快速啟動新的執行個體是非常快速，則主機正在已經執行） 的容器化的函式方法。</span><span class="sxs-lookup"><span data-stu-id="a8218-143">Use orchestration like Kubernetes with a containerized function approach (the host is already running so spinning up new instances is extremely fast).</span></span>

## <a name="database-updates-and-migrations"></a><span data-ttu-id="a8218-144">資料庫更新和移轉</span><span class="sxs-lookup"><span data-stu-id="a8218-144">Database updates and migrations</span></span>

<span data-ttu-id="a8218-145">無伺服器程式碼的優點是，您還可以發行新的函式，而不必重新部署整個應用程式。</span><span class="sxs-lookup"><span data-stu-id="a8218-145">An advantage of serverless code is that you can release new functions without having to redeploy the entire application.</span></span> <span data-ttu-id="a8218-146">沒有相關的關聯式資料庫時，這項優勢可能會變成一項缺點。</span><span class="sxs-lookup"><span data-stu-id="a8218-146">This advantage can become a disadvantage when there's a relational database involved.</span></span> <span data-ttu-id="a8218-147">變更資料庫結構描述很難與無伺服器的更新同步處理。</span><span class="sxs-lookup"><span data-stu-id="a8218-147">Changes to database schemas are difficult to synchronize with serverless updates.</span></span> <span data-ttu-id="a8218-148">當發生錯誤，並變更必須回復，會造成其他挑戰。</span><span class="sxs-lookup"><span data-stu-id="a8218-148">Additional challenges are posed when things go wrong and the changes must be rolled back.</span></span> <span data-ttu-id="a8218-149">微服務和無伺服器函式的最佳作法是他們擁有自己的資料的其中一個原因是資料完整性。</span><span class="sxs-lookup"><span data-stu-id="a8218-149">Data integrity is one reason that a best practice for microservices and serverless functions is that they own their own data.</span></span> <span data-ttu-id="a8218-150">您可將變更部署為單一單位的計算和資料。</span><span class="sxs-lookup"><span data-stu-id="a8218-150">It is possible to deploy changes as a single unit of compute and data.</span></span> <span data-ttu-id="a8218-151">事實上，許多舊版的系統功能必須是無伺服器架構與協調大型後端資料庫。</span><span class="sxs-lookup"><span data-stu-id="a8218-151">The reality is that many legacy systems feature a large back-end database that must be reconciled with the serverless architecture.</span></span>

<span data-ttu-id="a8218-152">若要解決結構描述版本控制是常用的方法是永遠不會修改現有的屬性和資料行，但改為加入新的資訊。</span><span class="sxs-lookup"><span data-stu-id="a8218-152">A popular approach to solve schema versioning is to never modify existing properties and columns, but instead add new information.</span></span> <span data-ttu-id="a8218-153">例如，請考慮將從布林值，變更 「 完成 」 旗標的待辦事項清單到 「 已完成日期 」。</span><span class="sxs-lookup"><span data-stu-id="a8218-153">For example, consider a change to move from a Boolean "completed" flag for a todo list to a "completed date."</span></span> <span data-ttu-id="a8218-154">而不是移除舊的欄位，將資料庫變更：</span><span class="sxs-lookup"><span data-stu-id="a8218-154">Instead of removing the old field, the database change will:</span></span>

1. <span data-ttu-id="a8218-155">加入新的 「 日期完成 」 的欄位。</span><span class="sxs-lookup"><span data-stu-id="a8218-155">Add a new "completed date" field.</span></span>
1. <span data-ttu-id="a8218-156">轉換 「 已完成 」 的布林值欄位，來評估是否已完成的日期是目前的日期之後的計算函式。</span><span class="sxs-lookup"><span data-stu-id="a8218-156">Transform the "completed" Boolean field to a computed function that evaluates whether the completed date is after the current date.</span></span>
1. <span data-ttu-id="a8218-157">新增觸發程序，將完成的日期設定為目前的日期，當設定已完成的布林值為 true。</span><span class="sxs-lookup"><span data-stu-id="a8218-157">Add a trigger to set the completed date to the current date when the completed Boolean is set to true.</span></span>

<span data-ttu-id="a8218-158">變更的順序可確保舊版程式碼會繼續執行 「 現狀 」，而較新的無伺服器函式可以利用新的欄位。</span><span class="sxs-lookup"><span data-stu-id="a8218-158">The sequence of changes ensures that legacy code continues to run "as is" while newer serverless functions can take advantage of the new field.</span></span>

<span data-ttu-id="a8218-159">如需詳細資料中無伺服器架構的詳細資訊，請參閱[分散式資料管理的挑戰和解決方案](../microservices-architecture/architect-microservice-container-applications/distributed-data-management.md)。</span><span class="sxs-lookup"><span data-stu-id="a8218-159">For more information about data in serverless architectures, see [Challenges and solutions for distributed data management](../microservices-architecture/architect-microservice-container-applications/distributed-data-management.md).</span></span>

## <a name="scaling"></a><span data-ttu-id="a8218-160">縮放</span><span class="sxs-lookup"><span data-stu-id="a8218-160">Scaling</span></span>

<span data-ttu-id="a8218-161">它是一個常見的誤解，無伺服器表示 「 任何伺服器。 」</span><span class="sxs-lookup"><span data-stu-id="a8218-161">It's a common misconception that serverless means "no server."</span></span> <span data-ttu-id="a8218-162">事實上，它是 「 較少伺服器。 」</span><span class="sxs-lookup"><span data-stu-id="a8218-162">It's in fact "less server."</span></span> <span data-ttu-id="a8218-163">有的事實是一定要了解談到調整備份基礎結構。</span><span class="sxs-lookup"><span data-stu-id="a8218-163">The fact there is a backing infrastructure is important to understand when it comes to scaling.</span></span> <span data-ttu-id="a8218-164">最無伺服器平台提供一組控制項來處理事件密度增加時，基礎結構應該如何調整。</span><span class="sxs-lookup"><span data-stu-id="a8218-164">Most serverless platforms provide a set of controls to handle how the infrastructure should scale when event density increases.</span></span> <span data-ttu-id="a8218-165">您可以選擇各種不同的選項，但您的策略可能會有所不同函式。</span><span class="sxs-lookup"><span data-stu-id="a8218-165">You can choose from a variety of options, but your strategy may vary depending on the function.</span></span> <span data-ttu-id="a8218-166">此外，函式通常執行下相關的主控件，以便在相同主機上的函式具有相同的調整選項。</span><span class="sxs-lookup"><span data-stu-id="a8218-166">Furthermore, functions are typically run under a related host, so that functions on the same host have the same scale options.</span></span> <span data-ttu-id="a8218-167">因此它是為了組織及職裝載哪些函式一起根據調整需求。</span><span class="sxs-lookup"><span data-stu-id="a8218-167">Therefore it is necessary to organize and strategize which functions are hosted together based on scale requirements.</span></span>

<span data-ttu-id="a8218-168">規則通常會指定如何相應增加 （增加的主機資源） 和向外延展 （增加主控件執行個體的數目） 根據不同的參數。</span><span class="sxs-lookup"><span data-stu-id="a8218-168">Rules often specify how to scale-up (increase the host resources) and scale-out (increase the number of host instances) based on varying parameters.</span></span> <span data-ttu-id="a8218-169">標尺的觸發程序可能包括排程、 要求率、 CPU 使用率和記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="a8218-169">Triggers for scales may include schedule, request rates, CPU utilization, and memory usage.</span></span> <span data-ttu-id="a8218-170">較高的效能通常需要付出成本。</span><span class="sxs-lookup"><span data-stu-id="a8218-170">Higher performance often comes at a greater cost.</span></span> <span data-ttu-id="a8218-171">隨著快速的要求率突然增加時，可能不會調整的成本較低、 以耗用量為基礎的方法。</span><span class="sxs-lookup"><span data-stu-id="a8218-171">The less expensive, consumption-based approaches may not scale as quickly when the request rate suddenly increases.</span></span> <span data-ttu-id="a8218-172">支付做好與付費的 「 保險成本 」 之間有所取捨完全是 「 當您移 」 和永無止盡速度較慢的回應，因為突然增加的需求。</span><span class="sxs-lookup"><span data-stu-id="a8218-172">There is a trade-off between paying up front "insurance cost" versus paying strictly "as you go" and risking slower responses due to sudden increases in demand.</span></span>

## <a name="monitoring-tracing-and-logging"></a><span data-ttu-id="a8218-173">監視、 追蹤和記錄</span><span class="sxs-lookup"><span data-stu-id="a8218-173">Monitoring, tracing, and logging</span></span>

<span data-ttu-id="a8218-174">DevOps 中經常被忽略的層面監視一次部署的應用程式。</span><span class="sxs-lookup"><span data-stu-id="a8218-174">An often overlooked aspect of DevOps is monitoring applications once deployed.</span></span> <span data-ttu-id="a8218-175">務必要有的策略來監視無伺服器函式。</span><span class="sxs-lookup"><span data-stu-id="a8218-175">It's important to have a strategy for monitoring serverless functions.</span></span> <span data-ttu-id="a8218-176">相互關聯，或辨識當使用者將多個函式呼叫相同的過程，通常是互動的最大的挑戰。</span><span class="sxs-lookup"><span data-stu-id="a8218-176">The biggest challenge is often correlation, or recognizing when a user calls multiple functions as part of the same interaction.</span></span> <span data-ttu-id="a8218-177">最無伺服器平台可讓主控台記錄，可以匯入協力廠商工具。</span><span class="sxs-lookup"><span data-stu-id="a8218-177">Most serverless platforms allow console logging that can be imported into third-party tools.</span></span> <span data-ttu-id="a8218-178">另外還有以自動化遙測收集、 產生及追蹤相互關聯識別碼，並監視特定的動作，以提供詳細的深入解析的選項。</span><span class="sxs-lookup"><span data-stu-id="a8218-178">There are also options to automate collection of telemetry, generate and track correlation IDs, and monitor specific actions to provide detailed insights.</span></span> <span data-ttu-id="a8218-179">Azure 提供的進階[Application Insights 平台](https://docs.microsoft.com/azure/azure-functions/functions-monitoring)進行監視和分析。</span><span class="sxs-lookup"><span data-stu-id="a8218-179">Azure provides the advanced [Application Insights platform](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) for monitoring and analytics.</span></span>

## <a name="inter-service-dependencies"></a><span data-ttu-id="a8218-180">服務間的相依性</span><span class="sxs-lookup"><span data-stu-id="a8218-180">Inter-service dependencies</span></span>

<span data-ttu-id="a8218-181">無伺服器架構可能包括依賴其他函式的函式。</span><span class="sxs-lookup"><span data-stu-id="a8218-181">A serverless architecture may include functions that rely on other functions.</span></span> <span data-ttu-id="a8218-182">事實上，並非不常見的無伺服器架構有多個服務呼叫彼此互動或分散式的交易的一部分。</span><span class="sxs-lookup"><span data-stu-id="a8218-182">In fact, it isn't uncommon in a serverless architecture to have multiple services call each other as part of an interaction or distributed transaction.</span></span> <span data-ttu-id="a8218-183">若要避免強式結合，建議您使用該服務不彼此直接參考。</span><span class="sxs-lookup"><span data-stu-id="a8218-183">To avoid strong coupling, it's recommended that services don't reference each other directly.</span></span> <span data-ttu-id="a8218-184">當服務端點需要變更時，直接參考可能會導致主要重構。</span><span class="sxs-lookup"><span data-stu-id="a8218-184">When the endpoint for a service needs to change, direct references could result in major refactoring.</span></span> <span data-ttu-id="a8218-185">建議的解決方案是要提供服務探索機制，例如登錄，可提供適當的結束點為要求類型。</span><span class="sxs-lookup"><span data-stu-id="a8218-185">A suggested solution is to provide a service discovery mechanism, such as a registry, that provides the appropriate end point for a request type.</span></span> <span data-ttu-id="a8218-186">另一個解決方案是運用佇列或主題等傳訊服務，服務之間的通訊。</span><span class="sxs-lookup"><span data-stu-id="a8218-186">Another solution is to leverage messaging services like queues or topics for communication between services.</span></span>

## <a name="managing-failure-and-providing-resiliency"></a><span data-ttu-id="a8218-187">管理失敗，並提供恢復功能</span><span class="sxs-lookup"><span data-stu-id="a8218-187">Managing failure and providing resiliency</span></span>

<span data-ttu-id="a8218-188">也很重要，請考慮*斷路器模式*:如果基於某些原因，服務會繼續失敗，並不建議您重複呼叫該服務。</span><span class="sxs-lookup"><span data-stu-id="a8218-188">It's also important to consider the *circuit-breaker pattern*: If, for some reason, a service continues to fail, it isn't advisable to call that service repeatedly.</span></span> <span data-ttu-id="a8218-189">相反地，稱為替代服務或傳回一則訊息，直到重新建立相依服務的健全狀況為止。</span><span class="sxs-lookup"><span data-stu-id="a8218-189">Instead, an alternative service is called or a message returned until the health of the dependent service is re-established.</span></span> <span data-ttu-id="a8218-190">無伺服器架構，就必須考慮解析和管理服務間的相依性的策略。</span><span class="sxs-lookup"><span data-stu-id="a8218-190">The serverless architecture needs to take into account the strategy for resolving and managing inter-service dependencies.</span></span>

<span data-ttu-id="a8218-191">若要繼續斷路器模式，服務必須可容錯且具有恢復功能。</span><span class="sxs-lookup"><span data-stu-id="a8218-191">To continue the circuit-breaker pattern, services need to be fault tolerant and resilient.</span></span> <span data-ttu-id="a8218-192">容錯移轉是指您即使在非預期的例外狀況之後繼續執行的應用程式的能力，或遇到無效的狀態。</span><span class="sxs-lookup"><span data-stu-id="a8218-192">Fault tolerance refers to the ability of your application to continue running even after unexpected exceptions or invalid states are encountered.</span></span> <span data-ttu-id="a8218-193">容錯移轉通常是程式碼本身的函式和如何寫完要處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="a8218-193">Fault tolerance is typically a function of the code itself and how it's written to handle exceptions.</span></span> <span data-ttu-id="a8218-194">復原是指如何支援應用程式是在從失敗復原。</span><span class="sxs-lookup"><span data-stu-id="a8218-194">Resiliency refers to how capable the app is at recovering from failures.</span></span> <span data-ttu-id="a8218-195">復原通常受無伺服器平台。</span><span class="sxs-lookup"><span data-stu-id="a8218-195">Resiliency is often managed by the serverless platform.</span></span> <span data-ttu-id="a8218-196">平台應該能夠現有失敗時，啟動新的無伺服器函式執行個體。</span><span class="sxs-lookup"><span data-stu-id="a8218-196">The platform should be able to spin up a new serverless function instance when the existing one fails.</span></span> <span data-ttu-id="a8218-197">平台應該也不夠聰明，無法停止微調，啟動新執行個體，每個新的執行個體失敗時。</span><span class="sxs-lookup"><span data-stu-id="a8218-197">The platform should also be intelligent enough to stop spinning up new instances when every new instance fails.</span></span>

<span data-ttu-id="a8218-198">如需詳細資訊，請參閱 <<c0> [ 實作斷路器模式](../microservices-architecture/implement-resilient-applications/implement-circuit-breaker-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="a8218-198">For more information, see [Implementing the Circuit Breaker pattern](../microservices-architecture/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span></span>

## <a name="versioning-and-greenblue-deployments"></a><span data-ttu-id="a8218-199">版本控制，而綠色/藍色的部署</span><span class="sxs-lookup"><span data-stu-id="a8218-199">Versioning and green/blue deployments</span></span>

<span data-ttu-id="a8218-200">無伺服器的主要優點是升級特定的函式，而不必重新部署整個應用程式的能力。</span><span class="sxs-lookup"><span data-stu-id="a8218-200">A major benefit of serverless is the ability to upgrade a specific function without having to redeploy the entire application.</span></span> <span data-ttu-id="a8218-201">若要成功升級，以便呼叫它們的服務會路由傳送至正確的程式碼版本必須已設定版本函式。</span><span class="sxs-lookup"><span data-stu-id="a8218-201">For upgrades to be successful, functions must be versioned so that services calling them are routed to the correct version of code.</span></span> <span data-ttu-id="a8218-202">部署新版本的策略也很重要的。</span><span class="sxs-lookup"><span data-stu-id="a8218-202">A strategy for deploying new versions is also important.</span></span> <span data-ttu-id="a8218-203">常見的方法是使用 「 綠色/藍色部署。 」</span><span class="sxs-lookup"><span data-stu-id="a8218-203">A common approach is to use "green/blue deployments."</span></span> <span data-ttu-id="a8218-204">綠色的部署是目前的函式。</span><span class="sxs-lookup"><span data-stu-id="a8218-204">The green deployment is the current function.</span></span> <span data-ttu-id="a8218-205">新的 「 藍色 」 版本是部署到生產環境，且測試。</span><span class="sxs-lookup"><span data-stu-id="a8218-205">A new "blue" version is deployed to production and tested.</span></span> <span data-ttu-id="a8218-206">在測試階段時，讓新的版本是即時交換的綠色和藍色的版本。</span><span class="sxs-lookup"><span data-stu-id="a8218-206">When testing passes, the green and blue versions are swapped so the new version comes live.</span></span> <span data-ttu-id="a8218-207">如果發生任何問題，他們可以互相交換上一步。</span><span class="sxs-lookup"><span data-stu-id="a8218-207">If any issues are encountered, they can be swapped back.</span></span> <span data-ttu-id="a8218-208">支援版本控制和綠色/藍色部署需要撰寫的函式，以容納版本變更，以及使用無伺服器的平台，可處理部署的組合。</span><span class="sxs-lookup"><span data-stu-id="a8218-208">Supporting versioning and green/blue deployments requires a combination of authoring the functions to accommodate version changes and working with the serverless platform to handle deployments.</span></span> <span data-ttu-id="a8218-209">其中一個方法是將 proxy 中所述[Azure 無伺服器平台](azure-functions.md#proxies)一章。</span><span class="sxs-lookup"><span data-stu-id="a8218-209">One possible approach is to use proxies, which are described in the [Azure serverless platform](azure-functions.md#proxies) chapter.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="a8218-210">[上一頁](serverless-architecture.md)
>[下一頁](serverless-design-examples.md)</span><span class="sxs-lookup"><span data-stu-id="a8218-210">[Previous](serverless-architecture.md)
[Next](serverless-design-examples.md)</span></span>