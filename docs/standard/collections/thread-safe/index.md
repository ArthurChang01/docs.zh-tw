---
title: "安全執行緒集合"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
caps.latest.revision: 
author: mairaw
ms.author: mairaw
manager: wpickett
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: ae53d5afbca15f8adafed428d4c2141312c972ed
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/23/2017
---
# <a name="thread-safe-collections"></a><span data-ttu-id="64135-102">安全執行緒集合</span><span class="sxs-lookup"><span data-stu-id="64135-102">Thread-Safe Collections</span></span>
<span data-ttu-id="64135-103">[!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] 引進 <xref:System.Collections.Concurrent?displayProperty=nameWithType> 命名空間，其中包含數個具備安全執行緒且可擴充的集合類別。</span><span class="sxs-lookup"><span data-stu-id="64135-103">The [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="64135-104">多個執行緒可以安全且有效率地新增或移除這些集合中的項目，而不需要利用使用者程式碼進行額外同步處理。</span><span class="sxs-lookup"><span data-stu-id="64135-104">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="64135-105">當您撰寫新的程式碼時，只要集合同時寫入多個執行緒，就使用並行集合類別。</span><span class="sxs-lookup"><span data-stu-id="64135-105">When you write new code, use the concurrent collection classes whenever the collection will be writing to multiple threads concurrently.</span></span> <span data-ttu-id="64135-106">如果您僅讀取共用集合，則可以使用 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空間中的類別。</span><span class="sxs-lookup"><span data-stu-id="64135-106">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="64135-107">除非您需要將目標設為 .NET Framework 1.1 或舊版本的執行階段，否則建議您不要使用 1.0 集合類別。</span><span class="sxs-lookup"><span data-stu-id="64135-107">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="64135-108">.NET Framework 1.0 和 2.0 集合中的執行緒同步處理</span><span class="sxs-lookup"><span data-stu-id="64135-108">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="64135-109">您可以在 <xref:System.Collections?displayProperty=nameWithType> 命名空間中找到 .NET Framework 1.0 中引進的集合。</span><span class="sxs-lookup"><span data-stu-id="64135-109">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="64135-110">這些包括常用 <xref:System.Collections.ArrayList> 和 <xref:System.Collections.Hashtable> 的集合透過 `Synchronized` 屬性來提供某種安全執行緒，而這個屬性會傳回集合的安全執行緒包裝函式。</span><span class="sxs-lookup"><span data-stu-id="64135-110">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="64135-111">包裝函式的運作方式是針對每個新增或移除作業鎖定整個集合。</span><span class="sxs-lookup"><span data-stu-id="64135-111">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="64135-112">因此，嘗試存取集合的每個執行緒都必須等待，直到輪到它取得一個鎖定。</span><span class="sxs-lookup"><span data-stu-id="64135-112">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="64135-113">這無法進行擴充，而且可能會造成大型集合的重大效能下降。</span><span class="sxs-lookup"><span data-stu-id="64135-113">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="64135-114">此外，設計未完全保護競爭情形。</span><span class="sxs-lookup"><span data-stu-id="64135-114">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="64135-115">如需詳細資訊，請參閱 MSDN 網站上的[在泛型集合中同步處理 (英文)](http://go.microsoft.com/fwlink/?LinkID=161130)。</span><span class="sxs-lookup"><span data-stu-id="64135-115">For more information, see [Synchronization in Generic Collections](http://go.microsoft.com/fwlink/?LinkID=161130) on the MSDN Web site.</span></span>  
  
 <span data-ttu-id="64135-116">您可以在 <xref:System.Collections.Generic?displayProperty=nameWithType> 命名空間中找到 .NET Framework 2.0 中引進的集合類別，</span><span class="sxs-lookup"><span data-stu-id="64135-116">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="64135-117">包括 <xref:System.Collections.Generic.List%601>、<xref:System.Collections.Generic.Dictionary%602> 等。</span><span class="sxs-lookup"><span data-stu-id="64135-117">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="64135-118">這些類別提供相較起 .NET Framework 1.0 類別的改良型別安全和效能。</span><span class="sxs-lookup"><span data-stu-id="64135-118">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="64135-119">不過，.NET Framework 2.0 集合類別不會提供任何執行緒同步處理；在多個執行緒上同時新增或移除項目時，使用者程式碼必須提供所有同步處理。</span><span class="sxs-lookup"><span data-stu-id="64135-119">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="64135-120">我們建議使用 [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] 中的並行集合類別，因為它們不僅提供 .NET Framework 2.0 集合類別的型別安全，而且效率和安全執行緒也會比 [!INCLUDE[net_v10_short](../../../../includes/net-v10-short-md.md)] 集合所提供的效率和安全執行緒更高且完整。</span><span class="sxs-lookup"><span data-stu-id="64135-120">We recommend the concurrent collections classes in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the [!INCLUDE[net_v10_short](../../../../includes/net-v10-short-md.md)] collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="64135-121">更細緻的鎖定和無鎖定機制</span><span class="sxs-lookup"><span data-stu-id="64135-121">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="64135-122">有些並行集合類型會使用輕量型同步處理機制，例如 [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)] 中新增的 <xref:System.Threading.SpinLock>、<xref:System.Threading.SpinWait>、<xref:System.Threading.SemaphoreSlim> 和 <xref:System.Threading.CountdownEvent>。</span><span class="sxs-lookup"><span data-stu-id="64135-122">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the [!INCLUDE[net_v40_short](../../../../includes/net-v40-short-md.md)].</span></span> <span data-ttu-id="64135-123">這些同步處理型別通常會先使用短期間的*忙碌旋轉*，再讓執行緒進入真正的 Wait 狀態。</span><span class="sxs-lookup"><span data-stu-id="64135-123">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="64135-124">預期等候時間很短時，旋轉的費用遠低於等待，這包含昂貴的核心轉換。</span><span class="sxs-lookup"><span data-stu-id="64135-124">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="64135-125">針對使用旋轉的集合類別，這個效率表示多個執行緒可以使用極高的速率來新增和移除項目。</span><span class="sxs-lookup"><span data-stu-id="64135-125">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="64135-126">如需旋轉與封鎖比較的詳細資訊，請參閱 [SpinLock](../../../../docs/standard/threading/spinlock.md) 和 [SpinWait](../../../../docs/standard/threading/spinwait.md)。</span><span class="sxs-lookup"><span data-stu-id="64135-126">For more information about spinning vs. blocking, see [SpinLock](../../../../docs/standard/threading/spinlock.md) and [SpinWait](../../../../docs/standard/threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="64135-127"><xref:System.Collections.Concurrent.ConcurrentQueue%601> 和 <xref:System.Collections.Concurrent.ConcurrentStack%601> 類別完全不使用鎖定。</span><span class="sxs-lookup"><span data-stu-id="64135-127">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="64135-128">相反地，它們依賴 <xref:System.Threading.Interlocked> 作業來取得安全執行緒。</span><span class="sxs-lookup"><span data-stu-id="64135-128">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="64135-129">因為並行集合類別支援 <xref:System.Collections.ICollection>，所以會提供 <xref:System.Collections.ICollection.IsSynchronized%2A> 和 <xref:System.Collections.ICollection.SyncRoot%2A> 屬性的實作，即使這些屬性無關也是一樣。</span><span class="sxs-lookup"><span data-stu-id="64135-129">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="64135-130">`IsSynchronized` 一律會傳回 `false`，而 `SyncRoot` 一律為 `null` (在 Visual Basic 中為 `Nothing`)。</span><span class="sxs-lookup"><span data-stu-id="64135-130">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="64135-131">下表列出 <xref:System.Collections.Concurrent?displayProperty=nameWithType> 命名空間中的集合類型。</span><span class="sxs-lookup"><span data-stu-id="64135-131">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="64135-132">類型</span><span class="sxs-lookup"><span data-stu-id="64135-132">Type</span></span>|<span data-ttu-id="64135-133">描述</span><span class="sxs-lookup"><span data-stu-id="64135-133">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="64135-134">提供任何可實作 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> 之類型的界限和封鎖功能。</span><span class="sxs-lookup"><span data-stu-id="64135-134">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="64135-135">如需詳細資訊，請參閱 [BlockingCollection 概觀](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="64135-135">For more information, see [BlockingCollection Overview](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="64135-136">索引鍵/值組字典的安全執行緒實作。</span><span class="sxs-lookup"><span data-stu-id="64135-136">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="64135-137">FIFO (先進先出) 佇列的安全執行緒實作。</span><span class="sxs-lookup"><span data-stu-id="64135-137">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="64135-138">LIFO (後進先出) 堆疊的安全執行緒實作。</span><span class="sxs-lookup"><span data-stu-id="64135-138">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="64135-139">未排序元素集合的安全執行緒實作。</span><span class="sxs-lookup"><span data-stu-id="64135-139">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="64135-140">類型必須實作以在 `BlockingCollection` 中使用的介面。</span><span class="sxs-lookup"><span data-stu-id="64135-140">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="64135-141">相關主題</span><span class="sxs-lookup"><span data-stu-id="64135-141">Related Topics</span></span>  
  
|<span data-ttu-id="64135-142">標題</span><span class="sxs-lookup"><span data-stu-id="64135-142">Title</span></span>|<span data-ttu-id="64135-143">描述</span><span class="sxs-lookup"><span data-stu-id="64135-143">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="64135-144">BlockingCollection 概觀</span><span class="sxs-lookup"><span data-stu-id="64135-144">BlockingCollection Overview</span></span>](../../../../docs/standard/collections/thread-safe/blockingcollection-overview.md)|<span data-ttu-id="64135-145">描述 <xref:System.Collections.Concurrent.BlockingCollection%601> 類型所提供的功能。</span><span class="sxs-lookup"><span data-stu-id="64135-145">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="64135-146">操作說明：在 ConcurrentDictionary 中新增和移除項目</span><span class="sxs-lookup"><span data-stu-id="64135-146">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-remove-items.md)|<span data-ttu-id="64135-147">描述如何新增和移除 <xref:System.Collections.Concurrent.ConcurrentDictionary%602> 中的項目</span><span class="sxs-lookup"><span data-stu-id="64135-147">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="64135-148">操作說明：從 BlockingCollection 個別新增和擷取項目</span><span class="sxs-lookup"><span data-stu-id="64135-148">How to: Add and Take Items Individually from a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-and-take-items.md)|<span data-ttu-id="64135-149">描述在未使用唯讀列舉值的情況下，如何新增和擷取封鎖回收中的項目。</span><span class="sxs-lookup"><span data-stu-id="64135-149">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="64135-150">操作說明：將界限和封鎖功能新增至集合</span><span class="sxs-lookup"><span data-stu-id="64135-150">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-add-bounding-and-blocking.md)|<span data-ttu-id="64135-151">描述如何使用任何集合類別作為 <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> 集合的基礎儲存機制。</span><span class="sxs-lookup"><span data-stu-id="64135-151">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="64135-152">操作說明：使用 ForEach 來移除 BlockingCollection 中的項目</span><span class="sxs-lookup"><span data-stu-id="64135-152">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-foreach-to-remove.md)|<span data-ttu-id="64135-153">描述如何使用 `foreach` (在 Visual Basic 中為 `For Each`) 來移除封鎖集合中的所有項目。</span><span class="sxs-lookup"><span data-stu-id="64135-153">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="64135-154">操作說明：在管線中使用封鎖集合的陣列</span><span class="sxs-lookup"><span data-stu-id="64135-154">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](../../../../docs/standard/collections/thread-safe/how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="64135-155">描述如何同時使用多個封鎖回收來實作管線。</span><span class="sxs-lookup"><span data-stu-id="64135-155">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="64135-156">操作說明：使用 ConcurrentBag 建立物件集區</span><span class="sxs-lookup"><span data-stu-id="64135-156">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](../../../../docs/standard/collections/thread-safe/how-to-create-an-object-pool.md)|<span data-ttu-id="64135-157">示範在您可以重複使用物件而非持續建立新物件的情況下，如何使用並行資料包改善效能。</span><span class="sxs-lookup"><span data-stu-id="64135-157">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="64135-158">參考資料</span><span class="sxs-lookup"><span data-stu-id="64135-158">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
