---
title: 執行緒和執行緒處理
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- multiple threads
- threading [.NET Framework]
- threading [.NET Framework], multiple threads
ms.assetid: 5baac3aa-e603-4fa6-9f89-0f2c1084e6b1
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 5049ed1b44155f3c21c53bef24a13006fe97a3fa
ms.sourcegitcommit: b22705f1540b237c566721018f974822d5cd8758
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/19/2018
ms.locfileid: "49452582"
---
# <a name="threads-and-threading"></a><span data-ttu-id="0b920-102">執行緒和執行緒處理</span><span class="sxs-lookup"><span data-stu-id="0b920-102">Threads and Threading</span></span>
<span data-ttu-id="0b920-103">作業系統會使用處理序來分隔它們所執行的各種不同應用程式。</span><span class="sxs-lookup"><span data-stu-id="0b920-103">Operating systems use processes to separate the different applications that they are executing.</span></span> <span data-ttu-id="0b920-104">執行緒是作業系統配置處理器時間的基本單位，而在該處理序內可以有多個執行緒執行程式碼。</span><span class="sxs-lookup"><span data-stu-id="0b920-104">Threads are the basic unit to which an operating system allocates processor time, and more than one thread can be executing code inside that process.</span></span> <span data-ttu-id="0b920-105">每個執行緒都保有例外處理常式、排程優先順序，以及系統用來儲存執行緒內容直到執行緒被排定為止的一組結構。</span><span class="sxs-lookup"><span data-stu-id="0b920-105">Each thread maintains exception handlers, a scheduling priority, and a set of structures the system uses to save the thread context until it is scheduled.</span></span> <span data-ttu-id="0b920-106">執行緒內容包括執行緒在執行緒主機處理序的位址空間中順暢繼續執行所需的所有資訊，包括執行緒的一組 CPU 暫存器和堆疊。</span><span class="sxs-lookup"><span data-stu-id="0b920-106">The thread context includes all the information the thread needs to seamlessly resume execution, including the thread's set of CPU registers and stack, in the address space of the thread's host process.</span></span>  
  
 <span data-ttu-id="0b920-107">.NET Framework 將作業系統處理序進一步細分成輕量型受控子處理序 (稱為應用程式定義域)，由 <xref:System.AppDomain?displayProperty=nameWithType> 代表。</span><span class="sxs-lookup"><span data-stu-id="0b920-107">The .NET Framework further subdivides an operating system process into lightweight managed subprocesses, called application domains, represented by <xref:System.AppDomain?displayProperty=nameWithType>.</span></span> <span data-ttu-id="0b920-108">一或多個受控執行緒 (由 <xref:System.Threading.Thread?displayProperty=nameWithType> 代表) 可以在相同受控處理序內的一個或任何數量的應用程式定義域中執行。</span><span class="sxs-lookup"><span data-stu-id="0b920-108">One or more managed threads (represented by <xref:System.Threading.Thread?displayProperty=nameWithType>) can run in one or any number of application domains within the same managed process.</span></span> <span data-ttu-id="0b920-109">雖然每個應用程式定義域都是從單一執行緒開始，但該應用程式定義域中的程式碼可以建立額外的應用程式定義域和額外的執行緒。</span><span class="sxs-lookup"><span data-stu-id="0b920-109">Although each application domain is started with a single thread, code in that application domain can create additional application domains and additional threads.</span></span> <span data-ttu-id="0b920-110">因此，受控執行緒可以在相同受控處理序內的應用程式定義域之間自由移動；您可以只使用一個執行緒在數個應用程式定義域之間移動。</span><span class="sxs-lookup"><span data-stu-id="0b920-110">The result is that a managed thread can move freely between application domains inside the same managed process; you might have only one thread moving among several application domains.</span></span>  
  
 <span data-ttu-id="0b920-111">作業系統如果支援先佔式多工作業，便可產生從多個處理序同時執行多個執行緒的效果。</span><span class="sxs-lookup"><span data-stu-id="0b920-111">An operating system that supports preemptive multitasking creates the effect of simultaneous execution of multiple threads from multiple processes.</span></span> <span data-ttu-id="0b920-112">做法是將可用的處理器時間分配給有需要的執行緒，將處理器時間配量依序配置給每個執行緒。</span><span class="sxs-lookup"><span data-stu-id="0b920-112">It does this by dividing the available processor time among the threads that need it, allocating a processor time slice to each thread one after another.</span></span> <span data-ttu-id="0b920-113">目前執行中的執行緒如果時間配量已過，就會暫停，而會由另一個執行緒繼續執行。</span><span class="sxs-lookup"><span data-stu-id="0b920-113">The currently executing thread is suspended when its time slice elapses, and another thread resumes running.</span></span> <span data-ttu-id="0b920-114">當系統從一個執行緒切換到另一個執行緒時，會儲存先佔執行緒的執行緒內容，然後重新載入執行緒佇列中下一個執行緒的已儲存執行緒內容。</span><span class="sxs-lookup"><span data-stu-id="0b920-114">When the system switches from one thread to another, it saves the thread context of the preempted thread and reloads the saved thread context of the next thread in the thread queue.</span></span>  
  
 <span data-ttu-id="0b920-115">時間配量的長短取決於作業系統和處理器。</span><span class="sxs-lookup"><span data-stu-id="0b920-115">The length of the time slice depends on the operating system and the processor.</span></span> <span data-ttu-id="0b920-116">由於每個時間配量都相當小，因此即使只有一個處理器，多個執行緒也會看似同時執行。</span><span class="sxs-lookup"><span data-stu-id="0b920-116">Because each time slice is small, multiple threads appear to be executing at the same time, even if there is only one processor.</span></span> <span data-ttu-id="0b920-117">這實際上就是多處理器系統上的情況，其中會在可用的處理器之間分配可執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="0b920-117">This is actually the case on multiprocessor systems, where the executable threads are distributed among the available processors.</span></span>  
  
## <a name="when-to-use-multiple-threads"></a><span data-ttu-id="0b920-118">使用多執行緒的時機</span><span class="sxs-lookup"><span data-stu-id="0b920-118">When To Use Multiple Threads</span></span>  
 <span data-ttu-id="0b920-119">軟體如果需要使用者互動，就必須能夠儘快回應使用者的活動，才能提供豐富的使用者體驗。</span><span class="sxs-lookup"><span data-stu-id="0b920-119">Software that requires user interaction must react to the user's activities as rapidly as possible to provide a rich user experience.</span></span> <span data-ttu-id="0b920-120">不過，同時它也必須執行儘快向使用者顯示資料所需的計算。</span><span class="sxs-lookup"><span data-stu-id="0b920-120">At the same time, however, it must do the calculations necessary to present data to the user as fast as possible.</span></span> <span data-ttu-id="0b920-121">如果您的應用程式只使用一個執行緒，您可以將[非同步程式設計](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)與 [.NET Framework 遠端處理](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kwdt6w2k(v=vs.100))或使用 ASP.NET 建立的 [XML Web 服務](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/7bkzywba(v=vs.100))結合，以除了您自己電腦的處理時間之外，再利用其他電腦的處理時間，來加快對使用者的回應速度及縮短您應用程式的資料處理時間。</span><span class="sxs-lookup"><span data-stu-id="0b920-121">If your application uses only one thread of execution, you can combine [asynchronous programming](../../../docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md) with [.NET Framework remoting](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/kwdt6w2k(v=vs.100)) or [XML Web services](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/7bkzywba(v=vs.100)) created using ASP.NET to use the processing time of other computers in addition to that of your own to increase responsiveness to the user and decrease the data processing time of your application.</span></span> <span data-ttu-id="0b920-122">如果您要執行大量輸入/輸出的工作，您也可以使用 I/O 完成連接埠來加快應用程式的回應速度。</span><span class="sxs-lookup"><span data-stu-id="0b920-122">If you are doing intensive input/output work, you can also use I/O completion ports to increase your application's responsiveness.</span></span>  
  
### <a name="advantages-of-multiple-threads"></a><span data-ttu-id="0b920-123">多執行緒的優點</span><span class="sxs-lookup"><span data-stu-id="0b920-123">Advantages of Multiple Threads</span></span>  
 <span data-ttu-id="0b920-124">無論如何，使用多個執行緒都是最強大的可用技術，不僅可加快對使用者的回應速度，還可處理讓作業幾乎同時完成所需的資料。</span><span class="sxs-lookup"><span data-stu-id="0b920-124">Using more than one thread, however, is the most powerful technique available to increase responsiveness to the user and process the data necessary to get the job done at almost the same time.</span></span> <span data-ttu-id="0b920-125">在有一個處理器的電腦上，多執行緒即可產生此效果，利用使用者事件之間的短暫時間在背景中處理資料。</span><span class="sxs-lookup"><span data-stu-id="0b920-125">On a computer with one processor, multiple threads can create this effect, taking advantage of the small periods of time in between user events to process the data in the background.</span></span> <span data-ttu-id="0b920-126">例如，使用者可以編輯試算表，而同時另一個執行緒則在相同的應用程式內重新計算該試算表的其他部分。</span><span class="sxs-lookup"><span data-stu-id="0b920-126">For example, a user can edit a spreadsheet while another thread is recalculating other parts of the spreadsheet within the same application.</span></span>  
  
 <span data-ttu-id="0b920-127">相同的應用程式無須經過任何修改，在多處理器電腦上執行時，即可大幅提升客戶滿意度。</span><span class="sxs-lookup"><span data-stu-id="0b920-127">Without modification, the same application would dramatically increase user satisfaction when run on a computer with more than one processor.</span></span> <span data-ttu-id="0b920-128">單一應用程式定義域可以使用多個執行緒來完成下列工作：</span><span class="sxs-lookup"><span data-stu-id="0b920-128">Your single application domain could use multiple threads to accomplish the following tasks:</span></span>  
  
-   <span data-ttu-id="0b920-129">透過網路與 Web 伺服器及資料庫進行通訊。</span><span class="sxs-lookup"><span data-stu-id="0b920-129">Communicate over a network, to a Web server, and to a database.</span></span>  
  
-   <span data-ttu-id="0b920-130">執行耗費大量時間的作業。</span><span class="sxs-lookup"><span data-stu-id="0b920-130">Perform operations that take a large amount of time.</span></span>  
  
-   <span data-ttu-id="0b920-131">區分不同優先順序的工作。</span><span class="sxs-lookup"><span data-stu-id="0b920-131">Distinguish tasks of varying priority.</span></span> <span data-ttu-id="0b920-132">例如，高優先順序執行緒會應付緊急工作，而低優先順序執行緒則執行其他工作。</span><span class="sxs-lookup"><span data-stu-id="0b920-132">For example, a high-priority thread manages time-critical tasks, and a low-priority thread performs other tasks.</span></span>  
  
-   <span data-ttu-id="0b920-133">讓使用者介面保持回應，同時又配置時間給背景工作。</span><span class="sxs-lookup"><span data-stu-id="0b920-133">Allow the user interface to remain responsive, while allocating time to background tasks.</span></span>  
  
### <a name="disadvantages-of-multiple-threads"></a><span data-ttu-id="0b920-134">多執行緒的缺點</span><span class="sxs-lookup"><span data-stu-id="0b920-134">Disadvantages of Multiple Threads</span></span>  
 <span data-ttu-id="0b920-135">建議您儘可能只使用少量的執行緒，這樣可以將作業系統資源的使用量降到最低而提升效能。</span><span class="sxs-lookup"><span data-stu-id="0b920-135">It is recommended that you use as few threads as possible, thereby minimizing the use of operating-system resources and improving performance.</span></span> <span data-ttu-id="0b920-136">設計您的應用程式時，執行緒也有資源需求和潛在的衝突需要考量。</span><span class="sxs-lookup"><span data-stu-id="0b920-136">Threading also has resource requirements and potential conflicts to be considered when designing your application.</span></span> <span data-ttu-id="0b920-137">資源需求如下：</span><span class="sxs-lookup"><span data-stu-id="0b920-137">The resource requirements are as follows:</span></span>  
  
-   <span data-ttu-id="0b920-138">系統會耗用記憶體來處理處理序、**AppDomain** 物件及執行緒所需的內容資訊。</span><span class="sxs-lookup"><span data-stu-id="0b920-138">The system consumes memory for the context information required by processes, **AppDomain** objects, and threads.</span></span> <span data-ttu-id="0b920-139">因此，可建立的處理序、**AppDomain** 物件及執行緒數量會受到可用記憶體的限制。</span><span class="sxs-lookup"><span data-stu-id="0b920-139">Therefore, the number of processes, **AppDomain** objects, and threads that can be created is limited by available memory.</span></span>  
  
-   <span data-ttu-id="0b920-140">追蹤大量執行緒會耗用大量的處理器時間。</span><span class="sxs-lookup"><span data-stu-id="0b920-140">Keeping track of a large number of threads consumes significant processor time.</span></span> <span data-ttu-id="0b920-141">如果執行緒太多，則大多數執行緒將不會有任何明顯的進展。</span><span class="sxs-lookup"><span data-stu-id="0b920-141">If there are too many threads, most of them will not make significant progress.</span></span> <span data-ttu-id="0b920-142">如果大多數目前的執行緒都在一個處理序中，其他處理序中的執行緒排程頻率就會較低。</span><span class="sxs-lookup"><span data-stu-id="0b920-142">If most of the current threads are in one process, threads in other processes are scheduled less frequently.</span></span>  
  
-   <span data-ttu-id="0b920-143">控制具有許多執行緒的程式碼執行相當複雜，且可能成為許多 Bug 的來源。</span><span class="sxs-lookup"><span data-stu-id="0b920-143">Controlling code execution with many threads is complex, and can be a source of many bugs.</span></span>  
  
-   <span data-ttu-id="0b920-144">若要終結執行緒，必須知道其可能的後果及如何處理這些問題。</span><span class="sxs-lookup"><span data-stu-id="0b920-144">Destroying threads requires knowing what could happen and handling those issues.</span></span>  
  
 <span data-ttu-id="0b920-145">提供對資源的共用存取權可能會造成衝突。</span><span class="sxs-lookup"><span data-stu-id="0b920-145">Providing shared access to resources can create conflicts.</span></span> <span data-ttu-id="0b920-146">若要避免衝突，您必須同步處理共用資源，或控制對共用資源的存取。</span><span class="sxs-lookup"><span data-stu-id="0b920-146">To avoid conflicts, you must synchronize, or control the access to, shared resources.</span></span> <span data-ttu-id="0b920-147">如果無法正確地同步處理存取權 (在相同或不同的應用程式定義域中)，可能會導致發生問題，例如死結 (兩個執行緒互相等候對方完成而停止回應) 和競爭條件 (因非預期嚴重倚賴兩個事件的時間而發生異常結果時)。</span><span class="sxs-lookup"><span data-stu-id="0b920-147">Failure to synchronize access properly (in the same or different application domains) can lead to problems such as deadlocks (in which two threads stop responding while each waits for the other to complete) and race conditions (when an anomalous result occurs due to an unexpected critical dependence on the timing of two events).</span></span> <span data-ttu-id="0b920-148">系統會提供同步處理物件，可用來協調多個執行緒之間的資源共用。</span><span class="sxs-lookup"><span data-stu-id="0b920-148">The system provides synchronization objects that can be used to coordinate resource sharing among multiple threads.</span></span> <span data-ttu-id="0b920-149">減少執行緒數量可以讓資源的同步處理變得更容易。</span><span class="sxs-lookup"><span data-stu-id="0b920-149">Reducing the number of threads makes it easier to synchronize resources.</span></span>  
  
 <span data-ttu-id="0b920-150">需要同步處理的資源包括：</span><span class="sxs-lookup"><span data-stu-id="0b920-150">Resources that require synchronization include:</span></span>  
  
-   <span data-ttu-id="0b920-151">系統資源 (例如通訊連接埠)。</span><span class="sxs-lookup"><span data-stu-id="0b920-151">System resources (such as communications ports).</span></span>  
  
-   <span data-ttu-id="0b920-152">多個處理序所共用的資源 (例如檔案控制代碼)。</span><span class="sxs-lookup"><span data-stu-id="0b920-152">Resources shared by multiple processes (such as file handles).</span></span>  
  
-   <span data-ttu-id="0b920-153">多個執行緒所存取之單一應用程式定義域的資源 (例如全域、靜態及執行個體欄位)。</span><span class="sxs-lookup"><span data-stu-id="0b920-153">The resources of a single application domain (such as global, static, and instance fields) accessed by multiple threads.</span></span>  
  
### <a name="threading-and-application-design"></a><span data-ttu-id="0b920-154">執行緒和應用程式設計</span><span class="sxs-lookup"><span data-stu-id="0b920-154">Threading and Application Design</span></span>  
 <span data-ttu-id="0b920-155">一般而言，針對不會阻礙其他執行緒的較簡短工作，以及當您不打算進行任何特定的工作排程時，使用 <xref:System.Threading.ThreadPool> 類別是處理多個執行緒的最簡單方法。</span><span class="sxs-lookup"><span data-stu-id="0b920-155">In general, using the <xref:System.Threading.ThreadPool> class is the easiest way to handle multiple threads for relatively short tasks that will not block other threads and when you do not expect any particular scheduling of the tasks.</span></span> <span data-ttu-id="0b920-156">不過，有幾個您應該建立自己的執行緒的理由：</span><span class="sxs-lookup"><span data-stu-id="0b920-156">However, there are a number of reasons to create your own threads:</span></span>  
  
-   <span data-ttu-id="0b920-157">如果您需要一個有特定優先順序的工作。</span><span class="sxs-lookup"><span data-stu-id="0b920-157">If you need a task to have a particular priority.</span></span>  
  
-   <span data-ttu-id="0b920-158">如果您有一個可能需要執行很久的工作 (因而會阻礙其他工作)。</span><span class="sxs-lookup"><span data-stu-id="0b920-158">If you have a task that might run a long time (and therefore block other tasks).</span></span>  
  
-   <span data-ttu-id="0b920-159">如果您需要將執行緒放入單一執行緒 Apartment 中 (所有 **ThreadPool** 執行緒都會在多執行緒 Apartment 中)。</span><span class="sxs-lookup"><span data-stu-id="0b920-159">If you need to place threads into a single-threaded apartment (all **ThreadPool** threads are in the multithreaded apartment).</span></span>  
  
-   <span data-ttu-id="0b920-160">如果您需要有一個與執行緒關聯的穩定身分識別。</span><span class="sxs-lookup"><span data-stu-id="0b920-160">If you need a stable identity associated with the thread.</span></span> <span data-ttu-id="0b920-161">例如，您應該使用專用執行緒來中止該執行緒、暫停它，或依名稱來探索它。</span><span class="sxs-lookup"><span data-stu-id="0b920-161">For example, you should use a dedicated thread to abort that thread, suspend it, or discover it by name.</span></span>  
  
-   <span data-ttu-id="0b920-162">如果您需要執行與使用者介面互動的背景執行緒，.NET Framework 2.0 版有提供一個使用事件來進行通訊的 <xref:System.ComponentModel.BackgroundWorker> 元件，可跨執行緒封送處理至使用者介面執行緒。</span><span class="sxs-lookup"><span data-stu-id="0b920-162">If you need to run background threads that interact with the user interface, the .NET Framework version 2.0 provides a <xref:System.ComponentModel.BackgroundWorker> component that communicates using events, with cross-thread marshaling to the user-interface thread.</span></span>  
  
### <a name="threading-and-exceptions"></a><span data-ttu-id="0b920-163">執行緒和例外狀況</span><span class="sxs-lookup"><span data-stu-id="0b920-163">Threading and Exceptions</span></span>  
 <span data-ttu-id="0b920-164">請務必處理執行緒中的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0b920-164">Do handle exceptions in threads.</span></span> <span data-ttu-id="0b920-165">執行緒 (甚至是背景執行緒) 中未處理的例外狀況通常會終止處理序。</span><span class="sxs-lookup"><span data-stu-id="0b920-165">Unhandled exceptions in threads, even background threads, generally terminate the process.</span></span> <span data-ttu-id="0b920-166">此規則有三個例外狀況：</span><span class="sxs-lookup"><span data-stu-id="0b920-166">There are three exceptions to this rule:</span></span>  
  
-   <span data-ttu-id="0b920-167">因為呼叫了 <xref:System.Threading.Thread.Abort%2A>，而導致執行緒中擲回 <xref:System.Threading.ThreadAbortException>。</span><span class="sxs-lookup"><span data-stu-id="0b920-167">A <xref:System.Threading.ThreadAbortException> is thrown in a thread because <xref:System.Threading.Thread.Abort%2A> was called.</span></span>  
  
-   <span data-ttu-id="0b920-168">因為將應用程式定義域卸載，而導致執行緒中擲回 <xref:System.AppDomainUnloadedException>。</span><span class="sxs-lookup"><span data-stu-id="0b920-168">An <xref:System.AppDomainUnloadedException> is thrown in a thread because the application domain is being unloaded.</span></span>  
  
-   <span data-ttu-id="0b920-169">Common Language Runtime 或主應用程式處理序會結束這個執行緒。</span><span class="sxs-lookup"><span data-stu-id="0b920-169">The common language runtime or a host process terminates the thread.</span></span>  
  
 <span data-ttu-id="0b920-170">如需詳細資訊，請參閱[受控執行緒中的例外狀況](../../../docs/standard/threading/exceptions-in-managed-threads.md)。</span><span class="sxs-lookup"><span data-stu-id="0b920-170">For more information, see [Exceptions in Managed Threads](../../../docs/standard/threading/exceptions-in-managed-threads.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0b920-171">在 .NET Framework 1.0 和 1.1 版中，通用語言執行平台會以無訊息模式截獲一些例外狀況 (例如在執行緒集區執行緒中)。</span><span class="sxs-lookup"><span data-stu-id="0b920-171">In the .NET Framework versions 1.0 and 1.1, the common language runtime silently traps some exceptions, for example in thread pool threads.</span></span> <span data-ttu-id="0b920-172">這可能會破壞應用程式狀態，最終導致應用程式沒有回應，而可能讓偵錯工作變得相當困難。</span><span class="sxs-lookup"><span data-stu-id="0b920-172">This may corrupt application state and eventually cause applications to hang, which might be very difficult to debug.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0b920-173">另請參閱</span><span class="sxs-lookup"><span data-stu-id="0b920-173">See also</span></span>

- <xref:System.Threading.ThreadPool>  
- <xref:System.ComponentModel.BackgroundWorker>  
- [<span data-ttu-id="0b920-174">同步處理多執行緒處理的資料</span><span class="sxs-lookup"><span data-stu-id="0b920-174">Synchronizing Data for Multithreading</span></span>](../../../docs/standard/threading/synchronizing-data-for-multithreading.md)  
- [<span data-ttu-id="0b920-175">Managed 執行緒集區</span><span class="sxs-lookup"><span data-stu-id="0b920-175">The Managed Thread Pool</span></span>](../../../docs/standard/threading/the-managed-thread-pool.md)
