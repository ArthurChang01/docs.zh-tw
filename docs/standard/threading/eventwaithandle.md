---
title: EventWaitHandle
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- threading [.NET Framework], EventWaitHandle class
- EventWaitHandle class
- event wait handles [.NET Framework]
- threading [.NET Framework], cross-process synchronization
ms.assetid: 11ee0b38-d663-4617-b793-35eb6c64e9fc
caps.latest.revision: "9"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 1bd248133bd95ff05246eb36a8e250247fd7ed61
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/21/2017
---
# <a name="eventwaithandle"></a><span data-ttu-id="8cba1-102">EventWaitHandle</span><span class="sxs-lookup"><span data-stu-id="8cba1-102">EventWaitHandle</span></span>
<span data-ttu-id="8cba1-103"><xref:System.Threading.EventWaitHandle>類別可讓執行緒信號和等候信號與對方進行通訊。</span><span class="sxs-lookup"><span data-stu-id="8cba1-103">The <xref:System.Threading.EventWaitHandle> class allows threads to communicate with each other by signaling and by waiting for signals.</span></span> <span data-ttu-id="8cba1-104">事件等候控制代碼 （也稱為事件） 都可以接收信號，才能發行一或多個等候中執行緒的等候控制代碼。</span><span class="sxs-lookup"><span data-stu-id="8cba1-104">Event wait handles (also referred to simply as events) are wait handles that can be signaled in order to release one or more waiting threads.</span></span> <span data-ttu-id="8cba1-105">收到信號之後，手動或自動，會重設事件等候控制代碼。</span><span class="sxs-lookup"><span data-stu-id="8cba1-105">After it is signaled, an event wait handle is reset either manually or automatically.</span></span> <span data-ttu-id="8cba1-106"><xref:System.Threading.EventWaitHandle>類別可代表其中一個本機事件等候控制代碼 （本機事件），或在具名的系統事件等候控制代碼 （名為可見的所有處理程序的系統事件）。</span><span class="sxs-lookup"><span data-stu-id="8cba1-106">The <xref:System.Threading.EventWaitHandle> class can represent either a local event wait handle (local event) or a named system event wait handle (named event or system event, visible to all processes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8cba1-107">事件等候控制代碼不是在概念上，通常是由這個文字的.NET Framework 中的事件。</span><span class="sxs-lookup"><span data-stu-id="8cba1-107">Event wait handles are not events in the sense usually meant by that word in the .NET Framework.</span></span> <span data-ttu-id="8cba1-108">沒有委派或事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="8cba1-108">There are no delegates or event handlers involved.</span></span> <span data-ttu-id="8cba1-109">「 事件 」 用來描述它們，因為它們具有傳統上稱為作業系統事件，而且發出信號，等候控制代碼的動作表示等候中執行緒已發生事件。</span><span class="sxs-lookup"><span data-stu-id="8cba1-109">The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.</span></span>  
  
 <span data-ttu-id="8cba1-110">這兩個本機和具名事件等候控制代碼使用系統同步處理物件，後者會受到保護<xref:Microsoft.Win32.SafeHandles.SafeWaitHandle>包裝函式，以確保會釋放資源。</span><span class="sxs-lookup"><span data-stu-id="8cba1-110">Both local and named event wait handles use system synchronization objects, which are protected by <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> wrappers to ensure that the resources are released.</span></span> <span data-ttu-id="8cba1-111">您可以使用<xref:System.Threading.WaitHandle.Dispose%2A>方法，當您完成使用物件立即釋放資源。</span><span class="sxs-lookup"><span data-stu-id="8cba1-111">You can use the <xref:System.Threading.WaitHandle.Dispose%2A> method to free the resources immediately when you have finished using the object.</span></span>  
  
## <a name="event-wait-handles-that-reset-automatically"></a><span data-ttu-id="8cba1-112">自動重設事件等候控制代碼</span><span class="sxs-lookup"><span data-stu-id="8cba1-112">Event Wait Handles That Reset Automatically</span></span>  
 <span data-ttu-id="8cba1-113">指定建立的自動重設事件<xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>當您建立<xref:System.Threading.EventWaitHandle>物件。</span><span class="sxs-lookup"><span data-stu-id="8cba1-113">You create an automatic reset event by specifying <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="8cba1-114">正如其名，這個同步處理事件會自動重設時收到信號之後釋出單一的等候執行緒。</span><span class="sxs-lookup"><span data-stu-id="8cba1-114">As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</span></span> <span data-ttu-id="8cba1-115">發出事件訊號藉由呼叫其<xref:System.Threading.EventWaitHandle.Set%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8cba1-115">Signal the event by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method.</span></span>  
  
 <span data-ttu-id="8cba1-116">自動重設事件通常用於一次提供單一執行緒的獨佔存取權的資源。</span><span class="sxs-lookup"><span data-stu-id="8cba1-116">Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</span></span> <span data-ttu-id="8cba1-117">執行緒藉由呼叫要求資源<xref:System.Threading.WaitHandle.WaitOne%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="8cba1-117">A thread requests the resource by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span> <span data-ttu-id="8cba1-118">如果沒有其他執行緒正在等候控制代碼，則方法會傳回`true`和呼叫端執行緒可以控制的資源。</span><span class="sxs-lookup"><span data-stu-id="8cba1-118">If no other thread is holding the wait handle, the method returns `true` and the calling thread has control of the resource.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8cba1-119">如同所有的同步處理機制，您必須確定所有程式碼路徑等候適當的等候控制代碼上才能存取受保護的資源。</span><span class="sxs-lookup"><span data-stu-id="8cba1-119">As with all synchronization mechanisms, you must ensure that all code paths wait on the appropriate wait handle before accessing a protected resource.</span></span> <span data-ttu-id="8cba1-120">執行緒同步處理是合作式。</span><span class="sxs-lookup"><span data-stu-id="8cba1-120">Thread synchronization is cooperative.</span></span>  
  
 <span data-ttu-id="8cba1-121">如果自動重設事件收到信號時沒有執行緒等候，它會保留信號直到執行緒嘗試在其上等候。</span><span class="sxs-lookup"><span data-stu-id="8cba1-121">If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</span></span> <span data-ttu-id="8cba1-122">事件會釋放執行緒，並立即重設，封鎖後續的執行緒。</span><span class="sxs-lookup"><span data-stu-id="8cba1-122">The event releases the thread and immediately resets, blocking subsequent threads.</span></span>  
  
## <a name="event-wait-handles-that-reset-manually"></a><span data-ttu-id="8cba1-123">事件等候控制代碼，手動重設</span><span class="sxs-lookup"><span data-stu-id="8cba1-123">Event Wait Handles That Reset Manually</span></span>  
 <span data-ttu-id="8cba1-124">指定建立手動重設事件<xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType>當您建立<xref:System.Threading.EventWaitHandle>物件。</span><span class="sxs-lookup"><span data-stu-id="8cba1-124">You create a manual reset event by specifying <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> when you create the <xref:System.Threading.EventWaitHandle> object.</span></span> <span data-ttu-id="8cba1-125">正如其名，這個同步處理事件必須手動重設之後尚未收到信號。</span><span class="sxs-lookup"><span data-stu-id="8cba1-125">As its name implies, this synchronization event must be reset manually after it has been signaled.</span></span> <span data-ttu-id="8cba1-126">重設，藉由呼叫其<xref:System.Threading.EventWaitHandle.Reset%2A>方法，等候事件控制代碼的執行緒立即繼續進行而不會封鎖。</span><span class="sxs-lookup"><span data-stu-id="8cba1-126">Until it is reset, by calling its <xref:System.Threading.EventWaitHandle.Reset%2A> method, threads that wait on the event handle proceed immediately without blocking.</span></span>  
  
 <span data-ttu-id="8cba1-127">手動重設事件的作用與閘道圍欄一樣。</span><span class="sxs-lookup"><span data-stu-id="8cba1-127">A manual reset event acts like the gate of a corral.</span></span> <span data-ttu-id="8cba1-128">事件未收到信號時封鎖在其等候的執行緒，就像是圍欄中。</span><span class="sxs-lookup"><span data-stu-id="8cba1-128">When the event is not signaled, threads that wait on it block, like horses in a corral.</span></span> <span data-ttu-id="8cba1-129">事件通知的時間，藉由呼叫其<xref:System.Threading.EventWaitHandle.Set%2A>方法，所有的等候中執行緒可用以繼續。</span><span class="sxs-lookup"><span data-stu-id="8cba1-129">When the event is signaled, by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, all waiting threads are free to proceed.</span></span> <span data-ttu-id="8cba1-130">事件會保留已收到信號，直到其<xref:System.Threading.EventWaitHandle.Reset%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="8cba1-130">The event remains signaled until its <xref:System.Threading.EventWaitHandle.Reset%2A> method is called.</span></span> <span data-ttu-id="8cba1-131">這可讓手動重設事件保留執行緒需要等候一個執行緒完成工作的理想方式。</span><span class="sxs-lookup"><span data-stu-id="8cba1-131">This makes the manual reset event an ideal way to hold up threads that need to wait until one thread finishes a task.</span></span>  
  
 <span data-ttu-id="8cba1-132">就像是離開圍欄，這需要釋放執行緒排程作業系統，並繼續執行的時間。</span><span class="sxs-lookup"><span data-stu-id="8cba1-132">Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</span></span> <span data-ttu-id="8cba1-133">如果<xref:System.Threading.EventWaitHandle.Reset%2A>方法在所有執行緒已都繼續執行之前呼叫，再次封鎖，剩餘的執行緒。</span><span class="sxs-lookup"><span data-stu-id="8cba1-133">If the <xref:System.Threading.EventWaitHandle.Reset%2A> method is called before all the threads have resumed execution, the remaining threads once again block.</span></span> <span data-ttu-id="8cba1-134">繼續執行與哪一個執行緒會封鎖取決於隨機因素，例如在系統上，執行緒數目負載等候排程器等等。</span><span class="sxs-lookup"><span data-stu-id="8cba1-134">Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</span></span> <span data-ttu-id="8cba1-135">如果通知事件的執行緒結束後發出訊號，這是最常見的使用模式，這並不是問題。</span><span class="sxs-lookup"><span data-stu-id="8cba1-135">This is not a problem if the thread that signals the event ends after signaling, which is the most common usage pattern.</span></span> <span data-ttu-id="8cba1-136">如果您想要開始新的工作在所有對事件發出信號等候執行緒都繼續執行的執行緒，您必須有繼續所有等候中執行緒，直到它封鎖。</span><span class="sxs-lookup"><span data-stu-id="8cba1-136">If you want the thread that signaled the event to begin a new task after all the waiting threads have resumed, you must block it until all the waiting threads have resumed.</span></span> <span data-ttu-id="8cba1-137">否則，您有競爭情形，，程式碼的行為無法預期。</span><span class="sxs-lookup"><span data-stu-id="8cba1-137">Otherwise, you have a race condition, and the behavior of your code is unpredictable.</span></span>  
  
## <a name="features-common-to-automatic-and-manual-events"></a><span data-ttu-id="8cba1-138">自動和手動事件通用的功能</span><span class="sxs-lookup"><span data-stu-id="8cba1-138">Features Common to Automatic and Manual Events</span></span>  
 <span data-ttu-id="8cba1-139">一般而言，一個或多個執行緒封鎖<xref:System.Threading.EventWaitHandle>之前解除封鎖的執行緒呼叫<xref:System.Threading.EventWaitHandle.Set%2A>方法，這個方法會釋放其中一個等候執行緒 （如果是自動重設事件），或全都 （如果是手動重設事件）。</span><span class="sxs-lookup"><span data-stu-id="8cba1-139">Typically, one or more threads block on an <xref:System.Threading.EventWaitHandle> until an unblocked thread calls the <xref:System.Threading.EventWaitHandle.Set%2A> method, which releases one of the waiting threads (in the case of automatic reset events) or all of them (in the case of manual reset events).</span></span> <span data-ttu-id="8cba1-140">執行緒可以發出信號<xref:System.Threading.EventWaitHandle>再封鎖，成為不可部分完成的作業，藉由呼叫靜態<xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="8cba1-140">A thread can signal an <xref:System.Threading.EventWaitHandle> and then block on it, as an atomic operation, by calling the static <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="8cba1-141"><xref:System.Threading.EventWaitHandle>物件可以用具有靜態<xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType>和<xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="8cba1-141"><xref:System.Threading.EventWaitHandle> objects can be used with the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="8cba1-142">因為<xref:System.Threading.EventWaitHandle>和<xref:System.Threading.Mutex>類別都衍生自<xref:System.Threading.WaitHandle>，您可以使用這兩個類別使用這些方法。</span><span class="sxs-lookup"><span data-stu-id="8cba1-142">Because the <xref:System.Threading.EventWaitHandle> and <xref:System.Threading.Mutex> classes both derive from <xref:System.Threading.WaitHandle>, you can use both classes with these methods.</span></span>  
  
### <a name="named-events"></a><span data-ttu-id="8cba1-143">具名的事件</span><span class="sxs-lookup"><span data-stu-id="8cba1-143">Named Events</span></span>  
 <span data-ttu-id="8cba1-144">Windows 作業系統可讓事件等候控制代碼具有的名稱。</span><span class="sxs-lookup"><span data-stu-id="8cba1-144">The Windows operating system allows event wait handles to have names.</span></span> <span data-ttu-id="8cba1-145">具名的事件是全系統性的。</span><span class="sxs-lookup"><span data-stu-id="8cba1-145">A named event is system wide.</span></span> <span data-ttu-id="8cba1-146">也就是說，一旦建立具名的事件時，即顯示所有處理序中的所有執行緒。</span><span class="sxs-lookup"><span data-stu-id="8cba1-146">That is, once the named event is created, it is visible to all threads in all processes.</span></span> <span data-ttu-id="8cba1-147">因此，具名的事件可用來同步處理程序及執行緒的活動。</span><span class="sxs-lookup"><span data-stu-id="8cba1-147">Thus, named events can be used to synchronize the activities of processes as well as threads.</span></span>  
  
 <span data-ttu-id="8cba1-148">您可以建立<xref:System.Threading.EventWaitHandle>物件，使用指定的事件名稱的建構函式的其中一個表示具名的系統事件。</span><span class="sxs-lookup"><span data-stu-id="8cba1-148">You can create an <xref:System.Threading.EventWaitHandle> object that represents a named system event by using one of the constructors that specifies an event name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8cba1-149">因為具名的事件是全系統，所以可能有多個<xref:System.Threading.EventWaitHandle>物件，代表相同具名事件。</span><span class="sxs-lookup"><span data-stu-id="8cba1-149">Because named events are system wide, it is possible to have multiple <xref:System.Threading.EventWaitHandle> objects that represent the same named event.</span></span> <span data-ttu-id="8cba1-150">每次呼叫建構函式，或<xref:System.Threading.EventWaitHandle.OpenExisting%2A>方法中，新<xref:System.Threading.EventWaitHandle>建立物件。</span><span class="sxs-lookup"><span data-stu-id="8cba1-150">Each time you call a constructor, or the <xref:System.Threading.EventWaitHandle.OpenExisting%2A> method, a new <xref:System.Threading.EventWaitHandle> object is created.</span></span> <span data-ttu-id="8cba1-151">重複指定相同的名稱，建立多個代表相同的具名的事件的物件。</span><span class="sxs-lookup"><span data-stu-id="8cba1-151">Specifying the same name repeatedly creates multiple objects that represent the same named event.</span></span>  
  
 <span data-ttu-id="8cba1-152">請謹慎地使用具名事件。</span><span class="sxs-lookup"><span data-stu-id="8cba1-152">Caution is advised in using named events.</span></span> <span data-ttu-id="8cba1-153">因為它們是全系統時，會使用相同名稱的另一個處理序可以意外封鎖執行緒。</span><span class="sxs-lookup"><span data-stu-id="8cba1-153">Because they are system wide, another process that uses the same name can block your threads unexpectedly.</span></span> <span data-ttu-id="8cba1-154">在同一部電腦上執行的惡意程式碼便可使用此點作為拒絕服務攻擊的基礎。</span><span class="sxs-lookup"><span data-stu-id="8cba1-154">Malicious code executing on the same computer could use this as the basis of a denial-of-service attack.</span></span>  
  
 <span data-ttu-id="8cba1-155">使用存取控制安全性來保護<xref:System.Threading.EventWaitHandle>物件，代表具名的事件，最好是使用指定的建構函式<xref:System.Security.AccessControl.EventWaitHandleSecurity>物件。</span><span class="sxs-lookup"><span data-stu-id="8cba1-155">Use access control security to protect an <xref:System.Threading.EventWaitHandle> object that represents a named event, preferably by using a constructor that specifies an <xref:System.Security.AccessControl.EventWaitHandleSecurity> object.</span></span> <span data-ttu-id="8cba1-156">您也可以套用存取控制安全性使用<xref:System.Threading.EventWaitHandle.SetAccessControl%2A>方法，但這離開視窗中的弱點可能會建立事件等候控制代碼時受到保護的時間之間。</span><span class="sxs-lookup"><span data-stu-id="8cba1-156">You can also apply access control security using the <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> method, but this leaves a window of vulnerability between the time the event wait handle is created and the time it is protected.</span></span> <span data-ttu-id="8cba1-157">保護事件使用存取控制安全性可以協助防止惡意攻擊，但不能解決意外名稱衝突的問題。</span><span class="sxs-lookup"><span data-stu-id="8cba1-157">Protecting events with access control security helps prevent malicious attacks, but it does not solve the problem of unintentional name collisions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8cba1-158">不同於<xref:System.Threading.EventWaitHandle>類別，衍生的類別<xref:System.Threading.AutoResetEvent>和<xref:System.Threading.ManualResetEvent>可以在本機的代表等候控制代碼。</span><span class="sxs-lookup"><span data-stu-id="8cba1-158">Unlike the <xref:System.Threading.EventWaitHandle> class, the derived classes <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent> can represent only local wait handles.</span></span> <span data-ttu-id="8cba1-159">它們不能代表具名的系統事件。</span><span class="sxs-lookup"><span data-stu-id="8cba1-159">They cannot represent named system events.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8cba1-160">另請參閱</span><span class="sxs-lookup"><span data-stu-id="8cba1-160">See Also</span></span>  
 <xref:System.Threading.EventWaitHandle>  
 <xref:System.Threading.WaitHandle>  
 <xref:System.Threading.AutoResetEvent>  
 <xref:System.Threading.ManualResetEvent>  
 [<span data-ttu-id="8cba1-161">EventWaitHandle、AutoResetEvent、CountdownEvent、ManualResetEvent</span><span class="sxs-lookup"><span data-stu-id="8cba1-161">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</span></span>](../../../docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)
