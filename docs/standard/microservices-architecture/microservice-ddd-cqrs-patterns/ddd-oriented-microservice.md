---
title: "設計 DDD 導向的微服務"
description: "容器化的.NET 應用程式的.NET Microservices 架構 |設計 DDD 導向的微服務"
keywords: "Docker, 微服務, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df45441089fd59d5e0e52b4bcec409adcc11fb71
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/18/2017
---
# <a name="designing-a-ddd-oriented-microservice"></a><span data-ttu-id="52a81-104">設計 DDD 導向的微服務</span><span class="sxs-lookup"><span data-stu-id="52a81-104">Designing a DDD-oriented microservice</span></span>

<span data-ttu-id="52a81-105">網域導向設計 (DDD) 倡導人士等商務的使用案例相關的事實為基礎的模型。</span><span class="sxs-lookup"><span data-stu-id="52a81-105">Domain-driven design (DDD) advocates modeling based on the reality of business as relevant to your use cases.</span></span> <span data-ttu-id="52a81-106">在建立應用程式的內容中，DDD 交談的問題為網域中。</span><span class="sxs-lookup"><span data-stu-id="52a81-106">In the context of building applications, DDD talks about problems as domains.</span></span> <span data-ttu-id="52a81-107">它會描述繫結內容當做獨立的問題區域 （每個繫結的內容會將微服務相互關聯），並強調常用的語言，討論這些問題。</span><span class="sxs-lookup"><span data-stu-id="52a81-107">It describes independent problem areas as Bounded Contexts (each Bounded Context correlates to a microservice), and emphasizes a common language to talk about these problems.</span></span> <span data-ttu-id="52a81-108">另提出許多技術概念和模式，如同網域實體具有豐富的模型 (沒有[anemic 網域模型](https://martinfowler.com/bliki/AnemicDomainModel.html))，值的物件、 彙總及彙總根 （或根實體） 以支援內部實作的規則。</span><span class="sxs-lookup"><span data-stu-id="52a81-108">It also suggests many technical concepts and patterns, like domain entities with rich models (no [anemic-domain model](https://martinfowler.com/bliki/AnemicDomainModel.html)), value objects, aggregates and aggregate root (or root entity) rules to support the internal implementation.</span></span> <span data-ttu-id="52a81-109">本節將介紹的設計和實作這些內部的模式。</span><span class="sxs-lookup"><span data-stu-id="52a81-109">This section introduces the design and implementation of those internal patterns.</span></span>

<span data-ttu-id="52a81-110">有時候這些 DDD 技術規則和模式會認為有實作 DDD 方法並不容易學習的學習曲線的障礙。</span><span class="sxs-lookup"><span data-stu-id="52a81-110">Sometimes these DDD technical rules and patterns are perceived as obstacles that have a steep learning curve for implementing DDD approaches.</span></span> <span data-ttu-id="52a81-111">但重要的部分是不模式本身，但其對齊的商業問題，讓組織程式碼和使用相同的商務詞彙表示 （通用語言）。</span><span class="sxs-lookup"><span data-stu-id="52a81-111">But the important part is not the patterns themselves, but organizing the code so it is aligned to the business problems, and using the same business terms (ubiquitous language).</span></span> <span data-ttu-id="52a81-112">此外，只有當您實作複雜 microservices 重要的商務規則應該套用 DDD 方法。</span><span class="sxs-lookup"><span data-stu-id="52a81-112">In addition, DDD approaches should be applied only if you are implementing complex microservices with significant business rules.</span></span> <span data-ttu-id="52a81-113">更簡單的責任，類似 CRUD 服務，可以使用簡單的方法來管理。</span><span class="sxs-lookup"><span data-stu-id="52a81-113">Simpler responsibilities, like a CRUD service, can be managed with simpler approaches.</span></span>

<span data-ttu-id="52a81-114">要繪製的界限是索引鍵的工作設計和定義微服務時。</span><span class="sxs-lookup"><span data-stu-id="52a81-114">Where to draw the boundaries is the key task when designing and defining a microservice.</span></span> <span data-ttu-id="52a81-115">DDD 模式可協助您了解網域中的複雜度。</span><span class="sxs-lookup"><span data-stu-id="52a81-115">DDD patterns help you understand the complexity in the domain.</span></span> <span data-ttu-id="52a81-116">網域模型，針對每個繫結的內容，您可以找出並定義實體、 值的物件，與您的網域建立模型的彙總。</span><span class="sxs-lookup"><span data-stu-id="52a81-116">For the domain model for each Bounded Context, you identify and define the entities, value objects, and aggregates that model your domain.</span></span> <span data-ttu-id="52a81-117">您建立並精簡包含定義您的內容界限內的網域模型。</span><span class="sxs-lookup"><span data-stu-id="52a81-117">You build and refine a domain model that is contained within a boundary that defines your context.</span></span> <span data-ttu-id="52a81-118">而這是非常明確的微服務形式。</span><span class="sxs-lookup"><span data-stu-id="52a81-118">And that is very explicit in the form of a microservice.</span></span> <span data-ttu-id="52a81-119">這些界限內的元件最終要您 microservices，不過在某些情況下，a BC 或商務 microservices 可以包括數個實體的服務。</span><span class="sxs-lookup"><span data-stu-id="52a81-119">The components within those boundaries end up being your microservices, although in some cases a BC or business microservices can be composed of several physical services.</span></span> <span data-ttu-id="52a81-120">DDD 即將界限及 microservices。</span><span class="sxs-lookup"><span data-stu-id="52a81-120">DDD is about boundaries and so are microservices.</span></span>

## <a name="keep-the-microservice-context-boundaries-relatively-small"></a><span data-ttu-id="52a81-121">保留的微服務內容界限相對較小</span><span class="sxs-lookup"><span data-stu-id="52a81-121">Keep the microservice context boundaries relatively small</span></span>

<span data-ttu-id="52a81-122">決定繫結內容之間的界限的放置位置平衡兩個競爭目標。</span><span class="sxs-lookup"><span data-stu-id="52a81-122">Determining where to place boundaries between Bounded Contexts balances two competing goals.</span></span> <span data-ttu-id="52a81-123">首先，您想要一開始建立最小的可能 microservices，雖然，不應該是主要的驅動程式。您應該建立需要一致性的項目周圍的界限。</span><span class="sxs-lookup"><span data-stu-id="52a81-123">First, you want to initially create the smallest possible microservices, although that should not be the main driver; you should create a boundary around things that need cohesion.</span></span> <span data-ttu-id="52a81-124">第二，您會想要避免多對話 microservices 之間的通訊。</span><span class="sxs-lookup"><span data-stu-id="52a81-124">Second, you want to avoid chatty communications between microservices.</span></span> <span data-ttu-id="52a81-125">這些目標可以有所出入另一個。</span><span class="sxs-lookup"><span data-stu-id="52a81-125">These goals can contradict one another.</span></span> <span data-ttu-id="52a81-126">您應該將系統分解成許多小 microservices 像直到您看到成長快速隨著每個額外的嘗試將新的繫結內容的通訊界限來平衡它們。</span><span class="sxs-lookup"><span data-stu-id="52a81-126">You should balance them by decomposing the system into as many small microservices as you can until you see communication boundaries growing quickly with each additional attempt to separate a new Bounded Context.</span></span> <span data-ttu-id="52a81-127">一致性是單一的繫結內容中的索引鍵。</span><span class="sxs-lookup"><span data-stu-id="52a81-127">Cohesion is key within a single bounded context.</span></span>

<span data-ttu-id="52a81-128">類似於[不適當的熟悉度程式碼的氣味](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy)時實作類別。</span><span class="sxs-lookup"><span data-stu-id="52a81-128">It is similar to the [Inappropriate Intimacy code smell](https://sourcemaking.com/refactoring/smells/inappropriate-intimacy) when implementing classes.</span></span> <span data-ttu-id="52a81-129">如果兩個 microservices 需要許多協同合作，它們可能應該相同的微服務。</span><span class="sxs-lookup"><span data-stu-id="52a81-129">If two microservices need to collaborate a lot with each other, they should probably be the same microservice.</span></span>

<span data-ttu-id="52a81-130">若要查看的另一個方法是自主。</span><span class="sxs-lookup"><span data-stu-id="52a81-130">Another way to look at this is autonomy.</span></span> <span data-ttu-id="52a81-131">如果微服務必須依賴其他服務，以直接要求，並不真的自發。</span><span class="sxs-lookup"><span data-stu-id="52a81-131">If a microservice must rely on another service to directly service a request, it is not truly autonomous.</span></span>

## <a name="layers-in-ddd-microservices"></a><span data-ttu-id="52a81-132">DDD microservices 中的圖層</span><span class="sxs-lookup"><span data-stu-id="52a81-132">Layers in DDD microservices</span></span>

<span data-ttu-id="52a81-133">大部分的企業應用程式具有重要的商務和技術的複雜性是由多個圖層定義。</span><span class="sxs-lookup"><span data-stu-id="52a81-133">Most enterprise applications with significant business and technical complexity are defined by multiple layers.</span></span> <span data-ttu-id="52a81-134">圖層是邏輯的成品，並不相關的服務部署。</span><span class="sxs-lookup"><span data-stu-id="52a81-134">The layers are a logical artifact, and are not related to the deployment of the service.</span></span> <span data-ttu-id="52a81-135">它們存在於協助開發人員管理在程式碼的複雜度。</span><span class="sxs-lookup"><span data-stu-id="52a81-135">They exist to help developers manage the complexity in the code.</span></span> <span data-ttu-id="52a81-136">不同層級 （例如網域的模型層與展示層等） 可能有不同的類型，這會強制這些型別之間的翻譯。</span><span class="sxs-lookup"><span data-stu-id="52a81-136">Different layers (like the domain model layer versus the presentation layer, etc.) might have different types, which mandates translations between those types.</span></span>

<span data-ttu-id="52a81-137">例如，無法從資料庫載入實體。</span><span class="sxs-lookup"><span data-stu-id="52a81-137">For example, an entity could be loaded from the database.</span></span> <span data-ttu-id="52a81-138">然後該資訊之後，或彙總的資訊包括額外的資料，從其他實體，可以傳送至用戶端透過 REST Web API 的 UI。</span><span class="sxs-lookup"><span data-stu-id="52a81-138">Then part of that information, or an aggregation of information including additional data from other entities, can be sent to the client UI through a REST Web API.</span></span> <span data-ttu-id="52a81-139">網域實體包含在網域模型層，而不會傳播至它不屬於，例如展示層的其他區域的點。</span><span class="sxs-lookup"><span data-stu-id="52a81-139">The point here is that the domain entity is contained within the domain model layer and should not be propagated to other areas that it does not belong to, like to the presentation layer.</span></span>

<span data-ttu-id="52a81-140">此外，您需要有實體永遠有效 (請參閱[設計網域模型層中的驗證](#designing-validations-in-the-domain-model-layer)> 一節) 彙總的根目錄 （根實體） 所控制。</span><span class="sxs-lookup"><span data-stu-id="52a81-140">Additionally, you need to have always-valid entities (see the [Designing validations in the domain model layer](#designing-validations-in-the-domain-model-layer) section) controlled by aggregate roots (root entities).</span></span> <span data-ttu-id="52a81-141">因此，實體不應是繫結至用戶端檢視，因為 UI 層級某些資料可能仍然不會驗證。</span><span class="sxs-lookup"><span data-stu-id="52a81-141">Therefore, entities should not be bound to client views, because at the UI level some data might still not be validated.</span></span> <span data-ttu-id="52a81-142">這是 ViewModel 是的。</span><span class="sxs-lookup"><span data-stu-id="52a81-142">This is what the ViewModel is for.</span></span> <span data-ttu-id="52a81-143">ViewModel 是專門用於簡報層所需的資料模型。</span><span class="sxs-lookup"><span data-stu-id="52a81-143">The ViewModel is a data model exclusively for presentation layer needs.</span></span> <span data-ttu-id="52a81-144">直接到 ViewModel 不屬於網域實體。</span><span class="sxs-lookup"><span data-stu-id="52a81-144">The domain entities do not belong directly to the ViewModel.</span></span> <span data-ttu-id="52a81-145">相反地，您需要翻譯 ViewModels 和網域實體之間，反之亦然。</span><span class="sxs-lookup"><span data-stu-id="52a81-145">Instead, you need to translate between ViewModels and domain entities and vice versa.</span></span>

<span data-ttu-id="52a81-146">透過單一項目時處理的複雜性，一定要有網域模型，由彙總根 （我們這更詳細地稍後討論），可確保所有的非變異值和規則相關以執行該群組的實體 （彙總）點或閘道，彙總的根。</span><span class="sxs-lookup"><span data-stu-id="52a81-146">When tackling complexity, it is important to have a domain model controlled by aggregate roots (we go into this in more detail later) that make sure that all the invariants and rules related to that group of entities (aggregate) are performed through a single entry point or gate, the aggregate root.</span></span>

<span data-ttu-id="52a81-147">圖 9 5 顯示 eShopOnContainers 應用程式中實作多層式的設計的方式。</span><span class="sxs-lookup"><span data-stu-id="52a81-147">Figure 9-5 shows how a layered design is implemented in the eShopOnContainers application.</span></span>

![](./media/image6.png)

<span data-ttu-id="52a81-148">**圖 9 5**。</span><span class="sxs-lookup"><span data-stu-id="52a81-148">**Figure 9-5**.</span></span> <span data-ttu-id="52a81-149">DDD eShopOnContainers 中順序的微服務中的圖層</span><span class="sxs-lookup"><span data-stu-id="52a81-149">DDD layers in the ordering microservice in eShopOnContainers</span></span>

<span data-ttu-id="52a81-150">您想要設計系統，讓每個圖層會只與特定的其他圖層進行通訊。</span><span class="sxs-lookup"><span data-stu-id="52a81-150">You want to design the system so that each layer communicates only with certain other layers.</span></span> <span data-ttu-id="52a81-151">可能您更輕鬆地強制執行如果圖層會實作為不同的類別庫，因為您可以清楚地識別哪些相依性會設定程式庫之間。</span><span class="sxs-lookup"><span data-stu-id="52a81-151">That may be easier to enforce if layers are implemented as different class libraries, because you can clearly identify what dependencies are set between libraries.</span></span> <span data-ttu-id="52a81-152">比方說，網域模型層應該不依賴其他任何層級 (網域模型類別應該是一般舊 CLR 物件，或[POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)，類別)。</span><span class="sxs-lookup"><span data-stu-id="52a81-152">For instance, the domain model layer should not take a dependency on any other layer (the domain model classes should be Plain Old CLR Objects, or [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object), classes).</span></span> <span data-ttu-id="52a81-153">顯示在圖 9-6， **Ordering.Domain**層媒體櫃具有相依性，只有在.NET Core 文件庫上但不是能在任何其他自訂的程式庫 （資料程式庫、 持續性文件庫等）。</span><span class="sxs-lookup"><span data-stu-id="52a81-153">As shown in Figure 9-6, the **Ordering.Domain** layer library has dependencies only on the .NET Core libraries but not on any other custom library (data library, persistence library, etc.).</span></span>

![](./media/image7.PNG)

<span data-ttu-id="52a81-154">**圖 9-6**。</span><span class="sxs-lookup"><span data-stu-id="52a81-154">**Figure 9-6**.</span></span> <span data-ttu-id="52a81-155">實作為程式庫允許更佳控制圖層之間的相依性的圖層</span><span class="sxs-lookup"><span data-stu-id="52a81-155">Layers implemented as libraries allow better control of dependencies between layers</span></span>

### <a name="the-domain-model-layer"></a><span data-ttu-id="52a81-156">網域模型層</span><span class="sxs-lookup"><span data-stu-id="52a81-156">The domain model layer</span></span>

<span data-ttu-id="52a81-157">Eric Evans 絕佳書籍[網域導向設計](http://domainlanguage.com/ddd/)隻字下列網域模型層和應用程式層級。</span><span class="sxs-lookup"><span data-stu-id="52a81-157">Eric Evans's excellent book [Domain Driven Design](http://domainlanguage.com/ddd/) says the following about the domain model layer and the application layer.</span></span>

<span data-ttu-id="52a81-158">**網域模型層**： 負責代表商務、 商務規則與商務情況的相關資訊的概念。</span><span class="sxs-lookup"><span data-stu-id="52a81-158">**Domain Model Layer**: Responsible for representing concepts of the business, information about the business situation, and business rules.</span></span> <span data-ttu-id="52a81-159">會反映商務狀況的狀態是控制，而且在這裡使用，即使將其儲存的技術詳細資料會委派給基礎結構。</span><span class="sxs-lookup"><span data-stu-id="52a81-159">State that reflects the business situation is controlled and used here, even though the technical details of storing it are delegated to the infrastructure.</span></span> <span data-ttu-id="52a81-160">此圖層是商務軟體的核心。</span><span class="sxs-lookup"><span data-stu-id="52a81-160">This layer is the heart of business software.</span></span>

<span data-ttu-id="52a81-161">網域模型層是表示商務的位置。</span><span class="sxs-lookup"><span data-stu-id="52a81-161">The domain model layer is where the business is expressed.</span></span> <span data-ttu-id="52a81-162">當您在.NET 中實作微服務網域模型層時，該圖層會編碼為擷取資料加上行為 （方法的邏輯） 之網域實體的類別程式庫。</span><span class="sxs-lookup"><span data-stu-id="52a81-162">When you implement a microservice domain model layer in .NET, that layer is coded as a class library with the domain entities that capture data plus behavior (methods with logic).</span></span>

<span data-ttu-id="52a81-163">遵循[永續性無知之](http://deviq.com/persistence-ignorance/)和[基礎結構忽略](https://ayende.com/blog/3137/infrastructure-ignorance)原則，此圖層必須完全忽略資料持續性的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="52a81-163">Following the [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and the [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, this layer must completely ignore data persistence details.</span></span> <span data-ttu-id="52a81-164">基礎結構層級才能執行這些持續性工作。</span><span class="sxs-lookup"><span data-stu-id="52a81-164">These persistence tasks should be performed by the infrastructure layer.</span></span> <span data-ttu-id="52a81-165">因此，此圖層不應該直接相依性的基礎，這表示很重要的規則是您在網域模型實體類別應該是[POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s。</span><span class="sxs-lookup"><span data-stu-id="52a81-165">Therefore, this layer should not take direct dependencies on the infrastructure, which means that an important rule is that your domain model entity classes should be [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)s.</span></span>

<span data-ttu-id="52a81-166">網域實體不應該有直接的相依性 （例如衍生自基底類別），Entity Framework 或 NHibernate 等任何資料存取基礎結構架構上。</span><span class="sxs-lookup"><span data-stu-id="52a81-166">Domain entities should not have any direct dependency (like deriving from a base class) on any data access infrastructure framework like Entity Framework or NHibernate.</span></span> <span data-ttu-id="52a81-167">在理想情況下，您網域的實體不應衍生自或實作任何基礎結構架構中定義的任何類型。</span><span class="sxs-lookup"><span data-stu-id="52a81-167">Ideally, your domain entities should not derive from or implement any type defined in any infrastructure framework.</span></span>

<span data-ttu-id="52a81-168">Entity Framework Core 像大多數最新型的 ORM 架構允許這種方式，以便您在網域模型類別不會連結至基礎結構。</span><span class="sxs-lookup"><span data-stu-id="52a81-168">Most modern ORM frameworks like Entity Framework Core allow this approach, so that your domain model classes are not coupled to the infrastructure.</span></span> <span data-ttu-id="52a81-169">不過，具有 POCO 實體不一定可以使用特定的 NoSQL 資料庫和架構，像執行者與 Azure Service Fabric 中的可靠集合時。</span><span class="sxs-lookup"><span data-stu-id="52a81-169">However, having POCO entities is not always possible when using certain NoSQL databases and frameworks, like Actors and Reliable Collections in Azure Service Fabric.</span></span>

<span data-ttu-id="52a81-170">請務必遵循永續性無知之原則的網域模型，即使您不應該忽略持續性考量。</span><span class="sxs-lookup"><span data-stu-id="52a81-170">Even when it is important to follow the Persistence Ignorance principle for you Domain model, you should not ignore persistence concerns.</span></span> <span data-ttu-id="52a81-171">它仍然是您一定要了解實體資料模型，以及它如何對應至您的實體物件模型。</span><span class="sxs-lookup"><span data-stu-id="52a81-171">It is still very important to understand the physical data model and how it maps to your entity object model.</span></span> <span data-ttu-id="52a81-172">否則，您可以建立不可能的設計。</span><span class="sxs-lookup"><span data-stu-id="52a81-172">Otherwise you can create impossible designs.</span></span>

<span data-ttu-id="52a81-173">此外，這不表示您可以使用關聯式資料庫設計模型，並直接將它移至 NoSQL 或文件導向的資料庫。</span><span class="sxs-lookup"><span data-stu-id="52a81-173">Also, this does not mean you can take a model designed for a relational database and directly move it to a NoSQL or document-oriented database.</span></span> <span data-ttu-id="52a81-174">在某些實體模型，模型可能適合，但通常沒有。</span><span class="sxs-lookup"><span data-stu-id="52a81-174">In some entity models, the model might fit, but usually it does not.</span></span> <span data-ttu-id="52a81-175">仍有實體模型必須遵守，基礎儲存體技術和 ORM 技術的條件約束。</span><span class="sxs-lookup"><span data-stu-id="52a81-175">There are still constraints that your entity model must adhere to, based both on the storage technology and ORM technology.</span></span>

### <a name="the-application-layer"></a><span data-ttu-id="52a81-176">應用程式層</span><span class="sxs-lookup"><span data-stu-id="52a81-176">The application layer</span></span>

<span data-ttu-id="52a81-177">繼續移至應用程式層中，我們可以再次引用 Eric Evans 書籍[網域導向設計](http://domainlanguage.com/ddd/):</span><span class="sxs-lookup"><span data-stu-id="52a81-177">Moving on to the application layer, we can again cite Eric Evans's book [Domain Driven Design](http://domainlanguage.com/ddd/):</span></span>

<span data-ttu-id="52a81-178">**應用程式層：**定義軟體應執行的工作，並指示算出問題的易懂的網域物件的工作。</span><span class="sxs-lookup"><span data-stu-id="52a81-178">**Application Layer:** Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems.</span></span> <span data-ttu-id="52a81-179">此圖層會負責的工作是商務有意義，或所需的應用程式層級中的其他系統的互動。</span><span class="sxs-lookup"><span data-stu-id="52a81-179">The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems.</span></span> <span data-ttu-id="52a81-180">此圖層是保持精簡。</span><span class="sxs-lookup"><span data-stu-id="52a81-180">This layer is kept thin.</span></span> <span data-ttu-id="52a81-181">它不包含商務規則或知識，但是只有座標工作和委派工作向下的下一層的網域物件的共同作業。</span><span class="sxs-lookup"><span data-stu-id="52a81-181">It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down.</span></span> <span data-ttu-id="52a81-182">它並沒有狀態反映出商務狀況中，但它可能會反映使用者或程式的工作進度的狀態。</span><span class="sxs-lookup"><span data-stu-id="52a81-182">It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.</span></span>

<span data-ttu-id="52a81-183">在.NET 中的微服務應用程式層通常自動程式碼做為 ASP.NET Core Web API 專案。</span><span class="sxs-lookup"><span data-stu-id="52a81-183">A microservice’s application layer in .NET is commonly coded as an ASP.NET Core Web API project.</span></span> <span data-ttu-id="52a81-184">專案實作微服務的互動、 遠端網路存取，以及從 UI 或用戶端應用程式所使用之外部 Web Api。</span><span class="sxs-lookup"><span data-stu-id="52a81-184">The project implements the microservice’s interaction, remote network access, and the external Web APIs used from the UI or client apps.</span></span> <span data-ttu-id="52a81-185">如果使用 CQRS 處理命令接受微服務，以及甚至事件導向間的通訊 microservices （整合事件），它就會包含查詢。</span><span class="sxs-lookup"><span data-stu-id="52a81-185">It includes queries if using a CQRS approach, commands accepted by the microservice, and even the event-driven communication between microservices (integration events).</span></span> <span data-ttu-id="52a81-186">代表應用程式層 ASP.NET Core Web API 不能包含商務規則或定義域知識 （尤其是網域的規則的交易或更新）;這些網域模型類別庫所擁有。</span><span class="sxs-lookup"><span data-stu-id="52a81-186">The ASP.NET Core Web API that represents the application layer must not contain business rules or domain knowledge (especially domain rules for transactions or updates); these should be owned by the domain model class library.</span></span> <span data-ttu-id="52a81-187">應用程式層必須只有座標工作和不保留或定義任何網域的狀態 （網域模型）。</span><span class="sxs-lookup"><span data-stu-id="52a81-187">The application layer must only coordinate tasks and must not hold or define any domain state (domain model).</span></span> <span data-ttu-id="52a81-188">它會委派商務規則的網域模型類別本身 （彙總根和網域實體），最後將會更新這些網域實體內的資料來的執行。</span><span class="sxs-lookup"><span data-stu-id="52a81-188">It delegates the execution of business rules to the domain model classes themselves (aggregate roots and domain entities), which will ultimately update the data within those domain entities.</span></span>

<span data-ttu-id="52a81-189">基本上，應用程式邏輯是您用來實作所有相依於指定的前端的使用案例。</span><span class="sxs-lookup"><span data-stu-id="52a81-189">Basically, the application logic is where you implement all use cases that depend on a given front end.</span></span> <span data-ttu-id="52a81-190">例如，相關的 Web API 服務的實作。</span><span class="sxs-lookup"><span data-stu-id="52a81-190">For example, the implementation related to a Web API service.</span></span>

<span data-ttu-id="52a81-191">目標是在網域模型層，其非變異項目、 資料模型與相關的商務規則的網域邏輯必須是完全獨立於展示和應用程式層。</span><span class="sxs-lookup"><span data-stu-id="52a81-191">The goal is that the domain logic in the domain model layer, its invariants, the data model, and related business rules must be completely independent from the presentation and application layers.</span></span> <span data-ttu-id="52a81-192">大部分，網域模型層必須直接依存於任何基礎結構架構。</span><span class="sxs-lookup"><span data-stu-id="52a81-192">Most of all, the domain model layer must not directly depend on any infrastructure framework.</span></span>

### <a name="the-infrastructure-layer"></a><span data-ttu-id="52a81-193">基礎結構層級</span><span class="sxs-lookup"><span data-stu-id="52a81-193">The infrastructure layer</span></span>

<span data-ttu-id="52a81-194">基礎結構層級是一開始會保留網域實體 （在記憶體中） 中的資料保存在資料庫或其他持續性存放區中的方式。</span><span class="sxs-lookup"><span data-stu-id="52a81-194">The infrastructure layer is how the data that is initially held in domain entities (in memory) is persisted in databases or another persistent store.</span></span> <span data-ttu-id="52a81-195">例如，使用 Entity Framework 核心程式碼來實作使用建立的 DBContext 來保存關聯式資料庫中的資料儲存機制模式類別。</span><span class="sxs-lookup"><span data-stu-id="52a81-195">An example is using Entity Framework Core code to implement the Repository pattern classes that use a DBContext to persist data in a relational database.</span></span>

<span data-ttu-id="52a81-196">根據先前所述[永續性無知之](http://deviq.com/persistence-ignorance/)和[基礎結構忽略](https://ayende.com/blog/3137/infrastructure-ignorance)基礎結構層級的原則必須不"contaminate 」 網域模型層。</span><span class="sxs-lookup"><span data-stu-id="52a81-196">In accordance with the previously mentioned [Persistence Ignorance](http://deviq.com/persistence-ignorance/) and [Infrastructure Ignorance](https://ayende.com/blog/3137/infrastructure-ignorance) principles, the infrastructure layer must not “contaminate” the domain model layer.</span></span> <span data-ttu-id="52a81-197">您必須防止網域模型實體類別無從驗證您用來保存資料 （EF 或任何其他架構） 的基礎結構不在架構上採取硬式相依性。</span><span class="sxs-lookup"><span data-stu-id="52a81-197">You must keep the domain model entity classes agnostic from the infrastructure that you use to persist data (EF or any other framework) by not taking hard dependencies on frameworks.</span></span> <span data-ttu-id="52a81-198">網域模型層類別庫應該只有您網域程式碼，只要[POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object)實體類別實作您的軟體中心以及完全分開基礎結構技術。</span><span class="sxs-lookup"><span data-stu-id="52a81-198">Your domain model layer class library should have only your domain code, just [POCO](https://en.wikipedia.org/wiki/Plain_Old_CLR_Object) entity classes implementing the heart of your software and completely decoupled from infrastructure technologies.</span></span>

<span data-ttu-id="52a81-199">因此，您的圖層或類別庫和專案應該最終取決於網域模型層級 （程式庫） 不是反之亦然，如圖 9-7 所示。</span><span class="sxs-lookup"><span data-stu-id="52a81-199">Thus, your layers or class libraries and projects should ultimately depend on your domain model layer (library), not vice versa, as shown in Figure 9-7.</span></span>

![](./media/image8.png)

<span data-ttu-id="52a81-200">**圖 9 7**。</span><span class="sxs-lookup"><span data-stu-id="52a81-200">**Figure 9-7**.</span></span> <span data-ttu-id="52a81-201">DDD 各層之間的相依性</span><span class="sxs-lookup"><span data-stu-id="52a81-201">Dependencies between layers in DDD</span></span>

<span data-ttu-id="52a81-202">此圖層設計應該是獨立的每個微服務。</span><span class="sxs-lookup"><span data-stu-id="52a81-202">This layer design should be independent for each microservice.</span></span> <span data-ttu-id="52a81-203">如前文所述，您可以實作最複雜 microservices 遵循 DDD 模式時實作簡單資料導向 microservices (單一層中的簡單 CRUD) 更簡單的方式。</span><span class="sxs-lookup"><span data-stu-id="52a81-203">As noted earlier, you can implement the most complex microservices following DDD patterns, while implementing simpler data-driven microservices (simple CRUD in a single layer) in a simpler way.</span></span>

#### <a name="additional-resources"></a><span data-ttu-id="52a81-204">其他資源</span><span class="sxs-lookup"><span data-stu-id="52a81-204">Additional resources</span></span>

-   <span data-ttu-id="52a81-205">**DevIQ。持續性忽略原則**
    [*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span><span class="sxs-lookup"><span data-stu-id="52a81-205">**DevIQ. Persistence Ignorance principle**
[*http://deviq.com/persistence-ignorance/*](http://deviq.com/persistence-ignorance/)</span></span>

-   <span data-ttu-id="52a81-206">**Oren Eini。基礎結構忽略**
    [*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span><span class="sxs-lookup"><span data-stu-id="52a81-206">**Oren Eini. Infrastructure Ignorance**
[*https://ayende.com/blog/3137/infrastructure-ignorance*](https://ayende.com/blog/3137/infrastructure-ignorance)</span></span>

-   <span data-ttu-id="52a81-207">**天使培茲。分層架構中網域導向設計**
    [*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span><span class="sxs-lookup"><span data-stu-id="52a81-207">**Angel Lopez. Layered Architecture In Domain-Driven Design**
[*https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/*](https://ajlopez.wordpress.com/2008/09/12/layered-architecture-in-domain-driven-design/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="52a81-208">[上一個](cqrs-微服務-reads.md) [下一步] (微服務-網域-model.md)</span><span class="sxs-lookup"><span data-stu-id="52a81-208">[Previous] (cqrs-microservice-reads.md) [Next] (microservice-domain-model.md)</span></span>
