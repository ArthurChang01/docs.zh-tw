---
title: 分散式資料管理的挑戰和解決方案
description: 容器化 .NET 應用程式的 .NET 微服務架構 | 分散式資料管理的挑戰和解決方案
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.openlocfilehash: 1d079dc7eef2f4abfbdec5a01b4233c8504d449d
ms.sourcegitcommit: 979597cd8055534b63d2c6ee8322938a27d0c87b
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 06/29/2018
ms.locfileid: "37106485"
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="9ae4f-103">分散式資料管理的挑戰和解決方案</span><span class="sxs-lookup"><span data-stu-id="9ae4f-103">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="9ae4f-104">挑戰 \#1：如何定義每項微服務的界限</span><span class="sxs-lookup"><span data-stu-id="9ae4f-104">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="9ae4f-105">定義微服務的界限，可能是所有人遇到的第一項挑戰。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-105">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="9ae4f-106">每項微服務必須是您應用程式的一個片段，而且每項微服務應該自發傳達所有的優點和挑戰。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-106">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="9ae4f-107">但如何識別這些界限呢？</span><span class="sxs-lookup"><span data-stu-id="9ae4f-107">But how do you identify those boundaries?</span></span>

<span data-ttu-id="9ae4f-108">首先，您需要將焦點放在應用程式的邏輯網域模型及相關資料。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-108">First, you need to focus on the application’s logical domain models and related data.</span></span> <span data-ttu-id="9ae4f-109">您必須嘗試識別低結合的孤立資料群，以及同一個應用程式內的不同內容。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-109">You must try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="9ae4f-110">每個內容可能具有不同的商業語言 (不同的商務詞彙)。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-110">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="9ae4f-111">這些內容都應該分開定義與管理。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-111">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="9ae4f-112">這些不同內容中使用的條款和在實體可能看似雷同，但您可能會發現特定內容中的某項商務概念，在另一份內容中用於不同的用途，甚至可能使用不同的名稱。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-112">The terms and entities used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="9ae4f-113">例如，使用者在身分識別或成員資格內容中稱為使用者，在 CRM 內容中稱為客戶，在訂購內容中稱為買方等等。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-113">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="9ae4f-114">您識別多種應用程式內容與每種內容不同網域之間界限的方式，與您識別每項商務微服務界限及其相關網域模型和資料的方式如出一轍。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-114">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="9ae4f-115">您一定要嘗試將這些微服務之間的結合程度降至最低。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-115">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="9ae4f-116">本指南會在稍後的[識別每項微服務的網域模型界限](#identifying-domain-model-boundaries-for-each-microservice)一節中，詳細說明此識別和網域模型設計。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-116">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="9ae4f-117">挑戰 \#2：如何建立從數項微服務擷取資料的查詢</span><span class="sxs-lookup"><span data-stu-id="9ae4f-117">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="9ae4f-118">第二項挑戰是如何實作從數項微服務擷取資料的查詢，同時避免與遠端用戶端應用程式的微服務過度對話。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-118">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="9ae4f-119">例如，行動應用程式單一畫面需要顯示的使用者資訊，為購物籃、目錄和使用者身分識別微服務所擁有。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-119">An example could be a single screen from a mobile app that needs to show user information that is owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="9ae4f-120">另一例則是包含許多資料表的複雜報表，這些資料表位於多項微服務中。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-120">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="9ae4f-121">正確的解決方案視查詢的複雜性而定。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-121">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="9ae4f-122">但如果您想要改善系統的通訊效率，則無論如何都需要有彙總資訊的方法。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-122">But in any case, you will need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="9ae4f-123">以下是最常用的解決方案。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-123">The most popular solutions are the following.</span></span>

<span data-ttu-id="9ae4f-124">**API 閘道**.</span><span class="sxs-lookup"><span data-stu-id="9ae4f-124">**API Gateway**.</span></span> <span data-ttu-id="9ae4f-125">如是擁有不同資料庫之多項微服務的簡單資料彙總，建議的方法是稱為 API 閘道的彙總微服務。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-125">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="9ae4f-126">不過，實作此模式時務須謹慎小心，因為它可能是系統的關鍵點，會違反微服務自主性原則。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-126">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="9ae4f-127">為降低這種可能性，您可以有多個精細處理的 API 閘道，它們每一個都將焦點放在系統的垂直「配量」或業務區域。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-127">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical “slice” or business area of the system.</span></span> <span data-ttu-id="9ae4f-128">稍後的＜使用 API 閘道＞一節會詳細說明 API 閘道模式。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-128">The API Gateway pattern is explained in more detail in the section in the Using an API Gateway later.</span></span>

<span data-ttu-id="9ae4f-129">**使用查詢/讀取資料表的 CQRS**。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-129">**CQRS with query/reads tables**.</span></span> <span data-ttu-id="9ae4f-130">另一個彙總多項微服務資料的解決方案是[具體化檢視模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-130">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="9ae4f-131">在這種方法中，您要事先以多項微服務擁有的資料產生唯讀資料表 (在實際查詢開始前準備好反正規化的資料)。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-131">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that is owned by multiple microservices.</span></span> <span data-ttu-id="9ae4f-132">資料表格式要符合用戶端應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-132">The table has a format suited to the client app’s needs.</span></span>

<span data-ttu-id="9ae4f-133">請考慮類似行動應用程式的畫面。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-133">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="9ae4f-134">如果您有單一資料庫，您可能會使用執行多個資料表複雜聯結的 SQL 查詢，為該畫面提取資料。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-134">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="9ae4f-135">不過，當您有多個資料庫，且每個資料庫為不同的微服務所擁有時，您無法查詢這些資料庫，也無法建立 SQL 聯結。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-135">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="9ae4f-136">您的複雜查詢會變成一項挑戰。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-136">Your complex query becomes a challenge.</span></span> <span data-ttu-id="9ae4f-137">您可以使用 CQRS 方法來解決需求：在只用於查詢的不同資料庫中建立反正規化的資料表。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-137">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that is used just for queries.</span></span> <span data-ttu-id="9ae4f-138">您可以利用應用程式畫面所需欄位和資料表資料行之間的一對一關聯性，專門為複雜查詢所需要的資料設計資料表。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-138">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application’s screen and the columns in the query table.</span></span> <span data-ttu-id="9ae4f-139">它也可以用作報表。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-139">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="9ae4f-140">這種方法不只可解決原始問題 (如何跨微服務查詢及聯結)，相較於複雜聯結，還可以大幅改善效能，因為查詢資料表中已經有應用程式需要的資料。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-140">This approach not only solves the original problem (how to query and join across microservices); it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="9ae4f-141">當然，使用利用查詢/讀取資料表的命令與查詢責任隔離 (CQRS) 表示會有額外的開發工作，而您需要堅持最終的一致性。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-141">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you will need to embrace eventual consistency.</span></span> <span data-ttu-id="9ae4f-142">然而，您應該對有效能和高延展性需求的[共同作業案例](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (或競爭案例，視觀點而定)，套用使用多個資料庫的 CQRS。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-142">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) is where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="9ae4f-143">**中央資料庫中「幾乎不存取的資料」**。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-143">**“Cold data” in central databases**.</span></span> <span data-ttu-id="9ae4f-144">對於可能不需要即時資料的複雜報表和查詢，常見的方法是將您「經常存取的資料」(來自微服務的交易資料) 匯出至僅供報表使用的大型資料庫成為「幾乎不存取的資料」。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-144">For complex reports and queries that might not require real-time data, a common approach is to export your “hot data” (transactional data from the microservices) as “cold data” into large databases that are used only for reporting.</span></span> <span data-ttu-id="9ae4f-145">中央資料庫系統可以是巨量資料型系統，例如 Hadoop，一種資料倉儲，類似 Azure SQL 資料倉儲，或甚至僅供報表使用的單一 SQL 資料庫 (如果大小不是問題)。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-145">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database used just for reports (if size will not be an issue).</span></span>

<span data-ttu-id="9ae4f-146">請牢記，這種集中式的資料庫僅供不需要即時資料的查詢和報表使用。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-146">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="9ae4f-147">作為來源的原始更新和交易，必須位於微服務資料中。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-147">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="9ae4f-148">同步處理資料的方式，是使用事件導向的通訊 (後續各節予以說明)，或使用其他資料庫基礎結構的匯入/匯出工具。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-148">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="9ae4f-149">如果使用事件導向的通訊，則該整合程序會類似先前所述針對 CQRS 查詢資料表的資料傳播方式。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-149">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="9ae4f-150">不過，如果您的應用程式設計涉及針對複雜查詢不斷彙總多項微服務的資訊，它可能是不良設計的徵兆，因為微服務應該盡可能與其他微服務隔離。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-150">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design—a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="9ae4f-151">(這會排除應一律使用幾乎不存取資料中央資料庫的報表/分析。)發生這種問題通常會成為合併微服務的理由。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-151">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="9ae4f-152">您必須平衡每一項微服務的演進與部署自主性與強式的相依性、一致性及資料彙總。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-152">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="9ae4f-153">挑戰 \#3：如何跨多項微服務達到一致性</span><span class="sxs-lookup"><span data-stu-id="9ae4f-153">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="9ae4f-154">如前所述，每項微服務所擁有的資料都是該微服務私用的，只能使用其微服務 API 存取。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-154">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="9ae4f-155">因此，呈現的挑戰就是如何實作端對端商務程序，同時跨多項微服務保持一致性。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-155">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="9ae4f-156">請參閱 [eShopOnContainers 參考應用程式](http://aka.ms/eshoponcontainers)的範例來分析此問題。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-156">To analyze this problem, let’s look at an example from the [eShopOnContainers reference application](http://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="9ae4f-157">目錄微服務會維護包括庫存量在內的所有產品相關資訊。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-157">The Catalog microservice maintains information about all the products, including their stock level.</span></span> <span data-ttu-id="9ae4f-158">訂購微服務會管理訂單，並一定會確認新訂單不能超過可用目錄產品存貨量。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-158">The Ordering microservice manages orders and must verify that a new order does not exceed the available catalog product stock.</span></span> <span data-ttu-id="9ae4f-159">(或者此案例可能涉及處理缺貨產品的邏輯。)在此應用程式的假設整合型版本中，訂購子系統只會使用 ACID 交易來檢查可用的存貨、在訂單資料表中建立訂單，然後更新產品資料表中可用的存貨。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-159">(Or the scenario might involve logic that handles backordered products.) In a hypothetical monolithic version of this application, the ordering subsystem could simply use an ACID transaction to check the available stock, create the order in the Orders table, and update the available stock in the Products table.</span></span>

<span data-ttu-id="9ae4f-160">不過，在微服務型的應用程式中，訂單和產品資料表分別為其微服務所擁有。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-160">However, in a microservices- based application, the Order and Product tables are owned by their respective microservices.</span></span> <span data-ttu-id="9ae4f-161">沒有任何一項微服務會在自己的交易或查詢中包含其他微服務所擁有的資料庫，如圖 4-9 所示。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-161">No microservice should ever include databases owned by another microservice in its own transactions or queries, as shown in Figure 4-9.</span></span>

![](./media/image9.PNG)

<span data-ttu-id="9ae4f-162">**圖 4-9**。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-162">**Figure 4-9**.</span></span> <span data-ttu-id="9ae4f-163">微服務無法直接存取其他微服務的資料表</span><span class="sxs-lookup"><span data-stu-id="9ae4f-163">A microservice cannot directly access a table in another microservice</span></span>

<span data-ttu-id="9ae4f-164">訂購微服務不應該直接更新產品資料表，因為產品資料表為目錄微服務所擁有。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-164">The Ordering microservice should not update the Products table directly, because the Products table is owned by the Catalog microservice.</span></span> <span data-ttu-id="9ae4f-165">為更新目錄微服務，訂購微服務只會使用非同步通訊，例如整合事件 (訊息和事件通訊)。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-165">To make an update to the Catalog microservice, the Ordering microservice should only ever use asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="9ae4f-166">這是 [eShopOnContainers](http://aka.ms/eshoponcontainers) 參考應用程式執行這類更新的方式。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-166">This is how the [eShopOnContainers](http://aka.ms/eshoponcontainers) reference application performs this type of update.</span></span>

<span data-ttu-id="9ae4f-167">如 [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem) (CAP 定理) 所述，您需要在可用性與 ACID 強式一致性中擇一。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-167">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="9ae4f-168">大部分的微服務型案例都會要求可用性和高延展性，而不是強式一致性。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-168">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="9ae4f-169">關鍵任務應用程式必須保持啟用及執行，開發人員才能透過處理弱式或最終一致性的技術，處理強式一致性。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-169">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="9ae4f-170">這是大部分微服務型架構採用的方法。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-170">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="9ae4f-171">此外，ACID 型或兩階段認可交易都不是只針對微服務原則，大部分的 NoSQL 資料庫 (例如 Azure Cosmos DB、MongoDB 等等) 都不支援兩階段認可交易。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-171">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions.</span></span> <span data-ttu-id="9ae4f-172">不過，跨服務和資料庫維護資料的一致性十分重要。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-172">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="9ae4f-173">這項挑戰也與當某些資料需要備援時，例如目錄微服務和購物籃微服務需要有產品名稱或描述時，如何跨多項微服務傳播變更的問題有關。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-173">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product’s name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="9ae4f-174">這個問題的最佳解決方案，是在透過事件導向通訊架構的微服務和發佈訂閱系統之間使用最終一致性。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-174">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="9ae4f-175">本指南稍後的[非同步的事件驅動通訊](#async_event_driven_communication)一節會討論這些主題。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-175">These topics are covered in the section [Asynchronous event-driven communication](#async_event_driven_communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="9ae4f-176">挑戰 \#4：如何設計跨微服務界限的通訊</span><span class="sxs-lookup"><span data-stu-id="9ae4f-176">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="9ae4f-177">跨微服務界限的通訊是項真正的挑戰。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-177">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="9ae4f-178">在此內容中，通訊非指您應該使用的通訊協定 (HTTP 和 REST、AMQP、傳訊等等)。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-178">In this context, communication does not refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="9ae4f-179">而是處理您應該使用的通訊樣式，特別是您的微服務應有的結合程度。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-179">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="9ae4f-180">視結合程度而定，發生失敗時，該失敗對系統造成的影響大不相同。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-180">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="9ae4f-181">在類似微服務型應用程式的分散式系統中，會有許多四處移動的成品以及跨許多伺服器或主機的分散式服務，元件最終會失敗。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-181">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="9ae4f-182">因為會發生部分失敗甚至更大範圍的中斷問題，所以設計微服務及跨這些微服務的通訊時，您需要將這類分散式系統的常見風險列入考量。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-182">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them taking into account the risks common in this type of distributed system.</span></span>

<span data-ttu-id="9ae4f-183">常用的方法是實作 HTTP (REST) 型的微服務，因為它們簡便易行。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-183">A popular approach is to implement HTTP (REST)- based microservices, due to their simplicity.</span></span> <span data-ttu-id="9ae4f-184">HTTP 型的方法完全可行，問題是您如何使用它。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-184">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="9ae4f-185">如果您使用 HTTP 要求和回應只是為了與用戶端應用程式或 API 閘道的微服務進行互動，那沒關係。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-185">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that is fine.</span></span> <span data-ttu-id="9ae4f-186">但如果您建立跨微服務的同步 HTTP 呼叫長鏈結，將微服務當作整合型應用程式的物件進行跨界限通訊，您的應用程式最後一定會發生問題。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-186">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="9ae4f-187">例如，假設用戶端應用程式向個別的微服務發出 HTTP API 呼叫，例如訂購微服務。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-187">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="9ae4f-188">如果訂購微服務接著在相同的要求/回應循環中，使用 HTTP 呼叫其他微服務，則您會建立 HTTP 呼叫鏈結。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-188">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you are creating a chain of HTTP calls.</span></span> <span data-ttu-id="9ae4f-189">它可能一開始看似合理。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-189">It might sound reasonable initially.</span></span> <span data-ttu-id="9ae4f-190">但一路下來總會碰到要考量的重點：</span><span class="sxs-lookup"><span data-stu-id="9ae4f-190">However, there are important points to consider when going down this path:</span></span>

-   <span data-ttu-id="9ae4f-191">封鎖和低效能。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-191">Blocking and low performance.</span></span> <span data-ttu-id="9ae4f-192">由於 HTTP 同步的本質，在完成所有內部 HTTP 呼叫前，原始要求不會收到回應。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-192">Due to the synchronous nature of HTTP, the original request will not get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="9ae4f-193">假設這些呼叫的數目大幅增加，與此同時封鎖了微服務的一個中繼 HTTP 呼叫。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-193">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="9ae4f-194">結果是會效能受到影響，整體延展性也會隨著額外 HTTP 要求增加而受到等比級數的影響。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-194">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

-   <span data-ttu-id="9ae4f-195">結合微服務與 HTTP。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-195">Coupling microservices with HTTP.</span></span> <span data-ttu-id="9ae4f-196">商務微服務不應給合其他商務微服務。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-196">Business microservices should not be coupled with other business microservices.</span></span> <span data-ttu-id="9ae4f-197">在理想情況下，它們不應該「知道」其他微服務的存在。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-197">Ideally, they should not “know” about the existence of other microservices.</span></span> <span data-ttu-id="9ae4f-198">如果您的應用程式如範例中所示依賴結合的微服務，希望達到每項微服務都有自主性幾乎是不可能的。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-198">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

-   <span data-ttu-id="9ae4f-199">任何一項微服務都會失敗。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-199">Failure in any one microservice.</span></span> <span data-ttu-id="9ae4f-200">如已實作經 HTTP 呼叫連結的微服務鏈結，當任一項微服務失敗時 (它們最終都會失敗)，整個微服務鏈結就會失敗。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-200">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="9ae4f-201">微服務型系統應該設計成可持續運作，以及在部分失敗期間能夠運作。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-201">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="9ae4f-202">即使您實作的用戶端邏輯使用指數型輪詢或斷路器機制重試，HTTP 呼叫鏈結愈複雜，所實作之以 HTTP 為基礎的失敗策略就愈複雜。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-202">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="9ae4f-203">事實上，如果您的內部微服務如所述，是透過建立 HTTP 要求的鏈結進行通訊，則您擁有的整合型應用程式是以處理序通訊機制之間的 HTTP 為基礎，而非以內部處理序通訊機制之間的 HTTP 為基礎，就可能引起爭議。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-203">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intraprocess communication mechanisms.</span></span>

<span data-ttu-id="9ae4f-204">因此，為了強制執行微服務自主性，並實現較佳的復原功能，您應該盡量少用跨微服務的要求/回應通訊鏈結。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-204">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="9ae4f-205">微服務通訊間建議只使用非同步互動，使用非同步訊息型及事件型通訊，或使用獨立於原始 HTTP 要求/回應週期外的 HTTP 輪詢。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-205">It is recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="9ae4f-206">本指南稍後的[非同步微服務整合強制執行微服務自主性](#asynchronous-microservice-integration-enforce-microservices-autonomy)和[非同步訊息型通訊](#asynchronous-message-based-communication)等節會詳細說明非同步通訊的使用。</span><span class="sxs-lookup"><span data-stu-id="9ae4f-206">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice’s autonomy](#asynchronous-microservice-integration-enforce-microservices-autonomy) and [Asynchronous message-based communication](#asynchronous-message-based-communication).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="9ae4f-207">其他資源</span><span class="sxs-lookup"><span data-stu-id="9ae4f-207">Additional resources</span></span>

-   <span data-ttu-id="9ae4f-208">**CAP 定理**
    [*https://en.wikipedia.org/wiki/CAP\_theorem*](https://en.wikipedia.org/wiki/CAP_theorem)</span><span class="sxs-lookup"><span data-stu-id="9ae4f-208">**CAP theorem**
[*https://en.wikipedia.org/wiki/CAP\_theorem*](https://en.wikipedia.org/wiki/CAP_theorem)</span></span>

-   <span data-ttu-id="9ae4f-209">**最終一致性**
    [*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span><span class="sxs-lookup"><span data-stu-id="9ae4f-209">**Eventual consistency**
[*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span></span>

-   <span data-ttu-id="9ae4f-210">**資料一致性入門**
    [*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span><span class="sxs-lookup"><span data-stu-id="9ae4f-210">**Data Consistency Primer**
[*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span></span>

-   <span data-ttu-id="9ae4f-211">**Martin Fowler：CQRS (命令與查詢職責分離)**
    [*https://martinfowler.com/bliki/CQRS.html*](https://martinfowler.com/bliki/CQRS.html)</span><span class="sxs-lookup"><span data-stu-id="9ae4f-211">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)**
[*https://martinfowler.com/bliki/CQRS.html*](https://martinfowler.com/bliki/CQRS.html)</span></span>

-   <span data-ttu-id="9ae4f-212">**具體化檢視**
    [*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span><span class="sxs-lookup"><span data-stu-id="9ae4f-212">**Materialized View**
[*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span></span>

-   <span data-ttu-id="9ae4f-213">**Charles Row。ACID vs.基礎：資料庫交易處理的轉換 pH**
    [*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span><span class="sxs-lookup"><span data-stu-id="9ae4f-213">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing**
[*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span></span>

-   <span data-ttu-id="9ae4f-214">**補償交易**
    [*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span><span class="sxs-lookup"><span data-stu-id="9ae4f-214">**Compensating Transaction**
[*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span></span>

-   <span data-ttu-id="9ae4f-215">**Udi Dahan.服務導向組合**
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span><span class="sxs-lookup"><span data-stu-id="9ae4f-215">**Udi Dahan. Service Oriented Composition**
[*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="9ae4f-216">[上一頁](logical-versus-physical-architecture.md)
[下一頁](identify-microservice-domain-model-boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="9ae4f-216">[Previous](logical-versus-physical-architecture.md)
[Next](identify-microservice-domain-model-boundaries.md)</span></span>
