---
title: "挑戰和解決方案的分散式的資料管理"
description: "容器化的.NET 應用程式的.NET Microservices 架構 |挑戰和解決方案的分散式的資料管理"
keywords: "Docker, 微服務, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: f961475b40c74bf448cff1aeae04ae4866360e52
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/22/2017
---
# <a name="challenges-and-solutions-for-distributed-data-management"></a><span data-ttu-id="637db-104">挑戰和解決方案的分散式的資料管理</span><span class="sxs-lookup"><span data-stu-id="637db-104">Challenges and solutions for distributed data management</span></span>

## <a name="challenge-1-how-to-define-the-boundaries-of-each-microservice"></a><span data-ttu-id="637db-105">挑戰\#1： 如何定義的每個微服務界限</span><span class="sxs-lookup"><span data-stu-id="637db-105">Challenge \#1: How to define the boundaries of each microservice</span></span>

<span data-ttu-id="637db-106">定義微服務界限可能是任何人在遇到第一個驗證題目。</span><span class="sxs-lookup"><span data-stu-id="637db-106">Defining microservice boundaries is probably the first challenge anyone encounters.</span></span> <span data-ttu-id="637db-107">必須是您的應用程式的每個微服務，而且每個微服務應該是自發所有的優點和它所傳達的挑戰。</span><span class="sxs-lookup"><span data-stu-id="637db-107">Each microservice has to be a piece of your application and each microservice should be autonomous with all the benefits and challenges that it conveys.</span></span> <span data-ttu-id="637db-108">但如何識別這些界限嗎？</span><span class="sxs-lookup"><span data-stu-id="637db-108">But how do you identify those boundaries?</span></span>

<span data-ttu-id="637db-109">首先，您需要將焦點放在應用程式的邏輯網域模型及相關的資料。</span><span class="sxs-lookup"><span data-stu-id="637db-109">First, you need to focus on the application’s logical domain models and related data.</span></span> <span data-ttu-id="637db-110">您必須嘗試識別資料及同一個應用程式內的不同內容的解除解合的島。</span><span class="sxs-lookup"><span data-stu-id="637db-110">You must try to identify decoupled islands of data and different contexts within the same application.</span></span> <span data-ttu-id="637db-111">每個內容可能會有不同的商業語言 （不同的商務詞彙表示）。</span><span class="sxs-lookup"><span data-stu-id="637db-111">Each context could have a different business language (different business terms).</span></span> <span data-ttu-id="637db-112">表示內容應定義，並分開管理。</span><span class="sxs-lookup"><span data-stu-id="637db-112">The contexts should be defined and managed independently.</span></span> <span data-ttu-id="637db-113">條款和在這些不同的內容中使用的實體可能會看似相似，但您可能會發現，在特定內容中，其中包含一個商務概念用於不同的用途，在另一個內容中，甚至可能需要不同的名稱。</span><span class="sxs-lookup"><span data-stu-id="637db-113">The terms and entities used in those different contexts might sound similar, but you might discover that in a particular context, a business concept with one is used for a different purpose in another context, and might even have a different name.</span></span> <span data-ttu-id="637db-114">例如，使用者可以稱為身分識別或成員資格的內容中的使用者身分在順序的內容中，買方之客戶在 CRM 內容中，為等等。</span><span class="sxs-lookup"><span data-stu-id="637db-114">For instance, a user can be referred as a user in the identity or membership context, as a customer in a CRM context, as a buyer in an ordering context, and so forth.</span></span>

<span data-ttu-id="637db-115">每個內容只是如何識別每個商務微服務和其相關的界限，識別與不同網域的多個應用程式內容之間的界限的方式領域模型和資料。</span><span class="sxs-lookup"><span data-stu-id="637db-115">The way you identify boundaries between multiple application contexts with a different domain for each context is exactly how you can identify the boundaries for each business microservice and its related domain model and data.</span></span> <span data-ttu-id="637db-116">您一定會嘗試最小化這些 microservices 之間的連接。</span><span class="sxs-lookup"><span data-stu-id="637db-116">You always attempt to minimize the coupling between those microservices.</span></span> <span data-ttu-id="637db-117">本指南會進入此識別和網域模型設計的一節更詳細地[識別每個微服務的網域模型界限](#identifying-domain-model-boundaries-for-each-microservice)更新版本。</span><span class="sxs-lookup"><span data-stu-id="637db-117">This guide goes into more detail about this identification and domain model design in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice) later.</span></span>

## <a name="challenge-2-how-to-create-queries-that-retrieve-data-from-several-microservices"></a><span data-ttu-id="637db-118">挑戰\#2： 如何建立從數個 microservices 擷取資料的查詢</span><span class="sxs-lookup"><span data-stu-id="637db-118">Challenge \#2: How to create queries that retrieve data from several microservices</span></span>

<span data-ttu-id="637db-119">第二個挑戰是如何實作從數個 microservices，擷取資料，同時避免多對話通訊以 microservices，從遠端用戶端應用程式的查詢。</span><span class="sxs-lookup"><span data-stu-id="637db-119">A second challenge is how to implement queries that retrieve data from several microservices, while avoiding chatty communication to the microservices from remote client apps.</span></span> <span data-ttu-id="637db-120">範例可能需要顯示使用者資訊的購物籃、 類別目錄和使用者身分識別 microservices 所擁有的行動裝置應用程式在單一螢幕。</span><span class="sxs-lookup"><span data-stu-id="637db-120">An example could be a single screen from a mobile app that needs to show user information that is owned by the basket, catalog, and user identity microservices.</span></span> <span data-ttu-id="637db-121">另一個範例就是包含許多資料表位於多個 microservices 複雜報表。</span><span class="sxs-lookup"><span data-stu-id="637db-121">Another example would be a complex report involving many tables located in multiple microservices.</span></span> <span data-ttu-id="637db-122">絕佳的解決方案視查詢的複雜性而定。</span><span class="sxs-lookup"><span data-stu-id="637db-122">The right solution depends on the complexity of the queries.</span></span> <span data-ttu-id="637db-123">但是，在任何情況下，您將需要彙總資訊的方法如果您想要改善您的系統通訊的效率。</span><span class="sxs-lookup"><span data-stu-id="637db-123">But in any case, you will need a way to aggregate information if you want to improve the efficiency in the communications of your system.</span></span> <span data-ttu-id="637db-124">以下是最常用的解決方案。</span><span class="sxs-lookup"><span data-stu-id="637db-124">The most popular solutions are the following.</span></span>

<span data-ttu-id="637db-125">**API 閘道**。</span><span class="sxs-lookup"><span data-stu-id="637db-125">**API Gateway**.</span></span> <span data-ttu-id="637db-126">對於多個 microservices 擁有不同的資料庫從簡單的資料彙總，建議的方法是指 API 閘道彙總微服務。</span><span class="sxs-lookup"><span data-stu-id="637db-126">For simple data aggregation from multiple microservices that own different databases, the recommended approach is an aggregation microservice referred to as an API Gateway.</span></span> <span data-ttu-id="637db-127">不過，您需要謹慎實作此模式中，因為它可以在系統中，淺壓深點，它可能會違反微服務自主性的原則。</span><span class="sxs-lookup"><span data-stu-id="637db-127">However, you need to be careful about implementing this pattern, because it can be a choke point in your system, and it can violate the principle of microservice autonomy.</span></span> <span data-ttu-id="637db-128">若要減輕這種可能性，您可以有多個處以精細 API 閘道每一個將焦點放在垂直 「 部分 」 或業務區域的系統。</span><span class="sxs-lookup"><span data-stu-id="637db-128">To mitigate this possibility, you can have multiple fined-grained API Gateways each one focusing on a vertical “slice” or business area of the system.</span></span> <span data-ttu-id="637db-129">使用中的一節將詳細說明 API 閘道模式稍後 API 閘道。</span><span class="sxs-lookup"><span data-stu-id="637db-129">The API Gateway pattern is explained in more detail in the section in the Using an API Gateway later.</span></span>

<span data-ttu-id="637db-130">**查詢/reads 資料表 CQRS**。</span><span class="sxs-lookup"><span data-stu-id="637db-130">**CQRS with query/reads tables**.</span></span> <span data-ttu-id="637db-131">從多個 microservices 彙總資料的另一個解決方案是[具體化的檢視模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)。</span><span class="sxs-lookup"><span data-stu-id="637db-131">Another solution for aggregating data from multiple microservices is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="637db-132">在這種方式，您會產生，事先 （非正規化的資料之前準備實際的查詢，就可能發生），唯讀資料的資料表與多個 microservices 所擁有。</span><span class="sxs-lookup"><span data-stu-id="637db-132">In this approach, you generate, in advance (prepare denormalized data before the actual queries happen), a read-only table with the data that is owned by multiple microservices.</span></span> <span data-ttu-id="637db-133">資料表的格式，適合用戶端應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="637db-133">The table has a format suited to the client app’s needs.</span></span>

<span data-ttu-id="637db-134">請考慮類似行動應用程式的畫面。</span><span class="sxs-lookup"><span data-stu-id="637db-134">Consider something like the screen for a mobile app.</span></span> <span data-ttu-id="637db-135">如果您有單一資料庫時，您可能會提取一起使用的 SQL 查詢，執行複雜的聯結涉及多個資料表，該螢幕上的資料。</span><span class="sxs-lookup"><span data-stu-id="637db-135">If you have a single database, you might pull together the data for that screen using a SQL query that performs a complex join involving multiple tables.</span></span> <span data-ttu-id="637db-136">不過，當您有多個資料庫，且每個資料庫由不同的微服務所擁有，您無法查詢這些資料庫，並建立 SQL 聯結。</span><span class="sxs-lookup"><span data-stu-id="637db-136">However, when you have multiple databases, and each database is owned by a different microservice, you cannot query those databases and create a SQL join.</span></span> <span data-ttu-id="637db-137">複雜的查詢會變成一項挑戰。</span><span class="sxs-lookup"><span data-stu-id="637db-137">Your complex query becomes a challenge.</span></span> <span data-ttu-id="637db-138">您可以解決使用 CQRS 方法的需求，您在不同的資料庫只用於查詢建立反正規化的資料表。</span><span class="sxs-lookup"><span data-stu-id="637db-138">You can address the requirement using a CQRS approach—you create a denormalized table in a different database that is used just for queries.</span></span> <span data-ttu-id="637db-139">設計資料表時，可能特別針對複雜的查詢，所需的應用程式的螢幕和查詢資料表中的資料行的欄位之間有一對一關聯性所需的資料。</span><span class="sxs-lookup"><span data-stu-id="637db-139">The table can be designed specifically for the data you need for the complex query, with a one-to-one relationship between fields needed by your application’s screen and the columns in the query table.</span></span> <span data-ttu-id="637db-140">它也可做為報表用途。</span><span class="sxs-lookup"><span data-stu-id="637db-140">It could also serve for reporting purposes.</span></span>

<span data-ttu-id="637db-141">這種方法不只會解決了原始問題 （如何查詢及聯結跨 microservices）;也可以改善效能大幅相較於複雜的聯結，因為您已經有應用程式必須在查詢資料表中的資料。</span><span class="sxs-lookup"><span data-stu-id="637db-141">This approach not only solves the original problem (how to query and join across microservices); it also improves performance considerably when compared with a complex join, because you already have the data that the application needs in the query table.</span></span> <span data-ttu-id="637db-142">當然，使用查詢/讀取資料表中的命令和查詢責任隔離 (CQRS) 表示額外的開發工作，您必須不怕最終一致性。</span><span class="sxs-lookup"><span data-stu-id="637db-142">Of course, using Command and Query Responsibility Segregation (CQRS) with query/reads tables means additional development work, and you will need to embrace eventual consistency.</span></span> <span data-ttu-id="637db-143">然而，對於效能和高延展性需求[共同作業案例](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/)（或競爭的情況下，根據觀點來看） 是您應該將 CQRS 套用具有多個資料庫。</span><span class="sxs-lookup"><span data-stu-id="637db-143">Nonetheless, requirements on performance and high scalability in [collaborative scenarios](http://udidahan.com/2011/10/02/why-you-should-be-using-cqrs-almost-everywhere/) (or competitive scenarios, depending on the point of view) is where you should apply CQRS with multiple databases.</span></span>

<span data-ttu-id="637db-144">**在中央資料庫中的 「 冷資料 」**。</span><span class="sxs-lookup"><span data-stu-id="637db-144">**“Cold data” in central databases**.</span></span> <span data-ttu-id="637db-145">對於複雜的報表和可能不需要即時資料的查詢，常見的方法不會匯出您 「 熱資料 」 （從 microservices 異動資料） 為成只用於報表的大型資料庫的 「 冷資料 」。</span><span class="sxs-lookup"><span data-stu-id="637db-145">For complex reports and queries that might not require real-time data, a common approach is to export your “hot data” (transactional data from the microservices) as “cold data” into large databases that are used only for reporting.</span></span> <span data-ttu-id="637db-146">中央資料庫系統都可以是巨量資料為基礎系統，例如 Hadoop，根據 Azure SQL 資料倉儲或甚至單一 SQL 資料庫 （如果大小不會發生問題），僅供報表使用類似的資料倉儲。</span><span class="sxs-lookup"><span data-stu-id="637db-146">That central database system can be a Big Data-based system, like Hadoop, a data warehouse like one based on Azure SQL Data Warehouse, or even a single SQL database used just for reports (if size will not be an issue).</span></span>

<span data-ttu-id="637db-147">請注意，這個集中式的資料庫會僅適用於查詢和需要即時資料的報表。</span><span class="sxs-lookup"><span data-stu-id="637db-147">Keep in mind that this centralized database would be used only for queries and reports that do not need real-time data.</span></span> <span data-ttu-id="637db-148">原始的更新和交易，做為來源的真實性，一定要 microservices 資料中。</span><span class="sxs-lookup"><span data-stu-id="637db-148">The original updates and transactions, as your source of truth, have to be in your microservices data.</span></span> <span data-ttu-id="637db-149">使用事件導向的通訊 （涵蓋在下一節），或使用其他資料庫基礎結構匯入/匯出工具，將會同步處理資料的方式。</span><span class="sxs-lookup"><span data-stu-id="637db-149">The way you would synchronize data would be either by using event-driven communication (covered in the next sections) or by using other database infrastructure import/export tools.</span></span> <span data-ttu-id="637db-150">如果您使用事件導向的通訊，該整合程序會如先前所述的 CQRS 查詢資料表，會傳播資料的方式類似。</span><span class="sxs-lookup"><span data-stu-id="637db-150">If you use event-driven communication, that integration process would be similar to the way you propagate data as described earlier for CQRS query tables.</span></span>

<span data-ttu-id="637db-151">不過，如果您的應用程式的設計牽涉到不斷地彙總來自多個 microservices 複雜查詢的資訊，它可能不正確的設計的徵兆，應該儘可能從其他 microservices 為隔離微服務。</span><span class="sxs-lookup"><span data-stu-id="637db-151">However, if your application design involves constantly aggregating information from multiple microservices for complex queries, it might be a symptom of a bad design—a microservice should be as isolated as possible from other microservices.</span></span> <span data-ttu-id="637db-152">（這不包括報表/analytics，應一律使用冷資料的中央資料庫。）通常發生此問題可能是合併 microservices 的理由。</span><span class="sxs-lookup"><span data-stu-id="637db-152">(This excludes reports/analytics that always should use cold-data central databases.) Having this problem often might be a reason to merge microservices.</span></span> <span data-ttu-id="637db-153">您必須平衡的演進自主性和部署的每個強式的相依性、 一致性，與資料彙總的微服務。</span><span class="sxs-lookup"><span data-stu-id="637db-153">You need to balance the autonomy of evolution and deployment of each microservice with strong dependencies, cohesion, and data aggregation.</span></span>

## <a name="challenge-3-how-to-achieve-consistency-across-multiple-microservices"></a><span data-ttu-id="637db-154">挑戰\#3： 如何跨多個 microservices 達到一致性</span><span class="sxs-lookup"><span data-stu-id="637db-154">Challenge \#3: How to achieve consistency across multiple microservices</span></span>

<span data-ttu-id="637db-155">如先前所述，每個微服務所擁有的資料是私用的微服務，並只使用可以存取其應用程式開發介面的微服務。</span><span class="sxs-lookup"><span data-stu-id="637db-155">As stated previously, the data owned by each microservice is private to that microservice and can only be accessed using its microservice API.</span></span> <span data-ttu-id="637db-156">因此，呈現一項挑戰是如何同時保持一致性，跨多個 microservices 實作端對端商務程序。</span><span class="sxs-lookup"><span data-stu-id="637db-156">Therefore, a challenge presented is how to implement end-to-end business processes while keeping consistency across multiple microservices.</span></span>

<span data-ttu-id="637db-157">若要分析此問題，讓我們看看從範例[eShopOnContainers 參考應用程式](http://aka.ms/eshoponcontainers)。</span><span class="sxs-lookup"><span data-stu-id="637db-157">To analyze this problem, let’s look at an example from the [eShopOnContainers reference application](http://aka.ms/eshoponcontainers).</span></span> <span data-ttu-id="637db-158">類別目錄的微服務會維護所有產品，包括其股票的層級的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="637db-158">The Catalog microservice maintains information about all the products, including their stock level.</span></span> <span data-ttu-id="637db-159">訂購微服務管理訂單，並必須確認新的訂單不能超過可用的類別目錄產品存貨。</span><span class="sxs-lookup"><span data-stu-id="637db-159">The Ordering microservice manages orders and must verify that a new order does not exceed the available catalog product stock.</span></span> <span data-ttu-id="637db-160">（或此案例可能涉及邏輯會處理交貨產品）。在此應用程式假設整合型版本，排序子系統無法只使用 ACID 交易來檢查可用的內建、 在 「 訂單 」 資料表中建立順序並更新 Products 資料表中可用的存貨。</span><span class="sxs-lookup"><span data-stu-id="637db-160">(Or the scenario might involve logic that handles backordered products.) In a hypothetical monolithic version of this application, the ordering subsystem could simply use an ACID transaction to check the available stock, create the order in the Orders table, and update the available stock in the Products table.</span></span>

<span data-ttu-id="637db-161">不過，在 microservices 為基礎應用程式中，Order 和產品資料表所擁有其各自的 microservices。</span><span class="sxs-lookup"><span data-stu-id="637db-161">However, in a microservices- based application, the Order and Product tables are owned by their respective microservices.</span></span> <span data-ttu-id="637db-162">沒有微服務曾應該包含在自己的交易或查詢，另一個的微服務所擁有的資料庫，如圖 4 至 9 所示。</span><span class="sxs-lookup"><span data-stu-id="637db-162">No microservice should ever include databases owned by another microservice in its own transactions or queries, as shown in Figure 4-9.</span></span>

![](./media/image9.PNG)

<span data-ttu-id="637db-163">**圖 4 至 9**。</span><span class="sxs-lookup"><span data-stu-id="637db-163">**Figure 4-9**.</span></span> <span data-ttu-id="637db-164">微服務無法直接存取另一個的微服務中的資料表</span><span class="sxs-lookup"><span data-stu-id="637db-164">A microservice cannot directly access a table in another microservice</span></span>

<span data-ttu-id="637db-165">訂購微服務應該更新 Products 資料表直接管理，因為 Products 資料表由目錄微服務所擁有。</span><span class="sxs-lookup"><span data-stu-id="637db-165">The Ordering microservice should not update the Products table directly, because the Products table is owned by the Catalog microservice.</span></span> <span data-ttu-id="637db-166">若要更新目錄微服務，訂購微服務應該永遠只會使用非同步通訊，例如整合事件 （訊息和事件為基礎的通訊）。</span><span class="sxs-lookup"><span data-stu-id="637db-166">To make an update to the Catalog microservice, the Ordering microservice should only ever use asynchronous communication such as integration events (message and event-based communication).</span></span> <span data-ttu-id="637db-167">這是如何[eShopOnContainers](http://aka.ms/eshoponcontainers)參考應用程式會執行這種類型的更新。</span><span class="sxs-lookup"><span data-stu-id="637db-167">This is how the [eShopOnContainers](http://aka.ms/eshoponcontainers) reference application performs this type of update.</span></span>

<span data-ttu-id="637db-168">如下所述[CAP 理論](https://en.wikipedia.org/wiki/CAP_theorem)，您必須選擇可用性之間 ACID 強式一致性。</span><span class="sxs-lookup"><span data-stu-id="637db-168">As stated by the [CAP theorem](https://en.wikipedia.org/wiki/CAP_theorem), you need to choose between availability and ACID strong consistency.</span></span> <span data-ttu-id="637db-169">大部分的微服務為基礎的情況下要求可用性和高的延展性，而不是強式一致性。</span><span class="sxs-lookup"><span data-stu-id="637db-169">Most microservice-based scenarios demand availability and high scalability as opposed to strong consistency.</span></span> <span data-ttu-id="637db-170">關鍵任務應用程式必須保持註冊，並且執行，以及開發人員可以處理強式一致性使用弱式或最終一致性的使用技巧。</span><span class="sxs-lookup"><span data-stu-id="637db-170">Mission-critical applications must remain up and running, and developers can work around strong consistency by using techniques for working with weak or eventual consistency.</span></span> <span data-ttu-id="637db-171">這是大部分的微服務基礎架構所採用的方法。</span><span class="sxs-lookup"><span data-stu-id="637db-171">This is the approach taken by most microservice-based architectures.</span></span>

<span data-ttu-id="637db-172">此外，ACID 樣式或兩階段認可的交易不是只針對 microservices 原則;大部分的 NoSQL 資料庫 （例如 Azure Cosmos DB、 MongoDB、 等等） 不支援兩階段認可的交易。</span><span class="sxs-lookup"><span data-stu-id="637db-172">Moreover, ACID-style or two-phase commit transactions are not just against microservices principles; most NoSQL databases (like Azure Cosmos DB, MongoDB, etc.) do not support two-phase commit transactions.</span></span> <span data-ttu-id="637db-173">不過，維護資料服務和資料庫的一致性十分重要。</span><span class="sxs-lookup"><span data-stu-id="637db-173">However, maintaining data consistency across services and databases is essential.</span></span> <span data-ttu-id="637db-174">如何跨多個 microservices 傳播變更，某些資料需要備援時的問題也與這項挑戰 — 例如，當您需要有產品的名稱或類別目錄的微服務 」 和 「 購物籃中的描述微服務。</span><span class="sxs-lookup"><span data-stu-id="637db-174">This challenge is also related to the question of how to propagate changes across multiple microservices when certain data needs to be redundant—for example, when you need to have the product’s name or description in the Catalog microservice and the Basket microservice.</span></span>

<span data-ttu-id="637db-175">這個問題的最佳解決方案是使用最終 microservices 以透過事件導向的通訊和發佈和訂閱的系統之間的一致性。</span><span class="sxs-lookup"><span data-stu-id="637db-175">A good solution for this problem is to use eventual consistency between microservices articulated through event-driven communication and a publish-and-subscribe system.</span></span> <span data-ttu-id="637db-176">這些主題的章節將討論[事件驅動的非同步通訊](#async_event_driven_communication)本指南稍後的。</span><span class="sxs-lookup"><span data-stu-id="637db-176">These topics are covered in the section [Asynchronous event-driven communication](#async_event_driven_communication) later in this guide.</span></span>

## <a name="challenge-4-how-to-design-communication-across-microservice-boundaries"></a><span data-ttu-id="637db-177">挑戰\#4： 如何設計跨微服務界限的通訊</span><span class="sxs-lookup"><span data-stu-id="637db-177">Challenge \#4: How to design communication across microservice boundaries</span></span>

<span data-ttu-id="637db-178">通訊跨微服務界限是真正的挑戰。</span><span class="sxs-lookup"><span data-stu-id="637db-178">Communicating across microservice boundaries is a real challenge.</span></span> <span data-ttu-id="637db-179">在此內容中的通訊並不是指您哪些通訊協定 （HTTP 和 AMQP 訊息，依此類推，REST） 應該使用。</span><span class="sxs-lookup"><span data-stu-id="637db-179">In this context, communication does not refer to what protocol you should use (HTTP and REST, AMQP, messaging, and so on).</span></span> <span data-ttu-id="637db-180">相反地，其定址該使用何種通訊樣式，以及特別是如何結合您 microservices 應該。</span><span class="sxs-lookup"><span data-stu-id="637db-180">Instead, it addresses what communication style you should use, and especially how coupled your microservices should be.</span></span> <span data-ttu-id="637db-181">結合層級，依據發生失敗時，您的系統上發生失敗的影響將會大大地改變。</span><span class="sxs-lookup"><span data-stu-id="637db-181">Depending on the level of coupling, when failure occurs, the impact of that failure on your system will vary significantly.</span></span>

<span data-ttu-id="637db-182">就像 microservices 型應用程式，與許多移動的成品和跨許多伺服器或主機，分散式服務的分散式系統中的元件最終將會失敗。</span><span class="sxs-lookup"><span data-stu-id="637db-182">In a distributed system like a microservices-based application, with so many artifacts moving around and with distributed services across many servers or hosts, components will eventually fail.</span></span> <span data-ttu-id="637db-183">部分失敗，而且甚至更大的潛在性中斷問題會發生，因此您需要對它們列入考量的風險一般在這種類型的分散式系統設計您 microservices 和通訊。</span><span class="sxs-lookup"><span data-stu-id="637db-183">Partial failure and even larger outages will occur, so you need to design your microservices and the communication across them taking into account the risks common in this type of distributed system.</span></span>

<span data-ttu-id="637db-184">常用的方法是實作 HTTP (REST) 為基礎 microservices，由於其簡易性。</span><span class="sxs-lookup"><span data-stu-id="637db-184">A popular approach is to implement HTTP (REST)- based microservices, due to their simplicity.</span></span> <span data-ttu-id="637db-185">以 HTTP 為基礎的方法是完全可接受的。與使用方式相關的問題。</span><span class="sxs-lookup"><span data-stu-id="637db-185">An HTTP-based approach is perfectly acceptable; the issue here is related to how you use it.</span></span> <span data-ttu-id="637db-186">如果您只是為了與您從用戶端應用程式或應用程式開發介面閘道的 microservices 互動使用 HTTP 要求和回應，沒關係。</span><span class="sxs-lookup"><span data-stu-id="637db-186">If you use HTTP requests and responses just to interact with your microservices from client applications or from API Gateways, that is fine.</span></span> <span data-ttu-id="637db-187">但如果您建立的同步 HTTP 呼叫的長鏈結跨 microservices，如同 microservices 是整合的應用程式中的物件，其界限透過通訊應用程式將最終遇到問題。</span><span class="sxs-lookup"><span data-stu-id="637db-187">But if you create long chains of synchronous HTTP calls across microservices, communicating across their boundaries as if the microservices were objects in a monolithic application, your application will eventually run into problems.</span></span>

<span data-ttu-id="637db-188">比方說，假設用戶端應用程式可讓個別的微服務，例如訂購微服務的 HTTP API 呼叫。</span><span class="sxs-lookup"><span data-stu-id="637db-188">For instance, imagine that your client application makes an HTTP API call to an individual microservice like the Ordering microservice.</span></span> <span data-ttu-id="637db-189">如果訂購微服務接著會呼叫其他使用相同的要求/回應 HTTP microservices 循環，您所建立的 HTTP 呼叫鏈結。</span><span class="sxs-lookup"><span data-stu-id="637db-189">If the Ordering microservice in turn calls additional microservices using HTTP within the same request/response cycle, you are creating a chain of HTTP calls.</span></span> <span data-ttu-id="637db-190">它可能會看似合理一開始。</span><span class="sxs-lookup"><span data-stu-id="637db-190">It might sound reasonable initially.</span></span> <span data-ttu-id="637db-191">不過，有向此路徑時要考量的重點：</span><span class="sxs-lookup"><span data-stu-id="637db-191">However, there are important points to consider when going down this path:</span></span>

-   <span data-ttu-id="637db-192">封鎖和低效能。</span><span class="sxs-lookup"><span data-stu-id="637db-192">Blocking and low performance.</span></span> <span data-ttu-id="637db-193">由於 HTTP 同步的本質，原始要求不會收到回應之前完成所有的內部 HTTP 呼叫。</span><span class="sxs-lookup"><span data-stu-id="637db-193">Due to the synchronous nature of HTTP, the original request will not get a response until all the internal HTTP calls are finished.</span></span> <span data-ttu-id="637db-194">假設是否這些呼叫的數目會大幅提升，而其中一個中繼 HTTP 呼叫的微服務，同時被封鎖。</span><span class="sxs-lookup"><span data-stu-id="637db-194">Imagine if the number of these calls increases significantly and at the same time one of the intermediate HTTP calls to a microservice is blocked.</span></span> <span data-ttu-id="637db-195">結果是會影響效能，，和其他 HTTP 要求增加為以等比級數受影響的整體延展性。</span><span class="sxs-lookup"><span data-stu-id="637db-195">The result is that performance is impacted, and the overall scalability will be exponentially affected as additional HTTP requests increase.</span></span>

-   <span data-ttu-id="637db-196">結合 microservices 使用 HTTP。</span><span class="sxs-lookup"><span data-stu-id="637db-196">Coupling microservices with HTTP.</span></span> <span data-ttu-id="637db-197">商務 microservices 不應搭配其他商務 microservices。</span><span class="sxs-lookup"><span data-stu-id="637db-197">Business microservices should not be coupled with other business microservices.</span></span> <span data-ttu-id="637db-198">在理想情況下，它們應該不 「 知道 」 有關的其他 microservices 存在。</span><span class="sxs-lookup"><span data-stu-id="637db-198">Ideally, they should not “know” about the existence of other microservices.</span></span> <span data-ttu-id="637db-199">如果您的應用程式依賴耦合 microservices 範例所示，達成自主性每微服務會幾乎不可能。</span><span class="sxs-lookup"><span data-stu-id="637db-199">If your application relies on coupling microservices as in the example, achieving autonomy per microservice will be almost impossible.</span></span>

-   <span data-ttu-id="637db-200">失敗的任何一個的微服務。</span><span class="sxs-lookup"><span data-stu-id="637db-200">Failure in any one microservice.</span></span> <span data-ttu-id="637db-201">如果您實作 microservices 任何 microservices 失敗時 （將會失敗的最終） microservices 的整個鏈結，透過 HTTP 呼叫連結的鏈結將會失敗。</span><span class="sxs-lookup"><span data-stu-id="637db-201">If you implemented a chain of microservices linked by HTTP calls, when any of the microservices fails (and eventually they will fail) the whole chain of microservices will fail.</span></span> <span data-ttu-id="637db-202">微服務為基礎的系統應該設計成可繼續運作且盡可能期間部分失敗。</span><span class="sxs-lookup"><span data-stu-id="637db-202">A microservice-based system should be designed to continue to work as well as possible during partial failures.</span></span> <span data-ttu-id="637db-203">即使您實作重試使用指數型輪詢或斷路器機制與用戶端邏輯時，多個複雜 HTTP 呼叫鏈結是，它會實作 HTTP 為基礎的失敗策略越複雜。</span><span class="sxs-lookup"><span data-stu-id="637db-203">Even if you implement client logic that uses retries with exponential backoff or circuit breaker mechanisms, the more complex the HTTP call chains are, the more complex it is implement a failure strategy based on HTTP.</span></span>

<span data-ttu-id="637db-204">事實上，若您的內部 microservices 正在通訊所述，建立的 HTTP 要求的鏈結，它可以被 argued 您有一個根據 HTTP，而不是 intraprocess 通訊機制的處理序之間的整合應用程式。</span><span class="sxs-lookup"><span data-stu-id="637db-204">In fact, if your internal microservices are communicating by creating chains of HTTP requests as described, it could be argued that you have a monolithic application, but one based on HTTP between processes instead of intraprocess communication mechanisms.</span></span>

<span data-ttu-id="637db-205">因此，為了強制執行微服務自主性，並讓較佳的恢復功能，您應該盡量少用鏈結的要求/回應通訊的跨 microservices。</span><span class="sxs-lookup"><span data-stu-id="637db-205">Therefore, in order to enforce microservice autonomy and have better resiliency, you should minimize the use of chains of request/response communication across microservices.</span></span> <span data-ttu-id="637db-206">建議您間微服務通訊，使用唯一的非同步互動，使用非同步訊息和事件為基礎的通訊，或使用 HTTP 輪詢獨立原始的 HTTP 要求/回應週期。</span><span class="sxs-lookup"><span data-stu-id="637db-206">It is recommended that you use only asynchronous interaction for inter-microservice communication, either by using asynchronous message- and event-based communication, or by using HTTP polling independently of the original HTTP request/response cycle.</span></span>

<span data-ttu-id="637db-207">具有其他詳細資料，稍後在本指南中的各節說明的非同步通訊使用[非同步的微服務整合會強制微服務的自主性](#asynchronous-microservice-integration-enforce-microservices-autonomy)和[非同步訊息架構通訊](#asynchronous-message-based-communication)。</span><span class="sxs-lookup"><span data-stu-id="637db-207">The use of asynchronous communication is explained with additional details later in this guide in the sections [Asynchronous microservice integration enforces microservice’s autonomy](#asynchronous-microservice-integration-enforce-microservices-autonomy) and [Asynchronous message-based communication](#asynchronous-message-based-communication).</span></span>

## <a name="additional-resources"></a><span data-ttu-id="637db-208">其他資源</span><span class="sxs-lookup"><span data-stu-id="637db-208">Additional resources</span></span>

-   <span data-ttu-id="637db-209">**CAP 理論**
    [*https://en.wikipedia.org/wiki/CAP\_理論*](https://en.wikipedia.org/wiki/CAP_theorem)</span><span class="sxs-lookup"><span data-stu-id="637db-209">**CAP theorem**
[*https://en.wikipedia.org/wiki/CAP\_theorem*](https://en.wikipedia.org/wiki/CAP_theorem)</span></span>

-   <span data-ttu-id="637db-210">**最終一致性**
    [*https://en.wikipedia.org/wiki/Eventual\_一致性*](https://en.wikipedia.org/wiki/Eventual_consistency)</span><span class="sxs-lookup"><span data-stu-id="637db-210">**Eventual consistency**
[*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span></span>

-   <span data-ttu-id="637db-211">**資料一致性入門**
    [*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span><span class="sxs-lookup"><span data-stu-id="637db-211">**Data Consistency Primer**
[*https://msdn.microsoft.com/library/dn589800.aspx*](https://msdn.microsoft.com/library/dn589800.aspx)</span></span>

-   <span data-ttu-id="637db-212">**Martin Fowler：CQRS （命令和查詢責任隔離）**
    [*http://martinfowler.com/bliki/CQRS.html*](http://martinfowler.com/bliki/CQRS.html)</span><span class="sxs-lookup"><span data-stu-id="637db-212">**Martin Fowler. CQRS (Command and Query Responsibility Segregation)**
[*http://martinfowler.com/bliki/CQRS.html*](http://martinfowler.com/bliki/CQRS.html)</span></span>

-   <span data-ttu-id="637db-213">**具體化檢視**
    [*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span><span class="sxs-lookup"><span data-stu-id="637db-213">**Materialized View**
[*https://docs.microsoft.com/azure/architecture/patterns/materialized-view*](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)</span></span>

-   <span data-ttu-id="637db-214">**Charles 資料列。ACID vs。基底： Shifting pH 資料庫交易處理**
    [*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span><span class="sxs-lookup"><span data-stu-id="637db-214">**Charles Row. ACID vs. BASE: The Shifting pH of Database Transaction Processing**
[*http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/*](http://www.dataversity.net/acid-vs-base-the-shifting-ph-of-database-transaction-processing/)</span></span>

-   <span data-ttu-id="637db-215">**補償交易**
    [*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span><span class="sxs-lookup"><span data-stu-id="637db-215">**Compensating Transaction**
[*https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction*](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span></span>

-   <span data-ttu-id="637db-216">**Udi Dahan。服務導向組合**
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span><span class="sxs-lookup"><span data-stu-id="637db-216">**Udi Dahan. Service Oriented Composition**
[*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="637db-217">[上一個](邏輯-或-實體-architecture.md) [下一步] (識別的微服務-網域-模型-boundaries.md)</span><span class="sxs-lookup"><span data-stu-id="637db-217">[Previous] (logical-versus-physical-architecture.md) [Next] (identify-microservice-domain-model-boundaries.md)</span></span>
