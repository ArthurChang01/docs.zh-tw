---
title: "在微服務架構中的通訊"
description: "容器化的.NET 應用程式的.NET Microservices 架構 |微服務架構架構中的通訊"
keywords: "Docker, 微服務, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 8d38095a151b7568619b17340d768eff684d3271
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/22/2017
---
# <a name="communication-in-a-microservice-architecture"></a><span data-ttu-id="84e83-104">在微服務架構中的通訊</span><span class="sxs-lookup"><span data-stu-id="84e83-104">Communication in a microservice architecture</span></span>

<span data-ttu-id="84e83-105">在整合的應用程式，在單一處理序上執行，元件叫用另一個使用語言層級方法或函式呼叫。</span><span class="sxs-lookup"><span data-stu-id="84e83-105">In a monolithic application running on a single process, components invoke one another using language-level method or function calls.</span></span> <span data-ttu-id="84e83-106">這些可以強結合如果您使用程式碼建立物件 (例如， `new ClassName()`)，可以予以解除解合的方式呼叫，如果您正在使用相依性插入參考的抽象概念，而不是具象的物件執行個體。</span><span class="sxs-lookup"><span data-stu-id="84e83-106">These can be strongly coupled if you are creating objects with code (for example, `new ClassName()`), or can be invoked in a decoupled way if you are using Dependency Injection by referencing abstractions rather than concrete object instances.</span></span> <span data-ttu-id="84e83-107">無論如何，相同的程序內執行的物件。</span><span class="sxs-lookup"><span data-stu-id="84e83-107">Either way, the objects are running within the same process.</span></span> <span data-ttu-id="84e83-108">變更從 microservices 架構的應用程式整合的應用程式時，最大的挑戰在於變更的溝通機制。</span><span class="sxs-lookup"><span data-stu-id="84e83-108">The biggest challenge when changing from a monolithic application to a microservices-based application lies in changing the communication mechanism.</span></span> <span data-ttu-id="84e83-109">直接轉換成服務的 RPC 呼叫的同處理序的方法呼叫從會導致多對話，並不會也在執行的通訊效率不分散式環境。</span><span class="sxs-lookup"><span data-stu-id="84e83-109">A direct conversion from in-process method calls into RPC calls to services will cause a chatty and not efficient communication that will not perform well in distributed environments.</span></span> <span data-ttu-id="84e83-110">正確設計分散式的系統的挑戰夠好已知還有稱為 canon[分散式運算 fallacies](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing)其中列出開發人員通常會從移動時的假設分散式設計整合。</span><span class="sxs-lookup"><span data-stu-id="84e83-110">The challenges of designing distributed system properly are well enough known that there is even a canon known as the [The fallacies of distributed computing](https://en.wikipedia.org/wiki/Fallacies_of_distributed_computing) that lists assumptions that developers often make when moving from monolithic to distributed designs.</span></span>

<span data-ttu-id="84e83-111">沒有不一種解決方案，但是數個。</span><span class="sxs-lookup"><span data-stu-id="84e83-111">There is not one solution, but several.</span></span> <span data-ttu-id="84e83-112">一個解決方法包括隔離商務 microservices 盡量。</span><span class="sxs-lookup"><span data-stu-id="84e83-112">One solution involves isolating the business microservices as much as possible.</span></span> <span data-ttu-id="84e83-113">然後使用內部 microservices 之間的非同步通訊，並取代一般的粗粒通訊物件之間的內部處理序通訊的更細緻通訊。</span><span class="sxs-lookup"><span data-stu-id="84e83-113">You then use asynchronous communication between the internal microservices and replace fine-grained communication that is typical in intra-process communication between objects with coarser-grained communication.</span></span> <span data-ttu-id="84e83-114">您可以分組為呼叫，並藉由傳回彙總結果的多個內部呼叫，用戶端的資料。</span><span class="sxs-lookup"><span data-stu-id="84e83-114">You can do this by grouping calls, and by returning data that aggregates the results of multiple internal calls, to the client.</span></span>

<span data-ttu-id="84e83-115">Microservices 為基礎的應用程式是在多個處理程序或服務，通常甚至跨多個伺服器或主機上執行的分散式的系統。</span><span class="sxs-lookup"><span data-stu-id="84e83-115">A microservices-based application is a distributed system running on multiple processes or services, usually even across multiple servers or hosts.</span></span> <span data-ttu-id="84e83-116">每個服務執行個體通常是處理程序。</span><span class="sxs-lookup"><span data-stu-id="84e83-116">Each service instance is typically a process.</span></span> <span data-ttu-id="84e83-117">因此，服務必須使用的處理序間的通訊協定，例如 HTTP、 AMQP 或例如 TCP、 根據每個服務的本質的二進位通訊協定互動。</span><span class="sxs-lookup"><span data-stu-id="84e83-117">Therefore, services must interact using an inter-process communication protocol such as HTTP, AMQP, or a binary protocol like TCP, depending on the nature of each service.</span></span>

<span data-ttu-id="84e83-118">微服務社群升級的原理"[智慧型端點和無聲管道](http://simplicable.com/new/smart-endpoints-and-dumb-pipes)。 」</span><span class="sxs-lookup"><span data-stu-id="84e83-118">The microservice community promotes the philosophy of “[smart endpoints and dumb pipes](http://simplicable.com/new/smart-endpoints-and-dumb-pipes).”</span></span> <span data-ttu-id="84e83-119">此標語鼓勵為分離盡可能之間 microservices，且為結合盡可能在單一的微服務內的設計。</span><span class="sxs-lookup"><span data-stu-id="84e83-119">This slogan encourages a design that is as decoupled as possible between microservices, and as cohesive as possible within a single microservice.</span></span> <span data-ttu-id="84e83-120">如前所述，每個微服務擁有它自己的資料和它自己網域的邏輯。</span><span class="sxs-lookup"><span data-stu-id="84e83-120">As explained earlier, each microservice owns its own data and its own domain logic.</span></span> <span data-ttu-id="84e83-121">但 microservices 撰寫的端對端應用程式通常只會經過使用 REST 通訊，而不是複雜的通訊協定，例如 WS-\*與彈性事件導向的通訊，而不是集中式商務程序 orchestrators。</span><span class="sxs-lookup"><span data-stu-id="84e83-121">But the microservices composing an end-to-end application are usually simply choreographed by using REST communications rather than complex protocols such as WS-\* and flexible event-driven communications instead of centralized business-process-orchestrators.</span></span>

<span data-ttu-id="84e83-122">兩個常用的通訊協定為 HTTP 要求/回應與資源應用程式開發介面 （查詢最重要的是） 時，和跨多個 microservices 輕量型非同步傳訊通訊時更新。</span><span class="sxs-lookup"><span data-stu-id="84e83-122">The two commonly used protocols are HTTP request/response with resource APIs (when querying most of all), and lightweight asynchronous messaging when communicating updates across multiple microservices.</span></span> <span data-ttu-id="84e83-123">這些會在下列各節中詳細說明。</span><span class="sxs-lookup"><span data-stu-id="84e83-123">These are explained in more detail in the following sections.</span></span>

## <a name="communication-types"></a><span data-ttu-id="84e83-124">通訊類型</span><span class="sxs-lookup"><span data-stu-id="84e83-124">Communication types</span></span>

<span data-ttu-id="84e83-125">用戶端和服務可以透過許多不同類型的通訊，以不同的案例與目標為目標的每個進行通訊。</span><span class="sxs-lookup"><span data-stu-id="84e83-125">Client and services can communicate through many different types of communication, each one targeting a different scenario and goals.</span></span> <span data-ttu-id="84e83-126">一開始，這些類型的通訊可以分類在兩個軸。</span><span class="sxs-lookup"><span data-stu-id="84e83-126">Initially, those types of communications can be classified in two axes.</span></span>

<span data-ttu-id="84e83-127">如果同步或非同步通訊協定，定義的第一個軸：</span><span class="sxs-lookup"><span data-stu-id="84e83-127">The first axis is defining if the protocol is synchronous or asynchronous:</span></span>

-   <span data-ttu-id="84e83-128">同步通訊協定。</span><span class="sxs-lookup"><span data-stu-id="84e83-128">Synchronous protocol.</span></span> <span data-ttu-id="84e83-129">HTTP 是同步的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="84e83-129">HTTP is a synchronous protocol.</span></span> <span data-ttu-id="84e83-130">用戶端傳送要求，並等候來自服務的回應。</span><span class="sxs-lookup"><span data-stu-id="84e83-130">The client sends a request and waits for a response from the service.</span></span> <span data-ttu-id="84e83-131">這是獨立用戶端程式碼執行，可能是同步的 （封鎖的執行緒） 或非同步 （不封鎖執行緒，和回應會最後到達回呼）。</span><span class="sxs-lookup"><span data-stu-id="84e83-131">That is independent of the client code execution that could be synchronous (thread is blocked) or asynchronous (thread is not blocked, and the response will reach a callback eventually).</span></span> <span data-ttu-id="84e83-132">此處的重點是通訊協定 (HTTP/HTTPS) 是同步，並收到 HTTP 伺服器回應時，用戶端程式碼才可以繼續其工作。</span><span class="sxs-lookup"><span data-stu-id="84e83-132">The important point here is that the protocol (HTTP/HTTPS) is synchronous and the client code can only continue its task when it receives the HTTP server response.</span></span>

-   <span data-ttu-id="84e83-133">非同步通訊協定。</span><span class="sxs-lookup"><span data-stu-id="84e83-133">Asynchronous protocol.</span></span> <span data-ttu-id="84e83-134">其他通訊協定，如 AMQP （許多作業系統和雲端環境所支援的通訊協定） 使用非同步的訊息。</span><span class="sxs-lookup"><span data-stu-id="84e83-134">Other protocols like AMQP (a protocol supported by many operating systems and cloud environments) use asynchronous messages.</span></span> <span data-ttu-id="84e83-135">用戶端程式碼或訊息寄件者通常不會等待回應。</span><span class="sxs-lookup"><span data-stu-id="84e83-135">The client code or message sender usually does not wait for a response.</span></span> <span data-ttu-id="84e83-136">傳送訊息給 RabbitMQ 佇列或任何其他訊息代理程式時，它只會傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="84e83-136">It just sends the message as when sending a message to a RabbitMQ queue or any other message broker.</span></span>

<span data-ttu-id="84e83-137">第二個軸定義為單一接收者或多個接收者通訊是否：</span><span class="sxs-lookup"><span data-stu-id="84e83-137">The second axis is defining if the communication has a single receiver or multiple receivers:</span></span>

-   <span data-ttu-id="84e83-138">單一接收者。</span><span class="sxs-lookup"><span data-stu-id="84e83-138">Single receiver.</span></span> <span data-ttu-id="84e83-139">每個要求必須剛好只有一個收件者或服務所處理。</span><span class="sxs-lookup"><span data-stu-id="84e83-139">Each request must be processed by exactly one receiver or service.</span></span> <span data-ttu-id="84e83-140">舉例來說，此通訊是[命令模式](https://en.wikipedia.org/wiki/Command_pattern)。</span><span class="sxs-lookup"><span data-stu-id="84e83-140">An example of this communication is the [Command pattern](https://en.wikipedia.org/wiki/Command_pattern).</span></span>

-   <span data-ttu-id="84e83-141">多個接收者。</span><span class="sxs-lookup"><span data-stu-id="84e83-141">Multiple receivers.</span></span> <span data-ttu-id="84e83-142">每個要求可以處理除以零到多個接收者。</span><span class="sxs-lookup"><span data-stu-id="84e83-142">Each request can be processed by zero to multiple receivers.</span></span> <span data-ttu-id="84e83-143">這種類型必須是通訊的非同步的。</span><span class="sxs-lookup"><span data-stu-id="84e83-143">This type of communication must be asynchronous.</span></span> <span data-ttu-id="84e83-144">範例是[發佈/訂閱](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern)類似的模式中使用的機制[事件驅動的架構](http://microservices.io/patterns/data/event-driven-architecture.html)。</span><span class="sxs-lookup"><span data-stu-id="84e83-144">An example is the [publish/subscribe](https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern) mechanism used in patterns like [Event-driven architecture](http://microservices.io/patterns/data/event-driven-architecture.html).</span></span> <span data-ttu-id="84e83-145">這根據事件匯流排的介面或訊息代理程式時傳播事件，透過多個 microservices 之間的資料更新它通常透過 service bus 或類似的成品，例如實作[Azure 服務匯流排](https://azure.microsoft.com/services/service-bus/)使用[主題和訂閱](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)。</span><span class="sxs-lookup"><span data-stu-id="84e83-145">This is based on an event-bus interface or message broker when propagating data updates between multiple microservices through events; it is usually implemented through a service bus or similar artifact like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) by using [topics and subscriptions](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span>

<span data-ttu-id="84e83-146">微服務為基礎的應用程式通常會使用這些通訊樣式的組合。</span><span class="sxs-lookup"><span data-stu-id="84e83-146">A microservice-based application will often use a combination of these communication styles.</span></span> <span data-ttu-id="84e83-147">叫用一般的 Web API HTTP 服務時，最常見的類型會是單一接收者同步的通訊協定，例如 HTTP/HTTPS 通訊。</span><span class="sxs-lookup"><span data-stu-id="84e83-147">The most common type is single-receiver communication with a synchronous protocol like HTTP/HTTPS when invoking a regular Web API HTTP service.</span></span> <span data-ttu-id="84e83-148">Microservices 通常也會使用訊息通訊協定 microservices 之間的非同步通訊。</span><span class="sxs-lookup"><span data-stu-id="84e83-148">Microservices also typically use messaging protocols for asynchronous communication between microservices.</span></span>

<span data-ttu-id="84e83-149">這些軸適合知道，以便清楚說明對可能的通訊機制，但它們不是建置 microservices 時重要的考量。</span><span class="sxs-lookup"><span data-stu-id="84e83-149">These axes are good to know so you have clarity on the possible communication mechanisms, but they are not the important concerns when building microservices.</span></span> <span data-ttu-id="84e83-150">整合 microservices 時，所選通訊協定的用戶端執行緒執行甚至非同步本質的非同步本質是重點。</span><span class="sxs-lookup"><span data-stu-id="84e83-150">The asynchronous nature of client thread execution not even the asynchronous nature of the selected protocol are the important points when integrating microservices.</span></span> <span data-ttu-id="84e83-151">什麼*是*重要能夠整合您 microservices 以非同步方式同時維護的獨立性 microservices 下, 一節中所述。</span><span class="sxs-lookup"><span data-stu-id="84e83-151">What *is* important is being able to integrate your microservices asynchronously while maintaining the independence of microservices, as explained in the following section.</span></span>

## <a name="asynchronous-microservice-integration-enforces-microservices-autonomy"></a><span data-ttu-id="84e83-152">非同步的微服務整合會強制微服務的自主性</span><span class="sxs-lookup"><span data-stu-id="84e83-152">Asynchronous microservice integration enforces microservice’s autonomy</span></span>

<span data-ttu-id="84e83-153">如所述，建置 microservices 為基礎的應用程式時很重要的一點是您整合您 microservices 的方式。</span><span class="sxs-lookup"><span data-stu-id="84e83-153">As mentioned, the important point when building a microservices-based application is the way you integrate your microservices.</span></span> <span data-ttu-id="84e83-154">在理想情況下，您應該嘗試最小化內部 microservices 之間的通訊。</span><span class="sxs-lookup"><span data-stu-id="84e83-154">Ideally, you should try to minimize the communication between the internal microservices.</span></span> <span data-ttu-id="84e83-155">較少之間的通訊 microservices，愈好。</span><span class="sxs-lookup"><span data-stu-id="84e83-155">The less communications between microservices, the better.</span></span> <span data-ttu-id="84e83-156">但是，在許多情況下您必須以某種方式整合 microservices。</span><span class="sxs-lookup"><span data-stu-id="84e83-156">But of course, in many cases you will have to somehow integrate the microservices.</span></span> <span data-ttu-id="84e83-157">當您需要執行此作業時，重要的規則是 microservices 之間的通訊，應該是非同步。</span><span class="sxs-lookup"><span data-stu-id="84e83-157">When you need to do that, the critical rule here is that the communication between the microservices should be asynchronous.</span></span> <span data-ttu-id="84e83-158">這不代表您必須使用特定的通訊協定 （例如，非同步訊息與同步 HTTP）。</span><span class="sxs-lookup"><span data-stu-id="84e83-158">That does not mean that you have to use a specific protocol (for example, asynchronous messaging versus synchronous HTTP).</span></span> <span data-ttu-id="84e83-159">它只是表示應該只由以非同步方式將資料傳播 microservices 之間的通訊，但不是嘗試相依於其他內部 microservices，做為初始服務的 HTTP 要求/回應作業的一部分。</span><span class="sxs-lookup"><span data-stu-id="84e83-159">It just means that the communication between microservices should be done only by propagating data asynchronously, but try not to depend on other internal microservices as part of the initial service’s HTTP request/response operation.</span></span>

<span data-ttu-id="84e83-160">可能的話，請永遠不會相依於多個 microservices，甚至不能用於查詢之間的同步通訊 （要求/回應）。</span><span class="sxs-lookup"><span data-stu-id="84e83-160">If possible, never depend on synchronous communication (request/response) between multiple microservices, not even for queries.</span></span> <span data-ttu-id="84e83-161">每個微服務的目標是希望自發並可供用戶端取用者，即使的端對端應用程式一部分的其他服務都關機或狀況不良。</span><span class="sxs-lookup"><span data-stu-id="84e83-161">The goal of each microservice is to be autonomous and available to the client consumer, even if the other services that are part of the end-to-end application are down or unhealthy.</span></span> <span data-ttu-id="84e83-162">如果您認為您需要進行其他 microservices （例如，執行 HTTP 要求的資料查詢） 從一個微服務呼叫中，以便能夠提供回應給用戶端應用程式，您必須將無法復原某些架構microservices 失敗。</span><span class="sxs-lookup"><span data-stu-id="84e83-162">If you think you need to make a call from one microservice to other microservices (like performing an HTTP request for a data query) in order to be able to provide a response to a client application, you have an architecture that will not be resilient when some microservices fail.</span></span>

<span data-ttu-id="84e83-163">此外，具有 HTTP microservices 的圖 4-15 中的第一個部分中所示，使用 HTTP 要求/回應循環建立長時要求鏈結，例如之間的相依性不只會使您 microservices 不自發，但其效能也是影響，因為其中一個該鏈結中的服務未在順利執行。</span><span class="sxs-lookup"><span data-stu-id="84e83-163">Moreover, having HTTP dependencies between microservices, like when creating long request/response cycles with HTTP request chains, as shown in the first part of the Figure 4-15, not only makes your microservices not autonomous but also their performance is impacted as soon as one of the services in that chain is not performing well.</span></span> 

<span data-ttu-id="84e83-164">您增加 microservices，例如查詢要求之間的同步相依性，更糟的整體回應時間取得用戶端應用程式。</span><span class="sxs-lookup"><span data-stu-id="84e83-164">The more you add synchronous dependencies between microservices, such as query requests, the worse the overall response time gets for the client apps.</span></span>

![](./media/image15.png)

<span data-ttu-id="84e83-165">**圖 4-15**。</span><span class="sxs-lookup"><span data-stu-id="84e83-165">**Figure 4-15**.</span></span> <span data-ttu-id="84e83-166">反向模式和 microservices 之間的通訊模式</span><span class="sxs-lookup"><span data-stu-id="84e83-166">Anti-patterns and patterns in communication between microservices</span></span>

<span data-ttu-id="84e83-167">如果您的微服務需要引發另一個的微服務的其他動作，可能的話，不要執行該動作以同步和做為原始的微服務要求與回覆作業的一部分。</span><span class="sxs-lookup"><span data-stu-id="84e83-167">If your microservice needs to raise an additional action in another microservice, if possible, do not perform that action synchronously and as part of the original microservice request and reply operation.</span></span> <span data-ttu-id="84e83-168">請改為以非同步方式執行 （使用非同步傳訊或整合事件、 佇列，等）。</span><span class="sxs-lookup"><span data-stu-id="84e83-168">Instead, do it asynchronously (using asynchronous messaging or integration events, queues, etc.).</span></span> <span data-ttu-id="84e83-169">但是，盡可能，不會叫用的動作，以同步方式做為原始的同步要求與回覆作業的一部分。</span><span class="sxs-lookup"><span data-stu-id="84e83-169">But, as much as possible, do not invoke the action synchronously as part of the original synchronous request and reply operation.</span></span>

<span data-ttu-id="84e83-170">最後再 （而且這是建置 microservices 時的大部份問題會發生），如果您初始的微服務需要原本由其他 microservices 所擁有的資料時，請勿依賴提出同步要求，該資料。</span><span class="sxs-lookup"><span data-stu-id="84e83-170">And finally (and this is where most of the issues arise when building microservices), if your initial microservice needs data that is originally owned by other microservices, do not rely on making synchronous requests for that data.</span></span> <span data-ttu-id="84e83-171">相反地，複製或資料 （只有您所需的屬性） 傳播到起始服務的資料庫，最終一致性 （通常使用透過整合事件幾節中所述）。</span><span class="sxs-lookup"><span data-stu-id="84e83-171">Instead, replicate or propagate that data (only the attributes you need) into the initial service’s database by using eventual consistency (typically by using integration events, as explained in upcoming sections).</span></span>

<span data-ttu-id="84e83-172">如前文所述的區段中[識別每個微服務的網域模型界限](#identifying-domain-model-boundaries-for-each-microservice)，在數個 microservices 之間複製某些資料不是設計不正確，相反地，當您可以將資料轉譯到特定語言或其他網域或繫結內容的條款。</span><span class="sxs-lookup"><span data-stu-id="84e83-172">As noted earlier in the section [Identifying domain-model boundaries for each microservice](#identifying-domain-model-boundaries-for-each-microservice), duplicating some data across several microservices is not an incorrect design—on the contrary, when doing that you can translate the data into the specific language or terms of that additional domain or Bounded Context.</span></span> <span data-ttu-id="84e83-173">例如，在[eShopOnContainers](http://aka.ms/MicroservicesArchitecture)應用程式具有名為具有名為使用者的實體，負責大部分的使用者資料的 identity.api 微服務。</span><span class="sxs-lookup"><span data-stu-id="84e83-173">For instance, in the [eShopOnContainers](http://aka.ms/MicroservicesArchitecture) application you have a microservice named identity.api that is in charge of most of the user’s data with an entity named User.</span></span> <span data-ttu-id="84e83-174">不過，當您需要儲存訂購微服務中使用者相關資料，您將它儲存為不同的實體，名為買方。</span><span class="sxs-lookup"><span data-stu-id="84e83-174">However, when you need to store data about the user within the Ordering microservice, you store it as a different entity named Buyer.</span></span> <span data-ttu-id="84e83-175">買方實體與原始使用者實體中，共用相同的識別，但它可能只有幾個屬性所需的訂購網域，並不完整的使用者設定檔。</span><span class="sxs-lookup"><span data-stu-id="84e83-175">The Buyer entity shares the same identity with the original User entity, but it might have only the few attributes needed by the Ordering domain, and not the whole user profile.</span></span>

<span data-ttu-id="84e83-176">您可以使用任何通訊協定來進行通訊，並散佈資料以非同步方式 microservices 才能擁有最終一致性。</span><span class="sxs-lookup"><span data-stu-id="84e83-176">You might use any protocol to communicate and propagate data asynchronously across microservices in order to have eventual consistency.</span></span> <span data-ttu-id="84e83-177">如前所述，您可以使用整合事件使用事件匯流排或 broker，或甚至還可以使用 HTTP 透過改用輪詢其他服務的訊息。</span><span class="sxs-lookup"><span data-stu-id="84e83-177">As mentioned, you could use integration events using an event bus or message broker or you could even use HTTP by polling the other services instead.</span></span> <span data-ttu-id="84e83-178">並不重要。</span><span class="sxs-lookup"><span data-stu-id="84e83-178">It does not matter.</span></span> <span data-ttu-id="84e83-179">重要的規則，就會建立同步您 microservices 之間的相依性。</span><span class="sxs-lookup"><span data-stu-id="84e83-179">The important rule is to not create synchronous dependencies between your microservices.</span></span>

<span data-ttu-id="84e83-180">下列各節說明您可以考慮在微服務應用程式中使用多個通訊樣式。</span><span class="sxs-lookup"><span data-stu-id="84e83-180">The following sections explain the multiple communication styles you can consider using in a microservice-based application.</span></span>

## <a name="communication-styles"></a><span data-ttu-id="84e83-181">通訊樣式</span><span class="sxs-lookup"><span data-stu-id="84e83-181">Communication styles</span></span>

<span data-ttu-id="84e83-182">有許多通訊協定和通訊，視您想要使用的通訊類型而定，您可以使用的選項。</span><span class="sxs-lookup"><span data-stu-id="84e83-182">There are many protocols and choices you can use for communication, depending on the communication type you want to use.</span></span> <span data-ttu-id="84e83-183">如果您使用的同步要求/回應為基礎的通訊機制，通訊協定，例如 HTTP 和 REST 的方式是最常見的特別是當您發行您的 Docker 主機 」 或 「 微服務叢集外的服務。</span><span class="sxs-lookup"><span data-stu-id="84e83-183">If you are using a synchronous request/response-based communication mechanism, protocols such as HTTP and REST approaches are the most common, especially if you are publishing your services outside the Docker host or microservice cluster.</span></span> <span data-ttu-id="84e83-184">如果您在內部 （在您的 Docker 主機或 microservices 叢集） 的服務之間通訊您也可以使用二進位格式 （例如 Service Fabric 遠端服務或 WCF 使用 TCP 和二進位格式） 的通訊機制。</span><span class="sxs-lookup"><span data-stu-id="84e83-184">If you are communicating between services internally (within your Docker host or microservices cluster) you might also want to use binary format communication mechanisms (like Service Fabric remoting or WCF using TCP and binary format).</span></span> <span data-ttu-id="84e83-185">或者，您可以使用以訊息為基礎的非同步通訊機制，例如 AMQP。</span><span class="sxs-lookup"><span data-stu-id="84e83-185">Alternatively, you can use asynchronous, message-based communication mechanisms such as AMQP.</span></span>

<span data-ttu-id="84e83-186">也有多個訊息格式，如 JSON 或 XML 或甚至二進位格式，可能會更有效率。</span><span class="sxs-lookup"><span data-stu-id="84e83-186">There are also multiple message formats like JSON or XML, or even binary formats, which can be more efficient.</span></span> <span data-ttu-id="84e83-187">如果您選擇的二進位格式不是一種標準，可能不是個不錯的主意公開發行您的服務使用該格式。</span><span class="sxs-lookup"><span data-stu-id="84e83-187">If your chosen binary format is not a standard, it is probably not a good idea to publicly publish your services using that format.</span></span> <span data-ttu-id="84e83-188">您可以在您 microservices 之間的內部通訊使用非標準格式。</span><span class="sxs-lookup"><span data-stu-id="84e83-188">You could use a non-standard format for internal communication between your microservices.</span></span> <span data-ttu-id="84e83-189">Microservices Docker 主機 」 或 「 微服務叢集 （Docker orchestrators 或 Azure Service Fabric） 內或向 microservices 的專屬的用戶端應用程式之間進行通訊時，您可以這樣做。</span><span class="sxs-lookup"><span data-stu-id="84e83-189">You might do this when communicating between microservices within your Docker host or microservice cluster (Docker orchestrators or Azure Service Fabric), or for proprietary client applications that talk to the microservices.</span></span>

### <a name="requestresponse-communication-with-http-and-rest"></a><span data-ttu-id="84e83-190">透過 HTTP 和 REST 要求/回應通訊</span><span class="sxs-lookup"><span data-stu-id="84e83-190">Request/response communication with HTTP and REST</span></span> 

<span data-ttu-id="84e83-191">當用戶端會使用要求/回應通訊時，它會將要求傳送至服務，然後服務處理程序要求，並將回應傳回。</span><span class="sxs-lookup"><span data-stu-id="84e83-191">When a client uses request/response communication, it sends a request to a service, then the service processes the request and sends back a response.</span></span> <span data-ttu-id="84e83-192">要求/回應通訊非常特別適合從用戶端應用程式的即時 UI （即時的使用者介面） 的查詢資料。</span><span class="sxs-lookup"><span data-stu-id="84e83-192">Request/response communication is especially well suited for querying data for a real-time UI (a live user interface) from client apps.</span></span> <span data-ttu-id="84e83-193">因此，在微服務架構中您可能會使用此通訊機制對於大部分查詢而言示圖 4-16。</span><span class="sxs-lookup"><span data-stu-id="84e83-193">Therefore, in a microservice architecture you will probably use this communication mechanism for most queries, as shown in Figure 4-16.</span></span>

![](./media/image16.png)

<span data-ttu-id="84e83-194">**圖 4-16**。</span><span class="sxs-lookup"><span data-stu-id="84e83-194">**Figure 4-16**.</span></span> <span data-ttu-id="84e83-195">使用 HTTP 要求/回應通訊 （同步或非同步）</span><span class="sxs-lookup"><span data-stu-id="84e83-195">Using HTTP request/response communication (synchronous or asynchronous)</span></span>

<span data-ttu-id="84e83-196">當用戶端會使用要求/回應通訊時，它會假設，回應會到達一段時間，通常少於一秒或幾秒鐘的時間最多。</span><span class="sxs-lookup"><span data-stu-id="84e83-196">When a client uses request/response communication, it assumes that the response will arrive in a short time, typically less than a second, or a few seconds at most.</span></span> <span data-ttu-id="84e83-197">對於回應延遲，您需要實作基礎的非同步通訊[傳訊模式](https://docs.microsoft.com/azure/architecture/patterns/category/messaging)和[傳訊技術](https://en.wikipedia.org/wiki/Message-oriented_middleware)，這是我們在下一節說明不同的方法。</span><span class="sxs-lookup"><span data-stu-id="84e83-197">For delayed responses, you need to implement asynchronous communication based on [messaging patterns](https://docs.microsoft.com/azure/architecture/patterns/category/messaging) and [messaging technologies](https://en.wikipedia.org/wiki/Message-oriented_middleware), which is a different approach that we explain in the next section.</span></span>

<span data-ttu-id="84e83-198">要求/回應通訊的熱門架構樣式是[REST](https://en.wikipedia.org/wiki/Representational_state_transfer)。</span><span class="sxs-lookup"><span data-stu-id="84e83-198">A popular architectural style for request/response communication is [REST](https://en.wikipedia.org/wiki/Representational_state_transfer).</span></span> <span data-ttu-id="84e83-199">這種方法為基礎，而緊密結合， [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)通訊協定，採用 HTTP 動詞命令，例如 GET、 POST 和 PUT。</span><span class="sxs-lookup"><span data-stu-id="84e83-199">This approach is based on, and tightly coupled to, the [HTTP](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) protocol, embracing HTTP verbs like GET, POST, and PUT.</span></span> <span data-ttu-id="84e83-200">建立服務時，其餘部分會是最常用架構的通訊方法。</span><span class="sxs-lookup"><span data-stu-id="84e83-200">REST is the most commonly used architectural communication approach when creating services.</span></span> <span data-ttu-id="84e83-201">當您開發 ASP.NET Core Web API 服務時，您可以實作 REST 服務。</span><span class="sxs-lookup"><span data-stu-id="84e83-201">You can implement REST services when you develop ASP.NET Core Web API services.</span></span>

<span data-ttu-id="84e83-202">為您的介面定義語言中使用 HTTP 的 REST 服務時，沒有其他的值。</span><span class="sxs-lookup"><span data-stu-id="84e83-202">There is additional value when using HTTP REST services as your interface definition language.</span></span> <span data-ttu-id="84e83-203">比方說，如果您使用[Swagger 中繼資料](http://swagger.io/)來描述服務 API，您可以使用工具，可產生用戶端 stub，可以直接探索及取用您的服務。</span><span class="sxs-lookup"><span data-stu-id="84e83-203">For instance, if you use [Swagger metadata](http://swagger.io/) to describe your service API, you can use tools that generate client stubs that can directly discover and consume your services.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="84e83-204">其他資源</span><span class="sxs-lookup"><span data-stu-id="84e83-204">Additional resources</span></span>

-   <span data-ttu-id="84e83-205">**Martin Fowler：Richardson Maturity Model。**</span><span class="sxs-lookup"><span data-stu-id="84e83-205">**Martin Fowler. Richardson Maturity Model.**</span></span> <span data-ttu-id="84e83-206">其他模型的描述。</span><span class="sxs-lookup"><span data-stu-id="84e83-206">A description of the REST model.</span></span>
    [<span data-ttu-id="84e83-207">*http://martinfowler.com/articles/richardsonMaturityModel.html*</span><span class="sxs-lookup"><span data-stu-id="84e83-207">*http://martinfowler.com/articles/richardsonMaturityModel.html*</span></span>](http://martinfowler.com/articles/richardsonMaturityModel.html)

-   <span data-ttu-id="84e83-208">**Swagger。**</span><span class="sxs-lookup"><span data-stu-id="84e83-208">**Swagger.**</span></span> <span data-ttu-id="84e83-209">官方網站。</span><span class="sxs-lookup"><span data-stu-id="84e83-209">The official site.</span></span>
    [<span data-ttu-id="84e83-210">*http://swagger.io/*</span><span class="sxs-lookup"><span data-stu-id="84e83-210">*http://swagger.io/*</span></span>](http://swagger.io/)

### <a name="push-and-real-time-communication-based-on-http"></a><span data-ttu-id="84e83-211">發送和 HTTP 為基礎的通訊</span><span class="sxs-lookup"><span data-stu-id="84e83-211">Push and real-time communication based on HTTP</span></span>

<span data-ttu-id="84e83-212">（通常是供不同比其餘部分） 的另一個可能性是較高層級架構與即時和一對多通訊例如[ASP.NET SignalR](https://www.asp.net/signalr)和通訊協定例如[WebSockets](https://en.wikipedia.org/wiki/WebSocket)。</span><span class="sxs-lookup"><span data-stu-id="84e83-212">Another possibility (usually for different purposes than REST) is a real-time and one-to-many communication with higher-level frameworks such as [ASP.NET SignalR](https://www.asp.net/signalr) and protocols such as [WebSockets](https://en.wikipedia.org/wiki/WebSocket).</span></span>

<span data-ttu-id="84e83-213">如圖 4-17 所示，即時 HTTP 訊息表示您可以將內容推送至連線的用戶端，當資料可用，而不是需要等候用戶端要求新的資料在伺服器的伺服端程式碼。</span><span class="sxs-lookup"><span data-stu-id="84e83-213">As Figure 4-17 shows, real-time HTTP communication means that you can have server code pushing content to connected clients as the data becomes available, rather than having the server wait for a client to request new data.</span></span>

![](./media/image17.png)

<span data-ttu-id="84e83-214">**圖 4-17**。</span><span class="sxs-lookup"><span data-stu-id="84e83-214">**Figure 4-17**.</span></span> <span data-ttu-id="84e83-215">一對一即時的非同步訊息通訊</span><span class="sxs-lookup"><span data-stu-id="84e83-215">One-to-one real-time asynchronous message communication</span></span>

<span data-ttu-id="84e83-216">由於即時通訊，用戶端應用程式幾乎會立即顯示變更。</span><span class="sxs-lookup"><span data-stu-id="84e83-216">Since communication is in real time, client apps show the changes almost instantly.</span></span> <span data-ttu-id="84e83-217">這通常被處理通訊協定，例如 WebSockets，使用許多 Websocket 連線 （用戶端每一個）。</span><span class="sxs-lookup"><span data-stu-id="84e83-217">This is usually handled by a protocol such as WebSockets, using many WebSockets connections (one per client).</span></span> <span data-ttu-id="84e83-218">典型的範例時，同時服務通訊的許多用戶端 web 應用程式在運動遊戲的分數中相符的變更。</span><span class="sxs-lookup"><span data-stu-id="84e83-218">A typical example is when a service communicates a change in the score of a sports game to many client web apps simultaneously.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="84e83-219">[上一個](direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [下一步] (非同步的訊息為基礎-communication.md)</span><span class="sxs-lookup"><span data-stu-id="84e83-219">[Previous] (direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) [Next] (asynchronous-message-based-communication.md)</span></span>
