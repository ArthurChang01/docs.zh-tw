---
title: "資料 sovereignty 每微服務"
description: "容器化的.NET 應用程式的.NET Microservices 架構 |資料 sovereignty 每微服務"
keywords: "Docker, 微服務, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: c51daae04215cfa6f5b5b8d2158a8ed1a8949652
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/22/2017
---
# <a name="data-sovereignty-per-microservice"></a><span data-ttu-id="482a4-104">資料 sovereignty 每微服務</span><span class="sxs-lookup"><span data-stu-id="482a4-104">Data sovereignty per microservice</span></span>

<span data-ttu-id="482a4-105">Microservices 架構的重要規則是每個微服務必須擁有網域資料和邏輯。</span><span class="sxs-lookup"><span data-stu-id="482a4-105">An important rule for microservices architecture is that each microservice must own its domain data and logic.</span></span> <span data-ttu-id="482a4-106">就像完整的應用程式擁有其邏輯和資料，因此必須每個微服務擁有其邏輯和自發的生命週期，與獨立部署每個微服務底下的資料。</span><span class="sxs-lookup"><span data-stu-id="482a4-106">Just as a full application owns its logic and data, so must each microservice own its logic and data under an autonomous lifecycle, with independent deployment per microservice.</span></span>

<span data-ttu-id="482a4-107">這表示，概念模型的網域將子系統或 microservices 之間，而有所不同。</span><span class="sxs-lookup"><span data-stu-id="482a4-107">This means that the conceptual model of the domain will differ between subsystems or microservices.</span></span> <span data-ttu-id="482a4-108">請考慮企業應用程式，其中客戶關係管理 (CRM) 應用程式，交易式購買子系統和客戶支援子系統上唯一客戶實體屬性和資料，每次呼叫而且每個使用不同的已繫結的內容 (BC)。</span><span class="sxs-lookup"><span data-stu-id="482a4-108">Consider enterprise applications, where customer relationship management (CRM) applications, transactional purchase subsystems, and customer support subsystems each call on unique customer entity attributes and data, and where each employs a different Bounded Context (BC).</span></span>

<span data-ttu-id="482a4-109">這個原則非常類似[網域導向設計 (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design)，其中每個[繫結內容](https://martinfowler.com/bliki/BoundedContext.html)或自發子系統或服務必須擁有其網域模型 （資料加上的邏輯和行為）。</span><span class="sxs-lookup"><span data-stu-id="482a4-109">This principle is similar in [Domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design), where each [Bounded Context](https://martinfowler.com/bliki/BoundedContext.html) or autonomous subsystem or service must own its domain model (data plus logic and behavior).</span></span> <span data-ttu-id="482a4-110">每個 DDD 繫結內容相互關聯到一個商務微服務 （一或多個服務）。</span><span class="sxs-lookup"><span data-stu-id="482a4-110">Each DDD Bounded Context correlates to one business microservice (one or several services).</span></span> <span data-ttu-id="482a4-111">（我們展開上繫結內容中的模式下一節中有關此點）。</span><span class="sxs-lookup"><span data-stu-id="482a4-111">(We expand on this point about the Bounded Context pattern in the next section.)</span></span>

<span data-ttu-id="482a4-112">相反地，許多應用程式中使用的傳統 （龐大資料） 方法是有單一的集中式的資料庫或幾個資料庫。</span><span class="sxs-lookup"><span data-stu-id="482a4-112">On the other hand, the traditional (monolithic data) approach used in many applications is to have a single centralized database or just a few databases.</span></span> <span data-ttu-id="482a4-113">這通常是標準化的 SQL database 用於整個應用程式和所有其內部子系統，如圖 4-7 所示。</span><span class="sxs-lookup"><span data-stu-id="482a4-113">This is often a normalized SQL database that is used for the whole application and all its internal subsystems, as shown in Figure 4-7.</span></span>

![](./media/image7.png)

<span data-ttu-id="482a4-114">**圖 4-7**。</span><span class="sxs-lookup"><span data-stu-id="482a4-114">**Figure 4-7**.</span></span> <span data-ttu-id="482a4-115">資料 sovereignty 比較： 龐大的資料庫，以及 microservices</span><span class="sxs-lookup"><span data-stu-id="482a4-115">Data sovereignty comparison: monolithic database versus microservices</span></span>

<span data-ttu-id="482a4-116">集中式的資料庫方法一開始會看起來更簡單，而且似乎以便重複使用的不同子系統進行一致的所有項目中的實體。</span><span class="sxs-lookup"><span data-stu-id="482a4-116">The centralized database approach initially looks simpler and seems to enable reuse of entities in different subsystems to make everything consistent.</span></span> <span data-ttu-id="482a4-117">但事實上您得到很大的資料表，做許多不同子系統，且包含屬性和資料行不需要在大部分情況下。</span><span class="sxs-lookup"><span data-stu-id="482a4-117">But the reality is you end up with huge tables that serve many different subsystems, and that include attributes and columns that are not needed in most cases.</span></span> <span data-ttu-id="482a4-118">就像嘗試登山簡短的軌跡、 進行全天汽車旅行，和學習地理區使用相同的實體對應。</span><span class="sxs-lookup"><span data-stu-id="482a4-118">it is like trying to use the same physical map for hiking a short trail, taking a day-long car trip, and learning geography.</span></span>

<span data-ttu-id="482a4-119">通常是單一關聯式資料庫含有的整合應用程式有兩個重要好處： [ACID 交易](https://en.wikipedia.org/wiki/ACID)和 SQL 語言，這兩個工作的所有資料表和應用程式相關的資料。</span><span class="sxs-lookup"><span data-stu-id="482a4-119">A monolithic application with typically a single relational database has two important benefits: [ACID transactions](https://en.wikipedia.org/wiki/ACID) and the SQL language, both working across all the tables and data related to your application.</span></span> <span data-ttu-id="482a4-120">這種方法可用來輕鬆地撰寫會結合來自多個資料表資料的查詢。</span><span class="sxs-lookup"><span data-stu-id="482a4-120">This approach provides a way to easily write a query that combines data from multiple tables.</span></span>

<span data-ttu-id="482a4-121">不過，資料存取限制變得更複雜移到 microservices 架構時。</span><span class="sxs-lookup"><span data-stu-id="482a4-121">However, data access becomes much more complex when you move to a microservices architecture.</span></span> <span data-ttu-id="482a4-122">但即使 ACID 交易可以或應該使用 「 微服務 」 或 「 繫結內容中，每個微服務所擁有的資料是私用的微服務，並只能透過其微服務應用程式開發介面來存取。</span><span class="sxs-lookup"><span data-stu-id="482a4-122">But even when ACID transactions can or should be used within a microservice or Bounded Context, the data owned by each microservice is private to that microservice and can only be accessed via its microservice API.</span></span> <span data-ttu-id="482a4-123">封裝資料，可確保 microservices 鬆散偶合，而且彼此就能持續改進。</span><span class="sxs-lookup"><span data-stu-id="482a4-123">Encapsulating the data ensures that the microservices are loosely coupled and can evolve independently of one another.</span></span> <span data-ttu-id="482a4-124">如果多個服務存取相同的資料，結構描述更新需要協調的更新的所有服務。</span><span class="sxs-lookup"><span data-stu-id="482a4-124">If multiple services were accessing the same data, schema updates would require coordinated updates to all the services.</span></span> <span data-ttu-id="482a4-125">這會破壞微服務生命週期自主。</span><span class="sxs-lookup"><span data-stu-id="482a4-125">This would break the microservice lifecycle autonomy.</span></span> <span data-ttu-id="482a4-126">但分散式的資料結構，表示您無法跨 microservices 進行單一 ACID 交易。</span><span class="sxs-lookup"><span data-stu-id="482a4-126">But distributed data structures mean that you cannot make a single ACID transaction across microservices.</span></span> <span data-ttu-id="482a4-127">這會表示商務程序跨越多個 microservices 時，您必須使用最終一致性。</span><span class="sxs-lookup"><span data-stu-id="482a4-127">This in turn means you must use eventual consistency when a business process spans multiple microservices.</span></span> <span data-ttu-id="482a4-128">這是難以實作比簡單的 SQL 聯結。同樣地，許多其他關聯式資料庫功能無法使用。 跨多個 microservices</span><span class="sxs-lookup"><span data-stu-id="482a4-128">This is much harder to implement than simple SQL joins; similarly, many other relational database features are not available across multiple microservices.</span></span>

<span data-ttu-id="482a4-129">從現在更進一步，不同 microservices 通常使用不同*種類*的資料庫。</span><span class="sxs-lookup"><span data-stu-id="482a4-129">Going even further, different microservices often use different *kinds* of databases.</span></span> <span data-ttu-id="482a4-130">現代應用程式存放區和程序的不同種類的資料，以及關聯式資料庫不一定是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="482a4-130">Modern applications store and process diverse kinds of data, and a relational database is not always the best choice.</span></span> <span data-ttu-id="482a4-131">某些使用案例，例如 Azure DocumentDB 或 MongoDB 的 NoSQL 資料庫可能會更方便的資料模型並提供較佳的效能和延展性比 SQL 資料庫，例如 SQL Server 或 Azure SQL Database。</span><span class="sxs-lookup"><span data-stu-id="482a4-131">For some use cases, a NoSQL database such as Azure DocumentDB or MongoDB might have a more convenient data model and offer better performance and scalability than a SQL database like SQL Server or Azure SQL Database.</span></span> <span data-ttu-id="482a4-132">在其他情況下，關聯式資料庫仍是最好的方法。</span><span class="sxs-lookup"><span data-stu-id="482a4-132">In other cases, a relational database is still the best approach.</span></span> <span data-ttu-id="482a4-133">因此，microservices 為基礎的應用程式通常會使用它有時稱為 「 SQL 和 NoSQL 資料庫的混合[polyglot 持續性](http://martinfowler.com/bliki/PolyglotPersistence.html)方法。</span><span class="sxs-lookup"><span data-stu-id="482a4-133">Therefore, microservices-based applications often use a mixture of SQL and NoSQL databases, which is sometimes called the [polyglot persistence](http://martinfowler.com/bliki/PolyglotPersistence.html) approach.</span></span>

<span data-ttu-id="482a4-134">儲存資料的資料分割、 polyglot 持續架構有許多好處。</span><span class="sxs-lookup"><span data-stu-id="482a4-134">A partitioned, polyglot-persistent architecture for data storage has many benefits.</span></span> <span data-ttu-id="482a4-135">這些包括鬆散偶合的服務和更佳效能、 延展性、 成本與管理能力。</span><span class="sxs-lookup"><span data-stu-id="482a4-135">These include loosely coupled services and better performance, scalability, costs, and manageability.</span></span> <span data-ttu-id="482a4-136">不過，它可能導致某些分散式的資料管理的挑戰，因為我們將說明中 「[識別網域模型界限](#identifying-domain-model-boundaries-for-each-microservice)"本章稍後。</span><span class="sxs-lookup"><span data-stu-id="482a4-136">However, it can introduce some distributed data management challenges, as we will explain in “[Identifying domain-model boundaries](#identifying-domain-model-boundaries-for-each-microservice)” later in this chapter.</span></span>

## <a name="the-relationship-between-microservices-and-the-bounded-context-pattern"></a><span data-ttu-id="482a4-137">Microservices 和繫結內容模式之間的關聯性</span><span class="sxs-lookup"><span data-stu-id="482a4-137">The relationship between microservices and the Bounded Context pattern</span></span>

<span data-ttu-id="482a4-138">微服務概念衍生自[繫結的內容 (BC) 模式](http://martinfowler.com/bliki/BoundedContext.html)中[網域導向設計 (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design)。</span><span class="sxs-lookup"><span data-stu-id="482a4-138">The concept of microservice derives from the [Bounded Context (BC) pattern](http://martinfowler.com/bliki/BoundedContext.html) in [domain-driven design (DDD)](https://en.wikipedia.org/wiki/Domain-driven_design).</span></span> <span data-ttu-id="482a4-139">透過將其分為多個 BCs 以及明確了解其界限 DDD 是搭配大型模型中處理。</span><span class="sxs-lookup"><span data-stu-id="482a4-139">DDD deals with large models by dividing them into multiple BCs and being explicit about their boundaries.</span></span> <span data-ttu-id="482a4-140">每個 BC 必須有它自己的模型和資料庫。同樣地，每個微服務擁有及其相關的資料。</span><span class="sxs-lookup"><span data-stu-id="482a4-140">Each BC must have its own model and database; likewise, each microservice owns its related data.</span></span> <span data-ttu-id="482a4-141">此外，每個 BC 通常都有它自己[通用語言](http://martinfowler.com/bliki/UbiquitousLanguage.html)協助軟體開發人員 」 和 「 網域專家之間的通訊。</span><span class="sxs-lookup"><span data-stu-id="482a4-141">In addition, each BC usually has its own [ubiquitous language](http://martinfowler.com/bliki/UbiquitousLanguage.html) to help communication between software developers and domain experts.</span></span>

<span data-ttu-id="482a4-142">通用語言中的這些詞彙 （主要網域實體） 可以有不同的名稱在不同的繫結內容中，即使不同的網域實體都共用相同的識別 （也就是唯一識別碼是用來從儲存體讀取實體）。</span><span class="sxs-lookup"><span data-stu-id="482a4-142">Those terms (mainly domain entities) in the ubiquitous language can have different names in different Bounded Contexts, even when different domain entities share the same identity (that is, the unique ID that is used to read the entity from storage).</span></span> <span data-ttu-id="482a4-143">比方說，在使用者設定檔繫結內容中，使用者網域實體可能會共用身分識別與買方網域實體順序的繫結內容中。</span><span class="sxs-lookup"><span data-stu-id="482a4-143">For instance, in a user-profile Bounded Context, the User domain entity might share identity with the Buyer domain entity in the ordering Bounded Context.</span></span>

<span data-ttu-id="482a4-144">微服務因此就像是繫結的內容，但它也會指定它是一種分散式的服務。</span><span class="sxs-lookup"><span data-stu-id="482a4-144">A microservice is therefore like a Bounded Context, but it also specifies that it is a distributed service.</span></span> <span data-ttu-id="482a4-145">建置為個別的處理序針對每個繫結的內容，且必須使用前文所述，如 HTTP/HTTPS，WebSockets，分散式通訊協定或[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)。</span><span class="sxs-lookup"><span data-stu-id="482a4-145">It is built as a separate process for each Bounded Context, and it must use the distributed protocols noted earlier, like HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span> <span data-ttu-id="482a4-146">繫結內容模式中，不過，未指定繫結內容是否分散式的服務或其是否只要邏輯界限 （例如泛型的子系統） 整合型部署應用程式中。</span><span class="sxs-lookup"><span data-stu-id="482a4-146">The Bounded Context pattern, however, does not specify whether the Bounded Context is a distributed service or if it is simply a logical boundary (such as a generic subsystem) within a monolithic-deployment application.</span></span>

<span data-ttu-id="482a4-147">請務必反白顯示，定義服務，以針對每個繫結的內容是較好的位置開始。</span><span class="sxs-lookup"><span data-stu-id="482a4-147">It is important to highlight that defining a service for each Bounded Context is a good place to start.</span></span> <span data-ttu-id="482a4-148">但您沒有限制，您的設計。</span><span class="sxs-lookup"><span data-stu-id="482a4-148">But you do not have to constrain your design to it.</span></span> <span data-ttu-id="482a4-149">有時您必須設計繫結的內容，或商務微服務是由數個實體的服務所組成。</span><span class="sxs-lookup"><span data-stu-id="482a4-149">Sometimes you must design a Bounded Context or business microservice composed of several physical services.</span></span> <span data-ttu-id="482a4-150">最後，這兩種模式，但是 — 繫結內容和微服務 — 密切相關。</span><span class="sxs-lookup"><span data-stu-id="482a4-150">But ultimately, both patterns—Bounded Context and microservice—are closely related.</span></span>

<span data-ttu-id="482a4-151">從藉由取得真正的分散式 microservices 形式界限 microservices DDD 優點。</span><span class="sxs-lookup"><span data-stu-id="482a4-151">DDD benefits from microservices by getting real boundaries in the form of distributed microservices.</span></span> <span data-ttu-id="482a4-152">但不是共用之間 microservices 模型概念都是您也想要在繫結的內容中。</span><span class="sxs-lookup"><span data-stu-id="482a4-152">But ideas like not sharing the model between microservices are what you also want in a Bounded Context.</span></span>

### <a name="additional-resources"></a><span data-ttu-id="482a4-153">其他資源</span><span class="sxs-lookup"><span data-stu-id="482a4-153">Additional resources</span></span>

-   <span data-ttu-id="482a4-154">**Chris Richardson。模式： 資料庫每個服務**
    [*http://microservices.io/patterns/data/database-per-service.html*](http://microservices.io/patterns/data/database-per-service.html)</span><span class="sxs-lookup"><span data-stu-id="482a4-154">**Chris Richardson. Pattern: Database per service**
[*http://microservices.io/patterns/data/database-per-service.html*](http://microservices.io/patterns/data/database-per-service.html)</span></span>

-   <span data-ttu-id="482a4-155">**Martin Fowler：BoundedContext**
    [*http://martinfowler.com/bliki/BoundedContext.html*](http://martinfowler.com/bliki/BoundedContext.html)</span><span class="sxs-lookup"><span data-stu-id="482a4-155">**Martin Fowler. BoundedContext**
[*http://martinfowler.com/bliki/BoundedContext.html*](http://martinfowler.com/bliki/BoundedContext.html)</span></span>

-   <span data-ttu-id="482a4-156">**Martin Fowler：PolyglotPersistence**
    [*http://martinfowler.com/bliki/PolyglotPersistence.html*](http://martinfowler.com/bliki/PolyglotPersistence.html)</span><span class="sxs-lookup"><span data-stu-id="482a4-156">**Martin Fowler. PolyglotPersistence**
[*http://martinfowler.com/bliki/PolyglotPersistence.html*](http://martinfowler.com/bliki/PolyglotPersistence.html)</span></span>

-   <span data-ttu-id="482a4-157">**Alberto Brandolini。策略性網域導向設計，含有內容對應**
    [*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span><span class="sxs-lookup"><span data-stu-id="482a4-157">**Alberto Brandolini. Strategic Domain Driven Design with Context Mapping**
[*https://www.infoq.com/articles/ddd-contextmapping*](https://www.infoq.com/articles/ddd-contextmapping)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="482a4-158">[上一個](microservices-architecture.md) [下一步] (邏輯-或-實體-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="482a4-158">[Previous] (microservices-architecture.md) [Next] (logical-versus-physical-architecture.md)</span></span>
