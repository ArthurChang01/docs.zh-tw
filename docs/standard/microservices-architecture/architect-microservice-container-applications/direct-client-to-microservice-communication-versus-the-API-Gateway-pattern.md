---
title: 直接用戶端與微服務通訊與 API 閘道模式
description: 容器化 .NET 應用程式的 .NET 微服務架構 | 直接用戶端與微服務通訊與 API 閘道模式
keywords: Docker, 微服務, ASP.NET, 容器, API 閘道
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: fa3f4bb97cf942ee7698b1efa1dcd09b3f2ca571
ms.sourcegitcommit: 2e8acae16ae802f2d6d04e3ce0a6dbf04e476513
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/18/2018
---
# <a name="direct-client-to-microservice-communication-versus-the-api-gateway-pattern"></a><span data-ttu-id="ce327-104">直接用戶端與微服務通訊與 API 閘道模式</span><span class="sxs-lookup"><span data-stu-id="ce327-104">Direct client-to-microservice communication versus the API Gateway pattern</span></span>

<span data-ttu-id="ce327-105">在微服務架構中，每個微服務都會公開一組 (通常) 微調端點。</span><span class="sxs-lookup"><span data-stu-id="ce327-105">In a microservices architecture, each microservice exposes a set of (typically) fine‑grained endpoints.</span></span> <span data-ttu-id="ce327-106">這項事實可能會影響用戶端與微服務通訊，如本節所述。</span><span class="sxs-lookup"><span data-stu-id="ce327-106">This fact can impact the client‑to‑microservice communication, as explained in this section.</span></span>

## <a name="direct-client-to-microservice-communication"></a><span data-ttu-id="ce327-107">直接用戶端對微服務通訊</span><span class="sxs-lookup"><span data-stu-id="ce327-107">Direct client-to-microservice communication</span></span>

<span data-ttu-id="ce327-108">可能的方法是使用直接用戶端對微服務通訊架構。</span><span class="sxs-lookup"><span data-stu-id="ce327-108">A possible approach is to use a direct client-to-microservice communication architecture.</span></span> <span data-ttu-id="ce327-109">使用這種方法，用戶端應用程式可以直接對某些微服務提出要求，如圖 4-12 所示。</span><span class="sxs-lookup"><span data-stu-id="ce327-109">In this approach, a client app can make requests directly to some of the microservices, as shown in Figure 4-12.</span></span>

![](./media/image12.png)

<span data-ttu-id="ce327-110">**圖 4-12**.</span><span class="sxs-lookup"><span data-stu-id="ce327-110">**Figure 4-12**.</span></span> <span data-ttu-id="ce327-111">使用直接用戶端對微服務通訊架構</span><span class="sxs-lookup"><span data-stu-id="ce327-111">Using a direct client-to-microservice communication architecture</span></span>

<span data-ttu-id="ce327-112">使用這種方法，</span><span class="sxs-lookup"><span data-stu-id="ce327-112">In this approach.</span></span> <span data-ttu-id="ce327-113">每個微服務都會有公用端點，有時每個微服務會有不同的 TCP 連接埠。</span><span class="sxs-lookup"><span data-stu-id="ce327-113">each microservice has a public endpoint, sometimes with a different TCP port for each microservice.</span></span> <span data-ttu-id="ce327-114">在 Azure 中，特定服務的 URL 範例可以是下列 URL：</span><span class="sxs-lookup"><span data-stu-id="ce327-114">An example of a URL for a particular service could be the following URL in Azure:</span></span>

<http://eshoponcontainers.westus.cloudapp.azure.com:88/>

<span data-ttu-id="ce327-115">在根據叢集的生產環境中，該 URL 會對應至叢集中所使用的負載平衡器，而負載平衡器接著會將要求分散到微服務。</span><span class="sxs-lookup"><span data-stu-id="ce327-115">In a production environment based on a cluster, that URL would map to the load balancer used in the cluster, which in turn distributes the requests across the microservices.</span></span> <span data-ttu-id="ce327-116">在生產環境中，您在微服務與網際網路之間可能會有 [Azure 應用程式閘道](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction)這類應用程式傳遞控制站 (ADC)。</span><span class="sxs-lookup"><span data-stu-id="ce327-116">In production environments, you could have an Application Delivery Controller (ADC) like [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) between your microservices and the Internet.</span></span> <span data-ttu-id="ce327-117">這會作為透明層，不僅可執行負載平衡，也會透過提供 SSL 終止來保護您的服務。</span><span class="sxs-lookup"><span data-stu-id="ce327-117">This acts as a transparent tier that not only performs load balancing, but secures your services by offering SSL termination.</span></span> <span data-ttu-id="ce327-118">這會改善主機的負載，方法是將 CPU 密集 SSL 終止和其他路由責任卸載給 Azure 應用程式閘道。</span><span class="sxs-lookup"><span data-stu-id="ce327-118">This improves the load of your hosts by offloading CPU-intensive SSL termination and other routing duties to the Azure Application Gateway.</span></span> <span data-ttu-id="ce327-119">從邏輯應用程式架構觀點，在任何情況下，負載平衡器和 ADC 都是透明的。</span><span class="sxs-lookup"><span data-stu-id="ce327-119">In any case, a load balancer and ADC are transparent from a logical application architecture point of view.</span></span>

<span data-ttu-id="ce327-120">直接用戶端對微服務通訊架構可能適用於小型微服務應用程式，特別是用戶端應用程式為 ASP.NET MVC 應用程式這類伺服器端 Web 應用程式時。</span><span class="sxs-lookup"><span data-stu-id="ce327-120">A direct client-to-microservice communication architecture could be good enough for a small microservice-based application, especially if the client app is a server-side web application like an ASP.NET MVC app.</span></span> <span data-ttu-id="ce327-121">不過，如果您建置大型且複雜的微服務應用程式 (例如，處理數十個微服務型別時)，特別是用戶端應用程式為遠端行動應用程式或 SPA Web 應用程式時，該方法會面臨的一些問題。</span><span class="sxs-lookup"><span data-stu-id="ce327-121">However, when you build large and complex microservice-based applications (for example, when handling dozens of microservice types), and especially when the client apps are remote mobile apps or SPA web applications, that approach faces a few issues.</span></span>

<span data-ttu-id="ce327-122">開發根據微服務的大型應用程式時，請考慮下列問題：</span><span class="sxs-lookup"><span data-stu-id="ce327-122">Consider the following questions when developing a large application based on microservices:</span></span>

-   <span data-ttu-id="ce327-123">*用戶端應用程式如何最小化後端要求數目以及減少與多個微服務的過於頻繁通訊？*</span><span class="sxs-lookup"><span data-stu-id="ce327-123">*How can client apps minimize the number of requests to the backend and reduce chatty communication to multiple microservices?*</span></span>

<span data-ttu-id="ce327-124">與多個微服務互動來建置單一 UI 畫面，會增加跨網際網路往返的次數。</span><span class="sxs-lookup"><span data-stu-id="ce327-124">Interacting with multiple microservices to build a single UI screen increases the number of roundtrips across the Internet.</span></span> <span data-ttu-id="ce327-125">這會增加 UI 端的延遲和複雜性。</span><span class="sxs-lookup"><span data-stu-id="ce327-125">This increases latency and complexity on the UI side.</span></span> <span data-ttu-id="ce327-126">在理想情況下，應該會在伺服器端有效率地彙總回應，而這樣做可減少延遲，因為會平行取得多個資料片段，而且只要準備就緒，某些 UI 就會顯示資料。</span><span class="sxs-lookup"><span data-stu-id="ce327-126">Ideally, responses should be efficiently aggregated in the server side—this reduces latency, since multiple pieces of data come back in parallel and some UI can show data as soon as it is ready.</span></span>

-   <span data-ttu-id="ce327-127">*如何處理授權、資料轉換和動態要求分派這類跨領域考量？*</span><span class="sxs-lookup"><span data-stu-id="ce327-127">*How can you handle cross-cutting concerns such as authorization, data transformations, and dynamic request dispatching?*</span></span>

<span data-ttu-id="ce327-128">實作安全性和跨領域考量 (例如每個微服務上的安全性和授權) 可能需要大量開發工作。</span><span class="sxs-lookup"><span data-stu-id="ce327-128">Implementing security and cross-cutting concerns like security and authorization on every microservice can require significant development effort.</span></span> <span data-ttu-id="ce327-129">可能的方法是 Docker 主機或內部叢集內有這些服務，以限制從外部直接存取它們，並在集中位置 (例如 API 閘道) 實作這些跨領域考量。</span><span class="sxs-lookup"><span data-stu-id="ce327-129">A possible approach is to have those services within the Docker host or internal cluster, in order to restrict direct access to them from the outside, and to implement those cross-cutting concerns in a centralized place, like an API Gateway.</span></span>

-   <span data-ttu-id="ce327-130">*用戶端應用程式如何與使用非友善網際網路通訊協定的服務通訊？*</span><span class="sxs-lookup"><span data-stu-id="ce327-130">*How can client apps communicate with services that use non-Internet-friendly protocols?*</span></span>

<span data-ttu-id="ce327-131">用戶端應用程式通常不支援伺服器端上使用的通訊協定 (例如 AMQP 或二進位通訊協定)。</span><span class="sxs-lookup"><span data-stu-id="ce327-131">Protocols used on the server side (like AMQP or binary protocols) are usually not supported in client apps.</span></span> <span data-ttu-id="ce327-132">因此，必須透過 HTTP/HTTPS 這類通訊協定執行要求，而且之後會轉譯成其他通訊協定。</span><span class="sxs-lookup"><span data-stu-id="ce327-132">Therefore, requests must be performed through protocols like HTTP/HTTPS and translated to the other protocols afterwards.</span></span> <span data-ttu-id="ce327-133">在此情況下，「攔截式」方法可能有幫助。</span><span class="sxs-lookup"><span data-stu-id="ce327-133">A *man-in-the-middle* approach can help in this situation.</span></span>

-   <span data-ttu-id="ce327-134">*如何形成特別針對行動應用程式所產生的外觀？*</span><span class="sxs-lookup"><span data-stu-id="ce327-134">*How can you shape a façade especially made for mobile apps?*</span></span>

<span data-ttu-id="ce327-135">多個微服務 API 的設計可能不是最適合不同用戶端應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="ce327-135">The API of multiple microservices might not be well designed for the needs of different client applications.</span></span> <span data-ttu-id="ce327-136">例如，行動應用程式需求可能會與 Web 應用程式需求不同。</span><span class="sxs-lookup"><span data-stu-id="ce327-136">For instance, the needs of a mobile app might be different than the needs of a web app.</span></span> <span data-ttu-id="ce327-137">針對行動應用程式，您甚至可能需要更進一步最佳化，讓資料回應更具效率。</span><span class="sxs-lookup"><span data-stu-id="ce327-137">For mobile apps, you might need to optimize even further so that data responses can be more efficient.</span></span> <span data-ttu-id="ce327-138">作法是彙總多個微服務中的資料並傳回一組資料，有時會排除行動應用程式不需要之回應中的任何資料。</span><span class="sxs-lookup"><span data-stu-id="ce327-138">You might do this by aggregating data from multiple microservices and returning a single set of data, and sometimes eliminating any data in the response that is not needed by the mobile app.</span></span> <span data-ttu-id="ce327-139">而且，您當然可以壓縮該資料。</span><span class="sxs-lookup"><span data-stu-id="ce327-139">And, of course, you might compress that data.</span></span> <span data-ttu-id="ce327-140">同樣地，在此案例中，行動應用程式與微服務之間的外觀或 API 可能十分方便使用。</span><span class="sxs-lookup"><span data-stu-id="ce327-140">Again, a façade or API in between the mobile app and the microservices can be convenient for this scenario.</span></span>

## <a name="using-an-api-gateway"></a><span data-ttu-id="ce327-141">使用 API 閘道</span><span class="sxs-lookup"><span data-stu-id="ce327-141">Using an API Gateway</span></span>

<span data-ttu-id="ce327-142">當您使用多個用戶端應用程式來設計和建置大型或複雜微服務應用程式時，可以考慮使用的不錯方法是 [API 閘道](https://microservices.io/patterns/apigateway.html)。</span><span class="sxs-lookup"><span data-stu-id="ce327-142">When you design and build large or complex microservice-based applications with multiple client apps, a good approach to consider can be an [API Gateway](https://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="ce327-143">這個服務提供特定一組微服務的單一進入點。</span><span class="sxs-lookup"><span data-stu-id="ce327-143">This is a service that provides a single entry point for certain groups of microservices.</span></span> <span data-ttu-id="ce327-144">它與物件導向設計中的[外觀模式](https://en.wikipedia.org/wiki/Facade_pattern)類似但在此情況下，它是分散式系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="ce327-144">It is similar to the [Facade pattern](https://en.wikipedia.org/wiki/Facade_pattern) from object‑oriented design, but in this case, it is part of a distributed system.</span></span> <span data-ttu-id="ce327-145">API 閘道模式有時也稱為「前端的後端 [(BFF)](https://samnewman.io/patterns/architectural/bff/)」，因為您是在考量用戶端應用程式需求時建置它。</span><span class="sxs-lookup"><span data-stu-id="ce327-145">The API Gateway pattern is also sometimes known as the “backend for frontend” [(BFF)](https://samnewman.io/patterns/architectural/bff/) because you build it while thinking about the needs of the client app.</span></span>

<span data-ttu-id="ce327-146">圖 4-13 顯示自訂 API 閘道如何納入微服務架構。</span><span class="sxs-lookup"><span data-stu-id="ce327-146">Figure 4-13 shows how a custom API Gateway can fit into a microservice-based architecture.</span></span>
<span data-ttu-id="ce327-147">請務必在該圖表中將它反白顯示，您會使用面向多個和不同用戶端應用程式的單一自訂 API 閘道服務。</span><span class="sxs-lookup"><span data-stu-id="ce327-147">It is important to highlight that in that diagram, you would be using a single custom API Gateway service facing multiple and different client apps.</span></span> <span data-ttu-id="ce327-148">這項事實的風險可能十分重大，因為 API 閘道服務將會根據用戶端應用程式的許多不同需求而成長和演變。</span><span class="sxs-lookup"><span data-stu-id="ce327-148">That fact can be an important risk because your API Gateway service will be growing and evolving based on many different requirements from the client apps.</span></span> <span data-ttu-id="ce327-149">最後，它會因為這些不同需求而十分繁雜，而且可能十分類似整合型應用程式或整合型服務。</span><span class="sxs-lookup"><span data-stu-id="ce327-149">Eventually, it will be bloated because of those different needs and effectively it could be pretty similar to a monolithic application or monolithic service.</span></span> <span data-ttu-id="ce327-150">這是極為建議將 API 閘道分割為多個服務或多個較小 API 閘道 (例如一個板型規格一個) 的原因。</span><span class="sxs-lookup"><span data-stu-id="ce327-150">That is why it is very much recommended to split the API Gateway in multiple services or multiple smaller API Gateways, one per form-factor type, for instance.</span></span>

![](./media/image13.png)

<span data-ttu-id="ce327-151">**圖 4-13**.</span><span class="sxs-lookup"><span data-stu-id="ce327-151">**Figure 4-13**.</span></span> <span data-ttu-id="ce327-152">使用實作為自訂 Web API 服務的 API 閘道</span><span class="sxs-lookup"><span data-stu-id="ce327-152">Using an API Gateway implemented as a custom Web API service</span></span>

<span data-ttu-id="ce327-153">在此範例中，API 閘道會實作為以容器形式執行的自訂 Web API 服務。</span><span class="sxs-lookup"><span data-stu-id="ce327-153">In this example, the API Gateway would be implemented as a custom Web API service running as a container.</span></span>

<span data-ttu-id="ce327-154">如前所述，您應該實作數個 API 閘道，以擁有每個用戶端應用程式需求的不同樣貌。</span><span class="sxs-lookup"><span data-stu-id="ce327-154">As mentioned, you should implement several API Gateways so that you can have a different façade for the needs of each client app.</span></span> <span data-ttu-id="ce327-155">每個 API 閘道都可以提供針對每個用戶端應用程式量身訂做的不同 API，甚至可能會根據用戶端板型規格，方法是實作其下呼叫多個內部微服務的特定介面卡程式碼。</span><span class="sxs-lookup"><span data-stu-id="ce327-155">Each API Gateway can provide a different API tailored for each client app, possibly even based on the client form factor by implementing specific adapter code which underneath calls multiple internal microservices.</span></span>

<span data-ttu-id="ce327-156">因為自訂 API 閘道通常是資料彙總工具，所以您必須謹慎使用它。</span><span class="sxs-lookup"><span data-stu-id="ce327-156">Since a custom API Gateway is usually a data aggregator, you need to be careful with it.</span></span> <span data-ttu-id="ce327-157">通常不適合讓單一 API 閘道彙總您應用程式的所有內部微服務。</span><span class="sxs-lookup"><span data-stu-id="ce327-157">Usually it isn't a good idea to have a single API Gateway aggregating all the internal microservices of your application.</span></span> <span data-ttu-id="ce327-158">若是如此，它會作為整合型彙總工具或協調器，並且因結合所有微服務而違反微服務自主性。</span><span class="sxs-lookup"><span data-stu-id="ce327-158">If it does, it acts as a monolithic aggregator or orchestrator and violates microservice autonomy by coupling all the microservices.</span></span> <span data-ttu-id="ce327-159">因此，應該根據商務界限來隔離 API 閘道，而不是作為整個應用程式的彙總工具。</span><span class="sxs-lookup"><span data-stu-id="ce327-159">Therefore, the API Gateways should be segregated based on business boundaries and not act as an aggregator for the whole application.</span></span>

<span data-ttu-id="ce327-160">細微 API 閘道有時也可以是微服務本身，甚至具有領域或公司名稱和相關資料。</span><span class="sxs-lookup"><span data-stu-id="ce327-160">Sometimes a granular API Gateway can also be a microservice by itself, and even have a domain or business name and related data.</span></span> <span data-ttu-id="ce327-161">擁有商務或領域所指出的 API 閘道界限可幫助您獲得更好的設計。</span><span class="sxs-lookup"><span data-stu-id="ce327-161">Having the API Gateway’s boundaries dictated by the business or domain will help you to get a better design.</span></span>

<span data-ttu-id="ce327-162">API 閘道層中的細微性可能特別適用於根據微服務的更進階複合 UI 應用程式，因為微調 API 閘道概念類似於 UI 組合服務。</span><span class="sxs-lookup"><span data-stu-id="ce327-162">Granularity in the API Gateway tier can be especially useful for more advanced composite UI applications based on microservices, because the concept of a fine-grained API Gateway is similar to a UI composition service.</span></span> <span data-ttu-id="ce327-163">我們稍後會在[建立根據微服務的複合 UI](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices) 中討論這點。</span><span class="sxs-lookup"><span data-stu-id="ce327-163">We discuss this later in the [Creating composite UI based on microservices](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices).</span></span>

<span data-ttu-id="ce327-164">因此，針對許多中型和大型應用程式，使用自訂建置的 API 閘道通常是不錯的方法，但不能作為單一整合型彙總工具或唯一中央自訂 API 閘道。</span><span class="sxs-lookup"><span data-stu-id="ce327-164">Therefore, for many medium- and large-size applications, using a custom-built API Gateway is usually a good approach, but not as a single monolithic aggregator or unique central custom API Gateway.</span></span>

<span data-ttu-id="ce327-165">另一種方法是使用 [Azure API 管理](https://azure.microsoft.com/services/api-management/)這類產品，如圖 4-14 所示。</span><span class="sxs-lookup"><span data-stu-id="ce327-165">Another approach is to use a product like [Azure API Management](https://azure.microsoft.com/services/api-management/) as shown in Figure 4-14.</span></span> <span data-ttu-id="ce327-166">這種方法不僅可以解決 API 閘道需求，也可以提供收集 API 深入資訊這類功能。</span><span class="sxs-lookup"><span data-stu-id="ce327-166">This approach not only solves your API Gateway needs, but provides features like gathering insights from your APIs.</span></span> <span data-ttu-id="ce327-167">如果您使用 API 管理解決方案，則 API 閘道只是該完整 API 管理解決方案內的元件。</span><span class="sxs-lookup"><span data-stu-id="ce327-167">If you are using an API management solution, an API Gateway is only a component within that full API management solution.</span></span>

![](./media/image14.png)

<span data-ttu-id="ce327-168">**圖 4-14**.</span><span class="sxs-lookup"><span data-stu-id="ce327-168">**Figure 4-14**.</span></span> <span data-ttu-id="ce327-169">將 Azure API 管理用於 API 閘道</span><span class="sxs-lookup"><span data-stu-id="ce327-169">Using Azure API Management for your API Gateway</span></span>

<span data-ttu-id="ce327-170">在此情況下，使用 Azure API 管理這類產品時，您可能會有單一 API 閘道的這個事實的風險不大，因為這類 API 閘道較「輕量」，表示您未實作可能朝向整合型元件發展的自訂 C# 程式碼。</span><span class="sxs-lookup"><span data-stu-id="ce327-170">In this case, when using a product like Azure API Management, the fact that you might have a single API Gateway is not so risky because these kinds of API Gateways are "thinner", meaning that you don't implement custom C# code that could evolve towards a monolithic component.</span></span> 

<span data-ttu-id="ce327-171">這類型的產品更像是輸入通訊的反向 Proxy，在其中，您也可以從內部微服務篩選 API，以及將授權套用至這個單一階層的已發行 API。</span><span class="sxs-lookup"><span data-stu-id="ce327-171">This type of product acts more like a reverse proxy for ingress communication, where you can also filter the APIs from the internal microservices plus apply authorization to the published APIs in this single tier.</span></span>

<span data-ttu-id="ce327-172">可從 API 管理系統取得的深入資訊可幫助您了解 API 使用方式和其執行方式。</span><span class="sxs-lookup"><span data-stu-id="ce327-172">The insights available from an API Management system help you get an understanding of how your APIs are being used and how they are performing.</span></span> <span data-ttu-id="ce327-173">作法是讓您檢視接近即時的分析報表，以及識別可能會影響您商務的趨勢。</span><span class="sxs-lookup"><span data-stu-id="ce327-173">They do this by letting you view near real-time analytics reports and identifying trends that might impact your business.</span></span> <span data-ttu-id="ce327-174">此外，您可能會有要求和回應活動的記錄，以進行進一步線上及離線分析。</span><span class="sxs-lookup"><span data-stu-id="ce327-174">Plus, you can have logs about request and response activity for further online and offline analysis.</span></span>

<span data-ttu-id="ce327-175">使用 Azure API 管理，您可以使用金鑰、權杖和 IP 篩選來保護 API。</span><span class="sxs-lookup"><span data-stu-id="ce327-175">With Azure API Management, you can secure your APIs using a key, a token, and IP filtering.</span></span> <span data-ttu-id="ce327-176">這些功能可讓您強制執行彈性且微調的配額和速率限制、使用原則修改您 API 的形狀和行為，並改善快取回應的效能。</span><span class="sxs-lookup"><span data-stu-id="ce327-176">These features let you enforce flexible and fine-grained quotas and rate limits, modify the shape and behavior of your APIs using policies, and improve performance with response caching.</span></span>

<span data-ttu-id="ce327-177">在本指南和參考範例應用程式 (eShopOnContainers) 中，我們會限制更簡單且自訂容器化架構的架構，以專注於一般容器，而不需要使用 Azure API 管理這類 PaaS 產品。</span><span class="sxs-lookup"><span data-stu-id="ce327-177">In this guide and the reference sample application (eShopOnContainers), we are limiting the architecture to a simpler and custom-made containerized architecture in order to focus on plain containers without using PaaS products like Azure API Management.</span></span> <span data-ttu-id="ce327-178">但對於部署至 Microsoft Azure 的大型微服務應用程式，建議您檢閱並採用作為 API 閘道基底的 Azure API 管理。</span><span class="sxs-lookup"><span data-stu-id="ce327-178">But for large microservice-based applications that are deployed into Microsoft Azure, we encourage you to review and adopt Azure API Management as the base for your API Gateways.</span></span>

## <a name="drawbacks-of-the-api-gateway-pattern"></a><span data-ttu-id="ce327-179">API 閘道模式的缺點</span><span class="sxs-lookup"><span data-stu-id="ce327-179">Drawbacks of the API Gateway pattern</span></span>

-   <span data-ttu-id="ce327-180">最大的缺點在於當您實作 API 閘道時，會結合該階層與內部微服務。</span><span class="sxs-lookup"><span data-stu-id="ce327-180">The most important drawback is that when you implement an API Gateway, you are coupling that tier with the internal microservices.</span></span> <span data-ttu-id="ce327-181">這類結合可能會造成您應用程式的嚴重問題。</span><span class="sxs-lookup"><span data-stu-id="ce327-181">Coupling like this might introduce serious difficulties for your application.</span></span> <span data-ttu-id="ce327-182">Clemens Vaster 是 Azure 服務匯流排小組的架構設計人員，在他於 GOTO 2016 的 [Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k) (訊息和微服務) 講習會中將這項潛在困難稱為「新的 ESB」。</span><span class="sxs-lookup"><span data-stu-id="ce327-182">Clemens Vaster, architect at the Azure Service Bus team, refers to this potential difficulty as “the new ESB” in his "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" session at GOTO 2016.</span></span>

-   <span data-ttu-id="ce327-183">使用微服務 API 閘道會建立其他可能單一失敗點。</span><span class="sxs-lookup"><span data-stu-id="ce327-183">Using a microservices API Gateway creates an additional possible single point of failure.</span></span>

-   <span data-ttu-id="ce327-184">API 閘道可能會導致因額外網路呼叫而增加回應時間。</span><span class="sxs-lookup"><span data-stu-id="ce327-184">An API Gateway can introduce increased response time due to the additional network call.</span></span> <span data-ttu-id="ce327-185">不過，這個額外呼叫的影響通常會小於擁有過於頻繁直接呼叫內部微服務的用戶端介面。</span><span class="sxs-lookup"><span data-stu-id="ce327-185">However, this extra call usually has less impact than having a client interface that is too chatty directly calling the internal microservices.</span></span>

-   <span data-ttu-id="ce327-186">如果未正確地相應放大，則 API 閘道可能會成為瓶頸。</span><span class="sxs-lookup"><span data-stu-id="ce327-186">If not scaled out properly, the API Gateway can become a bottleneck.</span></span>

-   <span data-ttu-id="ce327-187">如果 API 閘道包含自訂邏輯和資料彙總，則需要額外開發成本和未來維護。</span><span class="sxs-lookup"><span data-stu-id="ce327-187">An API Gateway requires additional development cost and future maintenance if it includes custom logic and data aggregation.</span></span> <span data-ttu-id="ce327-188">開發人員必須更新 API 閘道，才能公開每個微服務的端點。</span><span class="sxs-lookup"><span data-stu-id="ce327-188">Developers must update the API Gateway in order to expose each microservice’s endpoints.</span></span> <span data-ttu-id="ce327-189">此外，內部微服務中的實作變更可能會導致 API 閘道層級的程式碼變更。</span><span class="sxs-lookup"><span data-stu-id="ce327-189">Moreover, implementation changes in the internal microservices might cause code changes at the API Gateway level.</span></span> <span data-ttu-id="ce327-190">不過，如果 API 閘道只會套用安全性、記錄和版本控制 (就像使用 Azure API 管理時一樣)，可能不會套用這個額外的開發成本。</span><span class="sxs-lookup"><span data-stu-id="ce327-190">However, if the API Gateway is just applying security, logging, and versioning (as when using Azure API Management), this additional development cost might not apply.</span></span>

-   <span data-ttu-id="ce327-191">如果 API 閘道是由單一小組所開發，則可能會有開發瓶頸。</span><span class="sxs-lookup"><span data-stu-id="ce327-191">If the API Gateway is developed by a single team, there can be a development bottleneck.</span></span> <span data-ttu-id="ce327-192">這是較佳方法是具有數個回應不同用戶端需求之微調 API 閘道的另一個原因。</span><span class="sxs-lookup"><span data-stu-id="ce327-192">This is another reason why a better approach is to have several fined-grained API Gateways that respond to different client needs.</span></span> <span data-ttu-id="ce327-193">您也可以在內部將 API 閘道區分為處理內部微服務之不同小組所擁有的多個區域或層級。</span><span class="sxs-lookup"><span data-stu-id="ce327-193">You could also segregate the API Gateway internally into multiple areas or layers that are owned by the different teams working on the internal microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="ce327-194">其他資源</span><span class="sxs-lookup"><span data-stu-id="ce327-194">Additional resources</span></span>

-   <span data-ttu-id="ce327-195">**Charles Richardson：模式：API 閘道/前端的後端**
    [*https://microservices.io/patterns/apigateway.html*](https://microservices.io/patterns/apigateway.html)</span><span class="sxs-lookup"><span data-stu-id="ce327-195">**Charles Richardson. Pattern: API Gateway / Backend for Front-End**
[*https://microservices.io/patterns/apigateway.html*](https://microservices.io/patterns/apigateway.html)</span></span>

-   <span data-ttu-id="ce327-196">**Azure API 管理**
    [*https://azure.microsoft.com/services/api-management/*](https://azure.microsoft.com/services/api-management/)</span><span class="sxs-lookup"><span data-stu-id="ce327-196">**Azure API Management**
[*https://azure.microsoft.com/services/api-management/*](https://azure.microsoft.com/services/api-management/)</span></span>

-   <span data-ttu-id="ce327-197">**Udi Dahan.Service Oriented Composition (服務導向組合)**\\</span><span class="sxs-lookup"><span data-stu-id="ce327-197">**Udi Dahan. Service Oriented Composition**\\</span></span>
    [*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)

-   <span data-ttu-id="ce327-198">**Clemens Vasters：GOTO 2016 的傳訊和微服務** (影片) [*https://www.youtube.com/watch?v=rXi5CLjIQ9k*](https://www.youtube.com/watch?v=rXi5CLjIQ9k)</span><span class="sxs-lookup"><span data-stu-id="ce327-198">**Clemens Vasters. Messaging and Microservices at GOTO 2016** (video) [*https://www.youtube.com/watch?v=rXi5CLjIQ9k*](https://www.youtube.com/watch?v=rXi5CLjIQ9k)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="ce327-199">[上一個] (identify-microservice-domain-model-boundaries.md) [下一個] (communication-in-microservice-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="ce327-199">[Previous] (identify-microservice-domain-model-boundaries.md) [Next] (communication-in-microservice-architecture.md)</span></span>
