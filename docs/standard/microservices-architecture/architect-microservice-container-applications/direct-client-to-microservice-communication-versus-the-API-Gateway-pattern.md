---
title: "與 API 閘道模式的直接用戶端的微服務通訊"
description: "容器化的.NET 應用程式的.NET Microservices 架構 |與 API 閘道模式的直接用戶端的微服務通訊"
keywords: "Docker Microservices、 ASP.NET、 容器、 API 閘道"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 10/18/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: c8227ec47888c7cf361f34c4c85a09c0666f886e
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/22/2017
---
# <a name="direct-client-to-microservice-communication-versus-the-api-gateway-pattern"></a><span data-ttu-id="a8a25-104">與 API 閘道模式的直接用戶端的微服務通訊</span><span class="sxs-lookup"><span data-stu-id="a8a25-104">Direct client-to-microservice communication versus the API Gateway pattern</span></span>

<span data-ttu-id="a8a25-105">在 microservices 架構中，每個微服務會公開一組一般 fine‑grained 端點。</span><span class="sxs-lookup"><span data-stu-id="a8a25-105">In a microservices architecture, each microservice exposes a set of (typically) fine‑grained endpoints.</span></span> <span data-ttu-id="a8a25-106">這項事實可能會影響 client‑to‑microservice 通訊，如本節所述。</span><span class="sxs-lookup"><span data-stu-id="a8a25-106">This fact can impact the client‑to‑microservice communication, as explained in this section.</span></span>

## <a name="direct-client-to-microservice-communication"></a><span data-ttu-id="a8a25-107">若要微服務的用戶端會直接通訊</span><span class="sxs-lookup"><span data-stu-id="a8a25-107">Direct client-to-microservice communication</span></span>

<span data-ttu-id="a8a25-108">可能的方法是使用直接通訊，用戶端的微服務架構。</span><span class="sxs-lookup"><span data-stu-id="a8a25-108">A possible approach is to use a direct client-to-microservice communication architecture.</span></span> <span data-ttu-id="a8a25-109">這種方法，用戶端應用程式可以對要求直接某些 microservices，如圖 4-12 版中所示。</span><span class="sxs-lookup"><span data-stu-id="a8a25-109">In this approach, a client app can make requests directly to some of the microservices, as shown in Figure 4-12.</span></span>

![](./media/image12.png)

<span data-ttu-id="a8a25-110">**圖 4-12**。</span><span class="sxs-lookup"><span data-stu-id="a8a25-110">**Figure 4-12**.</span></span> <span data-ttu-id="a8a25-111">使用直接通訊，用戶端的微服務架構</span><span class="sxs-lookup"><span data-stu-id="a8a25-111">Using a direct client-to-microservice communication architecture</span></span>

<span data-ttu-id="a8a25-112">在這種方法。</span><span class="sxs-lookup"><span data-stu-id="a8a25-112">In this approach.</span></span> <span data-ttu-id="a8a25-113">每個微服務有公用端點，有時會有不同的 TCP 連接埠的每個微服務。</span><span class="sxs-lookup"><span data-stu-id="a8a25-113">each microservice has a public endpoint, sometimes with a different TCP port for each microservice.</span></span> <span data-ttu-id="a8a25-114">針對特定服務的 URL 的範例可能是在 Azure 中的下列 URL:</span><span class="sxs-lookup"><span data-stu-id="a8a25-114">An example of a URL for a particular service could be the following URL in Azure:</span></span>

<span data-ttu-id="a8a25-115"><http://eshoponcontainers.westus.cloudapp.azure.com:88 /></span><span class="sxs-lookup"><span data-stu-id="a8a25-115"><http://eshoponcontainers.westus.cloudapp.azure.com:88/></span></span>

<span data-ttu-id="a8a25-116">在生產環境中的叢集，URL 會對應至叢集中使用的負載平衡器為基礎的接著將要求分散到 microservices。</span><span class="sxs-lookup"><span data-stu-id="a8a25-116">In a production environment based on a cluster, that URL would map to the load balancer used in the cluster, which in turn distributes the requests across the microservices.</span></span> <span data-ttu-id="a8a25-117">在實際執行環境中，您可能會有類似的應用程式傳遞控制站 (ADC) [Azure 應用程式閘道](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction)您 microservices 與網際網路之間。</span><span class="sxs-lookup"><span data-stu-id="a8a25-117">In production environments, you could have an Application Delivery Controller (ADC) like [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/application-gateway-introduction) between your microservices and the Internet.</span></span> <span data-ttu-id="a8a25-118">這可以做為透明的層，不會執行負載平衡，只保護您的服務供應項目 SSL 終止。</span><span class="sxs-lookup"><span data-stu-id="a8a25-118">This acts as a transparent tier that not only performs load balancing, but secures your services by offering SSL termination.</span></span> <span data-ttu-id="a8a25-119">這可以改善您的主機負載卸載 CPU 運算密集 SSL 終止和其他路由的責任給 Azure 應用程式閘道。</span><span class="sxs-lookup"><span data-stu-id="a8a25-119">This improves the load of your hosts by offloading CPU-intensive SSL termination and other routing duties to the Azure Application Gateway.</span></span> <span data-ttu-id="a8a25-120">在任何情況下，負載平衡器和 ADC 皆為透明從邏輯應用程式架構的觀點。</span><span class="sxs-lookup"><span data-stu-id="a8a25-120">In any case, a load balancer and ADC are transparent from a logical application architecture point of view.</span></span>

<span data-ttu-id="a8a25-121">直接通訊，用戶端的微服務架構可能是適用於小型微服務應用程式中，特別是當用戶端應用程式是伺服器端 web 應用程式，例如 ASP.NET MVC 應用程式。</span><span class="sxs-lookup"><span data-stu-id="a8a25-121">A direct client-to-microservice communication architecture could be good enough for a small microservice-based application, especially if the client app is a server-side web application like an ASP.NET MVC app.</span></span> <span data-ttu-id="a8a25-122">不過，當您建置大型且複雜微服務為基礎的應用程式 （例如，處理數十個微服務型別時），而且特別是當用戶端應用程式遠端行動裝置應用程式或 SPA web 應用程式，該方法會面臨的一些問題。</span><span class="sxs-lookup"><span data-stu-id="a8a25-122">However, when you build large and complex microservice-based applications (for example, when handling dozens of microservice types), and especially when the client apps are remote mobile apps or SPA web applications, that approach faces a few issues.</span></span>

<span data-ttu-id="a8a25-123">開發 microservices 為基礎的大型應用程式時，請考慮下列問題：</span><span class="sxs-lookup"><span data-stu-id="a8a25-123">Consider the following questions when developing a large application based on microservices:</span></span>

-   <span data-ttu-id="a8a25-124">*用戶端應用程式如何最小化後端要求的數目和減少至多個 microservices 多對話通訊？*</span><span class="sxs-lookup"><span data-stu-id="a8a25-124">*How can client apps minimize the number of requests to the backend and reduce chatty communication to multiple microservices?*</span></span>

<span data-ttu-id="a8a25-125">在網際網路上會互動來建置單一 UI 畫面的多個 microservices 增加往返的次數。</span><span class="sxs-lookup"><span data-stu-id="a8a25-125">Interacting with multiple microservices to build a single UI screen increases the number of roundtrips across the Internet.</span></span> <span data-ttu-id="a8a25-126">這會增加延遲和 UI 端上的複雜性。</span><span class="sxs-lookup"><span data-stu-id="a8a25-126">This increases latency and complexity on the UI side.</span></span> <span data-ttu-id="a8a25-127">在理想情況下，回應應該有效率地彙總伺服器端 — 這會減少延遲，因為多個資料片段回來以平行方式，而且只要準備就緒時，某些 UI 可以顯示的資料。</span><span class="sxs-lookup"><span data-stu-id="a8a25-127">Ideally, responses should be efficiently aggregated in the server side—this reduces latency, since multiple pieces of data come back in parallel and some UI can show data as soon as it is ready.</span></span>

-   <span data-ttu-id="a8a25-128">*您要如何處理跨領域的考量，如授權、 資料轉換和動態要求分派？*</span><span class="sxs-lookup"><span data-stu-id="a8a25-128">*How can you handle cross-cutting concerns such as authorization, data transformations, and dynamic request dispatching?*</span></span>

<span data-ttu-id="a8a25-129">實作的安全性與跨領域考量，像是安全性和授權上每個微服務可能需要大量的開發工作。</span><span class="sxs-lookup"><span data-stu-id="a8a25-129">Implementing security and cross-cutting concerns like security and authorization on every microservice can require significant development effort.</span></span> <span data-ttu-id="a8a25-130">可能的方法是讓這些服務內的 Docker 主機或內部的叢集，以限制他們從外部，直接存取，並在集中位置，例如應用程式開發介面 Gateway 實作這些跨領域的考量。</span><span class="sxs-lookup"><span data-stu-id="a8a25-130">A possible approach is to have those services within the Docker host or internal cluster, in order to restrict direct access to them from the outside, and to implement those cross-cutting concerns in a centralized place, like an API Gateway.</span></span>

-   <span data-ttu-id="a8a25-131">*可以用戶端應用程式與通訊的方式使用非易記網際網路通訊協定的服務？*</span><span class="sxs-lookup"><span data-stu-id="a8a25-131">*How can client apps communicate with services that use non-Internet-friendly protocols?*</span></span>

<span data-ttu-id="a8a25-132">通常在用戶端應用程式中不支援通訊協定 （例如 AMQP 或二進位通訊協定） 的伺服器端上使用。</span><span class="sxs-lookup"><span data-stu-id="a8a25-132">Protocols used on the server side (like AMQP or binary protocols) are usually not supported in client apps.</span></span> <span data-ttu-id="a8a25-133">因此，要求必須透過如 HTTP/HTTPS 通訊協定來執行，而且之後轉譯成其他通訊協定。</span><span class="sxs-lookup"><span data-stu-id="a8a25-133">Therefore, requests must be performed through protocols like HTTP/HTTPS and translated to the other protocols afterwards.</span></span> <span data-ttu-id="a8a25-134">A*攔截*方法可以在此情況下幫助。</span><span class="sxs-lookup"><span data-stu-id="a8a25-134">A *man-in-the-middle* approach can help in this situation.</span></span>

-   <span data-ttu-id="a8a25-135">*您要如何形成外觀，尤其是對行動裝置應用程式？*</span><span class="sxs-lookup"><span data-stu-id="a8a25-135">*How can you shape a façade especially made for mobile apps?*</span></span>

<span data-ttu-id="a8a25-136">針對不同的用戶端應用程式的需求可能不會也設計多個 microservices API。</span><span class="sxs-lookup"><span data-stu-id="a8a25-136">The API of multiple microservices might not be well designed for the needs of different client applications.</span></span> <span data-ttu-id="a8a25-137">比方說，行動裝置應用程式的需求可能會與 web 應用程式的需求不同。</span><span class="sxs-lookup"><span data-stu-id="a8a25-137">For instance, the needs of a mobile app might be different than the needs of a web app.</span></span> <span data-ttu-id="a8a25-138">行動裝置應用程式，您可能需要更進一步最佳化，讓資料回應可能會更有效率。</span><span class="sxs-lookup"><span data-stu-id="a8a25-138">For mobile apps, you might need to optimize even further so that data responses can be more efficient.</span></span> <span data-ttu-id="a8a25-139">您可能會從多個 microservices 彙總資料並傳回單一集合的資料，有時排除不需要行動裝置應用程式的回應中的任何資料，藉以執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="a8a25-139">You might do this by aggregating data from multiple microservices and returning a single set of data, and sometimes eliminating any data in the response that is not needed by the mobile app.</span></span> <span data-ttu-id="a8a25-140">而且，您可能會壓縮該資料。</span><span class="sxs-lookup"><span data-stu-id="a8a25-140">And, of course, you might compress that data.</span></span> <span data-ttu-id="a8a25-141">同樣地，外觀或行動裝置應用程式和 microservices 之間的應用程式開發介面可以是此案例中很方便。</span><span class="sxs-lookup"><span data-stu-id="a8a25-141">Again, a façade or API in between the mobile app and the microservices can be convenient for this scenario.</span></span>

## <a name="using-an-api-gateway"></a><span data-ttu-id="a8a25-142">使用 API 閘道</span><span class="sxs-lookup"><span data-stu-id="a8a25-142">Using an API Gateway</span></span>

<span data-ttu-id="a8a25-143">當您設計及建置大型或複雜微服務為基礎的應用程式使用多個用戶端應用程式時，可以是一個好的方法，考慮[API 閘道](http://microservices.io/patterns/apigateway.html)。</span><span class="sxs-lookup"><span data-stu-id="a8a25-143">When you design and build large or complex microservice-based applications with multiple client apps, a good approach to consider can be an [API Gateway](http://microservices.io/patterns/apigateway.html).</span></span> <span data-ttu-id="a8a25-144">這是 microservices 的特定群組提供單一進入點的服務。</span><span class="sxs-lookup"><span data-stu-id="a8a25-144">This is a service that provides a single entry point for certain groups of microservices.</span></span> <span data-ttu-id="a8a25-145">類似於[外觀模式](https://en.wikipedia.org/wiki/Facade_pattern)從 object‑oriented 設計，但在此情況下，它是分散式系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="a8a25-145">It is similar to the [Facade pattern](https://en.wikipedia.org/wiki/Facade_pattern) from object‑oriented design, but in this case, it is part of a distributed system.</span></span> <span data-ttu-id="a8a25-146">API 閘道模式有時也稱為 「 後端的 「 前端 」 [(BFF)](http://samnewman.io/patterns/architectural/bff/)因為您建置時思考用戶端應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="a8a25-146">The API Gateway pattern is also sometimes known as the “backend for frontend” [(BFF)](http://samnewman.io/patterns/architectural/bff/) because you build it while thinking about the needs of the client app.</span></span>

<span data-ttu-id="a8a25-147">圖 4-13 顯示自訂 API 閘道器如何納入微服務為基礎的架構。</span><span class="sxs-lookup"><span data-stu-id="a8a25-147">Figure 4-13 shows how a custom API Gateway can fit into a microservice-based architecture.</span></span>
<span data-ttu-id="a8a25-148">請務必中反白顯示，該圖表，您會使用單一自訂 API 閘道服務對向多個與不同的用戶端應用程式。</span><span class="sxs-lookup"><span data-stu-id="a8a25-148">It is important to highlight that in that diagram, you would be using a single custom API Gateway service facing multiple and different client apps.</span></span> <span data-ttu-id="a8a25-149">事實可以是重要的風險，因為將會成長及演變，您的應用程式開發介面的閘道服務會根據許多不同的需求，從用戶端應用程式。</span><span class="sxs-lookup"><span data-stu-id="a8a25-149">That fact can be an important risk because your API Gateway service will be growing and evolving based on many different requirements from the client apps.</span></span> <span data-ttu-id="a8a25-150">最後，將予以繁雜因為這些不同的需求並有效地可能很類似於整合型應用程式或整合服務。</span><span class="sxs-lookup"><span data-stu-id="a8a25-150">Eventually, it will be bloated because of those different needs and effectively it could be pretty similar to a monolithic application or monolithic service.</span></span> <span data-ttu-id="a8a25-151">這是非常建議使用分割應用程式開發介面中的閘道多個服務或多個較小 API 閘道，其中每個表單係數類型執行個體的原因。</span><span class="sxs-lookup"><span data-stu-id="a8a25-151">That is why it is very much recommended to split the API Gateway in multiple services or multiple smaller API Gateways, one per form-factor type, for instance.</span></span>

![](./media/image13.png)

<span data-ttu-id="a8a25-152">**圖 4-13**。</span><span class="sxs-lookup"><span data-stu-id="a8a25-152">**Figure 4-13**.</span></span> <span data-ttu-id="a8a25-153">使用 API 閘道實作為自訂的 Web API 服務</span><span class="sxs-lookup"><span data-stu-id="a8a25-153">Using an API Gateway implemented as a custom Web API service</span></span>

<span data-ttu-id="a8a25-154">在此範例中，API 閘道會實作為自訂的 Web API 服務執行的容器。</span><span class="sxs-lookup"><span data-stu-id="a8a25-154">In this example, the API Gateway would be implemented as a custom Web API service running as a container.</span></span>

<span data-ttu-id="a8a25-155">如前所述，您應該實作數個應用程式開發介面閘道，以便您可以有不同的外觀，針對每個用戶端應用程式的需求。</span><span class="sxs-lookup"><span data-stu-id="a8a25-155">As mentioned, you should implement several API Gateways so that you can have a different façade for the needs of each client app.</span></span> <span data-ttu-id="a8a25-156">每個 API 閘道可提供不同的應用程式開發介面量身訂做的每個用戶端應用程式中，可能甚至會根據用戶端衩怮藉由實作特定介面卡的下方呼叫多個內部 microservices 的程式碼。</span><span class="sxs-lookup"><span data-stu-id="a8a25-156">Each API Gateway can provide a different API tailored for each client app, possibly even based on the client form factor by implementing specific adapter code which underneath calls multiple internal microservices.</span></span>

<span data-ttu-id="a8a25-157">由於自訂 API 閘道通常是資料彙總工具，您必須謹慎使用它。</span><span class="sxs-lookup"><span data-stu-id="a8a25-157">Since a custom API Gateway is usually a data aggregator, you need to be careful with it.</span></span> <span data-ttu-id="a8a25-158">通常最好是有單一彙總您的應用程式的所有內部 microservices API 閘道沒有資源。</span><span class="sxs-lookup"><span data-stu-id="a8a25-158">Usually it isn't a good idea to have a single API Gateway aggregating all the internal microservices of your application.</span></span> <span data-ttu-id="a8a25-159">若是如此，它會做為整合型彙總工具或 orchestrator，並藉由所有 microservices 違反自主微服務。</span><span class="sxs-lookup"><span data-stu-id="a8a25-159">If it does, it acts as a monolithic aggregator or orchestrator and violates microservice autonomy by coupling all the microservices.</span></span> <span data-ttu-id="a8a25-160">因此，應用程式開發介面閘道應該被隔離根據商務界限，並不針對做為整個應用程式彙總工具。</span><span class="sxs-lookup"><span data-stu-id="a8a25-160">Therefore, the API Gateways should be segregated based on business boundaries and not act as an aggregator for the whole application.</span></span>

<span data-ttu-id="a8a25-161">有時候細微的 API 閘道可以也是微服務本身，而甚至可將網域或公司名稱及相關的資料。</span><span class="sxs-lookup"><span data-stu-id="a8a25-161">Sometimes a granular API Gateway can also be a microservice by itself, and even have a domain or business name and related data.</span></span> <span data-ttu-id="a8a25-162">擁有商務或網域所指定的 API 閘道的界限會幫助您獲得更好的設計。</span><span class="sxs-lookup"><span data-stu-id="a8a25-162">Having the API Gateway’s boundaries dictated by the business or domain will help you to get a better design.</span></span>

<span data-ttu-id="a8a25-163">閘道應用程式開發介面層中的資料粒度可能特別適用於更進階的複合 UI 應用程式根據 microservices，因為更細緻的 API 閘道概念就類似於 UI 組合服務。</span><span class="sxs-lookup"><span data-stu-id="a8a25-163">Granularity in the API Gateway tier can be especially useful for more advanced composite UI applications based on microservices, because the concept of a fine-grained API Gateway is similar to a UI composition service.</span></span> <span data-ttu-id="a8a25-164">我們會討論這稍後在[根據建立複合 UI microservices](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices)。</span><span class="sxs-lookup"><span data-stu-id="a8a25-164">We discuss this later in the [Creating composite UI based on microservices](#creating-composite-ui-based-on-microservices-including-visual-ui-shape-and-layout-generated-by-multiple-microservices).</span></span>

<span data-ttu-id="a8a25-165">因此，許多和大型-中型應用程式中使用自訂 API 閘道通常是較好的方法，但不是能作為單一龐大的彙總工具或唯一中央的自訂 API 閘道。</span><span class="sxs-lookup"><span data-stu-id="a8a25-165">Therefore, for many medium- and large-size applications, using a custom-built API Gateway is usually a good approach, but not as a single monolithic aggregator or unique central custom API Gateway.</span></span>

<span data-ttu-id="a8a25-166">另一個方法是使用像是產品[Azure API 管理](https://azure.microsoft.com/services/api-management/)如圖 4-14 版中所示。</span><span class="sxs-lookup"><span data-stu-id="a8a25-166">Another approach is to use a product like [Azure API Management](https://azure.microsoft.com/services/api-management/) as shown in Figure 4-14.</span></span> <span data-ttu-id="a8a25-167">這個方法不僅可以解決您的應用程式開發介面閘道需求，提供功能，例如收集 insights 從您的應用程式開發介面。</span><span class="sxs-lookup"><span data-stu-id="a8a25-167">This approach not only solves your API Gateway needs, but provides features like gathering insights from your APIs.</span></span> <span data-ttu-id="a8a25-168">如果您使用 API 管理解決方案，API 閘道會是該完整的 API 管理方案中的元件。</span><span class="sxs-lookup"><span data-stu-id="a8a25-168">If you are using an API management solution, an API Gateway is only a component within that full API management solution.</span></span>

![](./media/image14.png)

<span data-ttu-id="a8a25-169">**圖 4-14**。</span><span class="sxs-lookup"><span data-stu-id="a8a25-169">**Figure 4-14**.</span></span> <span data-ttu-id="a8a25-170">您的應用程式開發介面閘道使用 Azure API 管理</span><span class="sxs-lookup"><span data-stu-id="a8a25-170">Using Azure API Management for your API Gateway</span></span>

<span data-ttu-id="a8a25-171">在此情況下，當使用 Azure API 管理，您可能會有單一的應用程式開發介面閘道的事實等產品並不那麼風險因為這類的應用程式開發介面閘道 」 細"，這表示您不會實作自訂 C# 程式碼可能發展朝向整合元件。</span><span class="sxs-lookup"><span data-stu-id="a8a25-171">In this case, when using a product like Azure API Management, the fact that you might have a single API Gateway is not so risky because these kinds of API Gateways are "thinner", meaning that you don't implement custom C# code that could evolve towards a monolithic component.</span></span> 

<span data-ttu-id="a8a25-172">這種類型的產品更像是輸入通訊，其中也篩選從內部 microservices Api 以及將授權套用至已發行應用程式開發介面，此單一階層中的反向 proxy。</span><span class="sxs-lookup"><span data-stu-id="a8a25-172">This type of product acts more like a reverse proxy for ingress communication, where you can also filter the APIs from the internal microservices plus apply authorization to the published APIs in this single tier.</span></span>

<span data-ttu-id="a8a25-173">可從 API 管理系統說明的深入資訊了解您的應用程式開發介面的使用方式，而且正在執行的方式。</span><span class="sxs-lookup"><span data-stu-id="a8a25-173">The insights available from an API Management system help you get an understanding of how your APIs are being used and how they are performing.</span></span> <span data-ttu-id="a8a25-174">他們這麼做會讓您以接近即時的分析報告檢視及識別可能會影響您公司的趨勢。</span><span class="sxs-lookup"><span data-stu-id="a8a25-174">They do this by letting you view near real-time analytics reports and identifying trends that might impact your business.</span></span> <span data-ttu-id="a8a25-175">此外，您可以要求和回應的活動，供進一步線上及離線分析的相關記錄檔。</span><span class="sxs-lookup"><span data-stu-id="a8a25-175">Plus, you can have logs about request and response activity for further online and offline analysis.</span></span>

<span data-ttu-id="a8a25-176">使用 Azure API 管理，您可以保護您應用程式開發介面使用的索引鍵、 語彙基元，和 IP 篩選。</span><span class="sxs-lookup"><span data-stu-id="a8a25-176">With Azure API Management, you can secure your APIs using a key, a token, and IP filtering.</span></span> <span data-ttu-id="a8a25-177">這些功能可讓您強制執行彈性且更細緻的配額和速率限制、 修改圖形和使用原則，您 Api 的行為，並改善快取回應的效能。</span><span class="sxs-lookup"><span data-stu-id="a8a25-177">These features let you enforce flexible and fine-grained quotas and rate limits, modify the shape and behavior of your APIs using policies, and improve performance with response caching.</span></span>

<span data-ttu-id="a8a25-178">在本指南和參考範例應用程式 (eShopOnContainers) 中，我們會限制更簡單且自訂的容器化架構的架構，以便專注於一般的容器，而不需使用 Azure API 管理等的 PaaS 產品。</span><span class="sxs-lookup"><span data-stu-id="a8a25-178">In this guide and the reference sample application (eShopOnContainers), we are limiting the architecture to a simpler and custom-made containerized architecture in order to focus on plain containers without using PaaS products like Azure API Management.</span></span> <span data-ttu-id="a8a25-179">但對於大型微服務為基礎應用程式部署到 Microsoft Azure，建議您檢閱，並採用做為基底的 Azure API 管理的應用程式開發介面閘道。</span><span class="sxs-lookup"><span data-stu-id="a8a25-179">But for large microservice-based applications that are deployed into Microsoft Azure, we encourage you to review and adopt Azure API Management as the base for your API Gateways.</span></span>

## <a name="drawbacks-of-the-api-gateway-pattern"></a><span data-ttu-id="a8a25-180">API 閘道模式的缺點</span><span class="sxs-lookup"><span data-stu-id="a8a25-180">Drawbacks of the API Gateway pattern</span></span>

-   <span data-ttu-id="a8a25-181">最重要的缺點是，當您實作應用程式開發介面閘道，您會結合該層內部 microservices 與。</span><span class="sxs-lookup"><span data-stu-id="a8a25-181">The most important drawback is that when you implement an API Gateway, you are coupling that tier with the internal microservices.</span></span> <span data-ttu-id="a8a25-182">像這樣的結合程度可能會造成嚴重的問題，您的應用程式。</span><span class="sxs-lookup"><span data-stu-id="a8a25-182">Coupling like this might introduce serious difficulties for your application.</span></span> <span data-ttu-id="a8a25-183">Clemens Vaster，架構設計人員的 Azure 服務匯流排小組，是指在他此潛在難度"新 ESB 」 與 「[訊息和 Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)」 工作階段在 GOTO 2016。</span><span class="sxs-lookup"><span data-stu-id="a8a25-183">Clemens Vaster, architect at the Azure Service Bus team, refers to this potential difficulty as “the new ESB” in his "[Messaging and Microservices](https://www.youtube.com/watch?v=rXi5CLjIQ9k)" session at GOTO 2016.</span></span>

-   <span data-ttu-id="a8a25-184">使用 API 閘道 microservices 建立其他可能單一失敗點。</span><span class="sxs-lookup"><span data-stu-id="a8a25-184">Using a microservices API Gateway creates an additional possible single point of failure.</span></span>

-   <span data-ttu-id="a8a25-185">API 閘道可能導致回應時間增加由於額外的網路呼叫。</span><span class="sxs-lookup"><span data-stu-id="a8a25-185">An API Gateway can introduce increased response time due to the additional network call.</span></span> <span data-ttu-id="a8a25-186">不過，這個額外的呼叫通常有較少的影響，而不需要用戶端介面，是太多話直接呼叫內部 microservices。</span><span class="sxs-lookup"><span data-stu-id="a8a25-186">However, this extra call usually has less impact than having a client interface that is too chatty directly calling the internal microservices.</span></span>

-   <span data-ttu-id="a8a25-187">如果未向外延展正確，API 閘道成為瓶頸。</span><span class="sxs-lookup"><span data-stu-id="a8a25-187">If not scaled out properly, the API Gateway can become a bottleneck.</span></span>

-   <span data-ttu-id="a8a25-188">如果它包含自訂邏輯和資料彙總，API 閘道需要額外的開發成本和未來的維護。</span><span class="sxs-lookup"><span data-stu-id="a8a25-188">An API Gateway requires additional development cost and future maintenance if it includes custom logic and data aggregation.</span></span> <span data-ttu-id="a8a25-189">開發人員必須更新 API 閘道，才能公開每個微服務端點。</span><span class="sxs-lookup"><span data-stu-id="a8a25-189">Developers must update the API Gateway in order to expose each microservice’s endpoints.</span></span> <span data-ttu-id="a8a25-190">此外，在內部 microservices 實作變更可能會導致 API 閘道層級的程式碼變更。</span><span class="sxs-lookup"><span data-stu-id="a8a25-190">Moreover, implementation changes in the internal microservices might cause code changes at the API Gateway level.</span></span> <span data-ttu-id="a8a25-191">不過，如果應用程式開發介面閘道只將套用的安全性、 記錄和版本控制 （如同使用 Azure API 管理時），可能不會套用此額外的開發成本。</span><span class="sxs-lookup"><span data-stu-id="a8a25-191">However, if the API Gateway is just applying security, logging, and versioning (as when using Azure API Management), this additional development cost might not apply.</span></span>

-   <span data-ttu-id="a8a25-192">單一小組所開發的應用程式開發介面閘道，可以是開發瓶頸。</span><span class="sxs-lookup"><span data-stu-id="a8a25-192">If the API Gateway is developed by a single team, there can be a development bottleneck.</span></span> <span data-ttu-id="a8a25-193">這是較佳的方法為何有數個不同的用戶端需要回應的處以精細 API 閘道的另一個原因。</span><span class="sxs-lookup"><span data-stu-id="a8a25-193">This is another reason why a better approach is to have several fined-grained API Gateways that respond to different client needs.</span></span> <span data-ttu-id="a8a25-194">您也可以在內部隔離 API 閘道為多個區域或不同處理內部 microservices 的小組所擁有的圖層。</span><span class="sxs-lookup"><span data-stu-id="a8a25-194">You could also segregate the API Gateway internally into multiple areas or layers that are owned by the different teams working on the internal microservices.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="a8a25-195">其他資源</span><span class="sxs-lookup"><span data-stu-id="a8a25-195">Additional resources</span></span>

-   <span data-ttu-id="a8a25-196">**Charles Richardson。模式： API 閘道 / 後的端前端**
    [*http://microservices.io/patterns/apigateway.html*](http://microservices.io/patterns/apigateway.html)</span><span class="sxs-lookup"><span data-stu-id="a8a25-196">**Charles Richardson. Pattern: API Gateway / Backend for Front-End**
[*http://microservices.io/patterns/apigateway.html*](http://microservices.io/patterns/apigateway.html)</span></span>

-   <span data-ttu-id="a8a25-197">**Azure API 管理**
    [*https://azure.microsoft.com/services/api-management/*](https://azure.microsoft.com/services/api-management/)</span><span class="sxs-lookup"><span data-stu-id="a8a25-197">**Azure API Management**
[*https://azure.microsoft.com/services/api-management/*](https://azure.microsoft.com/services/api-management/)</span></span>

-   <span data-ttu-id="a8a25-198">**Udi Dahan。服務導向組合**\\</span><span class="sxs-lookup"><span data-stu-id="a8a25-198">**Udi Dahan. Service Oriented Composition**\\</span></span>
    [<span data-ttu-id="a8a25-199">*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*</span><span class="sxs-lookup"><span data-stu-id="a8a25-199">*http://udidahan.com/2014/07/30/service-oriented-composition-with-video/*</span></span>](http://udidahan.com/2014/07/30/service-oriented-composition-with-video/)

-   <span data-ttu-id="a8a25-200">**Clemens Vasters。訊息和在 GOTO 2016 Microservices** （影片） [ *https://www.youtube.com/watch?v=rXi5CLjIQ9k*](https://www.youtube.com/watch?v=rXi5CLjIQ9k)</span><span class="sxs-lookup"><span data-stu-id="a8a25-200">**Clemens Vasters. Messaging and Microservices at GOTO 2016** (video) [*https://www.youtube.com/watch?v=rXi5CLjIQ9k*](https://www.youtube.com/watch?v=rXi5CLjIQ9k)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="a8a25-201">[上一個](識別的微服務-網域-模型-boundaries.md) [下一步] (通訊層中的微服務-architecture.md)</span><span class="sxs-lookup"><span data-stu-id="a8a25-201">[Previous] (identify-microservice-domain-model-boundaries.md) [Next] (communication-in-microservice-architecture.md)</span></span>
