---
title: "Containerizing 整合的應用程式"
description: "容器化的.NET 應用程式的.NET Microservices 架構 |Containerizing 整合的應用程式"
keywords: "Docker, 微服務, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: 11e2c24403b9b61584e424696c844e00e5d34b03
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/21/2017
---
# <a name="containerizing-monolithic-applications"></a><span data-ttu-id="cc416-104">Containerizing 整合的應用程式</span><span class="sxs-lookup"><span data-stu-id="cc416-104">Containerizing monolithic applications</span></span>

<span data-ttu-id="cc416-105">您可以建立單一、 monolithically 已部署 web 應用程式或服務，並將它部署為容器。</span><span class="sxs-lookup"><span data-stu-id="cc416-105">You might want to build a single, monolithically deployed web application or service and deploy it as a container.</span></span> <span data-ttu-id="cc416-106">應用程式本身可能不會在內部龐大，但結構化以多個程式庫、 元件或甚至是圖層 （應用程式層級、 網域層級、 資料存取層等等）。</span><span class="sxs-lookup"><span data-stu-id="cc416-106">The application itself might not be internally monolithic, but structured as several libraries, components, or even layers (application layer, domain layer, data-access layer, etc.).</span></span> <span data-ttu-id="cc416-107">不過，外部，它會是在單一容器 — 在單一處理序中，單一的 web 應用程式或單一服務。</span><span class="sxs-lookup"><span data-stu-id="cc416-107">Externally, however, it is a single container—a single process, a single web application, or a single service.</span></span>

<span data-ttu-id="cc416-108">若要管理此模型，您可以部署單一容器來表示應用程式。</span><span class="sxs-lookup"><span data-stu-id="cc416-108">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="cc416-109">若要向上延展，只要加入前方負載平衡器與多個複本。</span><span class="sxs-lookup"><span data-stu-id="cc416-109">To scale up, you just add more copies with a load balancer in front.</span></span> <span data-ttu-id="cc416-110">管理單一容器或 VM 中的單一部署來自簡易性。</span><span class="sxs-lookup"><span data-stu-id="cc416-110">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image1.png)

<span data-ttu-id="cc416-111">**圖 4-1**。</span><span class="sxs-lookup"><span data-stu-id="cc416-111">**Figure 4-1**.</span></span> <span data-ttu-id="cc416-112">容器化的整合應用程式架構的範例</span><span class="sxs-lookup"><span data-stu-id="cc416-112">Example of the architecture of a containerized monolithic application</span></span>

<span data-ttu-id="cc416-113">您可以包含多個元件、 程式庫或內部層中每個容器，在圖 4-1 中所述。</span><span class="sxs-lookup"><span data-stu-id="cc416-113">You can include multiple components, libraries, or internal layers in each container, as illustrated in Figure 4-1.</span></span> <span data-ttu-id="cc416-114">不過，此整合模式可能會與"容器沒有一件事，和一個處理序中運作"，但可能容器原則衝突會在某些情況下 [確定]。</span><span class="sxs-lookup"><span data-stu-id="cc416-114">However, this monolithic pattern might conflict with the container principle “a container does one thing, and does it in one process”, but might be ok for some cases.</span></span>

<span data-ttu-id="cc416-115">這種方法的缺點變得顯而易見，如果應用程式成長，需要調整。</span><span class="sxs-lookup"><span data-stu-id="cc416-115">The downside of this approach becomes evident if the application grows, requiring it to scale.</span></span> <span data-ttu-id="cc416-116">如果可以調整整個應用程式，它並非真正的問題。</span><span class="sxs-lookup"><span data-stu-id="cc416-116">If the entire application can scale, it is not really a problem.</span></span> <span data-ttu-id="cc416-117">不過，在大部分情況下，應用程式只需要幾個部分都需要調整其他元件時使用小於淺壓深點。</span><span class="sxs-lookup"><span data-stu-id="cc416-117">However, in most cases, just a few parts of the application are the choke points that requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="cc416-118">例如，在典型的電子商務應用程式中，您可能需要調整產品資訊子系統中，因為比購買更多其他客戶瀏覽產品。</span><span class="sxs-lookup"><span data-stu-id="cc416-118">For example, in a typical e-commerce application, you likely need to scale the product information subsystem, because many more customers browse products than purchase them.</span></span> <span data-ttu-id="cc416-119">更多的客戶使用及其購物籃，比使用付款管線。</span><span class="sxs-lookup"><span data-stu-id="cc416-119">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="cc416-120">較少的客戶加入註解或檢視其採購歷程記錄。</span><span class="sxs-lookup"><span data-stu-id="cc416-120">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="cc416-121">因此，您可能必須少數幾個需要管理內容與行銷活動的員工。</span><span class="sxs-lookup"><span data-stu-id="cc416-121">And you might have only a handful of employees, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="cc416-122">如果您調整規模龐大的設計，請針對這些不同工作的所有程式碼是多次部署和縮放比例為相同的等級。</span><span class="sxs-lookup"><span data-stu-id="cc416-122">If you scale the monolithic design, all the code for these different tasks is deployed multiple times and scaled at the same grade.</span></span>

<span data-ttu-id="cc416-123">有多種方式可以調整應用程式 — 分割不同的應用程式和資料分割類似的商務概念或資料區域的水平重複。</span><span class="sxs-lookup"><span data-stu-id="cc416-123">There are multiple ways to scale an application—horizontal duplication, splitting different areas of the application, and partitioning similar business concepts or data.</span></span> <span data-ttu-id="cc416-124">但是，除了縮放所有元件的問題，變更單一元件需要完整測試整個應用程式，以及完整的重新部署的所有執行個體。</span><span class="sxs-lookup"><span data-stu-id="cc416-124">But, in addition to the problem of scaling all components, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="cc416-125">但是，整合的方法是不常見，因為應用程式開發一開始更為 microservices 方法。</span><span class="sxs-lookup"><span data-stu-id="cc416-125">However, the monolithic approach is common, because the development of the application is initially easier than for microservices approaches.</span></span> <span data-ttu-id="cc416-126">因此，許多組織開發使用這個架構的方法。</span><span class="sxs-lookup"><span data-stu-id="cc416-126">Thus, many organizations develop using this architectural approach.</span></span> <span data-ttu-id="cc416-127">某些組織有良好足夠的結果，而其他人到達限制。</span><span class="sxs-lookup"><span data-stu-id="cc416-127">While some organizations have had good enough results, others are hitting limits.</span></span> <span data-ttu-id="cc416-128">許多組織設計其應用程式，因為工具與基礎結構並不容易太建置服務導向架構 (SOA) 年前，及它們不會看到需要使用此模型，直到應用程式成長。</span><span class="sxs-lookup"><span data-stu-id="cc416-128">Many organizations designed their applications using this model because tools and infrastructure made it too difficult to build service oriented architectures (SOA) years ago, and they did not see the need—until the application grew.</span></span>

<span data-ttu-id="cc416-129">從基礎結構的觀點而言，每一部伺服器可以執行相同的主控件中的許多應用程式，並有一個可接受比效率的資源使用量，如圖 4-2 所示。</span><span class="sxs-lookup"><span data-stu-id="cc416-129">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in resources usage, as shown in Figure 4-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="cc416-130">**圖 4-2**。</span><span class="sxs-lookup"><span data-stu-id="cc416-130">**Figure 4-2**.</span></span> <span data-ttu-id="cc416-131">整合的方法： 裝載執行多個應用程式，做為容器執行每個應用程式</span><span class="sxs-lookup"><span data-stu-id="cc416-131">Monolithic approach: Host running multiple apps, each app running as a container</span></span>

<span data-ttu-id="cc416-132">Microsoft Azure 中的整合應用程式可以使用每個執行個體的專用的 Vm 部署。</span><span class="sxs-lookup"><span data-stu-id="cc416-132">Monolithic applications in Microsoft Azure can be deployed using dedicated VMs for each instance.</span></span> <span data-ttu-id="cc416-133">此外，使用[Azure VM 規模集](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)，您可以輕鬆地調整 Vm。</span><span class="sxs-lookup"><span data-stu-id="cc416-133">Additionally, using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="cc416-134">[Azure App Service](https://azure.microsoft.com/services/app-service/)可以也執行整合的應用程式並輕鬆擴充執行個體，而不需要您管理的 Vm。</span><span class="sxs-lookup"><span data-stu-id="cc416-134">[Azure App Service](https://azure.microsoft.com/services/app-service/) can also run monolithic applications and easily scale instances without requiring you to manage the VMs.</span></span> <span data-ttu-id="cc416-135">自 2016，Azure 應用程式服務可以執行單一執行個體，Docker 容器簡化部署。</span><span class="sxs-lookup"><span data-stu-id="cc416-135">Since 2016, Azure App Services can run single instances of Docker containers as well, simplifying deployment.</span></span>

<span data-ttu-id="cc416-136">QA 環境或有限的生產環境，您可以部署多個 Docker 主機 Vm 並平衡它們使用 Azure 的平衡器，如下圖 4-3。</span><span class="sxs-lookup"><span data-stu-id="cc416-136">As a QA environment or a limited production environment, you can deploy multiple Docker host VMs and balance them using the Azure balancer, as shown in Figure 4-3.</span></span> <span data-ttu-id="cc416-137">這可讓您管理調整以粗略的方法，因為整個應用程式都位於單一容器內。</span><span class="sxs-lookup"><span data-stu-id="cc416-137">This lets you manage scaling with a coarse-grain approach, because the whole application lives within a single container.</span></span>

![](./media/image3.png)

<span data-ttu-id="cc416-138">**圖 4-3**。</span><span class="sxs-lookup"><span data-stu-id="cc416-138">**Figure 4-3**.</span></span> <span data-ttu-id="cc416-139">向上擴充單一容器應用程式的多部主機的範例</span><span class="sxs-lookup"><span data-stu-id="cc416-139">Example of multiple hosts scaling up a single container application</span></span>

<span data-ttu-id="cc416-140">部署到不同主機都可以使用傳統部署技術來管理。</span><span class="sxs-lookup"><span data-stu-id="cc416-140">Deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="cc416-141">使用類似的命令可以管理 docker 主機`docker run`或`docker-compose`執行手動方式或透過自動化，例如持續傳遞 (CD) 管線。</span><span class="sxs-lookup"><span data-stu-id="cc416-141">Docker hosts can be managed with commands like `docker run` or `docker-compose` performed manually, or through automation such as continuous delivery (CD) pipelines.</span></span>

## <a name="deploying-a-monolithic-application-as-a-container"></a><span data-ttu-id="cc416-142">部署整合的應用程式，做為容器</span><span class="sxs-lookup"><span data-stu-id="cc416-142">Deploying a monolithic application as a container</span></span>

<span data-ttu-id="cc416-143">有許多優點，若要使用容器來管理整合的應用程式部署。</span><span class="sxs-lookup"><span data-stu-id="cc416-143">There are benefits to using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="cc416-144">調整容器執行個體是遠比快速而且容易部署額外的 Vm。</span><span class="sxs-lookup"><span data-stu-id="cc416-144">Scaling container instances is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="cc416-145">即使您使用 VM 規模集時，Vm 會需要啟動的時間。</span><span class="sxs-lookup"><span data-stu-id="cc416-145">Even if you use VM Scale Sets, VMs take time to start.</span></span> <span data-ttu-id="cc416-146">當部署為傳統的應用程式執行個體，而不是容器，應用程式的組態管理一部分 VM，這並不理想。</span><span class="sxs-lookup"><span data-stu-id="cc416-146">When deployed as traditional application instances instead of containers, the configuration of the application is managed as part of the VM, which is not ideal.</span></span>

<span data-ttu-id="cc416-147">部署更新的 Docker 映像的速度遠和有效率的網路。</span><span class="sxs-lookup"><span data-stu-id="cc416-147">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="cc416-148">Docker 映像一開始通常以秒為單位，這會加速首度發行。</span><span class="sxs-lookup"><span data-stu-id="cc416-148">Docker images typically start in seconds, which speeds rollouts.</span></span> <span data-ttu-id="cc416-149">破壞的 Docker 映像執行個體非常簡單，只要發出`docker stop`命令，然後通常少於一秒內完成。</span><span class="sxs-lookup"><span data-stu-id="cc416-149">Tearing down a Docker image instance is as easy as issuing a `docker stop` command, and typically completes in less than a second.</span></span>

<span data-ttu-id="cc416-150">容器是不變，根據設計，因為您永遠不需要擔心損毀的 Vm。</span><span class="sxs-lookup"><span data-stu-id="cc416-150">Because containers are immutable by design, you never need to worry about corrupted VMs.</span></span> <span data-ttu-id="cc416-151">相反地，VM 的更新指令碼可能會忘記某些特定的設定或磁碟上剩餘的檔案。</span><span class="sxs-lookup"><span data-stu-id="cc416-151">In contrast, update scripts for a VM might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="cc416-152">整合的應用程式可以從 Docker 獲益，雖然我們接觸只在優點。</span><span class="sxs-lookup"><span data-stu-id="cc416-152">While monolithic applications can benefit from Docker, we are touching only on the benefits.</span></span> <span data-ttu-id="cc416-153">管理容器的其他優點來自部署容器 orchestrators，管理不同的執行個體和每個容器執行個體的生命週期。</span><span class="sxs-lookup"><span data-stu-id="cc416-153">Additional benefits of managing containers come from deploying with container orchestrators, which manage the various instances and lifecycle of each container instance.</span></span> <span data-ttu-id="cc416-154">整合應用程式子系統，可調整、 開發，而且個別部署成重大是 microservices 的領域您進入點。</span><span class="sxs-lookup"><span data-stu-id="cc416-154">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

## <a name="publishing-a-single-container-based-application-to-azure-app-service"></a><span data-ttu-id="cc416-155">單一容器基礎應用程式發行至 Azure App Service</span><span class="sxs-lookup"><span data-stu-id="cc416-155">Publishing a single-container-based application to Azure App Service</span></span>

<span data-ttu-id="cc416-156">您是否想要取得的容器，部署至 Azure 的驗證，或只是單一容器應用程式的應用程式時，Azure 應用程式服務會提供以提供單一容器基礎的可延展服務的好方法。</span><span class="sxs-lookup"><span data-stu-id="cc416-156">Whether you want to get validation of a container deployed to Azure or when an application is simply a single-container application, Azure App Service provides a great way to provide scalable single-container-based services.</span></span> <span data-ttu-id="cc416-157">使用 Azure App Service 很簡單。</span><span class="sxs-lookup"><span data-stu-id="cc416-157">Using Azure App Service is simple.</span></span> <span data-ttu-id="cc416-158">它提供絕佳的整合，使用 Git，讓您輕鬆取得您的程式碼、 建置在 Visual Studio 中，並將它部署直接部署至 Azure。</span><span class="sxs-lookup"><span data-stu-id="cc416-158">It provides great integration with Git to make it easy to take your code, build it in Visual Studio, and deploy it directly to Azure.</span></span>

![](./media/image4.png)

<span data-ttu-id="cc416-159">**圖 4-4**。</span><span class="sxs-lookup"><span data-stu-id="cc416-159">**Figure 4-4**.</span></span> <span data-ttu-id="cc416-160">單一容器應用程式發行至 Azure 應用程式服務從 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="cc416-160">Publishing a single-container application to Azure App Service from Visual Studio</span></span>

<span data-ttu-id="cc416-161">Docker，沒有如果您需要其他的功能、 架構或相依性，不支援在 Azure 應用程式服務中，您必須等到 Azure 團隊更新 App Service 中的相依性。</span><span class="sxs-lookup"><span data-stu-id="cc416-161">Without Docker, if you needed other capabilities, frameworks, or dependencies that are not supported in Azure App Service, you had to wait until the Azure team updated those dependencies in App Service.</span></span> <span data-ttu-id="cc416-162">或者，您必須切換到其他服務，例如 Azure Service Fabric、 Azure 雲端服務或甚至 Vm，其中，您必須進一步控制，您無法安裝必要的元件或架構應用程式。</span><span class="sxs-lookup"><span data-stu-id="cc416-162">Or you had to switch to other services like Azure Service Fabric, Azure Cloud Services, or even VMs, where you had further control and you could install a required component or framework for your application.</span></span>

<span data-ttu-id="cc416-163">在 Visual Studio 2017 容器支援可讓您包含任何您想要在應用程式環境中，如圖 4-4 所示。</span><span class="sxs-lookup"><span data-stu-id="cc416-163">Container support in Visual Studio 2017 gives you the ability to include whatever you want in your application environment, as shown in Figure 4-4.</span></span> <span data-ttu-id="cc416-164">因為您已經執行在容器中，如果您將相依性加入至您的應用程式，您可以在 Dockerfile 或 Docker 映像中包含相依性。</span><span class="sxs-lookup"><span data-stu-id="cc416-164">Since you are running it in a container, if you add a dependency to your application, you can include the dependency in your Dockerfile or Docker image.</span></span>

<span data-ttu-id="cc416-165">也所示圖 4-4，發行流程推送透過容器登錄中的映像。</span><span class="sxs-lookup"><span data-stu-id="cc416-165">As also shown in Figure 4-4, the publish flow pushes an image through a container registry.</span></span> <span data-ttu-id="cc416-166">這可以是 Azure 容器登錄中 （登錄關閉您在 Azure 中的部署和保護 Azure Active Directory 群組和帳戶） 或任何其他 Docker 登錄，像是 Docker Hub 或內部登錄。</span><span class="sxs-lookup"><span data-stu-id="cc416-166">This can be the Azure Container Registry (a registry close to your deployments in Azure and secured by Azure Active Directory groups and accounts), or any other Docker registry, like Docker Hub or an on-premises registry.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="cc416-167">[上一個](index.md) [下一步] (docker-應用程式的狀態-data.md)</span><span class="sxs-lookup"><span data-stu-id="cc416-167">[Previous] (index.md) [Next] (docker-application-state-data.md)</span></span>
