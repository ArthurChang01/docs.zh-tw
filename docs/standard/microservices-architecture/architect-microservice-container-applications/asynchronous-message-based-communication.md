---
title: "非同步訊息架構通訊"
description: "容器化的.NET 應用程式的.NET Microservices 架構 |非同步訊息架構通訊"
keywords: "Docker, 微服務, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 05/26/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.topic: article
ms.openlocfilehash: df39771295d12e122edbe27e91cd899e3318e301
ms.sourcegitcommit: c2e216692ef7576a213ae16af2377cd98d1a67fa
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/22/2017
---
# <a name="asynchronous-message-based-communication"></a><span data-ttu-id="7b37b-104">非同步訊息架構通訊</span><span class="sxs-lookup"><span data-stu-id="7b37b-104">Asynchronous message-based communication</span></span>

<span data-ttu-id="7b37b-105">將變更傳播跨多個 microservices 和其相關的網域模型時，非同步傳訊和事件導向通訊非常重要。</span><span class="sxs-lookup"><span data-stu-id="7b37b-105">Asynchronous messaging and event-driven communication are critical when propagating changes across multiple microservices and their related domain models.</span></span> <span data-ttu-id="7b37b-106">如稍早討論 microservices 和繫結的內容 (BCs) 中所述，（使用者、 客戶、 產品、 帳戶等） 的模型可能代表不同 microservices 或 BCs 不同的項目。</span><span class="sxs-lookup"><span data-stu-id="7b37b-106">As mentioned earlier in the discussion microservices and Bounded Contexts (BCs), models (User, Customer, Product, Account, etc.) can mean different things to different microservices or BCs.</span></span> <span data-ttu-id="7b37b-107">這表示發生變更時，您需要某種方式來協調不同的模型之間的變更。</span><span class="sxs-lookup"><span data-stu-id="7b37b-107">That means that when changes occur, you need some way to reconcile changes across the different models.</span></span> <span data-ttu-id="7b37b-108">解決方案是最終一致性和事件導向的通訊，根據非同步訊息。</span><span class="sxs-lookup"><span data-stu-id="7b37b-108">A solution is eventual consistency and event-driven communication based on asynchronous messaging.</span></span>

<span data-ttu-id="7b37b-109">當使用訊息，處理序進行通訊所交換訊息，以非同步的方式。</span><span class="sxs-lookup"><span data-stu-id="7b37b-109">When using messaging, processes communicate by exchanging messages asynchronously.</span></span> <span data-ttu-id="7b37b-110">用戶端命令或為要求的服務傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="7b37b-110">A client makes a command or a request to a service by sending it a message.</span></span> <span data-ttu-id="7b37b-111">如果服務需要回覆，它會傳送回用戶端不同的訊息。</span><span class="sxs-lookup"><span data-stu-id="7b37b-111">If the service needs to reply, it sends a different message back to the client.</span></span> <span data-ttu-id="7b37b-112">因為它是以訊息為基礎的通訊，用戶端會假設不會在立即收到回覆，而且可能會有任何回應完全。</span><span class="sxs-lookup"><span data-stu-id="7b37b-112">Since it is a message-based communication, the client assumes that the reply will not be received immediately, and that there might be no response at all.</span></span>

<span data-ttu-id="7b37b-113">訊息的組成方式 （例如識別或安全性資訊的中繼資料） 的標頭和主體。</span><span class="sxs-lookup"><span data-stu-id="7b37b-113">A message is composed by a header (metadata such as identification or security information) and a body.</span></span> <span data-ttu-id="7b37b-114">通常會透過 AMQP 像非同步通訊協定來傳送訊息。</span><span class="sxs-lookup"><span data-stu-id="7b37b-114">Messages are usually sent through asynchronous protocols like AMQP.</span></span>

<span data-ttu-id="7b37b-115">慣用的基礎結構，這種類型的 microservices 社群中是通訊的輕量級的訊息仲介，不同於大型仲介和 orchestrators SOA 中使用。</span><span class="sxs-lookup"><span data-stu-id="7b37b-115">The preferred infrastructure for this type of communication in the microservices community is a lightweight message broker, which is different than the large brokers and orchestrators used in SOA.</span></span> <span data-ttu-id="7b37b-116">輕量級的訊息代理人在基礎結構是通常"無聲，「 僅當做訊息仲介，與簡單的實作，例如 RabbitMQ 或可擴充服務匯流排等 Azure 服務匯流排雲端。</span><span class="sxs-lookup"><span data-stu-id="7b37b-116">In a lightweight message broker, the infrastructure is typically “dumb,” acting only as a message broker, with simple implementations such as RabbitMQ or a scalable service bus in the cloud like Azure Service Bus.</span></span> <span data-ttu-id="7b37b-117">在此案例中，大部分的 「 智慧型 」 思考仍存留在所產生和取用訊息的端點，也就是 microservices 中。</span><span class="sxs-lookup"><span data-stu-id="7b37b-117">In this scenario, most of the “smart” thinking still lives in the endpoints that are producing and consuming messages—that is, in the microservices.</span></span>

<span data-ttu-id="7b37b-118">您應該嘗試執行，盡可能，另一項規則會使用唯一的非同步訊息之間的內部服務，以及使用同步通訊 （例如 HTTP) 只會從用戶端應用程式 （API 閘道加上第一層的前端服務microservices)。</span><span class="sxs-lookup"><span data-stu-id="7b37b-118">Another rule you should try to follow, as much as possible, is to use only asynchronous messaging between the internal services, and to use synchronous communication (such as HTTP) only from the client apps to the front-end services (API Gateways plus the first level of microservices).</span></span>

<span data-ttu-id="7b37b-119">有兩種類型的訊息的非同步通訊： 單一接收者訊息架構通訊及多個接收者訊息架構通訊。</span><span class="sxs-lookup"><span data-stu-id="7b37b-119">There are two kinds of asynchronous messaging communication: single receiver message-based communication, and multiple receivers message-based communication.</span></span> <span data-ttu-id="7b37b-120">下列各節中，我們會提供其相關詳細資料。</span><span class="sxs-lookup"><span data-stu-id="7b37b-120">In the following sections we provide details about them.</span></span>

## <a name="single-receiver-message-based-communication"></a><span data-ttu-id="7b37b-121">單一接收者訊息架構通訊</span><span class="sxs-lookup"><span data-stu-id="7b37b-121">Single-receiver message-based communication</span></span> 

<span data-ttu-id="7b37b-122">訊息架構與單一接收者的非同步通訊表示將訊息傳遞至其中一個，會讀取通道中，和一次處理訊息的取用者的點對點通訊。</span><span class="sxs-lookup"><span data-stu-id="7b37b-122">Message-based asynchronous communication with a single receiver means there is point-to-point communication that delivers a message to exactly one of the consumers that is reading from the channel, and that the message is processed just once.</span></span> <span data-ttu-id="7b37b-123">不過，有特殊的情況。</span><span class="sxs-lookup"><span data-stu-id="7b37b-123">However, there are special situations.</span></span> <span data-ttu-id="7b37b-124">例如，嘗試自動從失敗復原的雲端系統，相同的訊息無法多次傳送。</span><span class="sxs-lookup"><span data-stu-id="7b37b-124">For instance, in a cloud system that tries to automatically recover from failures, the same message could be sent multiple times.</span></span> <span data-ttu-id="7b37b-125">由於網路或其他失敗，用戶端必須能夠重試傳送訊息，且伺服器實作為等冪，才能處理特定訊息就可以一次作業。</span><span class="sxs-lookup"><span data-stu-id="7b37b-125">Due to network or other failures, the client has to be able to retry sending messages, and the server has to implement an operation to be idempotent in order to process a particular message just once.</span></span>

<span data-ttu-id="7b37b-126">單一接收者訊息架構通訊特別適合從一個微服務的非同步命令傳送到另一個顯示在圖 4-18，將示範這個方法。</span><span class="sxs-lookup"><span data-stu-id="7b37b-126">Single-receiver message-based communication is especially well suited for sending asynchronous commands from one microservice to another as shown in Figure 4-18 that illustrates this approach.</span></span>

<span data-ttu-id="7b37b-127">一旦您開始傳送訊息型通訊 （不論是透過命令或事件），您應該避免混用訊息為基礎的同步 HTTP 通訊的通訊。</span><span class="sxs-lookup"><span data-stu-id="7b37b-127">Once you start sending message-based communication (either with commands or events), you should avoid mixing message-based communication with synchronous HTTP communication.</span></span>

![](./media/image18.PNG)

<span data-ttu-id="7b37b-128">**圖 4-18**。</span><span class="sxs-lookup"><span data-stu-id="7b37b-128">**Figure 4-18**.</span></span> <span data-ttu-id="7b37b-129">單一的微服務，接收非同步的訊息</span><span class="sxs-lookup"><span data-stu-id="7b37b-129">A single microservice receiving an asynchronous message</span></span>

<span data-ttu-id="7b37b-130">請注意，當命令來自用戶端應用程式，它們可以實作為 HTTP 同步命令。</span><span class="sxs-lookup"><span data-stu-id="7b37b-130">Note that when the commands come from client applications, they can be implemented as HTTP synchronous commands.</span></span> <span data-ttu-id="7b37b-131">當您需要更高的延展性，或當您已經在處理訊息為基礎的商務程序，您應該使用訊息為基礎的命令。</span><span class="sxs-lookup"><span data-stu-id="7b37b-131">You should use message-based commands when you need higher scalability or when you are already in a message-based business process.</span></span>

## <a name="multiple-receivers-message-based-communication"></a><span data-ttu-id="7b37b-132">多個接收者訊息架構通訊</span><span class="sxs-lookup"><span data-stu-id="7b37b-132">Multiple-receivers message-based communication</span></span> 

<span data-ttu-id="7b37b-133">為更有彈性的方法，您也可以使用的發佈/訂閱機制，以便您寄件者的通訊可使用其他訂閱者 microservices 或外部應用程式。</span><span class="sxs-lookup"><span data-stu-id="7b37b-133">As a more flexible approach, you might also want to use a publish/subscribe mechanism so that your communication from the sender will be available to additional subscriber microservices or to external applications.</span></span> <span data-ttu-id="7b37b-134">因此，它可協助您遵循[開啟/關閉原則](https://en.wikipedia.org/wiki/Open/closed_principle)中傳送的服務。</span><span class="sxs-lookup"><span data-stu-id="7b37b-134">Thus, it helps you to follow the [open/closed principle](https://en.wikipedia.org/wiki/Open/closed_principle) in the sending service.</span></span> <span data-ttu-id="7b37b-135">這樣一來，而不需要修改寄件者服務未來可以加入其他 「 訂閱者 」。</span><span class="sxs-lookup"><span data-stu-id="7b37b-135">That way, additional subscribers can be added in the future without the need to modify the sender service.</span></span>

<span data-ttu-id="7b37b-136">當您使用發行/訂閱的通訊時，您可能使用事件匯流排介面發行至任何訂閱者的事件。</span><span class="sxs-lookup"><span data-stu-id="7b37b-136">When you use a publish/subscribe communication, you might be using an event bus interface to publish events to any subscriber.</span></span>

## <a name="asynchronous-event-driven-communication"></a><span data-ttu-id="7b37b-137">事件驅動的非同步通訊</span><span class="sxs-lookup"><span data-stu-id="7b37b-137">Asynchronous event-driven communication</span></span>

<span data-ttu-id="7b37b-138">使用事件驅動的非同步通訊，微服務會發行整合時的事件發生在其網域中，因此必須注意，例如產品類別目錄微服務的價格變更另一個的微服務。</span><span class="sxs-lookup"><span data-stu-id="7b37b-138">When using asynchronous event-driven communication, a microservice publishes an integration event when something happens within its domain and another microservice needs to be aware of it, like a price change in a product catalog microservice.</span></span> <span data-ttu-id="7b37b-139">其他 microservices 訂閱事件，讓它們以非同步方式接收。</span><span class="sxs-lookup"><span data-stu-id="7b37b-139">Additional microservices subscribe to the events so they can receive them asynchronously.</span></span> <span data-ttu-id="7b37b-140">當發生這種情況時，接收者可能會更新他們自己網域的實體，而造成更多的整合事件發行。</span><span class="sxs-lookup"><span data-stu-id="7b37b-140">When that happens, the receivers might update their own domain entities, which can cause more integration events to be published.</span></span> <span data-ttu-id="7b37b-141">此發行/訂閱系統通常會執行所使用的事件匯流排實作。</span><span class="sxs-lookup"><span data-stu-id="7b37b-141">This publish/subscribe system is usually performed by using an implementation of an event bus.</span></span> <span data-ttu-id="7b37b-142">事件匯流排都可以設計成做為抽象或介面，以訂閱或取消訂閱事件並發行事件所需的 API。</span><span class="sxs-lookup"><span data-stu-id="7b37b-142">The event bus can be designed as an abstraction or interface, with the API that is needed to subscribe or unsubscribe to events and to publish events.</span></span> <span data-ttu-id="7b37b-143">事件匯流排也可以有一個或多個實作根據任何處理序間和傳訊的 broker，像是訊息佇列或服務匯流排支援非同步通訊和發佈/訂閱模型。</span><span class="sxs-lookup"><span data-stu-id="7b37b-143">The event bus can also have one or more implementations based on any inter-process and messaging broker, like a messaging queue or service bus that supports asynchronous communication and a publish/subscribe model.</span></span>

<span data-ttu-id="7b37b-144">如果系統會使用由整合事件驅動的最終一致性，建議您使用這種方法進行完全清除終端使用者。</span><span class="sxs-lookup"><span data-stu-id="7b37b-144">If a system uses eventual consistency driven by integration events, it is recommended that this approach be made completely clear to the end user.</span></span> <span data-ttu-id="7b37b-145">系統不應該使用的模擬整合事件，例如 SignalR 或從用戶端的輪詢系統的方法。</span><span class="sxs-lookup"><span data-stu-id="7b37b-145">The system should not use an approach that mimics integration events, like SignalR or polling systems from the client.</span></span> <span data-ttu-id="7b37b-146">終端使用者，而業務擁有者必須明確面向系統中的最終一致性，並請注意，在許多情況下企業不需要使用這個方法時，任何問題，只要明確。</span><span class="sxs-lookup"><span data-stu-id="7b37b-146">The end user and the business owner have to explicitly embrace eventual consistency in the system and realize that in many cases the business does not have any problem with this approach, as long as it is explicit.</span></span>

<span data-ttu-id="7b37b-147">如同稍早在所註明[挑戰和解決方案的分散式資料管理](#challenges-and-solutions-for-distributed-data-management) 區段中，您可以使用整合事件來實作跨越多個 microservices 商務工作。</span><span class="sxs-lookup"><span data-stu-id="7b37b-147">As noted earlier in the [Challenges and solutions for distributed data management](#challenges-and-solutions-for-distributed-data-management) section, you can use integration events to implement business tasks that span multiple microservices.</span></span> <span data-ttu-id="7b37b-148">因此，您會有這些服務之間的最終一致性。</span><span class="sxs-lookup"><span data-stu-id="7b37b-148">Thus you will have eventual consistency between those services.</span></span> <span data-ttu-id="7b37b-149">最終一致性的交易是由分散式的動作集合所組成。</span><span class="sxs-lookup"><span data-stu-id="7b37b-149">An eventually consistent transaction is made up of a collection of distributed actions.</span></span> <span data-ttu-id="7b37b-150">在每個動作中，相關的微服務會更新網域實體，並將發佈中相同的端對端商務工作的下一個動作所引發的另一個整合事件。</span><span class="sxs-lookup"><span data-stu-id="7b37b-150">At each action, the related microservice updates a domain entity and publishes another integration event that raises the next action within the same end-to-end business task.</span></span>

<span data-ttu-id="7b37b-151">很重要的一點是您可能想要傳達給相同的事件訂閱的多個 microservices。</span><span class="sxs-lookup"><span data-stu-id="7b37b-151">An important point is that you might want to communicate to multiple microservices that are subscribed to the same event.</span></span> <span data-ttu-id="7b37b-152">若要這樣做，您可以使用發行/訂閱傳訊根據事件導向的通訊，如圖 4-19 所示。</span><span class="sxs-lookup"><span data-stu-id="7b37b-152">To do so, you can use publish/subscribe messaging based on event-driven communication, as shown in Figure 4-19.</span></span> <span data-ttu-id="7b37b-153">這個發行/訂閱機制不是獨占微服務架構的。</span><span class="sxs-lookup"><span data-stu-id="7b37b-153">This publish/subscribe mechanism is not exclusive to the microservice architecture.</span></span> <span data-ttu-id="7b37b-154">它是類似的方式[繫結內容](http://martinfowler.com/bliki/BoundedContext.html)中應該要能傳達 DDD，或您將傳播的方式寫入資料庫中的讀取資料庫的更新[命令和查詢責任隔離 (CQRS)](http://martinfowler.com/bliki/CQRS.html)架構模式。</span><span class="sxs-lookup"><span data-stu-id="7b37b-154">It is similar to the way [Bounded Contexts](http://martinfowler.com/bliki/BoundedContext.html) in DDD should communicate, or to the way you propagate updates from the write database to the read database in the [Command and Query Responsibility Segregation (CQRS)](http://martinfowler.com/bliki/CQRS.html) architecture pattern.</span></span> <span data-ttu-id="7b37b-155">目標是透過分散式系統的多個資料來源之間有最終一致性。</span><span class="sxs-lookup"><span data-stu-id="7b37b-155">The goal is to have eventual consistency between multiple data sources across your distributed system.</span></span>

![](./media/image19.png)

<span data-ttu-id="7b37b-156">**圖 4-19**。</span><span class="sxs-lookup"><span data-stu-id="7b37b-156">**Figure 4-19**.</span></span> <span data-ttu-id="7b37b-157">非同步事件驅動的訊息通訊</span><span class="sxs-lookup"><span data-stu-id="7b37b-157">Asynchronous event-driven message communication</span></span>

<span data-ttu-id="7b37b-158">您的實作會決定要用於事件導向、 訊息架構通訊的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="7b37b-158">Your implementation will determine what protocol to use for event-driven, message-based communications.</span></span> <span data-ttu-id="7b37b-159">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)可以協助您達成可靠的佇列的通訊。</span><span class="sxs-lookup"><span data-stu-id="7b37b-159">[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol) can help achieve reliable queued communication.</span></span>

<span data-ttu-id="7b37b-160">當您使用事件匯流排時，可能會想要使用的抽象層級 （例如事件匯流排介面） 根據具有所使用的訊息代理程式，例如從 API 的程式碼的相關類別中實作[RabbitMQ](https://www.rabbitmq.com/)或服務匯流排像[Azure 服務匯流排主題](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)。</span><span class="sxs-lookup"><span data-stu-id="7b37b-160">When you use an event bus, you might want to use an abstraction level (like an event bus interface) based on a related implementation in classes with code using the API from a message broker like [RabbitMQ](https://www.rabbitmq.com/) or a service bus like [Azure Service Bus with Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="7b37b-161">或者，您可以使用較高層級的服務匯流排，像是 NServiceBus、 MassTransit 或 Brighter 表達事件匯流排和發佈/訂閱系統。</span><span class="sxs-lookup"><span data-stu-id="7b37b-161">Alternatively, you might want to use a higher-level service bus like NServiceBus, MassTransit, or Brighter to articulate your event bus and publish/subscribe system.</span></span>

## <a name="a-note-about-messaging-technologies-for-production-systems"></a><span data-ttu-id="7b37b-162">關於訊息對生產系統技術附註</span><span class="sxs-lookup"><span data-stu-id="7b37b-162">A note about messaging technologies for production systems</span></span>

<span data-ttu-id="7b37b-163">適用於實作抽象事件匯流排傳訊的技術是在不同層級。</span><span class="sxs-lookup"><span data-stu-id="7b37b-163">The messaging technologies available for implementing your abstract event bus are at different levels.</span></span> <span data-ttu-id="7b37b-164">例如，產品，例如 RabbitMQ （傳訊 broker 傳輸） 和 Azure Service Bus 坐比其他產品，例如、 NServiceBus、 MassTransit 或 Brighter RabbitMQ 和 Azure 服務匯流排可以處理較低層級。</span><span class="sxs-lookup"><span data-stu-id="7b37b-164">For instance, products like RabbitMQ (a messaging broker transport) and Azure Service Bus sit at a lower level than other products like, NServiceBus, MassTransit, or Brighter, which can work on top of RabbitMQ and Azure Service Bus.</span></span> <span data-ttu-id="7b37b-165">您的選擇取決於應用程式層級和應用程式所需的方塊超出延展性多少豐富的功能。</span><span class="sxs-lookup"><span data-stu-id="7b37b-165">Your choice depends on how many rich features at the application level and out-of-the-box scalability you need for your application.</span></span> <span data-ttu-id="7b37b-166">實作只針對您的開發環境的概念證明事件匯流排，我們已經在 eShopOnContainers 範例中，在 Docker 容器上執行的 RabbitMQ 之上的簡單實作可能會不夠。</span><span class="sxs-lookup"><span data-stu-id="7b37b-166">For implementing just a proof-of-concept event bus for your development environment, as we have done in the eShopOnContainers sample, a simple implementation on top of RabbitMQ running on a Docker container might be enough.</span></span>

<span data-ttu-id="7b37b-167">不過，對於關鍵任務和實際執行系統上需要 hyper-v 延展性，您可能想要評估 Azure 服務匯流排。</span><span class="sxs-lookup"><span data-stu-id="7b37b-167">However, for mission-critical and production systems that need hyper-scalability, you might want to evaluate Azure Service Bus.</span></span> <span data-ttu-id="7b37b-168">高階的抽象概念和功能，可讓您更輕鬆的分散式應用程式開發，我們建議您評估其他商業和開放原始碼的服務匯流排，例如 NServiceBus、 MassTransit 和 Brighter。</span><span class="sxs-lookup"><span data-stu-id="7b37b-168">For high-level abstractions and features that make the development of distributed applications easier, we recommend that you evaluate other commercial and open-source service buses, such as NServiceBus, MassTransit, and Brighter.</span></span> <span data-ttu-id="7b37b-169">當然，您可以建立服務匯流排功能，在這類 RabbitMQ 和 Docker 的較低層級技術之上。</span><span class="sxs-lookup"><span data-stu-id="7b37b-169">Of course, you can build your own service-bus features on top of lower-level technologies like RabbitMQ and Docker.</span></span> <span data-ttu-id="7b37b-170">但是，該配管工作可能成本太多自訂企業應用程式。</span><span class="sxs-lookup"><span data-stu-id="7b37b-170">But that plumbing work might cost too much for a custom enterprise application.</span></span>

## <a name="resiliently-publishing-to-the-event-bus"></a><span data-ttu-id="7b37b-171">事件匯流排照顧發佈</span><span class="sxs-lookup"><span data-stu-id="7b37b-171">Resiliently publishing to the event bus</span></span>

<span data-ttu-id="7b37b-172">跨多個 microservices 實作的事件驅動的架構時，一項挑戰是如何以不可分割方式更新，同時照顧在其相關的整合事件發佈至事件匯流排，以某種方式根據原始的微服務中的狀態交易。</span><span class="sxs-lookup"><span data-stu-id="7b37b-172">A challenge when implementing an event-driven architecture across multiple microservices is how to atomically update state in the original microservice while resiliently publishing its related integration event into the event bus, somehow based on transactions.</span></span> <span data-ttu-id="7b37b-173">如下幾種方式可以達成此目的，雖然可能會有額外的方法。</span><span class="sxs-lookup"><span data-stu-id="7b37b-173">The following are a few ways to accomplish this, although there could be additional approaches as well.</span></span>

-   <span data-ttu-id="7b37b-174">使用 MSMQ 類似交易 （DTC 型） 佇列。</span><span class="sxs-lookup"><span data-stu-id="7b37b-174">Using a transactional (DTC-based) queue like MSMQ.</span></span> <span data-ttu-id="7b37b-175">（不過，這是傳統方法）。</span><span class="sxs-lookup"><span data-stu-id="7b37b-175">(However, this is a legacy approach.)</span></span>

-   <span data-ttu-id="7b37b-176">使用[交易記錄採礦](http://www.scoop.it/t/sql-server-transaction-log-mining)。</span><span class="sxs-lookup"><span data-stu-id="7b37b-176">Using [transaction log mining](http://www.scoop.it/t/sql-server-transaction-log-mining).</span></span>

-   <span data-ttu-id="7b37b-177">使用完整[事件來源](https://msdn.microsoft.com/en-us/library/dn589792.aspx)模式。</span><span class="sxs-lookup"><span data-stu-id="7b37b-177">Using full [Event Sourcing](https://msdn.microsoft.com/en-us/library/dn589792.aspx) pattern.</span></span>

-   <span data-ttu-id="7b37b-178">使用[寄件匣模式](http://gistlabs.com/2014/05/the-outbox/)： 將會建立事件，並將它發行的事件建立者元件的基底的訊息佇列為交易式資料庫資料表。</span><span class="sxs-lookup"><span data-stu-id="7b37b-178">Using the [Outbox pattern](http://gistlabs.com/2014/05/the-outbox/): a transactional database table as a message queue that will be the base for an event-creator component that would create the event and publish it.</span></span>

<span data-ttu-id="7b37b-179">使用非同步通訊時要考慮的其他主題是訊息等冪及訊息重複資料刪除。</span><span class="sxs-lookup"><span data-stu-id="7b37b-179">Additional topics to consider when using asynchronous communication are message idempotence and message deduplication.</span></span> <span data-ttu-id="7b37b-180">這些主題的章節將討論[實作事件架構 microservices （整合事件） 之間的通訊](#implementing_event_based_comms_microserv)本指南稍後的。</span><span class="sxs-lookup"><span data-stu-id="7b37b-180">These topics are covered in the section [Implementing event-based communication between microservices (integration events)](#implementing_event_based_comms_microserv) later in this guide.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="7b37b-181">其他資源</span><span class="sxs-lookup"><span data-stu-id="7b37b-181">Additional resources</span></span>

-   <span data-ttu-id="7b37b-182">**事件驅動訊息**
    [*http://soapatterns.org/design\_模式/事件\_驅動\_傳訊*](http://soapatterns.org/design_patterns/event_driven_messaging)</span><span class="sxs-lookup"><span data-stu-id="7b37b-182">**Event Driven Messaging**
[*http://soapatterns.org/design\_patterns/event\_driven\_messaging*](http://soapatterns.org/design_patterns/event_driven_messaging)</span></span>

-   <span data-ttu-id="7b37b-183">**發佈/訂閱通道**
    [*http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html*](http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)</span><span class="sxs-lookup"><span data-stu-id="7b37b-183">**Publish/Subscribe Channel**
[*http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html*](http://www.enterpriseintegrationpatterns.com/patterns/messaging/PublishSubscribeChannel.html)</span></span>

-   <span data-ttu-id="7b37b-184">**Udi Dahan。已釐清 CQRS**
    [*http://udidahan.com/2009/12/09/clarified-cqrs/*](http://udidahan.com/2009/12/09/clarified-cqrs/)</span><span class="sxs-lookup"><span data-stu-id="7b37b-184">**Udi Dahan. Clarified CQRS**
[*http://udidahan.com/2009/12/09/clarified-cqrs/*](http://udidahan.com/2009/12/09/clarified-cqrs/)</span></span>

-   <span data-ttu-id="7b37b-185">**命令和查詢責任隔離 (CQRS)**
    [*https://docs.microsoft.com/azure/architecture/patterns/cqrs*](https://docs.microsoft.com/azure/architecture/patterns/cqrs)</span><span class="sxs-lookup"><span data-stu-id="7b37b-185">**Command and Query Responsibility Segregation (CQRS)**
[*https://docs.microsoft.com/azure/architecture/patterns/cqrs*](https://docs.microsoft.com/azure/architecture/patterns/cqrs)</span></span>

-   <span data-ttu-id="7b37b-186">**之間通訊的繫結內容**
    [*https://msdn.microsoft.com/library/jj591572.aspx*](https://msdn.microsoft.com/library/jj591572.aspx)</span><span class="sxs-lookup"><span data-stu-id="7b37b-186">**Communicating Between Bounded Contexts**
[*https://msdn.microsoft.com/library/jj591572.aspx*](https://msdn.microsoft.com/library/jj591572.aspx)</span></span>

-   <span data-ttu-id="7b37b-187">**最終一致性**
    [*https://en.wikipedia.org/wiki/Eventual\_一致性*](https://en.wikipedia.org/wiki/Eventual_consistency)</span><span class="sxs-lookup"><span data-stu-id="7b37b-187">**Eventual consistency**
[*https://en.wikipedia.org/wiki/Eventual\_consistency*](https://en.wikipedia.org/wiki/Eventual_consistency)</span></span>

-   <span data-ttu-id="7b37b-188">**Jimmy Bogard：重構朝向彈性： 評估結合**
    [*https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/*](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)</span><span class="sxs-lookup"><span data-stu-id="7b37b-188">**Jimmy Bogard. Refactoring Towards Resilience: Evaluating Coupling**
[*https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/*](https://jimmybogard.com/refactoring-towards-resilience-evaluating-coupling/)</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="7b37b-189">[上一個](通訊層中的微服務-architecture.md) [下一步] (維護的微服務-apis.md)</span><span class="sxs-lookup"><span data-stu-id="7b37b-189">[Previous] (communication-in-microservice-architecture.md) [Next] (maintain-microservice-apis.md)</span></span>
