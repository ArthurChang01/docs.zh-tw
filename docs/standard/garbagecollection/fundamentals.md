---
title: "記憶體回收的基本概念"
description: "記憶體回收的基本概念"
keywords: .NET, .NET Core
author: stevehoag
ms.author: shoag
manager: wpickett
ms.date: 08/16/2016
ms.topic: article
ms.prod: .net-core
ms.technology: .net-core-technologies
ms.devlang: dotnet
ms.assetid: 9d5fce64-95a4-4609-8eee-b0ac70078cdb
translationtype: Human Translation
ms.sourcegitcommit: b20713600d7c3ddc31be5885733a1e8910ede8c6
ms.openlocfilehash: 78a2d593329f0703c71df2462cfea30b02adff85

---

# <a name="fundamentals-of-garbage-collection"></a>記憶體回收的基本概念

在 Common Language Runtime (CLR) 中，記憶體回收行程會當做自動記憶體管理員。 它提供了下列優點：

* 可讓您開發應用程式，而不需要釋放記憶體。 

* 有效率地在 Managed 堆積上配置物件。 

* 回收不再使用的物件、清除其記憶體，並且讓記憶體可供未來的配置使用。 Managed 物件在開始時會自動取得乾淨的內容，因此其建構函式不需要初始化每個資料欄位。

* 確保某個物件無法使用另一個物件的內容，藉以提供記憶體安全性。


本主題描述記憶體回收的核心概念。 它包含以下各節：

* [記憶體的基本概念](#fundamentals-of-memory)

* [回收記憶體的條件](#conditions-for-a-garbage-collection)

* [Managed 堆積](#the-managed-heap)

* [世代](#generations)

* [回收記憶體時會執行的作業](#what-happens-during-a-garbage-collection)

* [操作 Unmanaged 資源](#manipulating-unmanaged-resources)

## <a name="fundamentals-of-memory"></a>記憶體的基本概念

下列清單摘要說明重要的 CLR 記憶體概念。

* 每個處理序都有各自獨立的虛擬位址空間。 同一部電腦上的所有處理序會共用相同的實體記憶體，並且共用分頁檔 (如果有的話)。

* 根據預設，在 32 位元電腦上，每個處理序都有 2 GB 使用者模式虛擬位址空間。

* 身為應用程式開發人員，您只會處理虛擬位址空間，絕不會直接操作實體記憶體。 記憶體回收行程會在 Managed 堆積上自動配置和釋出虛擬記憶體。

* 虛擬記憶體可以有三種狀態： 

    * 可用。 記憶體區塊沒有任何參考，可進行配置。

    * 保留的。 記憶體區塊可供您使用，但是無法用於任何其他配置要求。 不過，在此記憶體區塊認可之前，您無法將資料儲存到其中。 

    * 已認可。 記憶體區塊會指派給實體儲存區。

* 虛擬位址空間可能會分成片段。 這表示，位址空間中有可用的區塊，也稱為可用的洞 (Hole)。 要求虛擬記憶體配置時，虛擬記憶體管理程式必須找到大小可滿足配置要求的單一可用區塊。 即使您擁有 2GB 可用空間，要求 2GB 的配置仍然不會成功，除非該空間全都在單一位址區塊中。

* 如果您用盡保留用的虛擬位址空間或認可用的實體空間，則可能會用盡記憶體。

即使實體記憶體壓力 (也就是實體記憶體的需求) 不高，仍會使用您的分頁檔。 您的實體記憶體第一次面臨壓力高的情況時，作業系統必須釋出實體記憶體的空間來儲存資料，而且它會將實體記憶體中的部分資料備份到分頁檔。 該資料只會在需要時進行分頁，因此可能在實體記憶體壓力相當低的情況下發生分頁。

## <a name="conditions-for-a-garbage-collection"></a>記憶體回收的條件

當下列其中一個條件成立時，就會進行記憶體回收：

* 系統的實體記憶體不足。

* 由 Managed 堆積上之已配置物件所使用的記憶體超過可接受的臨界值。 這個臨界值會在處理序執行時持續調整。

* 已呼叫 [GC.Collect](xref:System.GC.Collect) 方法。 在大多數的情況下，您不需要呼叫這個方法，因為記憶體回收行程會持續執行。 這個方法主要用於獨特的情況和測試。 

## <a name="the-managed-heap"></a>Managed 堆積

CLR 初始化記憶體回收行程之後，記憶體回收行程就會配置用來儲存和管理物件的記憶體區段。 這個記憶體稱為 Managed 堆積，與作業系統中的原生堆積相反。 

每個 Managed 處理序都有一個 Managed 堆積。 處理序中的所有執行緒都會對相同堆積上的物件配置記憶體。

> [!IMPORTANT]
> 記憶體回收行程所配置的區段大小是依實作而定，有可能在任何時間，包括在定期更新時做變更。 您的應用程式永遠都不應該對相關或根據特定區段的大小做出假設，也不應嘗試設定區段配置的可用記憶體數量。 
 
配置在堆積上的物件越少，記憶體回收行程必須進行的工作就越少。 當您配置物件時，請勿使用超出需求的進位值，例如，當您只需要 15 個位元組時，卻配置 32 個位元組的陣列。 

觸發記憶體回收時，記憶體回收行程就會回收無作用物件所佔據的記憶體。 回收處理序會壓縮使用中物件，讓它們集合在一起，並且移除無作用物件，因而讓堆積更小。 這樣可確保一起配置的物件會在 Managed 堆積上集中，以便保持其區域性。

記憶體回收的干擾程度 (頻率和持續期間) 是 Managed 堆積上之配置量和未被回收記憶體數量的結果。 

您可以將此堆積視為兩個堆積的累積：大型物件堆積和小型物件堆積。 

大型物件堆積包含 85,000 個位元組以上的超大型物件。 大型物件堆積上的物件通常是陣列。 超大型的執行個體物件非常罕見。 

## <a name="generations"></a>層代

堆積會組織成層代，因此它可以處理存留較久和存留較短的物件。 記憶體回收主要與存留較短物件的回收一起進行，而這些物件通常只佔據堆積的一小部分。 堆積上的物件有三個層代： 

* **世代 0。** 這是最新的層代而且包含存留較短的物件。 存留較短的物件範例是暫存變數。 記憶體回收最常在這個層代中進行。 

  新配置的物件會構成新的物件層代而且隱含成為層代 0 回收，但如果它們是大型物件，就會移至層代 2 回收中的大型物件堆積。

  大部分物件都會在層代 0 的記憶體回收中回收，而且不會存留至下一個層代。 

* **世代 1。** 這個層代包含存留較短的物件，而且當做存留較短物件與存留較長物件之間的緩衝區。 

* **世代 2。** 這個層代包含存留較長的物件。 存留較長的物件範例是伺服器應用程式中包含處理序持續期間存留之靜態資料的物件。

當條件許可時，記憶體回收會針對特定層代進行。 回收層代是指回收該層代中的物件及其所有較新的層代。 層代 2 記憶體回收也稱為完整記憶體回收，因為它會回收所有層代中的所有物件 (亦即，Managed 堆積中的所有物件)。

### <a name="survival-and-promotions"></a>未回收和提升

沒有在記憶體回收中回收的物件稱為未回收物件，而且會提升至下一個層代。 在層代 0 記憶體回收中未被回收的物件會提升至層代 1、在層代 1 記憶體回收中未被回收的物件會提升至層代 2，而在層代 2 記憶體回收中未被回收的物件則保留在層代 2 中。

當記憶體回收行程偵測出某個層代的未回收率很高時，它就會增加該層代的配置臨界值，因此下一次回收就會取得大量的回收記憶體。 CLR 會持續在兩個優先權之間取得平衡：不讓應用程式的工作集變得太大，而且不讓記憶體回收花費太多時間。

### <a name="ephemeral-generations-and-segments"></a>暫時層代和區段

因為層代 0 和 1 中的物件存留較短，所以這些層代稱為暫時層代。 

暫時層代必須配置於稱為暫時區段的記憶體區段中。 記憶體回收行程所取得的每個新區段都會成為新的暫時區段，而且包含在層代 0 記憶體回收中未被回收的物件。 舊的暫時區段會成為新的層代 2 區段。 


暫時區段可能會包括層代 2 物件。 層代 2 物件可以使用多個區段 (取決於處理序所需而且記憶體允許的數目)。 

暫時記憶體回收中釋放記憶體的數量會限制為暫時區段的大小。 所釋放的記憶體數量會與無作用物件所佔據的空間成正比。

## <a name="what-happens-during-a-garbage-collection"></a>記憶體回收期間進行的作業

記憶體回收具有下列階段： 

* 標記階段：尋找和建立所有使用中物件的清單。

* 重新配置階段：更新即將壓縮之物件的參考。 

* 壓縮階段：回收無作用物件所佔據的空間並壓縮未被回收的物件。 壓縮階段會將記憶體回收中未被回收的物件移至區段的較舊端。 

因為層代 2 回收可能會佔據多個區段，所以提升至層代 2 的物件可能會移至較舊區段。 層代 1 和層代 2 的未回收物件都可能會移至不同的區段，因為它們都會被提升至層代 2。 

正常情況下，大型物件堆積不會壓縮，因為複製大型物件會帶來效能損失。 不過，您可以視需要使用 [GCSettings.LargeObjectHeapCompactionMode](xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode) 屬性壓縮大型物件堆積。 

記憶體回收行程會使用下列資訊來判斷物件是否使用中： 

* **堆疊根目錄。** Just-in-Time (JIT) 編譯器和堆疊查核器所提供的堆疊變數。

* **記憶體回收控制代碼。** 會指向 Managed 物件，而且可由使用者程式碼或 Common Language Runtime 配置的控制代碼。

* **靜態資料。** 應用程式定義域中可能參考其他物件的靜態物件。 每個應用程式定義域都會追蹤其靜態物件。

記憶體回收開始之前，所有 Managed 執行緒都會暫停，但觸發記憶體回收的執行緒除外。

下圖顯示觸發記憶體回收且造成其他執行緒暫停的執行緒。

![當執行緒觸發記憶體回收時](./media/fundamentals/393001.png)

觸發記憶體回收的執行緒

## <a name="manipulating-unmanaged-resources"></a>管理 Unmanaged 資源

如果您的 Managed 物件使用其原生檔案控制代碼參考 Unmanaged 物件，則您必須明確釋放這些 Unmanaged 物件，因為記憶體回收行程只會追蹤 Managed 堆積上的記憶體。

Managed 物件的使用者無法處置此物件所使用的原生資源。 若要執行清除，您可以讓 Managed 物件變成可最終處理物件。 最終處理是由您在物件不再使用時所執行的清除動作組成。 當您的 Managed 物件無作用時，它就會執行其完成項方法中指定的清除動作。

當系統發現某個可最終處理物件無作用時，該物件的完成項就會放入佇列中，以便執行其清除動作，但是物件本身會提升至下一個層代。 因此，您必須等候直到在該層代上進行的下一次記憶體回收 (不一定是下一次記憶體回收)，以便判斷此物件是否已經回收。

## <a name="see-also"></a>請參閱

[.NET 中的記憶體回收](gc.md)



<!--HONumber=Nov16_HO3-->


