---
title: "Docker 應用程式的外部迴圈 DevOps 工作流程中的步驟"
description: "Microsoft 平台和工具與 Docker 容器化應用程式生命週期"
keywords: "Docker, 微服務, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.openlocfilehash: 070d174cde9e80f542865f5617b1c702a07a8018
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/21/2017
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="86c34-104">Docker 應用程式的外部迴圈 DevOps 工作流程中的步驟</span><span class="sxs-lookup"><span data-stu-id="86c34-104">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="86c34-105">圖 5-1 提供端對端的描述組成 DevOps 外部迴圈的工作流程的步驟。</span><span class="sxs-lookup"><span data-stu-id="86c34-105">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span>

![](./media/image1.png)

<span data-ttu-id="86c34-106">Docker 應用程式與 Microsoft 工具，如圖 5-1: DevOps 外部迴圈工作流程</span><span class="sxs-lookup"><span data-stu-id="86c34-106">Figure 5-1: DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="86c34-107">現在，讓我們來檢查每個步驟更詳細地。</span><span class="sxs-lookup"><span data-stu-id="86c34-107">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="86c34-108">步驟 1： 內部迴圈的開發工作流程</span><span class="sxs-lookup"><span data-stu-id="86c34-108">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="86c34-109">此步驟中會詳細說明第 4 章，但要複習，以下是外部迴圈開始處，開發人員將推送程式碼加入原始檔控制管理系統，（例如 Git) 起始 CI 管線動作的時間。</span><span class="sxs-lookup"><span data-stu-id="86c34-109">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-visual-studio-team-services-and-git"></a><span data-ttu-id="86c34-110">步驟 2： 原始程式碼控制整合性和管理 Visual Studio Team Services 與 Git</span><span class="sxs-lookup"><span data-stu-id="86c34-110">Step 2: Source-Code Control integration and management with Visual Studio Team Services and Git</span></span>

<span data-ttu-id="86c34-111">在此步驟中，您需要有版本控制系統來蒐集合併來自不同的開發人員在小組中的所有程式碼的版本。</span><span class="sxs-lookup"><span data-stu-id="86c34-111">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="86c34-112">即使原始程式碼控制 (SCC) 和原始碼管理可能看起來是第二個本質循環至大部分的開發人員，DevOps 生活中建立 Docker 應用程式時，務必強調您必須提交與應用程式的 Docker 映像直接到全域 Docker 登錄中 （例如 Azure 容器登錄中或 Docker Hub） 從開發人員的電腦。</span><span class="sxs-lookup"><span data-stu-id="86c34-112">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it is critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="86c34-113">相反地，發行和部署到生產環境的 Docker 映像必須全域建置或根據您的原始程式碼儲存機制 （例如 Git) CI 管線中建立單獨針對要整合的原始程式碼。</span><span class="sxs-lookup"><span data-stu-id="86c34-113">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that is being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="86c34-114">測試自己的機器中時，應該只由開發人員使用本機開發人員本身所產生的映像。</span><span class="sxs-lookup"><span data-stu-id="86c34-114">The local images generated by the developers themselves should be used just by the developers when testing within their own machines.</span></span> <span data-ttu-id="86c34-115">這是必須要有 DevOps 管線從 SCC 程式碼啟動的原因。</span><span class="sxs-lookup"><span data-stu-id="86c34-115">This is why it is critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="86c34-116">Visual Studio Team Services 和 Team Foundation Server 支援 Git 和 Team Foundation 版本控制。</span><span class="sxs-lookup"><span data-stu-id="86c34-116">Visual Studio Team Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="86c34-117">您可以選擇兩者之間，然後將它用於端對端 Microsoft 體驗。</span><span class="sxs-lookup"><span data-stu-id="86c34-117">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="86c34-118">不過，您也可以管理您的程式碼在外部儲存機制中 （如 GitHub、 內部 Git 儲存機制中或 Subversion） 仍然可以連接到它，並取得程式碼做為起點 DevOps CI 管線。</span><span class="sxs-lookup"><span data-stu-id="86c34-118">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-visual-studio-team-services-and-docker"></a><span data-ttu-id="86c34-119">步驟 3： 組建、 CI，整合和測試 Visual Studio Team Services 和 Docker</span><span class="sxs-lookup"><span data-stu-id="86c34-119">Step 3: Build, CI, Integrate, and Test with Visual Studio Team Services and Docker</span></span>

<span data-ttu-id="86c34-120">CI 已經成為現代化軟體測試及傳遞的標準。</span><span class="sxs-lookup"><span data-stu-id="86c34-120">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="86c34-121">Docker 方案會維持清楚的開發和作業團隊之間的重要性分離。</span><span class="sxs-lookup"><span data-stu-id="86c34-121">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="86c34-122">Docker 映像的不變性可確保可重複的部署之間什麼已開發、 測試透過 CI，並在生產中執行。</span><span class="sxs-lookup"><span data-stu-id="86c34-122">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="86c34-123">Docker 引擎跨 developer 膝上型電腦部署和測試基礎結構使其成為容器可攜式的環境。</span><span class="sxs-lookup"><span data-stu-id="86c34-123">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="86c34-124">此時，以正確的程式碼，提交進行版本控制系統之後，您需要*組建服務*拾取該程式碼，並執行全域的組建和測試。</span><span class="sxs-lookup"><span data-stu-id="86c34-124">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="86c34-125">這個步驟 （CI，建置、 測試） 的內部工作流程是需建構的 CI 管線，您的組建伺服器 (Visual Studio Team Services)，Docker 引擎及 Docker 登錄所組成 （Git 等），您的程式碼儲存機制。</span><span class="sxs-lookup"><span data-stu-id="86c34-125">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Visual Studio Team Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="86c34-126">您可以使用 Visual Studio Team Services 做為基礎建置您的應用程式和設定您的 CI 管線，以及發行內建的 「 成品 」 到 「 成品儲存機制，「 的下一個步驟中說明。</span><span class="sxs-lookup"><span data-stu-id="86c34-126">You can use Visual Studio Team Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="86c34-127">部署，也就是 「 最終成品 」 使用 Docker 時部署會與您的應用程式或服務的 Docker 映像內嵌在它們。</span><span class="sxs-lookup"><span data-stu-id="86c34-127">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="86c34-128">這些映像會推入或發行到*Docker 登錄*（您可以在 Azure 容器登錄中或公開的一個像 Docker Hub 登錄，常用於正式的基底映像等私用儲存機制）。</span><span class="sxs-lookup"><span data-stu-id="86c34-128">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="86c34-129">以下是基本概念： 的 CI 管線將會排除-關閉依據認可到 SCC Git 等儲存機制。</span><span class="sxs-lookup"><span data-stu-id="86c34-129">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="86c34-130">圖 5-2 的說明，認可會造成執行 Docker 容器中的建置工作，並在該作業的成功完成時，將 Docker 映像推送至 Docker 登錄，Visual Studio Team Services。</span><span class="sxs-lookup"><span data-stu-id="86c34-130">The commit will cause Visual Studio Team Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="86c34-131">圖 5-2： 所需的步驟 CI</span><span class="sxs-lookup"><span data-stu-id="86c34-131">Figure 5-2: The steps involved in CI</span></span>

<span data-ttu-id="86c34-132">以下是使用 Docker 和 Visual Studio Team Services 的基本 CI 工作流程步驟：</span><span class="sxs-lookup"><span data-stu-id="86c34-132">Here are the basic CI workflow steps with Docker and Visual Studio Team Services:</span></span>

1.  <span data-ttu-id="86c34-133">開發人員將認可推送到 SCC 儲存機制 （Git/Visual Studio Team Services、 GitHub）。</span><span class="sxs-lookup"><span data-stu-id="86c34-133">The developer pushes a commit to an SCC repository (Git/Visual Studio Team Services, GitHub, etc.).</span></span>

2.  <span data-ttu-id="86c34-134">如果您使用 Visual Studio Team Services 或 Git，CI 為內建的這表示很簡單，只選取 Visual Studio Team Services 中的 核取方塊。</span><span class="sxs-lookup"><span data-stu-id="86c34-134">If you're using Visual Studio Team Services or Git, CI is built in, which means that it is as simple as selecting a check box in Visual Studio Team Services.</span></span> <span data-ttu-id="86c34-135">如果您使用外部 （例如 GitHub) SCC *webhook*會通知更新的 Visual Studio Team Services 或推送至 Git/GitHub。</span><span class="sxs-lookup"><span data-stu-id="86c34-135">If you're using an external SCC (like GitHub), a *webhook* will notify Visual Studio Team Services of the update or push to Git/GitHub.</span></span>

3.  <span data-ttu-id="86c34-136">Visual Studio Team Services 中提取 SCC 存放庫，包括 DockerFile 描述映像，以及將應用程式和測試程式碼。</span><span class="sxs-lookup"><span data-stu-id="86c34-136">Visual Studio Team Services pulls the SCC repository, including the DockerFile describing the image as well as the application and test code.</span></span>

4.  <span data-ttu-id="86c34-137">Visual Studio Team Services 建置 Docker 映像，並標示標上組建編號。</span><span class="sxs-lookup"><span data-stu-id="86c34-137">Visual Studio Team Services builds a Docker image and labels it with a build number.</span></span>

5.  <span data-ttu-id="86c34-138">Visual Studio Team Services Docker 容器內佈建 Docker 主機時，會具現化，並執行適當的測試。</span><span class="sxs-lookup"><span data-stu-id="86c34-138">Visual Studio Team Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6.  <span data-ttu-id="86c34-139">測試都成功，如果影像第一次嚴格的有意義的名稱，讓您知道它是 blessed 的組建 (例如"/ 1.0.0 」 或任何其他標籤)，然後推送至 Docker 登錄 （Docker Hub、 Azure 容器登錄中、 DTR 等等） 的 和</span><span class="sxs-lookup"><span data-stu-id="86c34-139">If the tests are successful, the image is first relabeled to a meaningful name so that you know it is a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-visual-studio-team-services-and-the-docker-extension-for-visual-studio-team-services"></a><span data-ttu-id="86c34-140">為 Visual Studio Team Services 實作 CI 管線，與 Visual Studio Team Services 和 Docker 擴充功能</span><span class="sxs-lookup"><span data-stu-id="86c34-140">Implementing the CI pipeline with Visual Studio Team Services and the Docker extension for Visual Studio Team Services</span></span>

<span data-ttu-id="86c34-141">[Visual Studio Team Services Docker 擴充功能](https://aka.ms/vstsdockerextension)將工作加入您與您可以建立 Docker 映像、 將 Docker images 推送到已驗證的 Docker 登錄、 執行 Docker 映像，或執行其他作業所提供的 CI 管線Docker CLI。</span><span class="sxs-lookup"><span data-stu-id="86c34-141">The [Visual Studio Team Services Docker extension](https://aka.ms/vstsdockerextension) adds a task to your CI pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="86c34-142">它也會將 Docker Compose 工作可讓您建置、 推入，並執行 multicontainer Docker 應用程式，或執行 Docker 撰寫 CLI 所提供的其他作業，如圖 5-3 所示。</span><span class="sxs-lookup"><span data-stu-id="86c34-142">It also adds a Docker Compose task that you can use to build, push, and run multicontainer Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![](./media/image3.png)

<span data-ttu-id="86c34-143">圖 5-3: Docker CI 中的管線 Visual Studio Team Services</span><span class="sxs-lookup"><span data-stu-id="86c34-143">Figure 5-3: The Docker CI pipeline in Visual Studio Team Services</span></span>

<span data-ttu-id="86c34-144">Docker 主機和容器或映像 Docker 擴充功能可以使用服務端點。</span><span class="sxs-lookup"><span data-stu-id="86c34-144">The Docker extension can use service endpoints for Docker hosts and for container or image registries.</span></span> <span data-ttu-id="86c34-145">工作預設都會使用本機的 Docker 主機的話 （這目前需要自訂的 Visual Studio Team Services 代理程式）。否則，它們需要您提供的 Docker 主機連接。</span><span class="sxs-lookup"><span data-stu-id="86c34-145">The tasks default to using a local Docker host if available (this currently requires a custom Visual Studio Team Services agent); otherwise, they require that you provide a Docker host connection.</span></span> <span data-ttu-id="86c34-146">相依於 Docker 登錄，例如推入映像，將驗證的動作需要您提供 Docker 登錄連線。</span><span class="sxs-lookup"><span data-stu-id="86c34-146">Actions that depend on being authenticated with a Docker registry, such as pushing an image, require that you provide a Docker registry connection.</span></span>

<span data-ttu-id="86c34-147">Visual Studio Team Services Docker 擴充功能會在您的 Visual Studio Team Services 帳戶中安裝下列元件：</span><span class="sxs-lookup"><span data-stu-id="86c34-147">The Visual Studio Team Services Docker extension installs the following components in your Visual Studio Team Services account:</span></span>

-   <span data-ttu-id="86c34-148">連接到 Docker 登錄服務端點</span><span class="sxs-lookup"><span data-stu-id="86c34-148">A service endpoint for connecting to a Docker registry</span></span>

-   <span data-ttu-id="86c34-149">服務端點連線至 Docker 容器主機</span><span class="sxs-lookup"><span data-stu-id="86c34-149">A service endpoint for connecting to a Docker Container Host</span></span>

-   <span data-ttu-id="86c34-150">Docker 來執行下列工作：</span><span class="sxs-lookup"><span data-stu-id="86c34-150">A Docker task to do the following:</span></span>

-   <span data-ttu-id="86c34-151">建置的映像</span><span class="sxs-lookup"><span data-stu-id="86c34-151">Build an image</span></span>

-   <span data-ttu-id="86c34-152">將映像或儲存機制發送到登錄</span><span class="sxs-lookup"><span data-stu-id="86c34-152">Push an image or a repository to a registry</span></span>

-   <span data-ttu-id="86c34-153">在容器中執行映像</span><span class="sxs-lookup"><span data-stu-id="86c34-153">Run an image in a container</span></span>

-   <span data-ttu-id="86c34-154">執行 Docker 命令</span><span class="sxs-lookup"><span data-stu-id="86c34-154">Run a Docker command</span></span>

-   <span data-ttu-id="86c34-155">Docker Compose 工作執行 Docker Compose 命令</span><span class="sxs-lookup"><span data-stu-id="86c34-155">A Docker Compose task to run a Docker Compose command</span></span>

<span data-ttu-id="86c34-156">這些 Visual Studio Team Services 工作後，組建 Linux Docker 主機/佈建 VM 在 Azure 中並您慣用的 Docker 登錄 （Azure 容器登錄中，Docker Hub、 私用 Docker DTR 或任何其他 Docker 登錄），您可以組合您的 Docker CI 管線中非常一致的方式。</span><span class="sxs-lookup"><span data-stu-id="86c34-156">With these Visual Studio Team Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="86c34-157">***需求：***</span><span class="sxs-lookup"><span data-stu-id="86c34-157">***Requirements:***</span></span>

-   <span data-ttu-id="86c34-158">Visual Studio Team Services，或在內部部署安裝，Team Foundation Server 2015 Update 3 或更新版本。</span><span class="sxs-lookup"><span data-stu-id="86c34-158">Visual Studio Team Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

-   <span data-ttu-id="86c34-159">Visual Studio Team Services 代理程式具有 Docker 二進位檔。</span><span class="sxs-lookup"><span data-stu-id="86c34-159">A Visual Studio Team Services agent that has the Docker binaries.</span></span>

<span data-ttu-id="86c34-160">若要建立下列其中一種簡單的方法是使用 Docker 執行 Visual Studio Team Services 代理程式的 Docker 映像為基礎的容器。</span><span class="sxs-lookup"><span data-stu-id="86c34-160">An easy way to create one of these is to use Docker to run a container based on the Visual Studio Team Services agent Docker image.</span></span>

<span data-ttu-id="86c34-161">**進一歩** 讀取組合 Visual Studio Team Services Docker CI 管線，以及若要檢視的逐步解說，請造訪下列網站：</span><span class="sxs-lookup"><span data-stu-id="86c34-161">**More info** To read more about assembling a Visual Studio Team Services Docker CI pipeline and to view walkthroughs, visit the following sites:</span></span>

<span data-ttu-id="86c34-162">以 Docker 容器中執行 Visual Studio Team Services 代理程式： [https://hub.docker.com/r/ \ microsoft/vsts 代理 /](https://hub.docker.com/r/microsoft/vsts-agent/)</span><span class="sxs-lookup"><span data-stu-id="86c34-162">Running a Visual Studio Team Services agent as a Docker container: [https://hub.docker.com/r/\ microsoft/vsts-agent/](https://hub.docker.com/r/microsoft/vsts-agent/)</span></span>

<span data-ttu-id="86c34-163">VSTS Docker 擴充功能： <https://aka.ms/vstsdockerextension></span><span class="sxs-lookup"><span data-stu-id="86c34-163">VSTS Docker extension: <https://aka.ms/vstsdockerextension></span></span>

<span data-ttu-id="86c34-164">建立具有 Visual Studio Team Services 的.NET Core Linux Docker images: <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span><span class="sxs-lookup"><span data-stu-id="86c34-164">Building .NET Core Linux Docker images with Visual Studio Team Services: <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span></span>

<span data-ttu-id="86c34-165">建立 Linux 型 Visual Studio Team 服務使用建立機器 Docker 的支援： <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span><span class="sxs-lookup"><span data-stu-id="86c34-165">Building a Linux-based Visual Studio Team Service build machine with Docker support: <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span></span>

### <a name="integrate-test-and-validate-multicontainer-docker-applications"></a><span data-ttu-id="86c34-166">整合、 測試及驗證 multicontainer Docker 應用程式</span><span class="sxs-lookup"><span data-stu-id="86c34-166">Integrate, test, and validate multicontainer Docker applications</span></span>

<span data-ttu-id="86c34-167">一般而言，大部分的 Docker 應用程式所組成的多個容器，而不是單一的容器。</span><span class="sxs-lookup"><span data-stu-id="86c34-167">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="86c34-168">例如，microservices 導向應用程式會對每個微服務一個容器。</span><span class="sxs-lookup"><span data-stu-id="86c34-168">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="86c34-169">但是，即使沒有嚴格遵守 microservices 方法模式，是很可能您的 Docker 應用程式會組成多個容器或服務。</span><span class="sxs-lookup"><span data-stu-id="86c34-169">But, even without strictly following the microservices approach patterns, it is very probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="86c34-170">因此，在建置之後 CI 管線中的應用程式容器，您也需要部署、 整合和測試與它的所有容器中整合的 Docker 主機，或甚至您容器要測試叢集的整體應用程式散發。</span><span class="sxs-lookup"><span data-stu-id="86c34-170">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="86c34-171">如果您使用單一主機，您可以使用 Docker 命令，例如 docker-撰寫建置和部署來測試及驗證單一 VM 的 Docker 環境相關的容器。</span><span class="sxs-lookup"><span data-stu-id="86c34-171">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="86c34-172">但是，如果您使用像是 DC/OS、 Kubernetes，或 Docker Swarm orchestrator 叢集，您要部署您的容器，透過不同的機制或 orchestrator，根據您所選叢集/排程器。</span><span class="sxs-lookup"><span data-stu-id="86c34-172">But, if you are working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="86c34-173">以下是幾種類型的測試，您可以針對 Docker 容器執行：</span><span class="sxs-lookup"><span data-stu-id="86c34-173">Following are several types of tests that you can run against Docker containers:</span></span>

-   <span data-ttu-id="86c34-174">Docker 容器的單元測試</span><span class="sxs-lookup"><span data-stu-id="86c34-174">Unit tests for Docker containers</span></span>

-   <span data-ttu-id="86c34-175">相互關聯的應用程式或 microservices 測試群組</span><span class="sxs-lookup"><span data-stu-id="86c34-175">Testing groups of interrelated applications or microservices</span></span>

-   <span data-ttu-id="86c34-176">在生產環境和"canary 」 版本中的測試</span><span class="sxs-lookup"><span data-stu-id="86c34-176">Test in production and "canary" releases</span></span>

<span data-ttu-id="86c34-177">重點是當執行整合和功能測試，您必須執行這些測試的容器外。</span><span class="sxs-lookup"><span data-stu-id="86c34-177">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="86c34-178">測試不會定義並因為容器都根據應該與您要部署到實際執行環境的完全相同的靜態影像，您要部署，在容器內執行。</span><span class="sxs-lookup"><span data-stu-id="86c34-178">Tests must not be defined and run within the containers that you are deploying, because the containers are based on static images that should be exactly like those that you will be deploying into production.</span></span>

<span data-ttu-id="86c34-179">測試更進階的案例，例如測試數個群集 （測試叢集、 臨時的叢集，以及實際執行叢集） 時非常可行的選項是將映像發佈到登錄，以測試不同叢集中。</span><span class="sxs-lookup"><span data-stu-id="86c34-179">A very feasible option when testing more advanced scenarios like testing several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry to test in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="86c34-180">推送到全域 Docker 登錄的自訂應用程式的 Docker 映像</span><span class="sxs-lookup"><span data-stu-id="86c34-180">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="86c34-181">Docker 映像已經測試並驗證之後，您會想要標記，並將它們發行至 Docker 登錄。</span><span class="sxs-lookup"><span data-stu-id="86c34-181">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="86c34-182">Docker 登錄在 Docker 應用程式生命週期中是一項重要，因為它是您在其中儲存您的自訂測試 （也稱為 「 blessed 影像 」） 可以部署到品管及生產環境的中央位置。</span><span class="sxs-lookup"><span data-stu-id="86c34-182">The Docker registry is a critical piece in the Docker application life cycle because it is the central place where you store your custom test (aka "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="86c34-183">類似於儲存在您 SCC 的儲存機制 （Git 等） 的應用程式程式碼的程式 」 事實來源 」 的方式，Docker 登錄是您 「 事實來源 」 二進位應用程式或位元 QA 或生產環境部署。</span><span class="sxs-lookup"><span data-stu-id="86c34-183">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="86c34-184">一般而言，您可能想要具有您自訂映像的私用儲存機制中的私用儲存機制 Azure 容器登錄中或 Docker Trusted Registry 像在內部部署登錄或公用雲端登錄中，以限制的存取權 （例如Docker Hub)，不過在這個最後一個的情況下您的程式碼不是開放原始碼，如果必須信任廠商的安全性。</span><span class="sxs-lookup"><span data-stu-id="86c34-184">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="86c34-185">無論如何，依據您執行這項操作的方法很類似並且為最後根據 docker push 命令，如圖 5-4 所示。</span><span class="sxs-lookup"><span data-stu-id="86c34-185">Either way, the method by which you do this is pretty similar and ultimately based on the docker push command, as depicted in Figure 5-4.</span></span>

![](./media/image4.png)

<span data-ttu-id="86c34-186">圖 5-4： 發行至 Docker 登錄的自訂映像</span><span class="sxs-lookup"><span data-stu-id="86c34-186">Figure 5-4: Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="86c34-187">有多個供應項目，例如 Azure 容器登錄中、 Amazon Web Services 容器登錄中、 Google 容器登錄中、 爾斯頓碼頭登錄和等等的雲端廠商的 Docker 所登錄。</span><span class="sxs-lookup"><span data-stu-id="86c34-187">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="86c34-188">使用 Visual Studio Team Services Docker 延伸模組，您可以推送服務映像 docker compose.yml 檔，具有多個標記，已驗證的 Docker 登錄 （例如 Azure 容器登錄中），所定義的一組圖 5-5 所示。</span><span class="sxs-lookup"><span data-stu-id="86c34-188">Using the Visual Studio Team Services Docker extension, you can push a set of service images defined by a docker-compose.yml file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![](./media/image5.png)

<span data-ttu-id="86c34-189">圖 5-5： 使用 Visual Studio Team Services 來發行至 Docker 登錄的自訂映像</span><span class="sxs-lookup"><span data-stu-id="86c34-189">Figure 5-5: Using Visual Studio Team Services to publishing custom images to a Docker Registry</span></span>

<span data-ttu-id="86c34-190">**進一歩** 要閱讀更多有關 Visual Studio Team Services 的 Docker 擴充功能，請移至<https://aka.ms/vstsdockerextension>。</span><span class="sxs-lookup"><span data-stu-id="86c34-190">**More info** To read more about the Docker extension for Visual Studio Team Services, go to <https://aka.ms/vstsdockerextension>.</span></span> <span data-ttu-id="86c34-191">若要深入了解 Azure 容器登錄中，移至<https://aka.ms/azurecontainerregistry>。</span><span class="sxs-lookup"><span data-stu-id="86c34-191">To learn more about Azure Container Registry, go to <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="86c34-192">步驟 4: CD，部署</span><span class="sxs-lookup"><span data-stu-id="86c34-192">Step 4: CD, Deploy</span></span>

<span data-ttu-id="86c34-193">Docker 映像的不變性可確保可重複的部署使用什麼已開發、 測試透過 CI，並在生產中執行。</span><span class="sxs-lookup"><span data-stu-id="86c34-193">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="86c34-194">Docker 登錄 （私人或公用） 中發行的應用程式 Docker 映像之後，您就可以將它們部署到您可能需要數個環境 (生產環境中，不必在 QA、 暫存、 等等) 從您的 CD 管線，使用 Visual Studio Team Services管線工作或 Visual Studio Team Services Release Management。</span><span class="sxs-lookup"><span data-stu-id="86c34-194">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Visual Studio Team Services pipeline tasks or Visual Studio Team Services Release Management.</span></span>

<span data-ttu-id="86c34-195">不過，此時它會取決於您要部署哪種 Docker 應用程式。</span><span class="sxs-lookup"><span data-stu-id="86c34-195">However, at this point it depends on what kind of Docker application you are deploying.</span></span> <span data-ttu-id="86c34-196">部署簡單的應用程式 （從撰寫與部署觀點來看） 類似龐大組成少數的容器或服務應用程式及部署幾個伺服器或 Vm 是非常不同部署更複雜的應用程式，例如具有超功能 microservices 導向的應用程式。</span><span class="sxs-lookup"><span data-stu-id="86c34-196">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is very different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="86c34-197">下列各節會說明這兩種情況。</span><span class="sxs-lookup"><span data-stu-id="86c34-197">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="86c34-198">部署由多個 Docker 環境 Docker 應用程式</span><span class="sxs-lookup"><span data-stu-id="86c34-198">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="86c34-199">讓我們來查看較不複雜的案例： 簡單 Docker 主機 （Vm 或伺服器） 單一的環境或多個環境中部署 (QA、 預備及生產)。</span><span class="sxs-lookup"><span data-stu-id="86c34-199">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="86c34-200">在此案例中，在內部 CD 管線可以使用 docker-如圖 5-6 所述，撰寫 （從 Visual Studio Team Services 部署工作） 來部署容器或服務，其相關設定 Docker 應用程式。</span><span class="sxs-lookup"><span data-stu-id="86c34-200">In this scenario, internally your CD pipeline can use docker-compose (from your Visual Studio Team Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![](./media/image6.png)

<span data-ttu-id="86c34-201">圖 5-6： 部署簡單的 Docker 主機環境登錄應用程式容器</span><span class="sxs-lookup"><span data-stu-id="86c34-201">Figure 5-6: Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="86c34-202">圖 5-7 中，反白顯示如何連接建置 CI 到 QA/測試環境，Visual Studio Team Services 透過 Docker Compose 在 新增工作對話方塊，即可。</span><span class="sxs-lookup"><span data-stu-id="86c34-202">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Visual Studio Team Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="86c34-203">不過，當部署至預備環境或生產環境，您會通常使用處理多個環境版本管理功能 (例如 QA，預備及生產)。</span><span class="sxs-lookup"><span data-stu-id="86c34-203">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="86c34-204">如果您要部署到單一的 Docker 主機，它使用 Visual Studio Team Services"Docker Compose 」 工作 (這叫用 docker-向上命令實際上撰寫)。</span><span class="sxs-lookup"><span data-stu-id="86c34-204">If you're deploying to single Docker hosts, it is using the Visual Studio Team Services "Docker Compose" task (which is invoking the docker-compose up command under the hood).</span></span> <span data-ttu-id="86c34-205">如果您要部署至 Azure 容器服務，它會使用 Docker 部署工作，在下節中所述。</span><span class="sxs-lookup"><span data-stu-id="86c34-205">If you're deploying to Azure Container Service, it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![](./media/image7.png)

<span data-ttu-id="86c34-206">圖 5-7： 在 Visual Studio Team Services 管線中加入 Docker Compose 工作</span><span class="sxs-lookup"><span data-stu-id="86c34-206">Figure 5-7: Adding a Docker Compose task in a Visual Studio Team Services pipeline</span></span>

<span data-ttu-id="86c34-207">當您在 Visual Studio Team Services 中建立發行時，它會採用一組輸入成品。</span><span class="sxs-lookup"><span data-stu-id="86c34-207">When you create a release in Visual Studio Team Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="86c34-208">這些被要跨多個環境是不可變的存留期中的版本。</span><span class="sxs-lookup"><span data-stu-id="86c34-208">These are intended to be immutable throughout the lifetime of the release across multiple environments.</span></span> <span data-ttu-id="86c34-209">當您引入容器時，輸入的成品會識別在登錄中部署的映像。</span><span class="sxs-lookup"><span data-stu-id="86c34-209">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="86c34-210">根據這些識別的方式，他們不保證維持相同的版本中，最明顯的情況，當您從 docker-compose 檔案參考 」 myimage:latest 」 時期間。</span><span class="sxs-lookup"><span data-stu-id="86c34-210">Depending on how these are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference "myimage:latest" from a docker-compose file.</span></span>

<span data-ttu-id="86c34-211">Visual Studio Team Services 的 Docker 擴充功能可讓您產生包含特定的登錄機映像的組建成品的功能摘要保證可唯一識別相同的二進位映像。</span><span class="sxs-lookup"><span data-stu-id="86c34-211">The Docker extension for Visual Studio Team Services gives you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="86c34-212">這些是您真的要使用什麼做為輸入的版本。</span><span class="sxs-lookup"><span data-stu-id="86c34-212">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-visual-studio-team-services-release-management"></a><span data-ttu-id="86c34-213">使用 Visual Studio Team Services Release Management 來管理發行至 Docker 環境</span><span class="sxs-lookup"><span data-stu-id="86c34-213">Managing releases to Docker environments by using Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="86c34-214">透過 Visual Studio Team Services 延伸模組中，您可以建立新的映像、 將它發行到 Docker 登錄、 執行 Linux 或 Windows 主機上和使用例如 docker 命令-撰寫來部署多個容器，為整個應用程式，面對視覺效果Studio Team Services 版本管理功能，供多個環境，如圖 5-8 所示。</span><span class="sxs-lookup"><span data-stu-id="86c34-214">Through the Visual Studio Team Services extensions, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as docker-compose to deploy multiple containers as an entire application, all through the Visual Studio Team Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![](./media/image8.png)

<span data-ttu-id="86c34-215">圖 5-8： 設定 Visual 的 Studio Team Services Docker Compose 的工作，從 Visual Studio Team Services Release Management</span><span class="sxs-lookup"><span data-stu-id="86c34-215">Figure 5-8: Configuring Visual Studio Team Services Docker Compose tasks from Visual Studio Team Services Release Management</span></span>

<span data-ttu-id="86c34-216">不過，請記住，顯示在圖 5-6 中，並實作圖 5-8 案例 （它將它部署到簡單的 Docker 主機和 Vm，而且會有單一容器或每個影像的執行個體），很基本，而且可能應該僅適用於開發或測試 scenarios。</span><span class="sxs-lookup"><span data-stu-id="86c34-216">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is pretty basic (it is deploying to simple Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="86c34-217">在大部分的企業生產案例中，您會想讓高可用性 (HA) 和輕鬆管理擴充性的方式之間的負載平衡多個節點、 伺服器和 Vm，再加上 「 智慧型容錯移轉 」 因此，如果伺服器或節點失敗，其服務和容器將會移至另一部主機伺服器或 VM。</span><span class="sxs-lookup"><span data-stu-id="86c34-217">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so that if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="86c34-218">在此情況下，您需要更進階的技術，例如容器叢集、 orchestrators，以及排程器。</span><span class="sxs-lookup"><span data-stu-id="86c34-218">In that case, you need more advanced technologies like container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="86c34-219">因此，將部署到這些群集的方法是精確地透過下一節中說明的進階案例。</span><span class="sxs-lookup"><span data-stu-id="86c34-219">Thus, the way to deploy to those clusters is precisely through the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-complex-docker-applications-to-docker-clusters-dcos-kubernetes-and-docker-swarm"></a><span data-ttu-id="86c34-220">部署複雜的 Docker 應用程式至 Docker 叢集 （DC/OS、 Kubernetes，和 Docker Swarm）</span><span class="sxs-lookup"><span data-stu-id="86c34-220">Deploying complex Docker applications to Docker clusters (DC/OS, Kubernetes, and Docker Swarm)</span></span>

<span data-ttu-id="86c34-221">分散式應用程式的本質要求也會分散的計算資源。</span><span class="sxs-lookup"><span data-stu-id="86c34-221">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="86c34-222">要有生產調整功能，您必須先叢集功能，可提供高延展性和高可用性集區資源。</span><span class="sxs-lookup"><span data-stu-id="86c34-222">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and HA based on pooled resources.</span></span>

<span data-ttu-id="86c34-223">您可以部署容器手動這些群集來從 CLI 工具，例如 Docker Swarm (像是使用[docker 服務建立](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) 或 web UI 例如[Mesosphere 馬拉松](https://mesosphere.github.io/marathon/docs/marathon-ui.html)DC/OS 的叢集，但是您應該僅限 punctual 部署測試或基於管理目的而向外擴充或監視的目的，請保留的。</span><span class="sxs-lookup"><span data-stu-id="86c34-223">You could deploy containers manually to those clusters from a CLI tool such as Docker Swarm (like using [docker service create](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) or a web UI such as [Mesosphere Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html) for DC/OS clusters, but you should reserve that only for punctual deployment testing or for management purposes like scaling-out or monitoring purposes.</span></span>

<span data-ttu-id="86c34-224">從 CD 觀點來看和 Visual Studio Team Services 具體來說，您可以特別建立的部署工作從執行您將部署在分散式叢集您容器化應用程式的 Visual Studio Team Services Release Management 環境容器服務，如圖 5-9 中所述。</span><span class="sxs-lookup"><span data-stu-id="86c34-224">From a CD point of view, and Visual Studio Team Services specifically, you can run specially made deployment tasks from your Visual Studio Team Services Release Management environments which will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![](./media/image9.png)

<span data-ttu-id="86c34-225">圖 5-9： 部署容器服務的分散式應用程式</span><span class="sxs-lookup"><span data-stu-id="86c34-225">Figure 5-9: Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="86c34-226">一開始，當部署至特定的叢集或 orchestrators，您將會傳統上使用特定的部署指令碼和每個每個 orchestrator （也就是 Mesosphere DC/OS 或 Kubernetes 有不同的部署機制比 Docker 和 Docker 的機制廣域） 而非更簡單且容易使用 docker-撰寫 docker compose.yml 定義檔案為基礎的工具。</span><span class="sxs-lookup"><span data-stu-id="86c34-226">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Mesosphere DC/OS or Kubernetes have different deployment mechanisms than Docker and Docker Swarm) instead of the simpler and easy-to-use docker-compose tool based on the docker-compose.yml definition file.</span></span> <span data-ttu-id="86c34-227">不過，由於 Microsoft Visual Studio Team Services Docker 部署工作中，顯示在圖 5-10，您現在也可以將部署 DC/OS 只使用熟悉的 docker compose.yml 檔案，因為 Microsoft 為您執行該 「 轉譯 」 (從您docker compose.yml 檔案為其他格式所需的 DC/OS）。</span><span class="sxs-lookup"><span data-stu-id="86c34-227">However, thanks to the Microsoft Visual Studio Team Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to DC/OS by just using your familiar docker-compose.yml file because Microsoft performs that "translation" for you (from your docker-compose.yml file to other formats needed by DC/OS).</span></span>

![](./media/image10.png)

<span data-ttu-id="86c34-228">圖 5-10： 加入環境 RM Docker 部署工作</span><span class="sxs-lookup"><span data-stu-id="86c34-228">Figure 5-10: Adding the Docker Deploy task to your Environment RM</span></span>

<span data-ttu-id="86c34-229">圖 5-11 會示範如何編輯 Docker 部署工作，並指定目標類型 （Azure 容器服務 DC/作業系統，在此情況下）、 您 Docker 撰寫的檔案，以及 Docker 登錄連線 （例如 Azure 容器登錄中或 Docker Hub）。</span><span class="sxs-lookup"><span data-stu-id="86c34-229">Figure 5-11 demonstrates how you can edit the Docker Deploy task and specify the Target Type (Azure Container Service DC/OS, in this case), your Docker Compose File, and the Docker Registry connection (like Azure Container Registry or Docker Hub).</span></span> <span data-ttu-id="86c34-230">這是工作擷取做為容器 DC/OS 叢集中部署您已備妥要使用自訂 Docker 映像的地方。</span><span class="sxs-lookup"><span data-stu-id="86c34-230">This is where the task will retrieve your ready-to-use custom Docker images to be deployed as containers in the DC/OS cluster.</span></span>

![](./media/image11.png)

<span data-ttu-id="86c34-231">圖 5-11: Docker 部署工作定義部署 Azure 容器服務 DC/OS 到</span><span class="sxs-lookup"><span data-stu-id="86c34-231">Figure 5-11: Docker Deploy task definition deploying to Azure Container Service DC/OS</span></span>

<span data-ttu-id="86c34-232">**進一歩** 来閱讀更多有關 Visual Studio Team Services 和 Docker CD 管線，請造訪下列網站：</span><span class="sxs-lookup"><span data-stu-id="86c34-232">**More info** To read more about the CD pipeline with Visual Studio Team Services and Docker, visit the following sites:</span></span>

<span data-ttu-id="86c34-233">Docker 和 Azure 容器服務的 visual Studio Team Services 擴充功能： [https://aka.ms/ \ vstsdockerextension](https://aka.ms/vstsdockerextension)</span><span class="sxs-lookup"><span data-stu-id="86c34-233">Visual Studio Team Services extension for Docker and Azure Container Service: [https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span></span>

<span data-ttu-id="86c34-234">Azure 容器服務： <https://aka.ms/azurecontainerservice></span><span class="sxs-lookup"><span data-stu-id="86c34-234">Azure Container Service: <https://aka.ms/azurecontainerservice></span></span>

<span data-ttu-id="86c34-235">Mesosphere DC/OS: <https://mesosphere.com/product/></span><span class="sxs-lookup"><span data-stu-id="86c34-235">Mesosphere DC/OS: <https://mesosphere.com/product/></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="86c34-236">步驟 5： 執行和管理</span><span class="sxs-lookup"><span data-stu-id="86c34-236">Step 5: Run and manage</span></span>

<span data-ttu-id="86c34-237">因為執行和管理應用程式在企業實際執行層級是主要的主題中的本身，和因為作業的類型和工作該層級 （IT 作業），以及此區域的大範圍的人，我們有專供整個下一步它說明的章節。</span><span class="sxs-lookup"><span data-stu-id="86c34-237">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, we have devoted the entire next chapter to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="86c34-238">步驟 6： 監視和診斷</span><span class="sxs-lookup"><span data-stu-id="86c34-238">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="86c34-239">此主題也涵蓋在下一章，IT 部門在生產系統; 所執行之工作的一部分不過，請務必反白顯示，讓應用程式會持續改善，必須回到開發團隊摘要在此步驟中取得的深入資訊。</span><span class="sxs-lookup"><span data-stu-id="86c34-239">This topic also is covered in the next chapter as part of the tasks that IT operations performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="86c34-240">從該觀點來看，它也是部分 DevOps，雖然工作和作業通常都是透過 IT。</span><span class="sxs-lookup"><span data-stu-id="86c34-240">From that point of view, it is also part of DevOps, although the tasks and operations are usually performed by IT.</span></span>

<span data-ttu-id="86c34-241">監視和診斷是 DevOps 領域內的 100%時，只會監視的處理程序和開發小組對測試或測試環境中執行的分析。</span><span class="sxs-lookup"><span data-stu-id="86c34-241">Only when monitoring and diagnostics are 100 percent within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="86c34-242">這是藉由執行負載測試，或只是藉由監視 beta 或 QA 環境中，嘗試測試版測試人員的新版本。</span><span class="sxs-lookup"><span data-stu-id="86c34-242">This is done either by performing load testing or simply by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
<span data-ttu-id="86c34-243">[上一個](index.md) [下一步] (.../run-manage-monitor-docker-environments/index.md)</span><span class="sxs-lookup"><span data-stu-id="86c34-243">[Previous] (index.md) [Next] (../run-manage-monitor-docker-environments/index.md)</span></span>
