---
title: Docker 應用程式的外部迴圈 DevOps 工作流程中的步驟
description: 了解 DevOps 工作流程的 「 外部迴圈 」 的步驟
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 11/23/2018
ms.openlocfilehash: b75e9df1c31e8bcebcaa6d56336a6aa499d13e1d
ms.sourcegitcommit: 30e2fe5cc4165aa6dde7218ec80a13def3255e98
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/13/2019
ms.locfileid: "56220935"
---
# <a name="steps-in-the-outer-loop-devops-workflow-for-a-docker-application"></a><span data-ttu-id="b2383-103">Docker 應用程式的外部迴圈 DevOps 工作流程中的步驟</span><span class="sxs-lookup"><span data-stu-id="b2383-103">Steps in the outer-loop DevOps workflow for a Docker application</span></span>

<span data-ttu-id="b2383-104">圖 5-1 顯示端對端描述組成 DevOps 外部迴圈工作流程的步驟。</span><span class="sxs-lookup"><span data-stu-id="b2383-104">Figure 5-1 presents an end-to-end depiction of the steps comprising the DevOps outer-loop workflow.</span></span>

![](./media/image1.png)

<span data-ttu-id="b2383-105">圖 5-1:DevOps 與 Microsoft 工具的 Docker 應用程式的外部迴圈工作流程</span><span class="sxs-lookup"><span data-stu-id="b2383-105">Figure 5-1: DevOps outer-loop workflow for Docker applications with Microsoft tools</span></span>

<span data-ttu-id="b2383-106">現在，讓我們檢查每個更新版本的詳細步驟。</span><span class="sxs-lookup"><span data-stu-id="b2383-106">Now, let's examine each of these steps in greater detail.</span></span>

## <a name="step-1-inner-loop-development-workflow"></a><span data-ttu-id="b2383-107">步驟 1：內部迴圈開發工作流程</span><span class="sxs-lookup"><span data-stu-id="b2383-107">Step 1: Inner-loop development workflow</span></span>

<span data-ttu-id="b2383-108">此步驟中會詳細說明第 4 章中，但總而言之，以下是外部迴圈開始的位置，開發人員將推送程式碼至原始檔控制管理系統 （例如 Git) 起始 CI 管線動作的時刻。</span><span class="sxs-lookup"><span data-stu-id="b2383-108">This step is explained in detail in Chapter 4, but, to recap, here is where the outer-loop begins, the moment at which a developer pushes code to the source control management system (like Git) initiating CI pipeline actions.</span></span>

## <a name="step-2-source-code-control-integration-and-management-with-azure-devops-services-and-git"></a><span data-ttu-id="b2383-109">步驟 2：原始程式碼控制整合和管理 Azure DevOps Services 與 Git</span><span class="sxs-lookup"><span data-stu-id="b2383-109">Step 2: Source-Code Control integration and management with Azure DevOps Services and Git</span></span>

<span data-ttu-id="b2383-110">在此步驟中，您需要有版本控制系統來蒐集來自不同的開發人員在小組中的所有程式碼的合併的版本。</span><span class="sxs-lookup"><span data-stu-id="b2383-110">At this step, you need to have a version-control system to gather a consolidated version of all the code coming from the different developers in the team.</span></span>

<span data-ttu-id="b2383-111">即使原始碼控制 (SCC) 和原始碼管理似乎竟循環的大部分開發人員、 DevOps 生命週期中建立 Docker 應用程式時，請務必強調，您必須提交與應用程式的 Docker 映像直接向全球 Docker 登錄中 （例如 Azure Container Registry 或 Docker Hub） 從開發人員的電腦。</span><span class="sxs-lookup"><span data-stu-id="b2383-111">Even though source-code control (SCC) and source-code management might seem second-nature to most developers, when creating Docker applications in a DevOps life cycle, it is critical to emphasize that you must not submit the Docker images with the application directly to the global Docker Registry (like Azure Container Registry or Docker Hub) from the developer's machine.</span></span> <span data-ttu-id="b2383-112">相反地，發行並部署到生產環境的 Docker 映像必須全域組建或您的原始程式碼儲存機制 （例如 Git) 為基礎的 CI 管線中建立於要整合的原始程式碼。</span><span class="sxs-lookup"><span data-stu-id="b2383-112">On the contrary, the Docker images to be released and deployed to production environments must be created solely on the source code that is being integrated in your global build or CI pipeline based on your source-code repository (like Git).</span></span>

<span data-ttu-id="b2383-113">在自己的機器內測試時，應該使用本機開發人員本身所產生的映像只是由開發人員。</span><span class="sxs-lookup"><span data-stu-id="b2383-113">The local images generated by the developers themselves should be used just by the developers when testing within their own machines.</span></span> <span data-ttu-id="b2383-114">這是非常重要的 DevOps 管線從 SCC 的程式碼啟動的原因。</span><span class="sxs-lookup"><span data-stu-id="b2383-114">This is why it is critical to have the DevOps pipeline activated from the SCC code.</span></span>

<span data-ttu-id="b2383-115">Azure DevOps 服務和 Team Foundation Server 支援 Git 和 Team Foundation 版本控制。</span><span class="sxs-lookup"><span data-stu-id="b2383-115">Azure DevOps Services and Team Foundation Server support Git and Team Foundation Version Control.</span></span> <span data-ttu-id="b2383-116">您可以選擇它們，或使用端對端的 Microsoft 體驗。</span><span class="sxs-lookup"><span data-stu-id="b2383-116">You can choose between them and use it for an end-to-end Microsoft experience.</span></span> <span data-ttu-id="b2383-117">不過，您也可以管理您的程式碼，在外部儲存機制 （例如 GitHub、 內部部署的 Git 存放庫或 Subversion），而且仍然能夠連線到它，並取得您的 DevOps 的 CI 管線做為起點的程式碼。</span><span class="sxs-lookup"><span data-stu-id="b2383-117">However, you also can manage your code in external repositories (like GitHub, on-premises Git repositories, or Subversion) and still be able to connect to it and get the code as the starting point for your DevOps CI pipeline.</span></span>

## <a name="step-3-build-ci-integrate-and-test-with-azure-devops-services-and-docker"></a><span data-ttu-id="b2383-118">步驟 3：建置、 CI、 整合及測試與 Azure 的 DevOps 服務和 Docker</span><span class="sxs-lookup"><span data-stu-id="b2383-118">Step 3: Build, CI, Integrate, and Test with Azure DevOps Services and Docker</span></span>

<span data-ttu-id="b2383-119">CI 脫穎而出成為現代軟體測試及傳遞的標準。</span><span class="sxs-lookup"><span data-stu-id="b2383-119">CI has emerged as a standard for modern software testing and delivery.</span></span> <span data-ttu-id="b2383-120">Docker 解決方案會維持清楚的區隔開發和作業小組之間的問題。</span><span class="sxs-lookup"><span data-stu-id="b2383-120">The Docker solution maintains a clear separation of concerns between the development and operations teams.</span></span> <span data-ttu-id="b2383-121">Docker 映像的不變性可確保可重複的部署之間功能開發、 CI，透過測試和生產環境中執行。</span><span class="sxs-lookup"><span data-stu-id="b2383-121">The immutability of Docker images ensures a repeatable deployment between what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="b2383-122">開發人員的膝上型電腦上部署的 docker 引擎，並測試基礎結構可讓容器可攜式跨環境。</span><span class="sxs-lookup"><span data-stu-id="b2383-122">Docker Engine deployed across the developer laptops and test infrastructure makes the containers portable across environments.</span></span>

<span data-ttu-id="b2383-123">到目前為止，以正確的程式碼，提交進行版本控制系統之後，您需要*建置服務*挑選 程式碼，並執行全域組建和測試。</span><span class="sxs-lookup"><span data-stu-id="b2383-123">At this point, after you have a version-control system with the correct code submitted, you need a *build service* to pick up the code and run the global build and tests.</span></span>

<span data-ttu-id="b2383-124">此步驟中 （CI、 建置、 測試） 的內部工作流程是關於 CI 管線，組成 （Git 等），您的程式碼存放庫，您的組建伺服器 （Azure DevOps 服務），Docker 引擎及 Docker 登錄的建構。</span><span class="sxs-lookup"><span data-stu-id="b2383-124">The internal workflow for this step (CI, build, test) is about the construction of a CI pipeline consisting of your code repository (Git, etc.), your build server (Azure DevOps Services), Docker Engine, and a Docker Registry.</span></span>

<span data-ttu-id="b2383-125">您可以使用 Azure DevOps 服務作為基礎來建置您的應用程式和設定您的 CI 管線，並可用來發行建置的 「 成品 」 到 「 成品儲存機制，"會在下一個步驟中說明。</span><span class="sxs-lookup"><span data-stu-id="b2383-125">You can use Azure DevOps Services as the foundation for building your applications and setting your CI pipeline, and for publishing the built "artifacts" to an "artifacts repository," which is explained in the next step.</span></span>

<span data-ttu-id="b2383-126">使用 Docker 部署，也就是 「 最終成品 」 時部署會與您的應用程式或服務的 Docker 映像當中內嵌。</span><span class="sxs-lookup"><span data-stu-id="b2383-126">When using Docker for the deployment, the "final artifacts" to be deployed are Docker images with your application or services embedded within them.</span></span> <span data-ttu-id="b2383-127">這些映像會推送或發行至*Docker 登錄*（私用儲存機制的項目，您可以在 Azure Container Registry，或一個公用 Docker 中樞登錄，常用於官方的基底映像等）。</span><span class="sxs-lookup"><span data-stu-id="b2383-127">Those images are pushed or published to a *Docker Registry* (a private repository like the ones you can have in Azure Container Registry, or a public one like Docker Hub Registry, which is commonly used for official base images).</span></span>

<span data-ttu-id="b2383-128">以下是基本概念：CI 管線將會開始-關閉認可到 Git 等 SCC 儲存機制。</span><span class="sxs-lookup"><span data-stu-id="b2383-128">Here is the basic concept: The CI pipeline will be kicked-off by a commit to an SCC repository like Git.</span></span> <span data-ttu-id="b2383-129">認可會導致 Azure DevOps 服務來執行 Docker 容器內建置工作，並成功完成時的這項工作，將 Docker 映像推送至 Docker 登錄，在圖 5-2 示。</span><span class="sxs-lookup"><span data-stu-id="b2383-129">The commit will cause Azure DevOps Services to run a build job within a Docker container and, upon successful completion of that job, push a Docker image to the Docker Registry, as illustrated in Figure 5-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="b2383-130">圖 5-2:在 CI 中所需的步驟</span><span class="sxs-lookup"><span data-stu-id="b2383-130">Figure 5-2: The steps involved in CI</span></span>

<span data-ttu-id="b2383-131">以下是基本的 CI 工作流程步驟，使用 Docker 和 Azure DevOps 服務：</span><span class="sxs-lookup"><span data-stu-id="b2383-131">Here are the basic CI workflow steps with Docker and Azure DevOps Services:</span></span>

1.  <span data-ttu-id="b2383-132">開發人員將認可推送至 SCC 存放庫 （Git/Azure DevOps Services、 GitHub 等）。</span><span class="sxs-lookup"><span data-stu-id="b2383-132">The developer pushes a commit to an SCC repository (Git/Azure DevOps Services, GitHub, etc.).</span></span>

2.  <span data-ttu-id="b2383-133">如果您使用 Azure DevOps 服務或 Git、 CI 是內建，這表示它很簡單，只要選取 Azure DevOps 服務中的核取方塊。</span><span class="sxs-lookup"><span data-stu-id="b2383-133">If you're using Azure DevOps Services or Git, CI is built in, which means that it is as simple as selecting a check box in Azure DevOps Services.</span></span> <span data-ttu-id="b2383-134">如果您使用外部 （例如 GitHub)，SCC *webhook*會通知 Azure DevOps 服務的更新或推送至 Git/GitHub。</span><span class="sxs-lookup"><span data-stu-id="b2383-134">If you're using an external SCC (like GitHub), a *webhook* will notify Azure DevOps Services of the update or push to Git/GitHub.</span></span>

3.  <span data-ttu-id="b2383-135">Azure 的 DevOps 服務提取 SCC 存放庫，包括描述映像，以及應用程式和測試的程式碼的 DockerFile。</span><span class="sxs-lookup"><span data-stu-id="b2383-135">Azure DevOps Services pulls the SCC repository, including the DockerFile describing the image as well as the application and test code.</span></span>

4.  <span data-ttu-id="b2383-136">Azure 的 DevOps 服務建置 Docker 映像和標籤組建編號。</span><span class="sxs-lookup"><span data-stu-id="b2383-136">Azure DevOps Services builds a Docker image and labels it with a build number.</span></span>

5.  <span data-ttu-id="b2383-137">Azure 的 DevOps 服務具現化的 Docker 容器內已佈建的 Docker 主機，並執行適當的測試。</span><span class="sxs-lookup"><span data-stu-id="b2383-137">Azure DevOps Services instantiates the Docker container within the provisioned Docker Host, and runs the appropriate tests.</span></span>

6.  <span data-ttu-id="b2383-138">如果測試成功，影像先改為有意義的名稱，讓您知道它是 「 blessed 的組建 」 (例如"/ 1.0.0 」 或任何其他標籤)，然後推送至您的 Docker 登錄 （Docker Hub、 Azure Container Registry、 DTR 等等） 的 </span><span class="sxs-lookup"><span data-stu-id="b2383-138">If the tests are successful, the image is first relabeled to a meaningful name so that you know it is a "blessed build" (like "/1.0.0" or any other label), and then pushed up to your Docker Registry (Docker Hub, Azure Container Registry, DTR, etc.)</span></span>

### <a name="implementing-the-ci-pipeline-with-azure-devops-services-and-the-docker-extension-for-azure-devops-services"></a><span data-ttu-id="b2383-139">Azure DevOps 服務實作 CI 管線，使用 Azure DevOps 服務和 Docker 擴充功能</span><span class="sxs-lookup"><span data-stu-id="b2383-139">Implementing the CI pipeline with Azure DevOps Services and the Docker extension for Azure DevOps Services</span></span>

<span data-ttu-id="b2383-140">[Azure DevOps 服務 Docker 延伸模組](https://aka.ms/vstsdockerextension)將工作新增至您的 CI 管線，您可以建置 Docker 映像，將 Docker 映像推送到已驗證的 Docker 登錄、 執行 Docker 映像，或執行 Docker 所提供的其他作業CLI。</span><span class="sxs-lookup"><span data-stu-id="b2383-140">The [Azure DevOps Services Docker extension](https://aka.ms/vstsdockerextension) adds a task to your CI pipeline with which you can build Docker images, push Docker images to an authenticated Docker registry, run Docker images, or run other operations offered by the Docker CLI.</span></span> <span data-ttu-id="b2383-141">它也會新增的 Docker Compose 的工作，可用來建置、 推送及執行多容器 Docker 應用程式，或執行其他 Docker Compose CLI 所提供的作業，如所示的 圖 5-3。</span><span class="sxs-lookup"><span data-stu-id="b2383-141">It also adds a Docker Compose task that you can use to build, push, and run multicontainer Docker applications, or run other operations offered by the Docker Compose CLI, as shown in Figure 5-3.</span></span>

![](./media/image3.png)

<span data-ttu-id="b2383-142">圖 5-3:Azure DevOps 服務中的 Docker CI 管線</span><span class="sxs-lookup"><span data-stu-id="b2383-142">Figure 5-3: The Docker CI pipeline in Azure DevOps Services</span></span>

<span data-ttu-id="b2383-143">為 Docker 主機或容器或映像登錄，Docker 擴充功能可以使用服務端點。</span><span class="sxs-lookup"><span data-stu-id="b2383-143">The Docker extension can use service endpoints for Docker hosts and for container or image registries.</span></span> <span data-ttu-id="b2383-144">工作預設都會使用本機的 Docker 主機的話 （這目前需要自訂的 Azure DevOps 服務代理程式）;否則，它們需要您提供的 Docker 主機連線。</span><span class="sxs-lookup"><span data-stu-id="b2383-144">The tasks default to using a local Docker host if available (this currently requires a custom Azure DevOps Services agent); otherwise, they require that you provide a Docker host connection.</span></span> <span data-ttu-id="b2383-145">取決於使用 Docker 登錄，推送映像，例如正在驗證的動作需要您提供 Docker 登錄連線。</span><span class="sxs-lookup"><span data-stu-id="b2383-145">Actions that depend on being authenticated with a Docker registry, such as pushing an image, require that you provide a Docker registry connection.</span></span>

<span data-ttu-id="b2383-146">Azure DevOps 服務 Docker 擴充功能會在您的 Azure DevOps 服務帳戶安裝下列元件：</span><span class="sxs-lookup"><span data-stu-id="b2383-146">The Azure DevOps Services Docker extension installs the following components in your Azure DevOps Services account:</span></span>

-   <span data-ttu-id="b2383-147">連線到 Docker 登錄服務端點</span><span class="sxs-lookup"><span data-stu-id="b2383-147">A service endpoint for connecting to a Docker registry</span></span>

-   <span data-ttu-id="b2383-148">服務端點連線至 Docker 容器主機</span><span class="sxs-lookup"><span data-stu-id="b2383-148">A service endpoint for connecting to a Docker Container Host</span></span>

-   <span data-ttu-id="b2383-149">Docker 來執行下列工作：</span><span class="sxs-lookup"><span data-stu-id="b2383-149">A Docker task to do the following:</span></span>

-   <span data-ttu-id="b2383-150">建立映像</span><span class="sxs-lookup"><span data-stu-id="b2383-150">Build an image</span></span>

-   <span data-ttu-id="b2383-151">將映像或存放庫推送至登錄</span><span class="sxs-lookup"><span data-stu-id="b2383-151">Push an image or a repository to a registry</span></span>

-   <span data-ttu-id="b2383-152">在容器中執行的映像</span><span class="sxs-lookup"><span data-stu-id="b2383-152">Run an image in a container</span></span>

-   <span data-ttu-id="b2383-153">執行 Docker 命令</span><span class="sxs-lookup"><span data-stu-id="b2383-153">Run a Docker command</span></span>

-   <span data-ttu-id="b2383-154">Docker Compose 的工作執行的 Docker Compose 命令</span><span class="sxs-lookup"><span data-stu-id="b2383-154">A Docker Compose task to run a Docker Compose command</span></span>

<span data-ttu-id="b2383-155">這些 Azure DevOps 服務工作後，建置 Linux Docker 主機/VM 佈建在 Azure 和您慣用的 Docker 登錄 （Azure Container Registry，Docker Hub、 私用 Docker DTR 或任何其他的 Docker 登錄），您可以組合中的 Docker CI 管線非常一致的方式。</span><span class="sxs-lookup"><span data-stu-id="b2383-155">With these Azure DevOps Services tasks, a build Linux-Docker Host/VM provisioned in Azure and your preferred Docker registry (Azure Container Registry, Docker Hub, private Docker DTR, or any other Docker registry) you can assemble your Docker CI pipeline in a very consistent way.</span></span>

<span data-ttu-id="b2383-156">***需求：***</span><span class="sxs-lookup"><span data-stu-id="b2383-156">***Requirements:***</span></span>

-   <span data-ttu-id="b2383-157">Azure 的 DevOps 服務，或在內部部署安裝，Team Foundation Server 2015 Update 3 或更新版本。</span><span class="sxs-lookup"><span data-stu-id="b2383-157">Azure DevOps Services, or for on-premises installations, Team Foundation Server 2015 Update 3 or later.</span></span>

-   <span data-ttu-id="b2383-158">Azure DevOps 服務代理程式具有 Docker 二進位檔。</span><span class="sxs-lookup"><span data-stu-id="b2383-158">An Azure DevOps Services agent that has the Docker binaries.</span></span>

<span data-ttu-id="b2383-159">若要建立其中一種簡單的方法是使用 Docker 來執行 Azure DevOps 服務代理程式的 Docker 映像為基礎的容器。</span><span class="sxs-lookup"><span data-stu-id="b2383-159">An easy way to create one of these is to use Docker to run a container based on the Azure DevOps Services agent Docker image.</span></span>

<span data-ttu-id="b2383-160">**進一歩** 讀取詳細資訊組合 Azure DevOps 服務 Docker CI 管線，以及若要檢視的逐步解說，請造訪下列網站：</span><span class="sxs-lookup"><span data-stu-id="b2383-160">**More info** To read more about assembling a Azure DevOps Services Docker CI pipeline and to view walkthroughs, visit the following sites:</span></span>

<span data-ttu-id="b2383-161">執行 Azure DevOps 服務代理程式作為 Docker 容器： [ https://hub.docker.com/r/\ microsoft/vsts 代理程式 /](https://hub.docker.com/r/microsoft/vsts-agent/)</span><span class="sxs-lookup"><span data-stu-id="b2383-161">Running an Azure DevOps Services agent as a Docker container: [https://hub.docker.com/r/\ microsoft/vsts-agent/](https://hub.docker.com/r/microsoft/vsts-agent/)</span></span>

<span data-ttu-id="b2383-162">Azure 的 DevOps 服務 Docker 擴充功能： <https://aka.ms/vstsdockerextension></span><span class="sxs-lookup"><span data-stu-id="b2383-162">Azure DevOps Services Docker extension: <https://aka.ms/vstsdockerextension></span></span>

<span data-ttu-id="b2383-163">建置使用 Azure DevOps 服務的.NET Core Linux Docker 映像： <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span><span class="sxs-lookup"><span data-stu-id="b2383-163">Building .NET Core Linux Docker images with Azure DevOps Services: <https://blogs.msdn.microsoft.com/stevelasker/2016/06/13/building-net-core-linux-docker-images-with-visual-studio-team-services/></span></span>

<span data-ttu-id="b2383-164">建立具有 Docker 支援的 Linux 型 Visual Studio Team Service 組建電腦： <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span><span class="sxs-lookup"><span data-stu-id="b2383-164">Building a Linux-based Visual Studio Team Service build machine with Docker support: <http://donovanbrown.com/post/2016/06/03/Building-a-Linux-Based-Visual-Studio-Team-Service-Build-Machine-with-Docker-Support></span></span>

### <a name="integrate-test-and-validate-multicontainer-docker-applications"></a><span data-ttu-id="b2383-165">整合、 測試及驗證多容器 Docker 應用程式</span><span class="sxs-lookup"><span data-stu-id="b2383-165">Integrate, test, and validate multicontainer Docker applications</span></span>

<span data-ttu-id="b2383-166">一般而言，大部分的 Docker 應用程式是由多個容器，而不是單一容器組成。</span><span class="sxs-lookup"><span data-stu-id="b2383-166">Typically, most Docker applications are composed of multiple containers rather than a single container.</span></span> <span data-ttu-id="b2383-167">例如，您會有每個微服務的一個容器的微服務導向應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2383-167">A good example is a microservices-oriented application for which you would have one container per microservice.</span></span> <span data-ttu-id="b2383-168">但是，即使沒有嚴格遵循的微服務方法的模式，是非常有可能您的 Docker 應用程式會組成多個容器或服務。</span><span class="sxs-lookup"><span data-stu-id="b2383-168">But, even without strictly following the microservices approach patterns, it is very probable that your Docker application would be composed of multiple containers or services.</span></span>

<span data-ttu-id="b2383-169">因此，在建置應用程式中的容器 CI 管線之後, 您還必須部署、 整合及測試與它的所有容器整合 Docker 主機內或甚至是您的容器要測試叢集的整體應用程式散發。</span><span class="sxs-lookup"><span data-stu-id="b2383-169">Therefore, after building the application containers in the CI pipeline, you also need to deploy, integrate, and test the application as a whole with all of its containers within an integration Docker host or even into a test cluster to which your containers are distributed.</span></span>

<span data-ttu-id="b2383-170">如果您使用單一主機，您可以使用 Docker 命令，例如 docker-compose 來建置和部署相關的容器，以測試和驗證的單一 VM 中的 Docker 環境。</span><span class="sxs-lookup"><span data-stu-id="b2383-170">If you're using a single host, you can use Docker commands such as docker-compose to build and deploy related containers to test and validate the Docker environment in a single VM.</span></span> <span data-ttu-id="b2383-171">但是，如果您正在使用協調器，如 DC/OS、 Kubernetes 或 Docker Swarm 叢集，您需要部署您的容器，透過不同的機制或協調器時，根據您所選叢集/排程器。</span><span class="sxs-lookup"><span data-stu-id="b2383-171">But, if you are working with an orchestrator cluster like DC/OS, Kubernetes, or Docker Swarm, you need to deploy your containers through a different mechanism or orchestrator, depending on your selected cluster/scheduler.</span></span>

<span data-ttu-id="b2383-172">以下是您可以針對 Docker 容器執行的測試的數種：</span><span class="sxs-lookup"><span data-stu-id="b2383-172">Following are several types of tests that you can run against Docker containers:</span></span>

-   <span data-ttu-id="b2383-173">針對 Docker 容器的單元測試</span><span class="sxs-lookup"><span data-stu-id="b2383-173">Unit tests for Docker containers</span></span>

-   <span data-ttu-id="b2383-174">測試群組的相互關聯的應用程式或微服務</span><span class="sxs-lookup"><span data-stu-id="b2383-174">Testing groups of interrelated applications or microservices</span></span>

-   <span data-ttu-id="b2383-175">在生產環境和 「 canary 」 版本中測試</span><span class="sxs-lookup"><span data-stu-id="b2383-175">Test in production and "canary" releases</span></span>

<span data-ttu-id="b2383-176">重要的一點是當執行整合和功能測試時，您必須執行這些測試容器外。</span><span class="sxs-lookup"><span data-stu-id="b2383-176">The important point is that when running integration and functional tests, you must run those tests from outside of the containers.</span></span> <span data-ttu-id="b2383-177">測試不會定義和執行您要部署，容器內，因為容器以靜態應該完全一樣，您會部署到生產環境的映像為基礎。</span><span class="sxs-lookup"><span data-stu-id="b2383-177">Tests must not be defined and run within the containers that you are deploying, because the containers are based on static images that should be exactly like those that you will be deploying into production.</span></span>

<span data-ttu-id="b2383-178">測試更進階的案例，例如測試 （測試叢集、 臨時的叢集和生產叢集） 的數個叢集時，非常可行的選項是將映像發佈至登錄，以測試各種不同的叢集中。</span><span class="sxs-lookup"><span data-stu-id="b2383-178">A very feasible option when testing more advanced scenarios like testing several clusters (test cluster, staging cluster, and production cluster) is to publish the images to a registry to test in various clusters.</span></span>

### <a name="push-the-custom-application-docker-image-into-your-global-docker-registry"></a><span data-ttu-id="b2383-179">自訂應用程式的 Docker 映像推送到全球的 Docker 登錄</span><span class="sxs-lookup"><span data-stu-id="b2383-179">Push the custom application Docker image into your global Docker Registry</span></span>

<span data-ttu-id="b2383-180">Docker 映像已測試並驗證之後，您會想要加上標籤，並將其發行至您的 Docker 登錄。</span><span class="sxs-lookup"><span data-stu-id="b2383-180">After the Docker images have been tested and validated, you'll want to tag and publish them to your Docker registry.</span></span> <span data-ttu-id="b2383-181">Docker 登錄中 Docker 應用程式生命週期是評選為重要，因為這是您用來儲存您自訂的測試 （也稱為 「 blessed 映像 」），部署至 QA 和生產環境的中央位置。</span><span class="sxs-lookup"><span data-stu-id="b2383-181">The Docker registry is a critical piece in the Docker application life cycle because it is the central place where you store your custom test (aka "blessed images") to be deployed into QA and production environments.</span></span>

<span data-ttu-id="b2383-182">類似於儲存在您 SCC 的存放庫 （Git 等） 的應用程式程式碼的程式 「 信任來源 」 的方式，Docker 登錄是您 「 信任來源 」 為您的應用程式二進位或位元品管或生產環境部署。</span><span class="sxs-lookup"><span data-stu-id="b2383-182">Similar to how the application code stored in your SCC repository (Git, etc.) is your "source of truth," the Docker registry is your "source of truth" for your binary application or bits to be deployed to the QA or production environments.</span></span>

<span data-ttu-id="b2383-183">一般而言，您可能想要有您自訂映像的私人存放庫私人存放庫在 Azure Container Registry 或 Docker Trusted Registry，例如內部部署登錄或公用雲端登錄中，以限制的存取權 （例如Docker Hub)，雖然在最後這個情況下如果不是一個開放原始碼，您的程式碼中，您必須信任廠商的安全性。</span><span class="sxs-lookup"><span data-stu-id="b2383-183">Typically, you might want to have your private repositories for your custom images either in a private repository in Azure Container Registry or in an on-premises registry like Docker Trusted Registry, or in a public-cloud registry with restricted access (like Docker Hub), although in this last case if your code is not open source, you must trust the vendor's security.</span></span> <span data-ttu-id="b2383-184">無論如何，供您執行這項操作的方法是十分類似，最後會根據 docker push 命令中，如上圖中圖 5-4。</span><span class="sxs-lookup"><span data-stu-id="b2383-184">Either way, the method by which you do this is pretty similar and ultimately based on the docker push command, as depicted in Figure 5-4.</span></span>

![](./media/image4.png)

<span data-ttu-id="b2383-185">圖 5-4:發行到 Docker 登錄的自訂映像</span><span class="sxs-lookup"><span data-stu-id="b2383-185">Figure 5-4: Publishing custom images to Docker Registry</span></span>

<span data-ttu-id="b2383-186">有多個供應項目從像是 Azure Container Registry、 Amazon Web Services Container Registry、 Google Container Registry、 爾斯頓碼頭登錄等等的雲端供應商的 Docker 登錄。</span><span class="sxs-lookup"><span data-stu-id="b2383-186">There are multiple offerings of Docker registries from cloud vendors like Azure Container Registry, Amazon Web Services Container Registry, Google Container Registry, Quay Registry, and so on.</span></span>

<span data-ttu-id="b2383-187">使用 Azure DevOps 服務 Docker 延伸模組，您可以將推送一組由 docker-compose.yml 檔案，具有多個標記，已驗證的 Docker 登錄 （例如 Azure Container Registry)，來定義服務映像所示的 圖 5-5。</span><span class="sxs-lookup"><span data-stu-id="b2383-187">Using the Azure DevOps Services Docker extension, you can push a set of service images defined by a docker-compose.yml file, with multiple tags, to an authenticated Docker registry (like Azure Container Registry), as shown in Figure 5-5.</span></span>

![](./media/image5.png)

<span data-ttu-id="b2383-188">圖 5-5:使用 Azure DevOps 服務來發行至 Docker 登錄的自訂映像</span><span class="sxs-lookup"><span data-stu-id="b2383-188">Figure 5-5: Using Azure DevOps Services to publishing custom images to a Docker Registry</span></span>

<span data-ttu-id="b2383-189">**進一歩** 若要深入了解 Azure DevOps 服務的 Docker 擴充功能，請移至<https://aka.ms/vstsdockerextension>。</span><span class="sxs-lookup"><span data-stu-id="b2383-189">**More info** To read more about the Docker extension for Azure DevOps Services, go to <https://aka.ms/vstsdockerextension>.</span></span> <span data-ttu-id="b2383-190">若要深入了解 Azure Container Registry，請移至<https://aka.ms/azurecontainerregistry>。</span><span class="sxs-lookup"><span data-stu-id="b2383-190">To learn more about Azure Container Registry, go to <https://aka.ms/azurecontainerregistry>.</span></span>

## <a name="step-4-cd-deploy"></a><span data-ttu-id="b2383-191">步驟 4：CD，部署</span><span class="sxs-lookup"><span data-stu-id="b2383-191">Step 4: CD, Deploy</span></span>

<span data-ttu-id="b2383-192">Docker 映像的不變性可確保可重複使用什麼開發、 CI，透過測試和生產環境中執行的部署。</span><span class="sxs-lookup"><span data-stu-id="b2383-192">The immutability of Docker images ensures a repeatable deployment with what's developed, tested through CI, and run in production.</span></span> <span data-ttu-id="b2383-193">在您的 Docker 登錄 （私人或公用） 中發佈的應用程式 Docker 映像之後，您就可以將它們部署到您可能會有數個環境 (生產、 品管預備，等等) 從您的 CD 管線，透過使用 Azure DevOps 服務管線工作或 Azure DevOps 服務 Release Management。</span><span class="sxs-lookup"><span data-stu-id="b2383-193">After you have the application Docker images published in your Docker registry (either private or public), you can deploy them to the several environments that you might have (production, QA, staging, etc.) from your CD pipeline by using Azure DevOps Services pipeline tasks or Azure DevOps Services Release Management.</span></span>

<span data-ttu-id="b2383-194">不過，此時它會取決於您要部署的 Docker 應用程式種類。</span><span class="sxs-lookup"><span data-stu-id="b2383-194">However, at this point it depends on what kind of Docker application you are deploying.</span></span> <span data-ttu-id="b2383-195">部署簡單的應用程式 （從撰寫和部署觀點來看） 類似整合型應用程式包含幾個容器或服務，並已部署到少數伺服器或 Vm 是非常不同於部署更複雜的應用程式，例如超大規模的功能與微服務導向的應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2383-195">Deploying a simple application (from a composition and deployment point of view) like a monolithic application comprising a few containers or services and deployed to a few servers or VMs is very different from deploying a more complex application like a microservices-oriented application with hyperscale capabilities.</span></span> <span data-ttu-id="b2383-196">下列各節將說明這兩種情況。</span><span class="sxs-lookup"><span data-stu-id="b2383-196">These two scenarios are explained in the following sections.</span></span>

### <a name="deploying-composed-docker-applications-to-multiple-docker-environments"></a><span data-ttu-id="b2383-197">組成多個 Docker 環境的 Docker 應用程式的部署</span><span class="sxs-lookup"><span data-stu-id="b2383-197">Deploying composed Docker applications to multiple Docker environments</span></span>

<span data-ttu-id="b2383-198">首先討論較不複雜的案例： 部署至簡單 Docker 主機 （Vm 或伺服器） 在單一環境或多個環境 (QA，預備和生產環境)。</span><span class="sxs-lookup"><span data-stu-id="b2383-198">Let's look first at the less-complex scenario: deploying to simple Docker hosts (VMs or servers) in a single environment or multiple environments (QA, staging, and production).</span></span> <span data-ttu-id="b2383-199">在此案例中，在內部 CD 管線可以使用 docker-示 圖 5-6，撰寫 （從 Azure DevOps 服務部署工作） 來部署其相關設定的容器或服務，Docker 應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2383-199">In this scenario, internally your CD pipeline can use docker-compose (from your Azure DevOps Services deployment tasks) to deploy the Docker applications with its related set of containers or services, as illustrated in Figure 5-6.</span></span>

![](./media/image6.png)

<span data-ttu-id="b2383-200">圖 5-6:將應用程式容器部署到簡單的 Docker 主機環境登錄</span><span class="sxs-lookup"><span data-stu-id="b2383-200">Figure 5-6: Deploying application containers to simple Docker host environments registry</span></span>

<span data-ttu-id="b2383-201">圖 5-7 中，反白顯示如何連接建置 CI 到透過 Azure DevOps 服務的 QA/測試環境按一下 新增工作 對話方塊中的 Docker Compose。</span><span class="sxs-lookup"><span data-stu-id="b2383-201">Figure 5-7 highlights how you can connect your build CI to QA/test environments via Azure DevOps Services by clicking Docker Compose in the Add Task dialog box.</span></span> <span data-ttu-id="b2383-202">不過，部署至預備環境或生產環境時，您會通常使用 Release Management 功能處理多個環境 (例如品管預備和生產環境)。</span><span class="sxs-lookup"><span data-stu-id="b2383-202">However, when deploying to staging or production environments, you would usually use Release Management features handling multiple environments (like QA, staging, and production).</span></span> <span data-ttu-id="b2383-203">如果您要部署至單一 Docker 主機，它會使用 Azure DevOps 服務 「 Docker Compose 」 工作 (這叫用 docker-docker-compose up 命令，在幕後)。</span><span class="sxs-lookup"><span data-stu-id="b2383-203">If you're deploying to single Docker hosts, it is using the Azure DevOps Services "Docker Compose" task (which is invoking the docker-compose up command under the hood).</span></span> <span data-ttu-id="b2383-204">如果您要部署到 Azure Container Service，它會使用 Docker 部署工作中下, 節中所述。</span><span class="sxs-lookup"><span data-stu-id="b2383-204">If you're deploying to Azure Container Service, it uses the Docker Deployment task, as explained in the section that follows.</span></span>

![](./media/image7.png)

<span data-ttu-id="b2383-205">圖 5-7:Azure DevOps 服務管線中新增 Docker Compose 的工作</span><span class="sxs-lookup"><span data-stu-id="b2383-205">Figure 5-7: Adding a Docker Compose task in a Azure DevOps Services pipeline</span></span>

<span data-ttu-id="b2383-206">當您建立 Azure DevOps 服務中的發行時，它會採用一組輸入的成品。</span><span class="sxs-lookup"><span data-stu-id="b2383-206">When you create a release in Azure DevOps Services, it takes a set of input artifacts.</span></span> <span data-ttu-id="b2383-207">這些設定被為了跨多個環境是不可變的存留期的發行。</span><span class="sxs-lookup"><span data-stu-id="b2383-207">These are intended to be immutable throughout the lifetime of the release across multiple environments.</span></span> <span data-ttu-id="b2383-208">當您引入容器時，輸入的成品會識別在登錄中部署的映像。</span><span class="sxs-lookup"><span data-stu-id="b2383-208">When you introduce containers, the input artifacts identify images in a registry to deploy.</span></span> <span data-ttu-id="b2383-209">根據這些識別的方式，他們不保證維持不變的版本中，最明顯的情形下當您從 docker-compose 檔案參考 「 myimage:latest"期間。</span><span class="sxs-lookup"><span data-stu-id="b2383-209">Depending on how these are identified, they are not guaranteed to remain the same throughout the duration of the release, the most obvious case being when you reference "myimage:latest" from a docker-compose file.</span></span>

<span data-ttu-id="b2383-210">Azure DevOps 服務的 Docker 擴充功能可讓您產生包含特定的登錄機映像的組建成品的功能摘要保證可唯一識別相同的二進位映像。</span><span class="sxs-lookup"><span data-stu-id="b2383-210">The Docker extension for Azure DevOps Services gives you the ability to generate build artifacts that contain specific registry image digests that are guaranteed to uniquely identify the same image binary.</span></span> <span data-ttu-id="b2383-211">這些是什麼您真的想要做為輸入至版本。</span><span class="sxs-lookup"><span data-stu-id="b2383-211">These are what you really want to use as input to a release.</span></span>

### <a name="managing-releases-to-docker-environments-by-using-azure-devops-services-release-management"></a><span data-ttu-id="b2383-212">使用 Azure DevOps 服務 Release Management 來管理 Docker 環境的版本</span><span class="sxs-lookup"><span data-stu-id="b2383-212">Managing releases to Docker environments by using Azure DevOps Services Release Management</span></span>

<span data-ttu-id="b2383-213">透過 Azure DevOps 服務延伸模組，您可以建置新的映像、 將它發行到 Docker 登錄、 執行 Linux 或 Windows 主機上並使用命令，例如 docker-compose 來部署多個容器作為整個應用程式，透過 Azure DevOps如所示的 圖 5-8，服務適用於多個環境的發行管理功能。</span><span class="sxs-lookup"><span data-stu-id="b2383-213">Through the Azure DevOps Services extensions, you can build a new image, publish it to a Docker registry, run it on Linux or Windows hosts, and use commands such as docker-compose to deploy multiple containers as an entire application, all through the Azure DevOps Services Release Management capabilities intended for multiple environments, as shown in Figure 5-8.</span></span>

![](./media/image8.png)

<span data-ttu-id="b2383-214">圖 5-8:設定 Azure DevOps 服務 Docker Compose 的 Azure DevOps 服務 Release Management 的工作</span><span class="sxs-lookup"><span data-stu-id="b2383-214">Figure 5-8: Configuring Azure DevOps Services Docker Compose tasks from Azure DevOps Services Release Management</span></span>

<span data-ttu-id="b2383-215">不過，請記住，是相當基本，（它部署簡單的 Docker 主機和 Vm，並會有單一容器或每個影像的執行個體） 的案例中，顯示 圖 5-6，並實作 圖 5-8，並可能應僅適用於開發或測試的 scenarios。</span><span class="sxs-lookup"><span data-stu-id="b2383-215">However, keep in mind that the scenario shown in Figure 5-6 and implemented in Figure 5-8 is pretty basic (it is deploying to simple Docker hosts and VMs, and there will be a single container or instance per image) and probably should be used only for development or test scenarios.</span></span> <span data-ttu-id="b2383-216">在大部分的企業生產環境案例中，您會想要有高可用性 (HA) 和方便管理可調整性的負載分散於多個節點、 伺服器和 Vm，以及 「 智慧型容錯移轉 」 因此，如果伺服器或節點失敗，其服務和容器將會移至另一部主機伺服器或 VM。</span><span class="sxs-lookup"><span data-stu-id="b2383-216">In most enterprise production scenarios, you would want to have High Availability (HA) and easy-to-manage scalability by load balancing across multiple nodes, servers, and VMs, plus "intelligent failovers" so that if a server or node fails, its services and containers will be moved to another host server or VM.</span></span> <span data-ttu-id="b2383-217">在此情況下，您需要更進階的技術，例如容器叢集、 協調器和排程器。</span><span class="sxs-lookup"><span data-stu-id="b2383-217">In that case, you need more advanced technologies like container clusters, orchestrators, and schedulers.</span></span> <span data-ttu-id="b2383-218">因此，部署到這些叢集的方式，就是精確地透過進階的案例下一節所述。</span><span class="sxs-lookup"><span data-stu-id="b2383-218">Thus, the way to deploy to those clusters is precisely through the advanced scenarios explained in the next section.</span></span>

### <a name="deploying-complex-docker-applications-to-docker-clusters-dcos-kubernetes-and-docker-swarm"></a><span data-ttu-id="b2383-219">部署複雜的 Docker 應用程式到 Docker 叢集 （DC/OS、 Kubernetes 和 Docker Swarm）</span><span class="sxs-lookup"><span data-stu-id="b2383-219">Deploying complex Docker applications to Docker clusters (DC/OS, Kubernetes, and Docker Swarm)</span></span>

<span data-ttu-id="b2383-220">分散式應用程式的本質需要也分散式的運算資源。</span><span class="sxs-lookup"><span data-stu-id="b2383-220">The nature of distributed applications requires compute resources that are also distributed.</span></span> <span data-ttu-id="b2383-221">若要讓生產環境調整功能，您必須叢集提供高延展性的功能和 HA 根據集區的資源。</span><span class="sxs-lookup"><span data-stu-id="b2383-221">To have production-scale capabilities, you need to have clustering capabilities that provide high scalability and HA based on pooled resources.</span></span>

<span data-ttu-id="b2383-222">您可以將容器部署手動到這些叢集從 CLI 工具，例如 Docker Swarm (例如使用[建立 docker 服務](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) 或 web UI 這類[Mesosphere Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html) DC/os 叢集，但您應該只針對 punctual 部署測試或管理用途，例如相應放大，或監視的目的，請保留的。</span><span class="sxs-lookup"><span data-stu-id="b2383-222">You could deploy containers manually to those clusters from a CLI tool such as Docker Swarm (like using [docker service create](https://docs.docker.com/engine/swarm/swarm-tutorial/deploy-service/)) or a web UI such as [Mesosphere Marathon](https://mesosphere.github.io/marathon/docs/marathon-ui.html) for DC/OS clusters, but you should reserve that only for punctual deployment testing or for management purposes like scaling-out or monitoring purposes.</span></span>

<span data-ttu-id="b2383-223">從 CD 的觀點而言和 Azure DevOps 服務明確地說，您可以特別製作的部署工作從執行您的 Azure DevOps 服務 Release Management 環境會部署到容器中的分散式叢集容器化的應用程式服務，如所示的 圖 5-9。</span><span class="sxs-lookup"><span data-stu-id="b2383-223">From a CD point of view, and Azure DevOps Services specifically, you can run specially made deployment tasks from your Azure DevOps Services Release Management environments which will deploy your containerized applications to distributed clusters in Container Service, as illustrated in Figure 5-9.</span></span>

![](./media/image9.png)

<span data-ttu-id="b2383-224">圖 5-9:部署容器服務的分散式應用程式</span><span class="sxs-lookup"><span data-stu-id="b2383-224">Figure 5-9: Deploying distributed applications to Container Service</span></span>

<span data-ttu-id="b2383-225">一開始，部署到特定的叢集或協調器時，您將傳統上使用特定的部署指令碼和每個協調器 （亦即，Mesosphere DC/OS 或 Kubernetes 有不同的部署機制比 Docker 與 Docker 的機制Swarm) 而不是更簡單且方便使用 docker compose docker-compose.yml 定義檔案為基礎的工具。</span><span class="sxs-lookup"><span data-stu-id="b2383-225">Initially, when deploying to certain clusters or orchestrators, you would traditionally use specific deployment scripts and mechanisms per each orchestrator (that is, Mesosphere DC/OS or Kubernetes have different deployment mechanisms than Docker and Docker Swarm) instead of the simpler and easy-to-use docker-compose tool based on the docker-compose.yml definition file.</span></span> <span data-ttu-id="b2383-226">不過，多虧有 Microsoft Azure DevOps 服務 Docker 部署工作，顯示在 圖 5-10，您現在也可以部署至 DC/OS 只使用您熟悉的 docker-compose.yml 檔案，因為 Microsoft 會為您執行該 「 轉譯 」 (從您docker-compose.yml 檔案為其他格式所需的 DC/OS）。</span><span class="sxs-lookup"><span data-stu-id="b2383-226">However, thanks to the Microsoft Azure DevOps Services Docker Deploy task, shown in Figure 5-10, you now also can deploy to DC/OS by just using your familiar docker-compose.yml file because Microsoft performs that "translation" for you (from your docker-compose.yml file to other formats needed by DC/OS).</span></span>

![](./media/image10.png)

<span data-ttu-id="b2383-227">圖 5-10:部署 Docker 工作新增到您環境的 RM</span><span class="sxs-lookup"><span data-stu-id="b2383-227">Figure 5-10: Adding the Docker Deploy task to your Environment RM</span></span>

<span data-ttu-id="b2383-228">圖 5-11 示範如何編輯 Docker 部署工作，並指定目標類型 (Azure Container Service DC/OS，在此情況下)、 您 Docker Compose 檔案，以及 Docker 登錄連線 （例如 Azure Container Registry 或 Docker Hub）。</span><span class="sxs-lookup"><span data-stu-id="b2383-228">Figure 5-11 demonstrates how you can edit the Docker Deploy task and specify the Target Type (Azure Container Service DC/OS, in this case), your Docker Compose File, and the Docker Registry connection (like Azure Container Registry or Docker Hub).</span></span> <span data-ttu-id="b2383-229">這是工作擷取要部署 DC/OS 叢集中的容器為您已準備好使用自訂 Docker 映像的地方。</span><span class="sxs-lookup"><span data-stu-id="b2383-229">This is where the task will retrieve your ready-to-use custom Docker images to be deployed as containers in the DC/OS cluster.</span></span>

![](./media/image11.png)

<span data-ttu-id="b2383-230">圖 5-11:Docker 部署工作定義部署 Azure Container Service DC/OS 以</span><span class="sxs-lookup"><span data-stu-id="b2383-230">Figure 5-11: Docker Deploy task definition deploying to Azure Container Service DC/OS</span></span>

<span data-ttu-id="b2383-231">**進一歩** 若要深入了解 CD 管線中使用 Azure DevOps 服務和 Docker，請瀏覽下列網站：</span><span class="sxs-lookup"><span data-stu-id="b2383-231">**More info** To read more about the CD pipeline with Azure DevOps Services and Docker, visit the following sites:</span></span>

<span data-ttu-id="b2383-232">Docker 和 Azure Container Service 的 azure DevOps 服務延伸模組： [ https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span><span class="sxs-lookup"><span data-stu-id="b2383-232">Azure DevOps Services extension for Docker and Azure Container Service: [https://aka.ms/\ vstsdockerextension](https://aka.ms/vstsdockerextension)</span></span>

<span data-ttu-id="b2383-233">Azure Container Service: <https://aka.ms/azurecontainerservice></span><span class="sxs-lookup"><span data-stu-id="b2383-233">Azure Container Service: <https://aka.ms/azurecontainerservice></span></span>

<span data-ttu-id="b2383-234">Mesosphere DC/OS: <https://mesosphere.com/product/></span><span class="sxs-lookup"><span data-stu-id="b2383-234">Mesosphere DC/OS: <https://mesosphere.com/product/></span></span>

## <a name="step-5-run-and-manage"></a><span data-ttu-id="b2383-235">步驟 5：執行和管理</span><span class="sxs-lookup"><span data-stu-id="b2383-235">Step 5: Run and manage</span></span>

<span data-ttu-id="b2383-236">因為執行及管理應用程式在生產環境的企業層級是主要的主旨在本身，並因為作業的類型和工作該層級 （IT 作業），以及此區域的大範圍的人，我們有專門提供整個下一步若要說明的章節。</span><span class="sxs-lookup"><span data-stu-id="b2383-236">Because running and managing applications at enterprise-production level is a major subject in and of itself, and due to the type of operations and people working at that level (IT operations) as well as the large scope of this area, we have devoted the entire next chapter to explaining it.</span></span>

## <a name="step-6-monitor-and-diagnose"></a><span data-ttu-id="b2383-237">步驟 6：監視和診斷</span><span class="sxs-lookup"><span data-stu-id="b2383-237">Step 6: Monitor and diagnose</span></span>

<span data-ttu-id="b2383-238">本主題也涵蓋在下一步] 一章中一部分的 IT 作業會對生產系統; 中執行的工作不過，請務必反白顯示 [在此步驟中取得的深入解析必須摘要回到開發小組，以便持續改善應用程式。</span><span class="sxs-lookup"><span data-stu-id="b2383-238">This topic also is covered in the next chapter as part of the tasks that IT operations performs in production systems; however, is important to highlight that the insights obtained in this step must feed back to the development team so that the application is constantly improved.</span></span> <span data-ttu-id="b2383-239">從該觀點來看，也是一部分的 DevOps，雖然工作和作業通常都是透過 IT。</span><span class="sxs-lookup"><span data-stu-id="b2383-239">From that point of view, it is also part of DevOps, although the tasks and operations are usually performed by IT.</span></span>

<span data-ttu-id="b2383-240">監視和診斷是 DevOps 領域內的 100%時，只是監視程序和針對測試或測試環境的開發小組所執行的分析。</span><span class="sxs-lookup"><span data-stu-id="b2383-240">Only when monitoring and diagnostics are 100 percent within the realm of DevOps are the monitoring processes and analytics performed by the development team against testing or beta environments.</span></span> <span data-ttu-id="b2383-241">這是執行負載測試，或只是藉由監視 beta 或 QA 環境中，嘗試 beta 版測試人員的新版本。</span><span class="sxs-lookup"><span data-stu-id="b2383-241">This is done either by performing load testing or simply by monitoring beta or QA environments, where beta testers are trying the new versions.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="b2383-242">[上一頁](index.md)
>[下一頁](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span><span class="sxs-lookup"><span data-stu-id="b2383-242">[Previous](index.md)
[Next](create-ci-cd-pipelines-azure-devops-services-aspnetcore-kubernetes.md)</span></span>
