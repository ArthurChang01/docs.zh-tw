---
title: 整合型應用程式
description: Microsoft 平台和工具的容器化 Docker 應用程式生命週期
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.openlocfilehash: a2fe2c325377ec49f89199ad2e36c950ebab6a24
ms.sourcegitcommit: db8b83057d052c1f9f249d128b08d4423af0f7c2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/01/2018
ms.locfileid: "50757344"
---
# <a name="monolithic-applications"></a><span data-ttu-id="85b71-103">整合型應用程式</span><span class="sxs-lookup"><span data-stu-id="85b71-103">Monolithic applications</span></span>

<span data-ttu-id="85b71-104">在此案例中，您會建置單一的整合型 web 應用程式或服務，並將它部署為容器。</span><span class="sxs-lookup"><span data-stu-id="85b71-104">In this scenario, you are building a single and monolithic web application or service and deploying it as a container.</span></span> <span data-ttu-id="85b71-105">在應用程式中，結構可能不是單體式;它可能包含數個程式庫、 元件或甚至是階層 （應用程式層、 領域層、 資料存取層等等）。</span><span class="sxs-lookup"><span data-stu-id="85b71-105">Within the application, the structure might not be monolithic; it might comprise several libraries, components, or even layers (application layer, domain layer, data access layer, etc.).</span></span> <span data-ttu-id="85b71-106">在外部，它是單一容器，像是單一處理序、 單一 web 應用程式或單一服務。</span><span class="sxs-lookup"><span data-stu-id="85b71-106">Externally, it is a single container, like a single process, single web application, or single service.</span></span>

<span data-ttu-id="85b71-107">為了管理此模型，您會部署單一容器來代表應用程式。</span><span class="sxs-lookup"><span data-stu-id="85b71-107">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="85b71-108">調整其規模，只新增幾個使用負載平衡器前端的多個複本。</span><span class="sxs-lookup"><span data-stu-id="85b71-108">To scale it, just add a few more copies with a load balancer in front.</span></span> <span data-ttu-id="85b71-109">管理單一部署中的單一容器或虛擬機器 (VM) 很簡單。</span><span class="sxs-lookup"><span data-stu-id="85b71-109">The simplicity comes from managing a single deployment in a single container or virtual machine (VM).</span></span>

<span data-ttu-id="85b71-110">之後，容器會執行一個動作，並在其中一個處理序的主體，整合型模式處於衝突狀態。</span><span class="sxs-lookup"><span data-stu-id="85b71-110">Following the principal that a container does one thing only, and does it in one process, the monolithic pattern is in conflict.</span></span> <span data-ttu-id="85b71-111">您可以包含多個元件/程式庫或內部層級中每個容器，如所示的 圖 4-1。</span><span class="sxs-lookup"><span data-stu-id="85b71-111">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 4-1.</span></span>

![](./media/image1.png)

<span data-ttu-id="85b71-112">圖 4-1： 整合型應用程式架構的範例</span><span class="sxs-lookup"><span data-stu-id="85b71-112">Figure 4-1: An example of monolithic application architecture</span></span>

<span data-ttu-id="85b71-113">這種方法的缺點是，如果或應用程式成長而需要擴充。</span><span class="sxs-lookup"><span data-stu-id="85b71-113">The downside to this approach comes if or when the application grows, requiring it to scale.</span></span> <span data-ttu-id="85b71-114">若整個應用程式都擴充，則不成問題。</span><span class="sxs-lookup"><span data-stu-id="85b71-114">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="85b71-115">不過，在大部分情況下，應用程式的一些組件會阻礙，需要調整，而不使用其他元件。</span><span class="sxs-lookup"><span data-stu-id="85b71-115">However, in most cases, a few parts of the application are the choke points that require scaling, whereas other components are used less.</span></span>

<span data-ttu-id="85b71-116">使用一般的電子商務範例時，您可能需要的功能是擴充產品資訊元件。</span><span class="sxs-lookup"><span data-stu-id="85b71-116">Using the typical e-commerce example, what you likely need is to scale the product information component.</span></span> <span data-ttu-id="85b71-117">瀏覽產品的客戶比購買的人多。</span><span class="sxs-lookup"><span data-stu-id="85b71-117">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="85b71-118">比起使用付款管道，會有更多客戶使用其購物籃。</span><span class="sxs-lookup"><span data-stu-id="85b71-118">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="85b71-119">新增留言或檢視其購買歷程記錄的客戶較少。</span><span class="sxs-lookup"><span data-stu-id="85b71-119">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="85b71-120">而且您可能擁有只有少數幾個員工，在單一區域中，需要管理內容和行銷活動。</span><span class="sxs-lookup"><span data-stu-id="85b71-120">And you likely have only a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="85b71-121">藉由調整整合型設計，所有的程式碼會多次部署。</span><span class="sxs-lookup"><span data-stu-id="85b71-121">By scaling the monolithic design, all of the code is deployed multiple times.</span></span>

<span data-ttu-id="85b71-122">除了 「 小數位數-所有項目 」 問題，單一元件的變更需要完整重新測試整個應用程式，以及完整的重新部署的所有執行個體。</span><span class="sxs-lookup"><span data-stu-id="85b71-122">In addition to the "scale-everything" problem, changes to a single component require complete retesting of the entire application as well as a complete redeployment of all the instances.</span></span>

<span data-ttu-id="85b71-123">整合型方法很常見，和許多組織正在開發使用此架構的方法。</span><span class="sxs-lookup"><span data-stu-id="85b71-123">The monolithic approach is common, and many organizations are developing with this architectural method.</span></span> <span data-ttu-id="85b71-124">許多享有良好足夠的結果，而其他人遇到的限制。</span><span class="sxs-lookup"><span data-stu-id="85b71-124">Many enjoy good enough results, whereas others encounter limits.</span></span> <span data-ttu-id="85b71-125">許多設計其應用程式在此模型中的工具和基礎結構很難建置完成 Soa，因此他們也看需要-直到應用程式成長。</span><span class="sxs-lookup"><span data-stu-id="85b71-125">Many designed their applications in this model because the tools and infrastructure were too difficult to build SOAs, and they didn't see the need—until the app grew.</span></span>

<span data-ttu-id="85b71-126">基礎結構的觀點而言，每一部伺服器可以執行相同的主控件中的許多應用程式，並在您的資源使用量，有的效率可接受的比例，如所示 圖 4-2。</span><span class="sxs-lookup"><span data-stu-id="85b71-126">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in your resources usage, as shown in Figure 4-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="85b71-127">圖 4-2： 執行多個應用程式/容器的主機</span><span class="sxs-lookup"><span data-stu-id="85b71-127">Figure 4-2: A host running multiple apps/containers</span></span>

<span data-ttu-id="85b71-128">您可以針對每個執行個體使用專用的 Vm 部署在 Azure 中的整合型應用程式。</span><span class="sxs-lookup"><span data-stu-id="85b71-128">You can deploy monolithic applications in Azure by using dedicated VMs for each instance.</span></span> <span data-ttu-id="85b71-129">使用[Azure VM 擴展集](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)，您可以輕鬆地調整 Vm。</span><span class="sxs-lookup"><span data-stu-id="85b71-129">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can scale the VMs easily.</span></span> <span data-ttu-id="85b71-130">[Azure App Service](https://azure.microsoft.com/services/app-service/) 可以執行整合型應用程式並輕鬆地調整執行個體，而不必管理 VM。</span><span class="sxs-lookup"><span data-stu-id="85b71-130">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="85b71-131">自 2016，Azure App Service 可以執行單一執行個體的 Docker 容器，以簡化部署。</span><span class="sxs-lookup"><span data-stu-id="85b71-131">Since 2016, Azure App Services can run single instances of Docker containers, as well, simplifying the deployment.</span></span> <span data-ttu-id="85b71-132">而且，使用 Docker 時，您還可以部署單一 VM 作為 Docker 主機並執行多個執行個體。</span><span class="sxs-lookup"><span data-stu-id="85b71-132">And, using Docker, you can deploy a single VM as a Docker host and run multiple instances.</span></span> <span data-ttu-id="85b71-133">使用 Azure 平衡器，如所示在圖 4-3，您可以管理調整。</span><span class="sxs-lookup"><span data-stu-id="85b71-133">Using the Azure balancer, as illustrated in the Figure 4-3, you can manage scaling.</span></span>

![](./media/image3.png)

<span data-ttu-id="85b71-134">圖 4-3： 多部主機向外擴充單一 Docker 應用程式的應用程式/容器</span><span class="sxs-lookup"><span data-stu-id="85b71-134">Figure 4-3: Multiple hosts scaling-out a single Docker application apps/containers</span></span>

<span data-ttu-id="85b71-135">您可以管理不同主機透過傳統部署技術的部署。</span><span class="sxs-lookup"><span data-stu-id="85b71-135">You can manage the deployment to the various hosts via traditional deployment techniques.</span></span> <span data-ttu-id="85b71-136">您可以使用類似的命令來管理 Docker 主機`docker run`以手動的方式，透過我們稍後在本電子書中說明的持續傳遞 (CD) 管線等自動化。</span><span class="sxs-lookup"><span data-stu-id="85b71-136">You can manage Docker hosts by using commands like `docker run` manually, through automation such as Continuous Delivery (CD) pipelines, which we explain later in this e-book.</span></span>

## <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="85b71-137">整合型應用程式部署為容器</span><span class="sxs-lookup"><span data-stu-id="85b71-137">Monolithic application deployed as a container</span></span>

<span data-ttu-id="85b71-138">有許多使用容器來管理整合型部署的優點。</span><span class="sxs-lookup"><span data-stu-id="85b71-138">There are benefits to using containers to manage monolithic deployments.</span></span> <span data-ttu-id="85b71-139">調整容器執行個體遠比部署額外的 VM 更輕鬆快速。</span><span class="sxs-lookup"><span data-stu-id="85b71-139">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="85b71-140">雖然 VM 擴展集是很棒的功能，來調整 Vm，才能裝載 Docker 容器，它們就會需要時間來設定。</span><span class="sxs-lookup"><span data-stu-id="85b71-140">Although VM Scale Sets are a great feature to scale VMs, which are required to host your Docker containers, they take time to set up.</span></span> <span data-ttu-id="85b71-141">當部署為應用程式執行個體時，應用程式的設定是作為 VM 的一部分管理。</span><span class="sxs-lookup"><span data-stu-id="85b71-141">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="85b71-142">以 Docker 映像來部署更新會更快且網路效率更高。</span><span class="sxs-lookup"><span data-stu-id="85b71-142">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="85b71-143">Vn 執行個體可以設定相同主機上為您 Vn 1 執行個體中，排除新增額外的 Vm 所產生的成本。</span><span class="sxs-lookup"><span data-stu-id="85b71-143">The Vn instances can be set up on the same hosts as your Vn-1 instances, eliminating added costs resulting from additional VMs.</span></span> <span data-ttu-id="85b71-144">Docker 映像通常會啟動以秒為單位，因此可加速推出。</span><span class="sxs-lookup"><span data-stu-id="85b71-144">Docker images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="85b71-145">卸除 Docker 執行個體很簡單，只要叫用`docker stop`命令，通常少於一秒內完成。</span><span class="sxs-lookup"><span data-stu-id="85b71-145">Tearing down a Docker instance is as easy as invoking the `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="85b71-146">因為容器是原本就是不可變的根據設計，您永遠不必擔心 Vm 損毀，因為更新指令碼忘記處理部分特定設定或是磁碟上剩餘的檔案。</span><span class="sxs-lookup"><span data-stu-id="85b71-146">Because containers are inherently immutable, by design, you never need to worry about corrupted VMs because an update script forgot to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="85b71-147">雖然整合型應用程式可以從 Docker 獲益，我們要碰觸的優點的祕訣上。</span><span class="sxs-lookup"><span data-stu-id="85b71-147">Although monolithic apps can benefit from Docker, we're touching on only the tips of the benefits.</span></span> <span data-ttu-id="85b71-148">部署與管理各種不同的執行個體和每個容器執行個體的生命週期的容器 orchestrator 來自管理容器的較大的優勢。</span><span class="sxs-lookup"><span data-stu-id="85b71-148">The larger benefits of managing containers comes from deploying with container orchestrators that manage the various instances and life cycle of each container instance.</span></span> <span data-ttu-id="85b71-149">將整合型應用程式分成可個別擴充、開發及部署的多個子系統，是您開始使用微服務的不錯起點。</span><span class="sxs-lookup"><span data-stu-id="85b71-149">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

## <a name="publishing-a-single-docker-container-app-to-azure-app-service"></a><span data-ttu-id="85b71-150">將單一 Docker 容器應用程式發佈至 Azure App Service</span><span class="sxs-lookup"><span data-stu-id="85b71-150">Publishing a single Docker container app to Azure App Service</span></span>

<span data-ttu-id="85b71-151">可能是因為您想要取得的容器部署至 Azure 的快速驗證或因為應用程式只是單一容器應用程式，Azure App Service 提供適合用來提供可調整的單一容器服務。</span><span class="sxs-lookup"><span data-stu-id="85b71-151">Either because you want to get a quick validation of a container deployed to Azure or because the app is simply a single-container app, Azure App Services provides a great way to provide scalable single-container services.</span></span>

<span data-ttu-id="85b71-152">使用 Azure App Service 是直覺式，您可以啟動並快速執行，因為它提供絕佳的 Git 整合，以取得程式碼，建置在 Microsoft Visual Studio 中，並直接將它部署至 Azure。</span><span class="sxs-lookup"><span data-stu-id="85b71-152">Using Azure App Service is intuitive and you can get up and running quickly because it provides great Git integration to take your code, build it in Microsoft Visual Studio, and directly deploy it to Azure.</span></span> <span data-ttu-id="85b71-153">但傳統上 （使用任何 Docker)，視其他的功能、 架構或相依性，不支援的應用程式服務，您需要等待直到 Azure 團隊更新 App Service 中的這些相依性或切換到其他服務，例如Service Fabric、 雲端服務或甚至純文字的 Vm，您還有其他控制項和可以為您的應用程式安裝的必要的元件或架構。</span><span class="sxs-lookup"><span data-stu-id="85b71-153">But, traditionally (with no Docker), if you needed other capabilities, frameworks, or dependencies that aren't supported in App Services, you needed to wait for it until the Azure team updates those dependencies in App Service or switched to other services like Service Fabric, Cloud Services, or even plain VMs, for which you have further control and can install a required component or framework for your application.</span></span>

<span data-ttu-id="85b71-154">現在，不過 （宣佈在 Microsoft Connect 2016 在 2016 年 11 月） 和使用 Visual Studio 2017 時，在圖 4‑4 所示，在 Azure App Service 中的容器支援可讓您能夠包含任何您想要在您的應用程式環境中。</span><span class="sxs-lookup"><span data-stu-id="85b71-154">Now, however, (announced at Microsoft Connect 2016 in November 2016) and as shown in Figure 4‑4, when using Visual Studio 2017, container support in Azure App Service gives you the ability to include whatever you want in your app environment.</span></span> <span data-ttu-id="85b71-155">如果因為您在容器中執行它，您可以新增至您的應用程式的相依性，您會取得您的 Dockerfile 或 Docker 映像中包括這些相依性的功能。</span><span class="sxs-lookup"><span data-stu-id="85b71-155">If you added a dependency to your app, because you are running it in a container, you get the capability of including those dependencies in your Dockerfile or Docker image.</span></span>

![](./media/image4.png)

<span data-ttu-id="85b71-156">圖 4-4： 從 Visual Studio 應用程式/容器將容器發佈至 Azure App Service</span><span class="sxs-lookup"><span data-stu-id="85b71-156">Figure 4-4: Publishing a container to Azure App Service from Visual Studio apps/containers</span></span>

<span data-ttu-id="85b71-157">圖 4-4 也會顯示發行流程將透過容器登錄庫，它可以是 Azure Container Registry （登錄接近您在 Azure 中的部署和受保護的 Azure Active Directory 群組和帳戶） 或任何其他的 Docker 登錄的映像推送像是 Docker Hub 或內部部署的登錄。</span><span class="sxs-lookup"><span data-stu-id="85b71-157">Figure 4-4 also shows that the publish flow pushes an image through a Container Registry, which can be the Azure Container Registry (a registry near to your deployments in Azure and secured by Azure Active Directory groups and accounts) or any other Docker Registry like Docker Hub or on-premises registries.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="85b71-158">[上一頁](common-container-design-principles.md)
[下一頁](state-and-data-in-docker-applications.md)</span><span class="sxs-lookup"><span data-stu-id="85b71-158">[Previous](common-container-design-principles.md)
[Next](state-and-data-in-docker-applications.md)</span></span>
