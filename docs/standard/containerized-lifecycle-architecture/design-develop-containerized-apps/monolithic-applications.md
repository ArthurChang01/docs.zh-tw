---
title: "整合應用程式"
description: "Microsoft 平台和工具的容器化 Docker 應用程式生命週期"
keywords: "Docker, 微服務, ASP.NET, 容器"
author: CESARDELATORRE
ms.author: wiwagn
ms.date: 09/22/2017
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: 95561aaa8ffccb8eae3fe276192c6648c0819685
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/23/2017
---
# <a name="monolithic-applications"></a><span data-ttu-id="2e470-104">整合應用程式</span><span class="sxs-lookup"><span data-stu-id="2e470-104">Monolithic applications</span></span>

<span data-ttu-id="2e470-105">在此案例中，您會建置單一且整合的 web 應用程式或服務和部署的容器。</span><span class="sxs-lookup"><span data-stu-id="2e470-105">In this scenario, you are building a single and monolithic web application or service and deploying it as a container.</span></span> <span data-ttu-id="2e470-106">在應用程式結構可能不是整合;它可能由數個程式庫、 元件或甚至是圖層 （應用程式層級、 網域層級、 資料存取層等等） 所組成。</span><span class="sxs-lookup"><span data-stu-id="2e470-106">Within the application, the structure might not be monolithic; it might comprise several libraries, components, or even layers (application layer, domain layer, data access layer, etc.).</span></span> <span data-ttu-id="2e470-107">在外部，它是單一的容器，例如單一處理程序、 單一 web 應用程式或單一服務。</span><span class="sxs-lookup"><span data-stu-id="2e470-107">Externally, it is a single container, like a single process, single web application, or single service.</span></span>

<span data-ttu-id="2e470-108">若要管理此模型，您可以部署單一容器來表示應用程式。</span><span class="sxs-lookup"><span data-stu-id="2e470-108">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="2e470-109">若要調整它，只要加入與負載平衡器在前面的一些多個複本。</span><span class="sxs-lookup"><span data-stu-id="2e470-109">To scale it, just add a few more copies with a load balancer in front.</span></span> <span data-ttu-id="2e470-110">管理單一容器或虛擬機器 (VM) 中的單一部署來自簡易性。</span><span class="sxs-lookup"><span data-stu-id="2e470-110">The simplicity comes from managing a single deployment in a single container or virtual machine (VM).</span></span>

<span data-ttu-id="2e470-111">容器未一件事，而且沒有一個處理序中的主體，在整合模式處於衝突狀態。</span><span class="sxs-lookup"><span data-stu-id="2e470-111">Following the principal that a container does one thing only, and does it in one process, the monolithic pattern is in conflict.</span></span> <span data-ttu-id="2e470-112">圖 4-1 的說明，您可以包含多個元件/程式庫或每個容器，在內部層級。</span><span class="sxs-lookup"><span data-stu-id="2e470-112">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 4-1.</span></span>

![](./media/image1.png)

<span data-ttu-id="2e470-113">圖 4-1: 的範例應用程式整合架構</span><span class="sxs-lookup"><span data-stu-id="2e470-113">Figure 4-1: An example of monolithic application architecture</span></span>

<span data-ttu-id="2e470-114">這種方法的缺點是如果或當應用程式成長時，需要調整。</span><span class="sxs-lookup"><span data-stu-id="2e470-114">The downside to this approach comes if or when the application grows, requiring it to scale.</span></span> <span data-ttu-id="2e470-115">如果縮放整個應用程式，它並非真正的問題。</span><span class="sxs-lookup"><span data-stu-id="2e470-115">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="2e470-116">不過，在大部分情況下，應用程式的某些部分是淺壓深點需要調整，而較不使用其他元件的。</span><span class="sxs-lookup"><span data-stu-id="2e470-116">However, in most cases, a few parts of the application are the choke points that require scaling, whereas other components are used less.</span></span>

<span data-ttu-id="2e470-117">使用一般的電子商務範例，您可能需要什麼是調整的產品資訊的元件。</span><span class="sxs-lookup"><span data-stu-id="2e470-117">Using the typical e-commerce example, what you likely need is to scale the product information component.</span></span> <span data-ttu-id="2e470-118">更多其他客戶瀏覽產品，比購買。</span><span class="sxs-lookup"><span data-stu-id="2e470-118">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="2e470-119">更多的客戶使用及其購物籃，比使用付款管線。</span><span class="sxs-lookup"><span data-stu-id="2e470-119">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="2e470-120">較少的客戶加入註解或檢視其採購歷程記錄。</span><span class="sxs-lookup"><span data-stu-id="2e470-120">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="2e470-121">而且，您可能需要在少數幾個員工，在單一區域中，需要管理內容和行銷活動。</span><span class="sxs-lookup"><span data-stu-id="2e470-121">And you likely have only a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="2e470-122">藉由調整僵化設計，所有的程式碼是多次部署。</span><span class="sxs-lookup"><span data-stu-id="2e470-122">By scaling the monolithic design, all of the code is deployed multiple times.</span></span>

<span data-ttu-id="2e470-123">除了"小數位數的所有項目 」 問題，整個應用程式，以及完整的重新部署的所有執行個體的完整重新測試後必須變更單一元件。</span><span class="sxs-lookup"><span data-stu-id="2e470-123">In addition to the "scale-everything" problem, changes to a single component require complete retesting of the entire application as well as a complete redeployment of all the instances.</span></span>

<span data-ttu-id="2e470-124">是很常見，整合的方法，許多組織正在開發使用這個架構的方法。</span><span class="sxs-lookup"><span data-stu-id="2e470-124">The monolithic approach is common, and many organizations are developing with this architectural method.</span></span> <span data-ttu-id="2e470-125">許多享受良好足夠的結果，而其他人遇到的限制。</span><span class="sxs-lookup"><span data-stu-id="2e470-125">Many enjoy good enough results, whereas others encounter limits.</span></span> <span data-ttu-id="2e470-126">許多設計其應用程式在此模型，因為工具與基礎結構太難建置 SOAs，所以他們看不需要，直到應用程式成長。</span><span class="sxs-lookup"><span data-stu-id="2e470-126">Many designed their applications in this model because the tools and infrastructure were too difficult to build SOAs, and they didn't see the need—until the app grew.</span></span>

<span data-ttu-id="2e470-127">從基礎結構的觀點而言，每一部伺服器執行相同的主控件中的許多應用程式與您的資源使用量中, 有一個可接受比效率的如圖 4-2 所示。</span><span class="sxs-lookup"><span data-stu-id="2e470-127">From an infrastructure perspective, each server can run many applications within the same host and have an acceptable ratio of efficiency in your resources usage, as shown in Figure 4-2.</span></span>

![](./media/image2.png)

<span data-ttu-id="2e470-128">圖 4-2： 執行多個應用程式/容器的主機</span><span class="sxs-lookup"><span data-stu-id="2e470-128">Figure 4-2: A host running multiple apps/containers</span></span>

<span data-ttu-id="2e470-129">您可以使用專用的 Vm，每個執行個體部署在 Azure 中的整合應用程式。</span><span class="sxs-lookup"><span data-stu-id="2e470-129">You can deploy monolithic applications in Azure by using dedicated VMs for each instance.</span></span> <span data-ttu-id="2e470-130">使用[Azure VM 規模集](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)，您可以輕鬆地調整 Vm。</span><span class="sxs-lookup"><span data-stu-id="2e470-130">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can scale the VMs easily.</span></span> <span data-ttu-id="2e470-131">[Azure 應用程式服務](https://azure.microsoft.com/en-us/services/app-service/)可以執行整合的應用程式並輕鬆擴充執行個體，而不需要管理 Vm。</span><span class="sxs-lookup"><span data-stu-id="2e470-131">[Azure App Services](https://azure.microsoft.com/en-us/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="2e470-132">自 2016，Azure 應用程式服務可以執行單一執行個體的 Docker 容器，以及，簡化部署。</span><span class="sxs-lookup"><span data-stu-id="2e470-132">Since 2016, Azure App Services can run single instances of Docker containers, as well, simplifying the deployment.</span></span> <span data-ttu-id="2e470-133">然後使用 Docker 時，您可以部署單一 VM 做為 Docker 主機並執行多個執行個體。</span><span class="sxs-lookup"><span data-stu-id="2e470-133">And, using Docker, you can deploy a single VM as a Docker host and run multiple instances.</span></span> <span data-ttu-id="2e470-134">在圖 4-3 的說明，請使用 Azure 的平衡器，，您可以管理縮放比例。</span><span class="sxs-lookup"><span data-stu-id="2e470-134">Using the Azure balancer, as illustrated in the Figure 4-3, you can manage scaling.</span></span>

![](./media/image3.png)

<span data-ttu-id="2e470-135">圖 4-3： 多部主機向外擴充具有單一 Docker 應用程式的應用程式/容器</span><span class="sxs-lookup"><span data-stu-id="2e470-135">Figure 4-3: Multiple hosts scaling-out a single Docker application apps/containers</span></span>

<span data-ttu-id="2e470-136">您可以管理各種不同的主機，透過傳統部署技術的部署。</span><span class="sxs-lookup"><span data-stu-id="2e470-136">You can manage the deployment to the various hosts via traditional deployment techniques.</span></span> <span data-ttu-id="2e470-137">您可以使用類似的命令，以管理 Docker 主機`docker run`手動、 透過自動化，例如持續傳遞 (CD) 管線，我們說明稍後在本電子書。</span><span class="sxs-lookup"><span data-stu-id="2e470-137">You can manage Docker hosts by using commands like `docker run` manually, through automation such as Continuous Delivery (CD) pipelines, which we explain later in this e-book.</span></span>

## <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="2e470-138">整合應用程式部署為容器</span><span class="sxs-lookup"><span data-stu-id="2e470-138">Monolithic application deployed as a container</span></span>

<span data-ttu-id="2e470-139">有許多優點，若要使用容器來管理整合的部署。</span><span class="sxs-lookup"><span data-stu-id="2e470-139">There are benefits to using containers to manage monolithic deployments.</span></span> <span data-ttu-id="2e470-140">調整容器的執行個體是遠比快速而且容易部署額外的 Vm。</span><span class="sxs-lookup"><span data-stu-id="2e470-140">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="2e470-141">VM 規模集是很棒的功能，來調整 Vm，裝載所需 Docker 容器，但是它們會花時間設定。</span><span class="sxs-lookup"><span data-stu-id="2e470-141">Although VM Scale Sets are a great feature to scale VMs, which are required to host your Docker containers, they take time to set up.</span></span> <span data-ttu-id="2e470-142">當部署為應用程式執行個體，應用程式的組態管理 VM 的一部分。</span><span class="sxs-lookup"><span data-stu-id="2e470-142">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="2e470-143">部署更新的 Docker 映像的速度遠和有效率的網路。</span><span class="sxs-lookup"><span data-stu-id="2e470-143">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="2e470-144">Vn 執行個體可以設定相同主機上為您的 Vn 1 執行個體，因而不加入其他 Vm 所產生的成本。</span><span class="sxs-lookup"><span data-stu-id="2e470-144">The Vn instances can be set up on the same hosts as your Vn-1 instances, eliminating added costs resulting from additional VMs.</span></span> <span data-ttu-id="2e470-145">Docker 映像一開始通常以秒為單位，加速首度發行。</span><span class="sxs-lookup"><span data-stu-id="2e470-145">Docker images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="2e470-146">破壞的 Docker 執行個體非常簡單，只要叫用`docker stop`命令，通常少於一秒內完成。</span><span class="sxs-lookup"><span data-stu-id="2e470-146">Tearing down a Docker instance is as easy as invoking the `docker stop` command, typically completing in less than a second.</span></span>

<span data-ttu-id="2e470-147">由於容器本身不變的根據設計，永遠不需要擔心損毀的 Vm，因為某些特定的組態或檔案保留在磁碟上忘記更新指令碼。</span><span class="sxs-lookup"><span data-stu-id="2e470-147">Because containers are inherently immutable, by design, you never need to worry about corrupted VMs because an update script forgot to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="2e470-148">雖然整合的應用程式可受益於 Docker，我們要碰觸上好處的秘訣。</span><span class="sxs-lookup"><span data-stu-id="2e470-148">Although monolithic apps can benefit from Docker, we're touching on only the tips of the benefits.</span></span> <span data-ttu-id="2e470-149">部署與管理不同的執行個體和每個容器執行個體的生命週期的容器 orchestrators 來自管理容器的較大的優勢。</span><span class="sxs-lookup"><span data-stu-id="2e470-149">The larger benefits of managing containers comes from deploying with container orchestrators that manage the various instances and life cycle of each container instance.</span></span> <span data-ttu-id="2e470-150">整合應用程式子系統，可調整、 開發，而且個別部署成重大是 microservices 的領域您進入點。</span><span class="sxs-lookup"><span data-stu-id="2e470-150">Breaking up the monolithic application into subsystems that can be scaled, developed, and deployed individually is your entry point into the realm of microservices.</span></span>

## <a name="publishing-a-single-docker-container-app-to-azure-app-service"></a><span data-ttu-id="2e470-151">單一的 Docker 容器應用程式發行到 Azure 應用程式服務</span><span class="sxs-lookup"><span data-stu-id="2e470-151">Publishing a single Docker container app to Azure App Service</span></span>

<span data-ttu-id="2e470-152">可能是因為您想要取得快速部署至 Azure 容器驗證或因為應用程式只是單一容器應用程式，Azure 應用程式服務會提供以提供可擴充的單一容器服務的好方法。</span><span class="sxs-lookup"><span data-stu-id="2e470-152">Either because you want to get a quick validation of a container deployed to Azure or because the app is simply a single-container app, Azure App Services provides a great way to provide scalable single-container services.</span></span>

<span data-ttu-id="2e470-153">使用 Azure App Service 是直覺式可以啟動，且快速地執行，因為它提供絕佳的 Git 整合，以取得您的程式碼建置在 Microsoft Visual Studio 中，並直接將它部署至 Azure。</span><span class="sxs-lookup"><span data-stu-id="2e470-153">Using Azure App Service is intuitive and you can get up and running quickly because it provides great Git integration to take your code, build it in Microsoft Visual Studio, and directly deploy it to Azure.</span></span> <span data-ttu-id="2e470-154">但是，傳統 （使用任何 Docker)，如果您需要其他的功能、 架構或不支援的應用程式服務的相依性需要等候直到 Azure 團隊更新 App Service 中的相依性或切換到其他服務，例如Service Fabric、 雲端服務或甚至一般的 Vm，您有進一步的控制和可以安裝必要的元件或架構應用程式。</span><span class="sxs-lookup"><span data-stu-id="2e470-154">But, traditionally (with no Docker), if you needed other capabilities, frameworks, or dependencies that aren't supported in App Services, you needed to wait for it until the Azure team updates those dependencies in App Service or switched to other services like Service Fabric, Cloud Services, or even plain VMs, for which you have further control and can install a required component or framework for your application.</span></span>

<span data-ttu-id="2e470-155">現在，不過 （Microsoft Connect 2016 在 2016 年 11 月宣佈） 和使用 Visual Studio 2017 時，圖 4‑4 中所示，Azure App Service 中的容器支援可讓您以包含您要在應用程式環境中的任何。</span><span class="sxs-lookup"><span data-stu-id="2e470-155">Now, however, (announced at Microsoft Connect 2016 in November 2016) and as shown in Figure 4‑4, when using Visual Studio 2017, container support in Azure App Service gives you the ability to include whatever you want in your app environment.</span></span> <span data-ttu-id="2e470-156">如果因為您已經在容器中執行，您可以加入至您的應用程式的相依性，您會取得的功能包括 Dockerfile 或 Docker 映像中的這些相依性。</span><span class="sxs-lookup"><span data-stu-id="2e470-156">If you added a dependency to your app, because you are running it in a container, you get the capability of including those dependencies in your Dockerfile or Docker image.</span></span>

![](./media/image4.png)

<span data-ttu-id="2e470-157">圖 4-4： 從 Visual Studio 應用程式/容器將容器發行至 Azure App Service</span><span class="sxs-lookup"><span data-stu-id="2e470-157">Figure 4-4: Publishing a container to Azure App Service from Visual Studio apps/containers</span></span>

<span data-ttu-id="2e470-158">圖 4-4 也會顯示發行流程將推送透過容器登錄中，它可以是 Azure 容器登錄中 （登錄接近您在 Azure 中的部署和保護 Azure Active Directory 群組和帳戶） 或任何其他 Docker 登錄映像像 Docker Hub 或內部部署的登錄。</span><span class="sxs-lookup"><span data-stu-id="2e470-158">Figure 4-4 also shows that the publish flow pushes an image through a Container Registry, which can be the Azure Container Registry (a registry near to your deployments in Azure and secured by Azure Active Directory groups and accounts) or any other Docker Registry like Docker Hub or on-premises registries.</span></span>


>[!div class="step-by-step"]
<span data-ttu-id="2e470-159">[上一個](常見的容器-設計-principles.md) [下一步] (state-and-data-in-docker-applications.md)</span><span class="sxs-lookup"><span data-stu-id="2e470-159">[Previous] (common-container-design-principles.md) [Next] (state-and-data-in-docker-applications.md)</span></span>
