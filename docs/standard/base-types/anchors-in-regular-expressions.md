---
title: .NET 規則運算式中的錨點
description: 了解如何在規則運算式模式中使用錨點。
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- atomic zero-width assertions
- regular expressions, anchors
- regular expressions, atomic zero-width assertions
- anchors, in regular expressions
- metacharacters, atomic zero-width assertions
- metacharacters, anchors
- .NET Framework regular expressions, anchors
- .NET Framework regular expressions, atomic zero-width assertions
ms.assetid: 336391f6-2614-499b-8b1b-07a6837108a7
author: rpetrusha
ms.author: ronpet
ms.custom: seodec18
ms.openlocfilehash: f0e42c0032dc6f9dac0895a29db9de79547c0a49
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/23/2019
ms.locfileid: "54675344"
---
# <a name="anchors-in-regular-expressions"></a><span data-ttu-id="c9c4a-103">規則運算式中的錨點</span><span class="sxs-lookup"><span data-stu-id="c9c4a-103">Anchors in Regular Expressions</span></span>
<a name="top"></a> <span data-ttu-id="c9c4a-104">錨點或不可部分完成的無寬度判斷提示會指定字串中必須比對的位置。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-104">Anchors, or atomic zero-width assertions, specify a position in the string where a match must occur.</span></span> <span data-ttu-id="c9c4a-105">當您在搜尋運算式中使用錨點時，規則運算式引擎不會在字串中前進或使用字元；它只會尋找指定位置中的相符項目。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-105">When you use an anchor in your search expression, the regular expression engine does not advance through the string or consume characters; it looks for a match in the specified position only.</span></span> <span data-ttu-id="c9c4a-106">例如， `^` 指定必須從行首或字串的開頭開始比對。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-106">For example, `^` specifies that the match must start at the beginning of a line or string.</span></span> <span data-ttu-id="c9c4a-107">因此，僅當行首出現 "http:" 時，規則運算式 `^http:` 才會與其相符。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-107">Therefore, the regular expression `^http:` matches "http:" only when it occurs at the beginning of a line.</span></span> <span data-ttu-id="c9c4a-108">下表列出 .NET 中此規則運算式所支援的錨點。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-108">The following table lists the anchors supported by the regular expressions in .NET.</span></span>  
  
|<span data-ttu-id="c9c4a-109">錨點</span><span class="sxs-lookup"><span data-stu-id="c9c4a-109">Anchor</span></span>|<span data-ttu-id="c9c4a-110">說明</span><span class="sxs-lookup"><span data-stu-id="c9c4a-110">Description</span></span>|  
|------------|-----------------|  
|`^`|<span data-ttu-id="c9c4a-111">根據預設，比對必須發生在字串的開頭；在多行模式中，它必須發生在一行的開頭。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-111">By default, the match must occur at the beginning of the string; in multiline mode, it must occur at the beginning of the line.</span></span> <span data-ttu-id="c9c4a-112">如需詳細資訊，請參閱 [字串開頭或行首](#Start)。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-112">For more information, see [Start of String or Line](#Start).</span></span>|  
|`$`|<span data-ttu-id="c9c4a-113">根據預設，比對必須發生在字串的結尾或字串結尾的 `\n` 之前；在多行模式中，它必須發生在一行的結尾，或一行結尾的 `\n` 之前。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-113">By default, the match must occur at the end of the string or before `\n` at the end of the string; in multiline mode, it must occur at the end of the line or before `\n` at the end of the line.</span></span> <span data-ttu-id="c9c4a-114">如需詳細資訊，請參閱 [字串結尾或行尾](#End)。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-114">For more information, see [End of String or Line](#End).</span></span>|  
|`\A`|<span data-ttu-id="c9c4a-115">比對只能發生在字串的開頭 (不支援多行)。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-115">The match must occur at the beginning of the string only (no multiline support).</span></span> <span data-ttu-id="c9c4a-116">如需詳細資訊，請參閱 [僅字串開頭](#StartOnly)。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-116">For more information, see [Start of String Only](#StartOnly).</span></span>|  
|`\Z`|<span data-ttu-id="c9c4a-117">比對必須發生在字串結尾，或發生在字串結尾的 `\n` 之前。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-117">The match must occur at the end of the string, or before `\n` at the end of the string.</span></span> <span data-ttu-id="c9c4a-118">如需詳細資訊，請參閱 [字串結尾或結束新行之前](#EndOrNOnly)。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-118">For more information, see [End of String or Before Ending Newline](#EndOrNOnly).</span></span>|  
|`\z`|<span data-ttu-id="c9c4a-119">比對只能發生在字串結尾。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-119">The match must occur at the end of the string only.</span></span> <span data-ttu-id="c9c4a-120">如需詳細資訊，請參閱 [僅字串結尾](#EndOnly)。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-120">For more information, see [End of String Only](#EndOnly).</span></span>|  
|`\G`|<span data-ttu-id="c9c4a-121">比對必須從上一個比對結束的位置開始。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-121">The match must start at the position where the previous match ended.</span></span> <span data-ttu-id="c9c4a-122">如需詳細資訊，請參閱 [連續比對](#Contiguous)。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-122">For more information, see [Contiguous Matches](#Contiguous).</span></span>|  
|`\b`|<span data-ttu-id="c9c4a-123">比對必須發生在字邊界上。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-123">The match must occur on a word boundary.</span></span> <span data-ttu-id="c9c4a-124">如需詳細資訊，請參閱 [字邊界](#WordBoundary)。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-124">For more information, see [Word Boundary](#WordBoundary).</span></span>|  
|`\B`|<span data-ttu-id="c9c4a-125">比對不可發生在字邊界上。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-125">The match must not occur on a word boundary.</span></span> <span data-ttu-id="c9c4a-126">如需詳細資訊，請參閱 [非字邊界](#NonwordBoundary)。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-126">For more information, see [Non-Word Boundary](#NonwordBoundary).</span></span>|  
  
<a name="Start"></a>   
## <a name="start-of-string-or-line-"></a><span data-ttu-id="c9c4a-127">字串開頭或行首：^</span><span class="sxs-lookup"><span data-stu-id="c9c4a-127">Start of String or Line: ^</span></span>  
 <span data-ttu-id="c9c4a-128">根據預設，`^` 錨點可讓您指定下列模式必須從字串的第一個字元位置開始。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-128">By default, the `^` anchor specifies that the following pattern must begin at the first character position of the string.</span></span> <span data-ttu-id="c9c4a-129">如果您將 `^` 與 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 選項搭配使用 (請參閱[規則運算式選項](../../../docs/standard/base-types/regular-expression-options.md))，則比對必須發生在每一行的行首。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-129">If you use `^` with the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option (see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md)), the match must occur at the beginning of each line.</span></span>  
  
 <span data-ttu-id="c9c4a-130">下列範例會在規則運算式中使用 `^` 錨點，該規則運算式會擷取與某些職業棒球隊存在期間年份相關的資訊。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-130">The following example uses the `^` anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</span></span> <span data-ttu-id="c9c4a-131">此範例會呼叫 <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> 方法的兩個多載：</span><span class="sxs-lookup"><span data-stu-id="c9c4a-131">The example calls two overloads of the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method:</span></span>  
  
-   <span data-ttu-id="c9c4a-132">在符合規則運算式模式的輸入字串中，對 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> 多載的呼叫只會尋找其中的第一個子字串。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-132">The call to the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29> overload finds only the first substring in the input string that matches the regular expression pattern.</span></span>  
  
-   <span data-ttu-id="c9c4a-133">對 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> 參數的呼叫 ( `options` 參數設為 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> ) 會尋找所有五個子字串。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-133">The call to the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29> overload with the `options` parameter set to <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> finds all five substrings.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/startofstring1.cs#1)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/startofstring1.vb#1)]  
  
 <span data-ttu-id="c9c4a-134">規則運算式模式 `^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+` 的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-134">The regular expression pattern `^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+` is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="c9c4a-135">模式</span><span class="sxs-lookup"><span data-stu-id="c9c4a-135">Pattern</span></span>|<span data-ttu-id="c9c4a-136">說明</span><span class="sxs-lookup"><span data-stu-id="c9c4a-136">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="c9c4a-137">開始在輸入字串的開頭比對 (如果是使用 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 選項來呼叫此方法，則從行首開始比對)。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-137">Begin the match at the beginning of the input string (or the beginning of the line if the method is called with the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option).</span></span>|  
|`((\w+(\s?)){2,}`|<span data-ttu-id="c9c4a-138">比對一個或多個文字字元，後面接零，或接一個空格剛好兩次。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-138">Match one or more word characters followed either by zero or by one space exactly two times.</span></span> <span data-ttu-id="c9c4a-139">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-139">This is the first capturing group.</span></span> <span data-ttu-id="c9c4a-140">此運算式也定義了第二個和第三個擷取群組：第二個包含所擷取的文字，第三個則包含擷取到的空格。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-140">This expression also defines a second and third capturing group: The second consists of the captured word, and the third consists of the captured spaces.</span></span>|  
|`,\s`|<span data-ttu-id="c9c4a-141">比對後面接著空白字元的逗號。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-141">Match a comma followed by a white-space character.</span></span>|  
|`(\w+\s\w+)`|<span data-ttu-id="c9c4a-142">比對一或多個文字字元，後面接空格，再接一或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-142">Match one or more word characters followed by a space, followed by one or more word characters.</span></span> <span data-ttu-id="c9c4a-143">這是第四個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-143">This is the fourth capturing group.</span></span>|  
|`,`|<span data-ttu-id="c9c4a-144">比對逗號。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-144">Match a comma.</span></span>|  
|`\s\d{4}`|<span data-ttu-id="c9c4a-145">比對後面接著四個十進位數字的空格。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-145">Match a space followed by four decimal digits.</span></span>|  
|<code>(-(\d{4}&#124;present))?</code>|<span data-ttu-id="c9c4a-146">比對出現零次或一次的連字號，後面接著四個十進位數字或字串 "present"。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-146">Match zero or one occurrence of a hyphen followed by four decimal digits or the string "present".</span></span> <span data-ttu-id="c9c4a-147">這是第六個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-147">This is the sixth capturing group.</span></span> <span data-ttu-id="c9c4a-148">它也包括第七個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-148">It also includes a seventh capturing group.</span></span>|  
|`,?`|<span data-ttu-id="c9c4a-149">比對出現零次或一次的逗號。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-149">Match zero or one occurrence of a comma.</span></span>|  
|<code>(\s\d{4}(-(\d{4}&#124;present))?,?)+</code>|<span data-ttu-id="c9c4a-150">比對出現一或多次的下列項目：空格、四個十進位數字、出現零或一次的連字號 (該連字號後面接著四個十進位數字或字串 "present")，以及零或一個逗號。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-150">Match one or more occurrences of the following: a space, four decimal digits, zero or one occurrence of a hyphen followed by four decimal digits or the string "present", and zero or one comma.</span></span> <span data-ttu-id="c9c4a-151">這是第五個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-151">This is the fifth capturing group.</span></span>|  
  
 [<span data-ttu-id="c9c4a-152">回到頁首</span><span class="sxs-lookup"><span data-stu-id="c9c4a-152">Back to top</span></span>](#top)  
  
<a name="End"></a>   
## <a name="end-of-string-or-line-"></a><span data-ttu-id="c9c4a-153">字串結尾或行尾：$</span><span class="sxs-lookup"><span data-stu-id="c9c4a-153">End of String or Line: $</span></span>  
 <span data-ttu-id="c9c4a-154">`$` 錨點指定前述的模式必須發生在輸入字串的結尾，或輸入字串結尾的 `\n` 之前。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-154">The `$` anchor specifies that the preceding pattern must occur at the end of the input string, or before `\n` at the end of the input string.</span></span>  
  
 <span data-ttu-id="c9c4a-155">如果您將 `$` 與 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 選項搭配使用，則該比對也會在行尾發生。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-155">If you use `$` with the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option, the match can also occur at the end of a line.</span></span> <span data-ttu-id="c9c4a-156">請注意， `$` 會比對 `\n` ，但不會比對 `\r\n` (歸位字元與新行字元的組合，亦即 CR/LF)。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-156">Note that `$` matches `\n` but does not match `\r\n` (the combination of carriage return and newline characters, or CR/LF).</span></span> <span data-ttu-id="c9c4a-157">若要比對 CR/LF 字元組合，請在規則運算式模式中包含 `\r?$` 。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-157">To match the CR/LF character combination, include `\r?$` in the regular expression pattern.</span></span>  
  
 <span data-ttu-id="c9c4a-158">下列範例會將 `$` 錨點加入 [字串開頭或行首](#Start) 一節中範例所使用的規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-158">The following example adds the `$` anchor to the regular expression pattern used in the example in the [Start of String or Line](#Start) section.</span></span> <span data-ttu-id="c9c4a-159">當與原始的輸入字串 (包括五行文字) 搭配使用時， <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> 方法會找不到相符項目，因為第一行的結尾不符合 `$` 模式。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-159">When used with the original input string, which includes five lines of text, the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> method is unable to find a match, because the end of the first line does not match the `$` pattern.</span></span> <span data-ttu-id="c9c4a-160">當原始的輸入字串分割成字串陣列時， <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> 方法會成功地比對這五行。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-160">When the original input string is split into a string array, the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%29?displayProperty=nameWithType> method succeeds in matching each of the five lines.</span></span> <span data-ttu-id="c9c4a-161">當呼叫 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 方法且 `options` 參數設定為 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>時，會找不到相符項目，因為規則運算式模式並不考慮歸位字元項目 (\u+000D)。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-161">When the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method is called with the `options` parameter set to <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType>, no matches are found because the regular expression pattern does not account for the carriage return element (\u+000D).</span></span> <span data-ttu-id="c9c4a-162">不過，在將 `$` 取代為 `\r?$`來修改規則運算式模式時，將 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 參數再次設定為 `options` 來呼叫 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 方法，則會找出五個相符項目。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-162">However, when the regular expression pattern is modified by replacing `$` with `\r?$`, calling the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method with the `options` parameter set to <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> again finds five matches.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/endofstring1.cs#2)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/endofstring1.vb#2)]  
  
 [<span data-ttu-id="c9c4a-163">回到頁首</span><span class="sxs-lookup"><span data-stu-id="c9c4a-163">Back to top</span></span>](#top)  
  
<a name="StartOnly"></a>   
## <a name="start-of-string-only-a"></a><span data-ttu-id="c9c4a-164">僅字串開頭：\A</span><span class="sxs-lookup"><span data-stu-id="c9c4a-164">Start of String Only: \A</span></span>  
 <span data-ttu-id="c9c4a-165">`\A` 錨點指定比對必須發生在輸入字串的開頭。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-165">The `\A` anchor specifies that a match must occur at the beginning of the input string.</span></span> <span data-ttu-id="c9c4a-166">它與 `^` 錨點相同，不同處在於 `\A` 會忽略 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 選項。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-166">It is identical to the `^` anchor, except that `\A` ignores the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="c9c4a-167">因此，它可以只比對多行輸入字串中第一行的行首。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-167">Therefore, it can only match the start of the first line in a multiline input string.</span></span>  
  
 <span data-ttu-id="c9c4a-168">下列範例是類似於 `^` 和 `$` 錨點的範例。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-168">The following example is similar to the examples for the `^` and `$` anchors.</span></span> <span data-ttu-id="c9c4a-169">它會在規則運算式中使用 `\A` 錨點，該規則運算式會擷取與某些職業棒球隊存在期間年份相關的資訊。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-169">It uses the `\A` anchor in a regular expression that extracts information about the years during which some professional baseball teams existed.</span></span> <span data-ttu-id="c9c4a-170">輸入字串包含五行。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-170">The input string includes five lines.</span></span> <span data-ttu-id="c9c4a-171">在符合規則運算式模式的輸入字串中，對 <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> 方法的呼叫只會尋找其中的第一個子字串。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-171">The call to the <xref:System.Text.RegularExpressions.Regex.Matches%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.RegexOptions%29?displayProperty=nameWithType> method finds only the first substring in the input string that matches the regular expression pattern.</span></span> <span data-ttu-id="c9c4a-172">如範例所示， <xref:System.Text.RegularExpressions.RegexOptions.Multiline> 選項不會有任何作用。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-172">As the example shows, the <xref:System.Text.RegularExpressions.RegexOptions.Multiline> option has no effect.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/startofstring2.cs#3)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/startofstring2.vb#3)]  
  
 [<span data-ttu-id="c9c4a-173">回到頁首</span><span class="sxs-lookup"><span data-stu-id="c9c4a-173">Back to top</span></span>](#top)  
  
<a name="EndOrNOnly"></a>   
## <a name="end-of-string-or-before-ending-newline-z"></a><span data-ttu-id="c9c4a-174">字串結尾或結束新行之前：\Z</span><span class="sxs-lookup"><span data-stu-id="c9c4a-174">End of String or Before Ending Newline: \Z</span></span>  
 <span data-ttu-id="c9c4a-175">`\Z` 錨點指定比對必須發生在輸入字串的結尾，或在輸入字串結尾的 `\n` 之前。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-175">The `\Z` anchor specifies that a match must occur at the end of the input string, or before `\n` at the end of the input string.</span></span> <span data-ttu-id="c9c4a-176">它與 `$` 錨點相同，不同處在於 `\Z` 會忽略 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 選項。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-176">It is identical to the `$` anchor, except that `\Z` ignores the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="c9c4a-177">因此在多行字串中，它只會比對最後一行的結尾，或 `\n`前的上一行。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-177">Therefore, in a multiline string, it can only match the end of the last line, or the last line before `\n`.</span></span>  
  
 <span data-ttu-id="c9c4a-178">請注意， `\Z` 會比對 `\n` ，但不會比對 `\r\n` (CR/LF 字元組合)。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-178">Note that `\Z` matches `\n` but does not match `\r\n` (the CR/LF character combination).</span></span> <span data-ttu-id="c9c4a-179">若要比對 CR/LF，請將 `\r?\Z` 包含在規則運算式模式中。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-179">To match CR/LF, include `\r?\Z` in the regular expression pattern.</span></span>  
  
 <span data-ttu-id="c9c4a-180">下列範例會在規則運算式中使用 `\Z` 錨點，該規則運算式與 [字串開頭或行首](#Start) 一節中的範例類似，會擷取與某些職業棒球隊存在期間年份相關的資訊。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-180">The following example uses the `\Z` anchor in a regular expression that is similar to the example in the [Start of String or Line](#Start) section, which extracts information about the years during which some professional baseball teams existed.</span></span> <span data-ttu-id="c9c4a-181">規則運算式 `\r?\Z` 中的子運算式 `^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\Z` 會比對字串的結尾，也會比對以 `\n` 或 `\r\n`結尾的字串。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-181">The subexpression `\r?\Z` in the regular expression `^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\Z` matches the end of a string, and also matches a string that ends with `\n` or `\r\n`.</span></span> <span data-ttu-id="c9c4a-182">如此一來，陣列中的每個項目都會符合規則運算式模式。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-182">As a result, each element in the array matches the regular expression pattern.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/endofstring2.cs#4)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/endofstring2.vb#4)]  
  
 [<span data-ttu-id="c9c4a-183">回到頁首</span><span class="sxs-lookup"><span data-stu-id="c9c4a-183">Back to top</span></span>](#top)  
  
<a name="EndOnly"></a>   
## <a name="end-of-string-only-z"></a><span data-ttu-id="c9c4a-184">僅字串結尾：\z</span><span class="sxs-lookup"><span data-stu-id="c9c4a-184">End of String Only: \z</span></span>  
 <span data-ttu-id="c9c4a-185">`\z` 錨點指定比對必須發生在輸入字串的結尾。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-185">The `\z` anchor specifies that a match must occur at the end of the input string.</span></span> <span data-ttu-id="c9c4a-186">與 `$` 語言項目相同， `\z` 會忽略 <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> 選項。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-186">Like the `$` language element, `\z` ignores the <xref:System.Text.RegularExpressions.RegexOptions.Multiline?displayProperty=nameWithType> option.</span></span> <span data-ttu-id="c9c4a-187">不像 `\Z` 語言項目， `\z` 不會比對字串結尾處的 `\n` 字元。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-187">Unlike the `\Z` language element, `\z` does not match a `\n` character at the end of a string.</span></span> <span data-ttu-id="c9c4a-188">因此，它可以只比對輸入字串的最後一行。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-188">Therefore, it can only match the last line of the input string.</span></span>  
  
 <span data-ttu-id="c9c4a-189">下列範例會在規則運算式中使用 `\z` 錨點，該規則運算式與上一節中的範例不同，它會擷取與某些職業棒球隊存在期間年份相關的資訊。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-189">The following example uses the `\z` anchor in a regular expression that is otherwise identical to the example in the previous section, which extracts information about the years during which some professional baseball teams existed.</span></span> <span data-ttu-id="c9c4a-190">這個範例會將字串陣列中的五個項目與規則運算模式 `^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\z`進行比對。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-190">The example tries to match each of five elements in a string array with the regular expression pattern `^((\w+(\s?)){2,}),\s(\w+\s\w+),(\s\d{4}(-(\d{4}|present))?,?)+\r?\z`.</span></span> <span data-ttu-id="c9c4a-191">有兩個字串以歸位字元與換行字元結尾，一個字串以換行字元結尾，以及兩個字串不以歸位字元也不以換行字元結尾。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-191">Two of the strings end with carriage return and line feed characters, one ends with a line feed character, and two end with neither a carriage return nor a line feed character.</span></span> <span data-ttu-id="c9c4a-192">如輸出所示，只有不含歸位字元或換行字元的字串會符合模式。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-192">As the output shows, only the strings without a carriage return or line feed character match the pattern.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/endofstring3.cs#5)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/endofstring3.vb#5)]  
  
 [<span data-ttu-id="c9c4a-193">回到頁首</span><span class="sxs-lookup"><span data-stu-id="c9c4a-193">Back to top</span></span>](#top)  
  
<a name="Contiguous"></a>   
## <a name="contiguous-matches-g"></a><span data-ttu-id="c9c4a-194">連續比對：\G</span><span class="sxs-lookup"><span data-stu-id="c9c4a-194">Contiguous Matches: \G</span></span>  
 <span data-ttu-id="c9c4a-195">`\G` 錨點指定比對必須發生在上一個比對結束的點。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-195">The `\G` anchor specifies that a match must occur at the point where the previous match ended.</span></span> <span data-ttu-id="c9c4a-196">當您將此錨點配合 <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> 或 <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> 方法使用時，它可確保所有相符項目是連續的。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-196">When you use this anchor with the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> or <xref:System.Text.RegularExpressions.Match.NextMatch%2A?displayProperty=nameWithType> method, it ensures that all matches are contiguous.</span></span>  
  
 <span data-ttu-id="c9c4a-197">下列範例會使用規則運算式從逗點分隔的字串中擷取齧齒動物物種的名稱。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-197">The following example uses a regular expression to extract the names of rodent species from a comma-delimited string.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/contiguous1.cs#6)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/contiguous1.vb#6)]  
  
 <span data-ttu-id="c9c4a-198">規則運算式 `\G(\w+\s?\w*),?` 的解譯方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-198">The regular expression `\G(\w+\s?\w*),?` is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="c9c4a-199">模式</span><span class="sxs-lookup"><span data-stu-id="c9c4a-199">Pattern</span></span>|<span data-ttu-id="c9c4a-200">說明</span><span class="sxs-lookup"><span data-stu-id="c9c4a-200">Description</span></span>|  
|-------------|-----------------|  
|`\G`|<span data-ttu-id="c9c4a-201">從上一次比對結束的地方開始。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-201">Begin where the last match ended.</span></span>|  
|`\w+`|<span data-ttu-id="c9c4a-202">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-202">Match one or more word characters.</span></span>|  
|`\s?`|<span data-ttu-id="c9c4a-203">比對零或一個空格。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-203">Match zero or one space.</span></span>|  
|`\w*`|<span data-ttu-id="c9c4a-204">比對零個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-204">Match zero or more word characters.</span></span>|  
|`(\w+\s?\w*)`|<span data-ttu-id="c9c4a-205">比對一或多個文字字元，後面接零或一個空格，再接零或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-205">Match one or more word characters followed by zero or one space, followed by zero or more word characters.</span></span> <span data-ttu-id="c9c4a-206">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-206">This is the first capturing group.</span></span>|  
|`,?`|<span data-ttu-id="c9c4a-207">比對出現零次或一次的常值逗號字元。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-207">Match zero or one occurrence of a literal comma character.</span></span>|  
  
 [<span data-ttu-id="c9c4a-208">回到頁首</span><span class="sxs-lookup"><span data-stu-id="c9c4a-208">Back to top</span></span>](#top)  
  
<a name="WordBoundary"></a>   
## <a name="word-boundary-b"></a><span data-ttu-id="c9c4a-209">字邊界：\b</span><span class="sxs-lookup"><span data-stu-id="c9c4a-209">Word Boundary: \b</span></span>  
 <span data-ttu-id="c9c4a-210">`\b` 錨點指定比對必須發生在文字字元 ( `\w` 語言項目) 和非文字字元 ( `\W` 語言項目) 之間的邊界上。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-210">The `\b` anchor specifies that the match must occur on a boundary between a word character (the `\w` language element) and a non-word character (the `\W` language element).</span></span> <span data-ttu-id="c9c4a-211">文字字元由英數字元及底線所組成；非文字字元是非英數字元或底線的任何字元。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-211">Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore.</span></span> <span data-ttu-id="c9c4a-212">(如需詳細資訊，請參閱[字元類別](../../../docs/standard/base-types/character-classes-in-regular-expressions.md)。)比對也可能會在字串開頭或結尾的字邊界上發生。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-212">(For more information, see [Character Classes](../../../docs/standard/base-types/character-classes-in-regular-expressions.md).) The match may also occur on a word boundary at the beginning or end of the string.</span></span>  
  
 <span data-ttu-id="c9c4a-213">`\b` 錨點經常用來確保子運算式會比對整個字組，而非只比對字組的開頭或結尾。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-213">The `\b` anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</span></span> <span data-ttu-id="c9c4a-214">在下列範例中的規則運算式 `\bare\w*\b` 說明這個的使用方式。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-214">The regular expression `\bare\w*\b` in the following example illustrates this usage.</span></span> <span data-ttu-id="c9c4a-215">它會比對任何以子字串 "are" 為開頭的字組。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-215">It matches any word that begins with the substring "are".</span></span> <span data-ttu-id="c9c4a-216">範例的輸出也說明了 `\b` 會比對輸入字串的開頭和結尾。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-216">The output from the example also illustrates that `\b` matches both the beginning and the end of the input string.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/word1.cs#7)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/word1.vb#7)]  
  
 <span data-ttu-id="c9c4a-217">規則運算式模式的解譯方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-217">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="c9c4a-218">模式</span><span class="sxs-lookup"><span data-stu-id="c9c4a-218">Pattern</span></span>|<span data-ttu-id="c9c4a-219">說明</span><span class="sxs-lookup"><span data-stu-id="c9c4a-219">Description</span></span>|  
|-------------|-----------------|  
|`\b`|<span data-ttu-id="c9c4a-220">開始字緣比對。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-220">Begin the match at a word boundary.</span></span>|  
|`are`|<span data-ttu-id="c9c4a-221">比對子字串 "are"。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-221">Match the substring "are".</span></span>|  
|`\w*`|<span data-ttu-id="c9c4a-222">比對零個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-222">Match zero or more word characters.</span></span>|  
|`\b`|<span data-ttu-id="c9c4a-223">結束字緣比對。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-223">End the match at a word boundary.</span></span>|  
  
 [<span data-ttu-id="c9c4a-224">回到頁首</span><span class="sxs-lookup"><span data-stu-id="c9c4a-224">Back to top</span></span>](#top)  
  
<a name="NonwordBoundary"></a>   
## <a name="non-word-boundary-b"></a><span data-ttu-id="c9c4a-225">非字邊界：\B</span><span class="sxs-lookup"><span data-stu-id="c9c4a-225">Non-Word Boundary: \B</span></span>  
 <span data-ttu-id="c9c4a-226">`\B` 錨點指定比對不得發生在字邊界上。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-226">The `\B` anchor specifies that the match must not occur on a word boundary.</span></span> <span data-ttu-id="c9c4a-227">這和 `\b` 錨點相反。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-227">It is the opposite of the `\b` anchor.</span></span>  
  
 <span data-ttu-id="c9c4a-228">下列範例使用 `\B` 錨點來尋找在字組中出現的子字串 "qu"。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-228">The following example uses the `\B` anchor to locate occurrences of the substring "qu" in a word.</span></span> <span data-ttu-id="c9c4a-229">規則運算式模式 `\Bqu\w+` 會比對以 "qu" 開頭的子字串，其中字組開頭並非 "qu"，並且會繼續比對到字組的結尾。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-229">The regular expression pattern `\Bqu\w+` matches a substring that begins with a "qu" that does not start a word and that continues to the end of the word.</span></span>  
  
 [!code-csharp[Conceptual.RegEx.Language.Assertions#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regex.language.assertions/cs/nonword1.cs#8)]
 [!code-vb[Conceptual.RegEx.Language.Assertions#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regex.language.assertions/vb/nonword1.vb#8)]  
  
 <span data-ttu-id="c9c4a-230">規則運算式模式的解譯方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-230">The regular expression pattern is interpreted as shown in the following table.</span></span>  
  
|<span data-ttu-id="c9c4a-231">模式</span><span class="sxs-lookup"><span data-stu-id="c9c4a-231">Pattern</span></span>|<span data-ttu-id="c9c4a-232">說明</span><span class="sxs-lookup"><span data-stu-id="c9c4a-232">Description</span></span>|  
|-------------|-----------------|  
|`\B`|<span data-ttu-id="c9c4a-233">不要在字邊界開始比對。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-233">Do not begin the match at a word boundary.</span></span>|  
|`qu`|<span data-ttu-id="c9c4a-234">比對子字串 "qu"。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-234">Match the substring "qu".</span></span>|  
|`\w+`|<span data-ttu-id="c9c4a-235">比對一個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="c9c4a-235">Match one or more word characters.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="c9c4a-236">另請參閱</span><span class="sxs-lookup"><span data-stu-id="c9c4a-236">See also</span></span>

- [<span data-ttu-id="c9c4a-237">規則運算式語言 - 快速參考</span><span class="sxs-lookup"><span data-stu-id="c9c4a-237">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)
- [<span data-ttu-id="c9c4a-238">規則運算式選項</span><span class="sxs-lookup"><span data-stu-id="c9c4a-238">Regular Expression Options</span></span>](../../../docs/standard/base-types/regular-expression-options.md)
