---
title: .NET 規則運算式中的回溯
description: 了解如何控制回溯規則運算式模式比對。
ms.date: 11/12/2018
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- .NET Framework regular expressions, backtracking
- alternative matching patterns
- optional matching patterns
- searching with regular expressions, backtracking
- pattern-matching with regular expressions, backtracking
- backtracking
- regular expressions [.NET Framework], backtracking
- strings [.NET Framework], regular expressions
- parsing text with regular expressions, backtracking
ms.assetid: 34df1152-0b22-4a1c-a76c-3c28c47b70d8
author: rpetrusha
ms.author: ronpet
ms.custom: seodec18
ms.openlocfilehash: 3a61c65b108cba6bb256949a120afc76b58949f2
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/10/2018
ms.locfileid: "53130087"
---
# <a name="backtracking-in-regular-expressions"></a><span data-ttu-id="08aad-103">規則運算式中的回溯</span><span class="sxs-lookup"><span data-stu-id="08aad-103">Backtracking in Regular Expressions</span></span>
<a name="top"></a> <span data-ttu-id="08aad-104">回溯 (Backtracking) 會在規則運算式模式包含選擇性的 [數量詞](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) 或 [交替建構](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)，且規則運算式引擎返回之前儲存的狀態繼續搜尋相符項目時發生。</span><span class="sxs-lookup"><span data-stu-id="08aad-104">Backtracking occurs when a regular expression pattern contains optional [quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md) or [alternation constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md), and the regular expression engine returns to a previous saved state to continue its search for a match.</span></span> <span data-ttu-id="08aad-105">回溯是規則運算式的核心能力，可讓運算式功能強大且靈活，並且比對非常複雜的模式。</span><span class="sxs-lookup"><span data-stu-id="08aad-105">Backtracking is central to the power of regular expressions; it makes it possible for expressions to be powerful and flexible, and to match very complex patterns.</span></span> <span data-ttu-id="08aad-106">但同時，這項強大功能需付出相當的代價。</span><span class="sxs-lookup"><span data-stu-id="08aad-106">At the same time, this power comes at a cost.</span></span> <span data-ttu-id="08aad-107">回溯經常是影響規則運算式引擎之效能最重要的一項因素。</span><span class="sxs-lookup"><span data-stu-id="08aad-107">Backtracking is often the single most important factor that affects the performance of the regular expression engine.</span></span> <span data-ttu-id="08aad-108">幸好開發人員能夠掌控規則運算式引擎的行為，以及其使用回溯的方式。</span><span class="sxs-lookup"><span data-stu-id="08aad-108">Fortunately, the developer has control over the behavior of the regular expression engine and how it uses backtracking.</span></span> <span data-ttu-id="08aad-109">本主題將說明回溯運作的方式，以及如何進行控制。</span><span class="sxs-lookup"><span data-stu-id="08aad-109">This topic explains how backtracking works and how it can be controlled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="08aad-110">大致而言，像是 .NET 規則運算式引擎這類非決定性有限自動化 (NFA) 引擎將設計有效率且快速之規則運算式的責任交給了開發人員。</span><span class="sxs-lookup"><span data-stu-id="08aad-110">In general, a Nondeterministic Finite Automaton (NFA) engine like .NET regular expression engine places the responsibility for crafting efficient, fast regular expressions on the developer.</span></span>  
  
 <span data-ttu-id="08aad-111">此主題包括下列章節：</span><span class="sxs-lookup"><span data-stu-id="08aad-111">This topic contains the following sections:</span></span>  
  
-   [<span data-ttu-id="08aad-112">不進行回溯的線性比較</span><span class="sxs-lookup"><span data-stu-id="08aad-112">Linear Comparison Without Backtracking</span></span>](#linear_comparison_without_backtracking)  
  
-   [<span data-ttu-id="08aad-113">含有選擇性數量詞或交替建構的回溯</span><span class="sxs-lookup"><span data-stu-id="08aad-113">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>](#backtracking_with_optional_quantifiers_or_alternation_constructs)  
  
-   [<span data-ttu-id="08aad-114">含有巢狀選擇性數量詞的回溯</span><span class="sxs-lookup"><span data-stu-id="08aad-114">Backtracking with Nested Optional Quantifiers</span></span>](#backtracking_with_nested_optional_quantifiers)  
  
-   [<span data-ttu-id="08aad-115">控制回溯</span><span class="sxs-lookup"><span data-stu-id="08aad-115">Controlling Backtracking</span></span>](#controlling_backtracking)  
  
<a name="linear_comparison_without_backtracking"></a>   
## <a name="linear-comparison-without-backtracking"></a><span data-ttu-id="08aad-116">不進行回溯的線性比較</span><span class="sxs-lookup"><span data-stu-id="08aad-116">Linear Comparison Without Backtracking</span></span>  
 <span data-ttu-id="08aad-117">如果規則運算式模式沒有選擇性數量詞或交替建構，則規則運算式引擎會以線性時間執行。</span><span class="sxs-lookup"><span data-stu-id="08aad-117">If a regular expression pattern has no optional quantifiers or alternation constructs, the regular expression engine executes in linear time.</span></span> <span data-ttu-id="08aad-118">也就是說，規則運算式引擎比對模式中的第一個語言項目與輸入字串中的文字之後，會嘗試比對模式中的下一個語言項目與輸入字串中的下一個字元或字元群組。</span><span class="sxs-lookup"><span data-stu-id="08aad-118">That is, after the regular expression engine matches the first language element in the pattern with text in the input string, it tries to match the next language element in the pattern with the next character or group of characters in the input string.</span></span> <span data-ttu-id="08aad-119">這項作業會繼續進行，直到比對成功或失敗為止。</span><span class="sxs-lookup"><span data-stu-id="08aad-119">This continues until the match either succeeds or fails.</span></span> <span data-ttu-id="08aad-120">無論成功或失敗，規則運算式引擎都會在輸入字串中一次前進一個字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-120">In either case, the regular expression engine advances by one character at a time in the input string.</span></span>  
  
 <span data-ttu-id="08aad-121">下列範例提供一個實例。</span><span class="sxs-lookup"><span data-stu-id="08aad-121">The following example provides an illustration.</span></span> <span data-ttu-id="08aad-122">規則運算式 `e{2}\w\b` 會尋找兩個出現字母 "e" 的位置，這後面接著任何文字字元，然後再接著字邊界。</span><span class="sxs-lookup"><span data-stu-id="08aad-122">The regular expression `e{2}\w\b` looks for two occurrences of the letter "e" followed by any word character followed by a word boundary.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking1.cs#1)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking1.vb#1)]  
  
 <span data-ttu-id="08aad-123">雖然這個規則運算式包括數量詞 `{2}`，但仍然會以線性方式進行評估。</span><span class="sxs-lookup"><span data-stu-id="08aad-123">Although this regular expression includes the quantifier `{2}`, it is evaluated in a linear manner.</span></span> <span data-ttu-id="08aad-124">規則運算式引擎不會回溯，因為 `{2}` 不是選擇性的數量詞，它指定了確切的數字，而不是前面的子運算式必須比對的可變次數。</span><span class="sxs-lookup"><span data-stu-id="08aad-124">The regular expression engine does not backtrack because `{2}` is not an optional quantifier; it specifies an exact number and not a variable number of times that the previous subexpression must match.</span></span> <span data-ttu-id="08aad-125">因此，規則運算式引擎會嘗試比對規則運算式模式與輸入字串，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="08aad-125">As a result, the regular expression engine tries to match the regular expression pattern with the input string as shown in the following table.</span></span>  
  
|<span data-ttu-id="08aad-126">作業</span><span class="sxs-lookup"><span data-stu-id="08aad-126">Operation</span></span>|<span data-ttu-id="08aad-127">模式中的位置</span><span class="sxs-lookup"><span data-stu-id="08aad-127">Position in pattern</span></span>|<span data-ttu-id="08aad-128">字串中的位置</span><span class="sxs-lookup"><span data-stu-id="08aad-128">Position in string</span></span>|<span data-ttu-id="08aad-129">結果</span><span class="sxs-lookup"><span data-stu-id="08aad-129">Result</span></span>|  
|---------------|-------------------------|------------------------|------------|  
|<span data-ttu-id="08aad-130">1</span><span class="sxs-lookup"><span data-stu-id="08aad-130">1</span></span>|<span data-ttu-id="08aad-131">e</span><span class="sxs-lookup"><span data-stu-id="08aad-131">e</span></span>|<span data-ttu-id="08aad-132">"needing a reed" (索引 0)</span><span class="sxs-lookup"><span data-stu-id="08aad-132">"needing a reed" (index 0)</span></span>|<span data-ttu-id="08aad-133">沒有符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-133">No match.</span></span>|  
|<span data-ttu-id="08aad-134">2</span><span class="sxs-lookup"><span data-stu-id="08aad-134">2</span></span>|<span data-ttu-id="08aad-135">e</span><span class="sxs-lookup"><span data-stu-id="08aad-135">e</span></span>|<span data-ttu-id="08aad-136">"eeding a reed" (索引 1)</span><span class="sxs-lookup"><span data-stu-id="08aad-136">"eeding a reed" (index 1)</span></span>|<span data-ttu-id="08aad-137">可能符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-137">Possible match.</span></span>|  
|<span data-ttu-id="08aad-138">3</span><span class="sxs-lookup"><span data-stu-id="08aad-138">3</span></span>|<span data-ttu-id="08aad-139">e{2}</span><span class="sxs-lookup"><span data-stu-id="08aad-139">e{2}</span></span>|<span data-ttu-id="08aad-140">"eding a reed" (索引 2)</span><span class="sxs-lookup"><span data-stu-id="08aad-140">"eding a reed" (index 2)</span></span>|<span data-ttu-id="08aad-141">可能符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-141">Possible match.</span></span>|  
|<span data-ttu-id="08aad-142">4</span><span class="sxs-lookup"><span data-stu-id="08aad-142">4</span></span>|<span data-ttu-id="08aad-143">\w</span><span class="sxs-lookup"><span data-stu-id="08aad-143">\w</span></span>|<span data-ttu-id="08aad-144">"ding a reed" (索引 3)</span><span class="sxs-lookup"><span data-stu-id="08aad-144">"ding a reed" (index 3)</span></span>|<span data-ttu-id="08aad-145">可能符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-145">Possible match.</span></span>|  
|<span data-ttu-id="08aad-146">5</span><span class="sxs-lookup"><span data-stu-id="08aad-146">5</span></span>|<span data-ttu-id="08aad-147">\b</span><span class="sxs-lookup"><span data-stu-id="08aad-147">\b</span></span>|<span data-ttu-id="08aad-148">"ing a reed" (索引 4)</span><span class="sxs-lookup"><span data-stu-id="08aad-148">"ing a reed" (index 4)</span></span>|<span data-ttu-id="08aad-149">可能符合的結果失敗。</span><span class="sxs-lookup"><span data-stu-id="08aad-149">Possible match fails.</span></span>|  
|<span data-ttu-id="08aad-150">6</span><span class="sxs-lookup"><span data-stu-id="08aad-150">6</span></span>|<span data-ttu-id="08aad-151">e</span><span class="sxs-lookup"><span data-stu-id="08aad-151">e</span></span>|<span data-ttu-id="08aad-152">"eding a reed" (索引 2)</span><span class="sxs-lookup"><span data-stu-id="08aad-152">"eding a reed" (index 2)</span></span>|<span data-ttu-id="08aad-153">可能符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-153">Possible match.</span></span>|  
|<span data-ttu-id="08aad-154">7</span><span class="sxs-lookup"><span data-stu-id="08aad-154">7</span></span>|<span data-ttu-id="08aad-155">e{2}</span><span class="sxs-lookup"><span data-stu-id="08aad-155">e{2}</span></span>|<span data-ttu-id="08aad-156">"ding a reed" (索引 3)</span><span class="sxs-lookup"><span data-stu-id="08aad-156">"ding a reed" (index 3)</span></span>|<span data-ttu-id="08aad-157">可能符合的結果失敗。</span><span class="sxs-lookup"><span data-stu-id="08aad-157">Possible match fails.</span></span>|  
|<span data-ttu-id="08aad-158">8</span><span class="sxs-lookup"><span data-stu-id="08aad-158">8</span></span>|<span data-ttu-id="08aad-159">e</span><span class="sxs-lookup"><span data-stu-id="08aad-159">e</span></span>|<span data-ttu-id="08aad-160">"ding a reed" (索引 3)</span><span class="sxs-lookup"><span data-stu-id="08aad-160">"ding a reed" (index 3)</span></span>|<span data-ttu-id="08aad-161">比對會失敗。</span><span class="sxs-lookup"><span data-stu-id="08aad-161">Match fails.</span></span>|  
|<span data-ttu-id="08aad-162">9</span><span class="sxs-lookup"><span data-stu-id="08aad-162">9</span></span>|<span data-ttu-id="08aad-163">e</span><span class="sxs-lookup"><span data-stu-id="08aad-163">e</span></span>|<span data-ttu-id="08aad-164">"ing a reed" (索引 4)</span><span class="sxs-lookup"><span data-stu-id="08aad-164">"ing a reed" (index 4)</span></span>|<span data-ttu-id="08aad-165">沒有符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-165">No match.</span></span>|  
|<span data-ttu-id="08aad-166">10</span><span class="sxs-lookup"><span data-stu-id="08aad-166">10</span></span>|<span data-ttu-id="08aad-167">e</span><span class="sxs-lookup"><span data-stu-id="08aad-167">e</span></span>|<span data-ttu-id="08aad-168">"ng a reed" (索引 5)</span><span class="sxs-lookup"><span data-stu-id="08aad-168">"ng a reed" (index 5)</span></span>|<span data-ttu-id="08aad-169">沒有符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-169">No match.</span></span>|  
|<span data-ttu-id="08aad-170">11</span><span class="sxs-lookup"><span data-stu-id="08aad-170">11</span></span>|<span data-ttu-id="08aad-171">e</span><span class="sxs-lookup"><span data-stu-id="08aad-171">e</span></span>|<span data-ttu-id="08aad-172">"g a reed" (索引 6)</span><span class="sxs-lookup"><span data-stu-id="08aad-172">"g a reed" (index 6)</span></span>|<span data-ttu-id="08aad-173">沒有符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-173">No match.</span></span>|  
|<span data-ttu-id="08aad-174">12</span><span class="sxs-lookup"><span data-stu-id="08aad-174">12</span></span>|<span data-ttu-id="08aad-175">e</span><span class="sxs-lookup"><span data-stu-id="08aad-175">e</span></span>|<span data-ttu-id="08aad-176">" a reed" (索引 7)</span><span class="sxs-lookup"><span data-stu-id="08aad-176">" a reed" (index 7)</span></span>|<span data-ttu-id="08aad-177">沒有符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-177">No match.</span></span>|  
|<span data-ttu-id="08aad-178">13</span><span class="sxs-lookup"><span data-stu-id="08aad-178">13</span></span>|<span data-ttu-id="08aad-179">e</span><span class="sxs-lookup"><span data-stu-id="08aad-179">e</span></span>|<span data-ttu-id="08aad-180">"a reed" (索引 8)</span><span class="sxs-lookup"><span data-stu-id="08aad-180">"a reed" (index 8)</span></span>|<span data-ttu-id="08aad-181">沒有符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-181">No match.</span></span>|  
|<span data-ttu-id="08aad-182">14</span><span class="sxs-lookup"><span data-stu-id="08aad-182">14</span></span>|<span data-ttu-id="08aad-183">e</span><span class="sxs-lookup"><span data-stu-id="08aad-183">e</span></span>|<span data-ttu-id="08aad-184">" reed" (索引 9)</span><span class="sxs-lookup"><span data-stu-id="08aad-184">" reed" (index 9)</span></span>|<span data-ttu-id="08aad-185">沒有符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-185">No match.</span></span>|  
|<span data-ttu-id="08aad-186">15</span><span class="sxs-lookup"><span data-stu-id="08aad-186">15</span></span>|<span data-ttu-id="08aad-187">e</span><span class="sxs-lookup"><span data-stu-id="08aad-187">e</span></span>|<span data-ttu-id="08aad-188">"a reed" (索引 10)</span><span class="sxs-lookup"><span data-stu-id="08aad-188">"reed" (index 10)</span></span>|<span data-ttu-id="08aad-189">沒有符合的結果</span><span class="sxs-lookup"><span data-stu-id="08aad-189">No match</span></span>|  
|<span data-ttu-id="08aad-190">16</span><span class="sxs-lookup"><span data-stu-id="08aad-190">16</span></span>|<span data-ttu-id="08aad-191">e</span><span class="sxs-lookup"><span data-stu-id="08aad-191">e</span></span>|<span data-ttu-id="08aad-192">"eed" (索引 11)</span><span class="sxs-lookup"><span data-stu-id="08aad-192">"eed" (index 11)</span></span>|<span data-ttu-id="08aad-193">可能符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-193">Possible match.</span></span>|  
|<span data-ttu-id="08aad-194">17</span><span class="sxs-lookup"><span data-stu-id="08aad-194">17</span></span>|<span data-ttu-id="08aad-195">e{2}</span><span class="sxs-lookup"><span data-stu-id="08aad-195">e{2}</span></span>|<span data-ttu-id="08aad-196">"ed" (索引 12)</span><span class="sxs-lookup"><span data-stu-id="08aad-196">"ed" (index 12)</span></span>|<span data-ttu-id="08aad-197">可能符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-197">Possible match.</span></span>|  
|<span data-ttu-id="08aad-198">18</span><span class="sxs-lookup"><span data-stu-id="08aad-198">18</span></span>|<span data-ttu-id="08aad-199">\w</span><span class="sxs-lookup"><span data-stu-id="08aad-199">\w</span></span>|<span data-ttu-id="08aad-200">"d" (索引 13)</span><span class="sxs-lookup"><span data-stu-id="08aad-200">"d" (index 13)</span></span>|<span data-ttu-id="08aad-201">可能符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-201">Possible match.</span></span>|  
|<span data-ttu-id="08aad-202">19</span><span class="sxs-lookup"><span data-stu-id="08aad-202">19</span></span>|<span data-ttu-id="08aad-203">\b</span><span class="sxs-lookup"><span data-stu-id="08aad-203">\b</span></span>|<span data-ttu-id="08aad-204">"" (索引 14)</span><span class="sxs-lookup"><span data-stu-id="08aad-204">"" (index 14)</span></span>|<span data-ttu-id="08aad-205">符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-205">Match.</span></span>|  
  
 <span data-ttu-id="08aad-206">如果規則運算式模式未包含選擇性數量詞或交替建構，則比對規則運算式模式與輸入字串所需的比較次數上限，約相當於輸入字串中的字元數。</span><span class="sxs-lookup"><span data-stu-id="08aad-206">If a regular expression pattern includes no optional quantifiers or alternation constructs, the maximum number of comparisons required to match the regular expression pattern with the input string is roughly equivalent to the number of characters in the input string.</span></span> <span data-ttu-id="08aad-207">在這個案例中，規則運算式引擎會使用 19 項比較找出這 13 個字元字串中可能的相符項目。</span><span class="sxs-lookup"><span data-stu-id="08aad-207">In this case, the regular expression engine uses 19 comparisons to identify possible matches in this 13-character string.</span></span>  <span data-ttu-id="08aad-208">換句話說，如果沒有選擇性數量詞或交替建構，規則運算式引擎就會以近似線性時間執行。</span><span class="sxs-lookup"><span data-stu-id="08aad-208">In other words, the regular expression engine runs in near-linear time if it contains no optional quantifiers or alternation constructs.</span></span>  
  
 [<span data-ttu-id="08aad-209">回到頁首</span><span class="sxs-lookup"><span data-stu-id="08aad-209">Back to top</span></span>](#top)  
  
<a name="backtracking_with_optional_quantifiers_or_alternation_constructs"></a>   
## <a name="backtracking-with-optional-quantifiers-or-alternation-constructs"></a><span data-ttu-id="08aad-210">含有選擇性數量詞或交替建構的回溯</span><span class="sxs-lookup"><span data-stu-id="08aad-210">Backtracking with Optional Quantifiers or Alternation Constructs</span></span>  
 <span data-ttu-id="08aad-211">當規則運算式包含選擇性數量詞或交替建構時，輸入字串的評估就不再是線性。</span><span class="sxs-lookup"><span data-stu-id="08aad-211">When a regular expression includes optional quantifiers or alternation constructs, the evaluation of the input string is no longer linear.</span></span> <span data-ttu-id="08aad-212">與 NFA 引擎比對的模式是由規則運算式中的語言項目所引導，而不是由輸入字串中要比對的字元引導。</span><span class="sxs-lookup"><span data-stu-id="08aad-212">Pattern matching with an NFA engine is driven by the language elements in the regular expression and not by the characters to be matched in the input string.</span></span> <span data-ttu-id="08aad-213">因此，規則運算式引擎會嘗試完整比對選擇性或替代子運算式。</span><span class="sxs-lookup"><span data-stu-id="08aad-213">Therefore, the regular expression engine tries to fully match optional or alternative subexpressions.</span></span> <span data-ttu-id="08aad-214">當規則運算式引擎前進到子運算式中的下一個語言項目且比對失敗時，它可能會捨棄成功比對的一部分，並且返回之前儲存的狀態，以便完整比對規則運算式與輸入字串。</span><span class="sxs-lookup"><span data-stu-id="08aad-214">When it advances to the next language element in the subexpression and the match is unsuccessful, the regular expression engine can abandon a portion of its successful match and return to an earlier saved state in the interest of matching the regular expression as a whole with the input string.</span></span> <span data-ttu-id="08aad-215">這個返回之前儲存狀態尋找符合結果的程序，就稱為回溯 (Backtracking)。</span><span class="sxs-lookup"><span data-stu-id="08aad-215">This process of returning to a previous saved state to find a match is known as backtracking.</span></span>  
  
 <span data-ttu-id="08aad-216">例如，想想規則運算式模式 `.*(es)`，它會比對字元 "es" 與其前面的所有字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-216">For example, consider the regular expression pattern `.*(es)`, which matches the characters "es" and all the characters that precede it.</span></span> <span data-ttu-id="08aad-217">如下列範例中所示，如果輸入字串為 "Essential services are provided by regular expressions."，則模式會比對整個字串直到 (且包含) "expressions" 中的 "es" 為止。</span><span class="sxs-lookup"><span data-stu-id="08aad-217">As the following example shows, if the input string is "Essential services are provided by regular expressions.", the pattern matches the whole string up to and including the "es" in "expressions".</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking2.cs#2)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking2.vb#2)]  
  
 <span data-ttu-id="08aad-218">為了進行這項比對，規則運算式引擎會使用回溯，如下所示：</span><span class="sxs-lookup"><span data-stu-id="08aad-218">To do this, the regular expression engine uses backtracking as follows:</span></span>  
  
-   <span data-ttu-id="08aad-219">它會比對 `.*` (其會比對零個、一個或多個任意字元) 與整個輸入字串。</span><span class="sxs-lookup"><span data-stu-id="08aad-219">It matches the `.*` (which matches zero, one, or more occurrences of any character) with the whole input string.</span></span>  
  
-   <span data-ttu-id="08aad-220">它會嘗試比對規則運算式模式中的 "e"。</span><span class="sxs-lookup"><span data-stu-id="08aad-220">It attempts to match "e" in the regular expression pattern.</span></span> <span data-ttu-id="08aad-221">不過，輸入字串沒有其他可供比對的字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-221">However, the input string has no remaining characters available to match.</span></span>  
  
-   <span data-ttu-id="08aad-222">接著它會回溯至上一個成功的比對結果 "Essential services are provided by regular expressions"，並嘗試比對 "e" 與句尾的句號。</span><span class="sxs-lookup"><span data-stu-id="08aad-222">It backtracks to its last successful match, "Essential services are provided by regular expressions", and attempts to match "e" with the period at the end of the sentence.</span></span> <span data-ttu-id="08aad-223">比對會失敗。</span><span class="sxs-lookup"><span data-stu-id="08aad-223">The match fails.</span></span>  
  
-   <span data-ttu-id="08aad-224">然後它會繼續回溯至前一個成功的比對結果，一次一個字元，直到暫時相符的子字串為 "Essential services are provided by regular expr"。</span><span class="sxs-lookup"><span data-stu-id="08aad-224">It continues to backtrack to a previous successful match one character at a time until the tentatively matched substring is "Essential services are provided by regular expr".</span></span> <span data-ttu-id="08aad-225">然後運算式會比較模式中的 "e" 與 "expressions" 中的第二個 "e"，並且尋找符合的結果。</span><span class="sxs-lookup"><span data-stu-id="08aad-225">It then compares the "e" in the pattern to the second "e" in "expressions" and finds a match.</span></span>  
  
-   <span data-ttu-id="08aad-226">接著再比較模式中的 "s" 與相符的 "e" 字元後面接著的 "s" ("expressions" 中的第一個 "s")。</span><span class="sxs-lookup"><span data-stu-id="08aad-226">It compares "s" in the pattern to the "s" that follows the matched "e" character (the first "s" in "expressions").</span></span> <span data-ttu-id="08aad-227">比對將會成功。</span><span class="sxs-lookup"><span data-stu-id="08aad-227">The match is successful.</span></span>  
  
 <span data-ttu-id="08aad-228">當您使用回溯時，比對規則運算式模式與長度 55 個字元的輸入字串需要進行 67 次比較作業。</span><span class="sxs-lookup"><span data-stu-id="08aad-228">When you use backtracking, matching the regular expression pattern with the input string, which is 55 characters long, requires 67 comparison operations.</span></span> <span data-ttu-id="08aad-229">通常如果規則運算式模式包含單一交替建構或單一選擇性數量詞，則比對模式所需的比較作業次數會超過輸入字串中字元數的兩倍。</span><span class="sxs-lookup"><span data-stu-id="08aad-229">Generally, if a regular expression pattern has a single alternation construct or a single optional quantifier, the number of comparison operations required to match the pattern is more than twice the number of characters in the input string.</span></span>  
  
 [<span data-ttu-id="08aad-230">回到頁首</span><span class="sxs-lookup"><span data-stu-id="08aad-230">Back to top</span></span>](#top)  
  
<a name="backtracking_with_nested_optional_quantifiers"></a>   
## <a name="backtracking-with-nested-optional-quantifiers"></a><span data-ttu-id="08aad-231">含有巢狀選擇性數量詞的回溯</span><span class="sxs-lookup"><span data-stu-id="08aad-231">Backtracking with Nested Optional Quantifiers</span></span>  
 <span data-ttu-id="08aad-232">如果模式包含大量交替建構、包括巢狀交替建構，或是最常見的巢狀選擇性數量詞，則比對規則運算式模式所需的比較作業次數可能大幅增加。</span><span class="sxs-lookup"><span data-stu-id="08aad-232">The number of comparison operations required to match a regular expression pattern can increase exponentially if the pattern includes a large number of alternation constructs, if it includes nested alternation constructs, or, most commonly, if it includes nested optional quantifiers.</span></span> <span data-ttu-id="08aad-233">例如，規則運算式模式 `^(a+)+$` 的設計為比對包含一個或多個 "a" 字元的完整字串。</span><span class="sxs-lookup"><span data-stu-id="08aad-233">For example, the regular expression pattern `^(a+)+$` is designed to match a complete string that contains one or more "a" characters.</span></span> <span data-ttu-id="08aad-234">範例中提供了兩個長度相同的輸入字串，但只有第一個字串與模式相符。</span><span class="sxs-lookup"><span data-stu-id="08aad-234">The example provides two input strings of identical length, but only the first string matches the pattern.</span></span> <span data-ttu-id="08aad-235"><xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> 類別可用來判斷比對作業進行的時間。</span><span class="sxs-lookup"><span data-stu-id="08aad-235">The <xref:System.Diagnostics.Stopwatch?displayProperty=nameWithType> class is used to determine how long the match operation takes.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking3.cs#3)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking3.vb#3)]  
  
 <span data-ttu-id="08aad-236">如範例的輸出所示，規則運算式引擎耗費約為識別比對字串的兩倍時間，才發現輸入字串與模式不相符。</span><span class="sxs-lookup"><span data-stu-id="08aad-236">As the output from the example shows, the regular expression engine took about twice as long to find that an input string did not match the pattern as it did to identify a matching string.</span></span> <span data-ttu-id="08aad-237">這是因為失敗的比對永遠代表最糟的狀況。</span><span class="sxs-lookup"><span data-stu-id="08aad-237">This is because an unsuccessful match always represents a worst-case scenario.</span></span> <span data-ttu-id="08aad-238">規則運算式引擎必須先使用規則運算式依循所有可能的途徑來處理資料，才能得到比對失敗的結果，而巢狀括號會製造許多額外的途徑來處理資料。</span><span class="sxs-lookup"><span data-stu-id="08aad-238">The regular expression engine must use the regular expression to follow all possible paths through the data before it can conclude that the match is unsuccessful, and the nested parentheses create many additional paths through the data.</span></span> <span data-ttu-id="08aad-239">規則運算式引擎會藉由執行下列操作得出第二個字串與模式不相符的結果：</span><span class="sxs-lookup"><span data-stu-id="08aad-239">The regular expression engine concludes that the second string did not match the pattern by doing the following:</span></span>  
  
-   <span data-ttu-id="08aad-240">它會檢查是否位於字串開頭，然後比對字串中的前五個字元與 `a+`模式。</span><span class="sxs-lookup"><span data-stu-id="08aad-240">It checks that it was at the beginning of the string, and then matches the first five characters in the string with the pattern `a+`.</span></span> <span data-ttu-id="08aad-241">然後判斷字串中沒有額外的 "a" 字元群組。</span><span class="sxs-lookup"><span data-stu-id="08aad-241">It then determines that there are no additional groups of "a" characters in the string.</span></span> <span data-ttu-id="08aad-242">最後測試是否到達字串結尾。</span><span class="sxs-lookup"><span data-stu-id="08aad-242">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="08aad-243">由於字串中剩下一個額外的字串，因此比對失敗。</span><span class="sxs-lookup"><span data-stu-id="08aad-243">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="08aad-244">這個失敗的比對需要經過 9 次比較。</span><span class="sxs-lookup"><span data-stu-id="08aad-244">This failed match requires 9 comparisons.</span></span> <span data-ttu-id="08aad-245">規則運算式引擎還會儲存 "a" (以下稱為符合結果 1)、"aa" (符合結果 2)、"aaa" (符合結果 3) 和 "aaaa" (符合結果 4) 這些符合結果的狀態資訊。</span><span class="sxs-lookup"><span data-stu-id="08aad-245">The regular expression engine also saves state information from its matches of "a" (which we will call match 1), "aa" (match 2), "aaa" (match 3), and "aaaa" (match 4).</span></span>  
  
-   <span data-ttu-id="08aad-246">它會返回之前儲存的符合結果 4。</span><span class="sxs-lookup"><span data-stu-id="08aad-246">It returns to the previously saved match 4.</span></span> <span data-ttu-id="08aad-247">然後判斷出有一個額外的 "a" 字元要指派至額外的擷取群組。</span><span class="sxs-lookup"><span data-stu-id="08aad-247">It determines that there is one additional "a" character to assign to an additional captured group.</span></span> <span data-ttu-id="08aad-248">最後測試是否到達字串結尾。</span><span class="sxs-lookup"><span data-stu-id="08aad-248">Finally, it tests for the end of the string.</span></span> <span data-ttu-id="08aad-249">由於字串中剩下一個額外的字串，因此比對失敗。</span><span class="sxs-lookup"><span data-stu-id="08aad-249">Because one additional character remains in the string, the match fails.</span></span> <span data-ttu-id="08aad-250">這個失敗的比對需要經過 4 次比較。</span><span class="sxs-lookup"><span data-stu-id="08aad-250">This failed match requires 4 comparisons.</span></span> <span data-ttu-id="08aad-251">到目前為止，總共執行了 13 次比較。</span><span class="sxs-lookup"><span data-stu-id="08aad-251">So far, a total of 13 comparisons have been performed.</span></span>  
  
-   <span data-ttu-id="08aad-252">它會返回之前儲存的符合結果 3。</span><span class="sxs-lookup"><span data-stu-id="08aad-252">It returns to the previously saved match 3.</span></span> <span data-ttu-id="08aad-253">然後判斷出有兩個額外的 "a" 字元要指派至額外的擷取群組。</span><span class="sxs-lookup"><span data-stu-id="08aad-253">It determines that there are two additional "a" characters to assign to an additional captured group.</span></span> <span data-ttu-id="08aad-254">然而，字串結尾測試失敗。</span><span class="sxs-lookup"><span data-stu-id="08aad-254">However, the end-of-string test fails.</span></span> <span data-ttu-id="08aad-255">接著它會返回符合結果 3，並嘗試比對兩個額外的擷取群組中的這兩個額外的 "a" 字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-255">It then returns to match3 and tries to match the two additional "a" characters in two additional captured groups.</span></span> <span data-ttu-id="08aad-256">字串結尾測試仍然失敗。</span><span class="sxs-lookup"><span data-stu-id="08aad-256">The end-of-string test still fails.</span></span> <span data-ttu-id="08aad-257">這些失敗的比對需要經過 12 次比較。</span><span class="sxs-lookup"><span data-stu-id="08aad-257">These failed matches require 12 comparisons.</span></span> <span data-ttu-id="08aad-258">到目前為止，總共執行了 25 次比較。</span><span class="sxs-lookup"><span data-stu-id="08aad-258">So far, a total of 25 comparisons have been performed.</span></span>  
  
 <span data-ttu-id="08aad-259">輸入字串與規則運算式的比較會依照這種方式繼續進行，直到規則運算式引擎嘗試過所有可能的比對組合，然後得到沒有符合的結果這個結論。</span><span class="sxs-lookup"><span data-stu-id="08aad-259">Comparison of the input string with the regular expression continues in this way until the regular expression engine has tried all possible combinations of matches, and then concludes that there is no match.</span></span> <span data-ttu-id="08aad-260">由於巢狀數量詞的關係，這個比較是 O(2<sup>n</sup>) 或指數運算，其中 *n* 是輸入字串中的字元數。</span><span class="sxs-lookup"><span data-stu-id="08aad-260">Because of the nested quantifiers, this comparison is an O(2<sup>n</sup>) or an exponential operation, where *n* is the number of characters in the input string.</span></span> <span data-ttu-id="08aad-261">這表示，在最糟的情況下，包含 30 個字元的輸入字串約需要進行 1,073,741,824 次比較，而包含 40 個字元的輸入字串約需要進行 1,099,511,627,776 次比較。</span><span class="sxs-lookup"><span data-stu-id="08aad-261">This means that in the worst case, an input string of 30 characters requires approximately 1,073,741,824 comparisons, and an input string of 40 characters requires approximately 1,099,511,627,776 comparisons.</span></span> <span data-ttu-id="08aad-262">如果您使用這類長度甚至更長的字串，則規則運算式方法處理不符合規則運算式模式的輸入時，可能需要相當長的時間才能完成。</span><span class="sxs-lookup"><span data-stu-id="08aad-262">If you use strings of these or even greater lengths, regular expression methods can take an extremely long time to complete when they process input that does not match the regular expression pattern.</span></span>  
  
 [<span data-ttu-id="08aad-263">回到頁首</span><span class="sxs-lookup"><span data-stu-id="08aad-263">Back to top</span></span>](#top)  
  
<a name="controlling_backtracking"></a>   
## <a name="controlling-backtracking"></a><span data-ttu-id="08aad-264">控制回溯</span><span class="sxs-lookup"><span data-stu-id="08aad-264">Controlling Backtracking</span></span>  
 <span data-ttu-id="08aad-265">回溯可讓您建立強大、靈活的規則運算式。</span><span class="sxs-lookup"><span data-stu-id="08aad-265">Backtracking lets you create powerful, flexible regular expressions.</span></span> <span data-ttu-id="08aad-266">不過，如上一節所示，這些好處可能伴隨著令人敬謝不敏的低落效能。</span><span class="sxs-lookup"><span data-stu-id="08aad-266">However, as the previous section showed, these benefits may be coupled with unacceptably poor performance.</span></span> <span data-ttu-id="08aad-267">為了避免大量回溯，當您具現化 <xref:System.Text.RegularExpressions.Regex> 物件或呼叫靜態規則運算式比對方法時，應該定義逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="08aad-267">To prevent excessive backtracking, you should define a time-out interval when you instantiate a <xref:System.Text.RegularExpressions.Regex> object or call a static regular expression matching method.</span></span> <span data-ttu-id="08aad-268">下一節將討論這個部分。</span><span class="sxs-lookup"><span data-stu-id="08aad-268">This is discussed in the next section.</span></span> <span data-ttu-id="08aad-269">此外，.NET 支援三個規則運算式語言元素，可限制或隱藏回溯並支援複雜的規則運算式，而且對效能的影響微不足道：[非回溯子運算式](#Nonbacktracking)、[左合樣判斷提示](#Lookbehind)和[右合樣判斷提示](#Lookahead)。</span><span class="sxs-lookup"><span data-stu-id="08aad-269">In addition, .NET supports three regular expression language elements that limit or suppress backtracking and that support complex regular expressions with little or no performance penalty: [nonbacktracking subexpressions](#Nonbacktracking), [lookbehind assertions](#Lookbehind), and [lookahead assertions](#Lookahead).</span></span> <span data-ttu-id="08aad-270">如需各語言項目的詳細資訊，請參閱 [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="08aad-270">For more information about each language element, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
<a name="Timeout"></a>   
### <a name="defining-a-time-out-interval"></a><span data-ttu-id="08aad-271">定義逾時間隔</span><span class="sxs-lookup"><span data-stu-id="08aad-271">Defining a Time-out Interval</span></span>  
 <span data-ttu-id="08aad-272">從 [!INCLUDE[net_v45](../../../includes/net-v45-md.md)]開始，您可以設定逾時值，表示規則運算式引擎開始搜尋單一符合項目到放棄嘗試並擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況之前的最長間隔。</span><span class="sxs-lookup"><span data-stu-id="08aad-272">Starting with the [!INCLUDE[net_v45](../../../includes/net-v45-md.md)], you can set a time-out value that represents the longest interval the regular expression engine will search for a single match before it abandons the attempt and throws a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception.</span></span> <span data-ttu-id="08aad-273">您可以提供執行個體規則運算式之 <xref:System.TimeSpan> 建構函式的 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 值，藉此指定逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="08aad-273">You specify the time-out interval by supplying a <xref:System.TimeSpan> value to the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor for instance regular expressions.</span></span> <span data-ttu-id="08aad-274">此外，每一個靜態模式比對方法都有 <xref:System.TimeSpan> 參數的多載，可讓您指定逾時值。</span><span class="sxs-lookup"><span data-stu-id="08aad-274">In addition, each static pattern matching method has an overload with a <xref:System.TimeSpan> parameter that allows you to specify a time-out value.</span></span> <span data-ttu-id="08aad-275">根據預設，逾時間隔會設為 <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType>，表示規則運算式引擎不會逾時。</span><span class="sxs-lookup"><span data-stu-id="08aad-275">By default, the time-out interval is set to <xref:System.Text.RegularExpressions.Regex.InfiniteMatchTimeout?displayProperty=nameWithType> and the regular expression engine does not time out.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="08aad-276">如果您的規則運算式倚賴回溯，建議您一定要設定逾時間隔。</span><span class="sxs-lookup"><span data-stu-id="08aad-276">We recommend that you always set a time-out interval if your regular expression relies on backtracking.</span></span>  
  
 <span data-ttu-id="08aad-277"><xref:System.Text.RegularExpressions.RegexMatchTimeoutException> 例外狀況表示規則運算式引擎在指定的逾時間隔內找不到相符項目，但不會指出擲回例外狀況的原因。</span><span class="sxs-lookup"><span data-stu-id="08aad-277">A <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> exception indicates that the regular expression engine was unable to find a match within the specified time-out interval but does not indicate why the exception was thrown.</span></span> <span data-ttu-id="08aad-278">這個原因可能是大量回溯，不過也有可能是對於擲回例外狀況當時的系統負載而言，設定的逾時間隔太低。</span><span class="sxs-lookup"><span data-stu-id="08aad-278">The reason might be excessive backtracking, but it is also possible that the time-out interval was set too low given the system load at the time the exception was thrown.</span></span> <span data-ttu-id="08aad-279">當您處理例外狀況時，可以選擇中放棄一步比對輸入字串，或增加逾時間隔並重試比對作業。</span><span class="sxs-lookup"><span data-stu-id="08aad-279">When you handle the exception, you can choose to abandon further matches with the input string or increase the time-out interval and retry the matching operation.</span></span>  
  
 <span data-ttu-id="08aad-280">例如，下列程式碼會呼叫 <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> 建構函式來具現化逾時值為一秒的 <xref:System.Text.RegularExpressions.Regex> 物件。</span><span class="sxs-lookup"><span data-stu-id="08aad-280">For example, the following code calls the <xref:System.Text.RegularExpressions.Regex.%23ctor%28System.String%2CSystem.Text.RegularExpressions.RegexOptions%2CSystem.TimeSpan%29?displayProperty=nameWithType> constructor to instantiate a <xref:System.Text.RegularExpressions.Regex> object with a time-out value of one second.</span></span> <span data-ttu-id="08aad-281">規則運算式模式 `(a+)+$` 會在行尾比對一個或多個 "a" 字元的一個或多個序列，並且受限於大量回溯。</span><span class="sxs-lookup"><span data-stu-id="08aad-281">The regular expression pattern `(a+)+$`, which matches one or more sequences of one or more "a" characters at the end of a line, is subject to excessive backtracking.</span></span> <span data-ttu-id="08aad-282">如果擲回 <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> ，則範例會將逾時值增加至最大間隔三秒。</span><span class="sxs-lookup"><span data-stu-id="08aad-282">If a <xref:System.Text.RegularExpressions.RegexMatchTimeoutException> is thrown, the example increases the time-out value up to a maximum interval of three seconds.</span></span> <span data-ttu-id="08aad-283">在這個間隔之後，它就會放棄嘗試比對模式。</span><span class="sxs-lookup"><span data-stu-id="08aad-283">After that, it abandons the attempt to match the pattern.</span></span>  
  
 [!code-csharp[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/csharp/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Text.RegularExpressions.Regex.ctor#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.regularexpressions.regex.ctor/vb/ctor1.vb#1)]  
  
<a name="Nonbacktracking"></a>   
### <a name="nonbacktracking-subexpression"></a><span data-ttu-id="08aad-284">非回溯子運算式</span><span class="sxs-lookup"><span data-stu-id="08aad-284">Nonbacktracking Subexpression</span></span>  
 <span data-ttu-id="08aad-285">`(?>` *子運算式*`)` 語言項目會隱藏子運算式中的回溯。</span><span class="sxs-lookup"><span data-stu-id="08aad-285">The `(?>` *subexpression*`)` language element suppresses backtracking in a subexpression.</span></span> <span data-ttu-id="08aad-286">對於避免發生與比對失敗相關的效能問題相當有用。</span><span class="sxs-lookup"><span data-stu-id="08aad-286">It is useful for preventing the performance problems associated with failed matches.</span></span>  
  
 <span data-ttu-id="08aad-287">下列範例說明隱藏回溯如何在使用巢狀數量詞時改善效能。</span><span class="sxs-lookup"><span data-stu-id="08aad-287">The following example illustrates how suppressing backtracking improves performance when using nested quantifiers.</span></span> <span data-ttu-id="08aad-288">它會測量規則運算式引擎判斷出輸入字串與兩個規則運算式不相符所需的時間。</span><span class="sxs-lookup"><span data-stu-id="08aad-288">It measures the time required for the regular expression engine to determine that an input string does not match two regular expressions.</span></span> <span data-ttu-id="08aad-289">第一個規則運算式會使用回溯嘗試比對包含出現一次或多次的一個或多個十六進位數字的字串，後面接著一個冒號，再接著一個或多個十六進位數字，最後接著兩個冒號。</span><span class="sxs-lookup"><span data-stu-id="08aad-289">The first regular expression uses backtracking to attempt to match a string that contains one or more occurrences of one or more hexadecimal digits, followed by a colon, followed by one or more hexadecimal digits, followed by two colons.</span></span> <span data-ttu-id="08aad-290">第二個規則運算式與第一個完全相同，但會停用回溯。</span><span class="sxs-lookup"><span data-stu-id="08aad-290">The second regular expression is identical to the first, except that it disables backtracking.</span></span> <span data-ttu-id="08aad-291">如範例的輸出所示，停用回溯使效能大幅提升。</span><span class="sxs-lookup"><span data-stu-id="08aad-291">As the output from the example shows, the performance improvement from disabling backtracking is significant.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking4.cs#4)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking4.vb#4)]  
  
<a name="Lookbehind"></a>   
### <a name="lookbehind-assertions"></a><span data-ttu-id="08aad-292">左合樣判斷提示</span><span class="sxs-lookup"><span data-stu-id="08aad-292">Lookbehind Assertions</span></span>  
 <span data-ttu-id="08aad-293">.NET 包含兩個語言元素：`(?<=`*subexpression*`)` 和 `(?<!`*subexpression*`)`，這兩者會比對輸入字串中的前一個或多個字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-293">.NET includes two language elements, `(?<=`*subexpression*`)` and `(?<!`*subexpression*`)`, that match the previous character or characters in the input string.</span></span> <span data-ttu-id="08aad-294">這兩個語言項目都是零寬度判斷提示，也就是說，它們會判斷緊接著目前字元前面的字元是否可由 *子運算式*比對，而不需前進或回溯。</span><span class="sxs-lookup"><span data-stu-id="08aad-294">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately precede the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="08aad-295">`(?<=` *子運算式* `)` 是左合樣判斷提示，也就是說，目前位置前面的字元必須符合 *子運算式*。</span><span class="sxs-lookup"><span data-stu-id="08aad-295">`(?<=` *subexpression* `)` is a positive lookbehind assertion; that is, the character or characters before the current position must match *subexpression*.</span></span> <span data-ttu-id="08aad-296">`(?<!`*子運算式*`)` 是左不合樣判斷提示，也就是說，目前位置前面的字元必須不符合 *子運算式*。</span><span class="sxs-lookup"><span data-stu-id="08aad-296">`(?<!`*subexpression*`)` is a negative lookbehind assertion; that is, the character or characters before the current position must not match *subexpression*.</span></span> <span data-ttu-id="08aad-297">當 *子運算式* 為前一個子運算式的子集時，左合樣和左不合樣判斷提示最為實用。</span><span class="sxs-lookup"><span data-stu-id="08aad-297">Both positive and negative lookbehind assertions are most useful when *subexpression* is a subset of the previous subexpression.</span></span>  
  
 <span data-ttu-id="08aad-298">下列範例使用兩個同等的規則運算式模式，來驗證電子郵件地址中的使用者名稱。</span><span class="sxs-lookup"><span data-stu-id="08aad-298">The following example uses two equivalent regular expression patterns that validate the user name in an email address.</span></span> <span data-ttu-id="08aad-299">第一個模式因為進行大量回溯，而受限於低落的效能。</span><span class="sxs-lookup"><span data-stu-id="08aad-299">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="08aad-300">第二個模式修改了第一個規則運算式，將巢狀數量詞取代為左合樣判斷提示。</span><span class="sxs-lookup"><span data-stu-id="08aad-300">The second pattern modifies the first regular expression by replacing a nested quantifier with a positive lookbehind assertion.</span></span> <span data-ttu-id="08aad-301">範例的輸入顯示 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法的執行時間。</span><span class="sxs-lookup"><span data-stu-id="08aad-301">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking5.cs#5)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking5.vb#5)]  
  
 <span data-ttu-id="08aad-302">第一個規則運算式模式 `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="08aad-302">The first regular expression pattern, `^[0-9A-Z]([-.\w]*[0-9A-Z])*@`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="08aad-303">模式</span><span class="sxs-lookup"><span data-stu-id="08aad-303">Pattern</span></span>|<span data-ttu-id="08aad-304">說明</span><span class="sxs-lookup"><span data-stu-id="08aad-304">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="08aad-305">從字串的開頭開始比對。</span><span class="sxs-lookup"><span data-stu-id="08aad-305">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="08aad-306">比對英數字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-306">Match an alphanumeric character.</span></span> <span data-ttu-id="08aad-307">這項比較不區分大小寫，因為 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法是使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 選項呼叫。</span><span class="sxs-lookup"><span data-stu-id="08aad-307">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="08aad-308">比對出現零次、一次或多次的連字號、句號或文字字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-308">Match zero, one, or more occurrences of a hyphen, period, or word character.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="08aad-309">比對英數字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-309">Match an alphanumeric character.</span></span>|  
|`([-.\w]*[0-9A-Z])*`|<span data-ttu-id="08aad-310">比對出現零次或多次的零個或多個連字號、句號或文字字元組合，後面接著英數字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-310">Match zero or more occurrences of the combination of zero or more hyphens, periods, or word characters, followed by an alphanumeric character.</span></span> <span data-ttu-id="08aad-311">這是第一個擷取群組。</span><span class="sxs-lookup"><span data-stu-id="08aad-311">This is the first capturing group.</span></span>|  
|`@`|<span data-ttu-id="08aad-312">比對 "\@" 記號。</span><span class="sxs-lookup"><span data-stu-id="08aad-312">Match an at sign ("\@").</span></span>|  
  
 <span data-ttu-id="08aad-313">第二個規則運算式模式 `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`使用左合樣判斷提示。</span><span class="sxs-lookup"><span data-stu-id="08aad-313">The second regular expression pattern, `^[0-9A-Z][-.\w]*(?<=[0-9A-Z])@`, uses a positive lookbehind assertion.</span></span> <span data-ttu-id="08aad-314">其定義方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="08aad-314">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="08aad-315">模式</span><span class="sxs-lookup"><span data-stu-id="08aad-315">Pattern</span></span>|<span data-ttu-id="08aad-316">說明</span><span class="sxs-lookup"><span data-stu-id="08aad-316">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="08aad-317">從字串的開頭開始比對。</span><span class="sxs-lookup"><span data-stu-id="08aad-317">Start the match at the beginning of the string.</span></span>|  
|`[0-9A-Z]`|<span data-ttu-id="08aad-318">比對英數字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-318">Match an alphanumeric character.</span></span> <span data-ttu-id="08aad-319">這項比較不區分大小寫，因為 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法是使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 選項呼叫。</span><span class="sxs-lookup"><span data-stu-id="08aad-319">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`[-.\w]*`|<span data-ttu-id="08aad-320">比對出現零次或多次的連字號、句號或文字字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-320">Match zero or more occurrences of a hyphen, period, or word character.</span></span>|  
|`(?<=[0-9A-Z])`|<span data-ttu-id="08aad-321">如果是英數字，則向左合樣最後一個符合的字元並繼續比對。</span><span class="sxs-lookup"><span data-stu-id="08aad-321">Look back at the last matched character and continue the match if it is alphanumeric.</span></span> <span data-ttu-id="08aad-322">請注意，英數字元是由句號、連字號和所有文字字元組成之集合的子集。</span><span class="sxs-lookup"><span data-stu-id="08aad-322">Note that alphanumeric characters are a subset of the set that consists of periods, hyphens, and all word characters.</span></span>|  
|`@`|<span data-ttu-id="08aad-323">比對 "\@" 記號。</span><span class="sxs-lookup"><span data-stu-id="08aad-323">Match an at sign ("\@").</span></span>|  
  
<a name="Lookahead"></a>   
### <a name="lookahead-assertions"></a><span data-ttu-id="08aad-324">右合樣判斷提示</span><span class="sxs-lookup"><span data-stu-id="08aad-324">Lookahead Assertions</span></span>  
 <span data-ttu-id="08aad-325">.NET 包含兩個語言元素：`(?=`*subexpression*`)` 和 `(?!`*subexpression*`)`，這兩者會比對輸入字串中的下一個或多個字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-325">.NET includes two language elements, `(?=`*subexpression*`)` and `(?!`*subexpression*`)`, that match the next character or characters in the input string.</span></span> <span data-ttu-id="08aad-326">這兩個語言項目都是零寬度判斷提示，也就是說，它們會判斷緊接著目前字元後面的字元是否可由 *子運算式*比對，而不需前進或回溯。</span><span class="sxs-lookup"><span data-stu-id="08aad-326">Both language elements are zero-width assertions; that is, they determine whether the character or characters that immediately follow the current character can be matched by *subexpression*, without advancing or backtracking.</span></span>  
  
 <span data-ttu-id="08aad-327">`(?=` *子運算式* `)` 是右合樣判斷提示，也就是說，目前位置後面的字元必須符合 *子運算式*。</span><span class="sxs-lookup"><span data-stu-id="08aad-327">`(?=` *subexpression* `)` is a positive lookahead assertion; that is, the character or characters after the current position must match *subexpression*.</span></span> <span data-ttu-id="08aad-328">`(?!`*子運算式*`)` 是右不合樣判斷提示，也就是說，目前位置後面的字元必須不符合 *子運算式*。</span><span class="sxs-lookup"><span data-stu-id="08aad-328">`(?!`*subexpression*`)` is a negative lookahead assertion; that is, the character or characters after the current position must not match *subexpression*.</span></span> <span data-ttu-id="08aad-329">當 *子運算式* 為下一個子運算式的子集時，右合樣和右不合樣判斷提示最為實用。</span><span class="sxs-lookup"><span data-stu-id="08aad-329">Both positive and negative lookahead assertions are most useful when *subexpression* is a subset of the next subexpression.</span></span>  
  
 <span data-ttu-id="08aad-330">下列範例使用兩個同等的規則運算式模式，這兩個模式會驗證完整類型名稱。</span><span class="sxs-lookup"><span data-stu-id="08aad-330">The following example uses two equivalent regular expression patterns that validate a fully qualified type name.</span></span> <span data-ttu-id="08aad-331">第一個模式因為進行大量回溯，而受限於低落的效能。</span><span class="sxs-lookup"><span data-stu-id="08aad-331">The first pattern is subject to poor performance because of excessive backtracking.</span></span> <span data-ttu-id="08aad-332">第二個修改了第一個規則運算式，將巢狀數量詞取代為右合樣判斷提示。</span><span class="sxs-lookup"><span data-stu-id="08aad-332">The second modifies the first regular expression by replacing a nested quantifier with a positive lookahead assertion.</span></span> <span data-ttu-id="08aad-333">範例的輸入顯示 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法的執行時間。</span><span class="sxs-lookup"><span data-stu-id="08aad-333">The output from the example displays the execution time of the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/cs/backtracking6.cs#6)]
 [!code-vb[Conceptual.RegularExpressions.Backtracking#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.backtracking/vb/backtracking6.vb#6)]  
  
 <span data-ttu-id="08aad-334">第一個規則運算式模式 `^(([A-Z]\w*)+\.)*[A-Z]\w*$`的定義如下表所示。</span><span class="sxs-lookup"><span data-stu-id="08aad-334">The first regular expression pattern, `^(([A-Z]\w*)+\.)*[A-Z]\w*$`, is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="08aad-335">模式</span><span class="sxs-lookup"><span data-stu-id="08aad-335">Pattern</span></span>|<span data-ttu-id="08aad-336">說明</span><span class="sxs-lookup"><span data-stu-id="08aad-336">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="08aad-337">從字串的開頭開始比對。</span><span class="sxs-lookup"><span data-stu-id="08aad-337">Start the match at the beginning of the string.</span></span>|  
|`([A-Z]\w*)+\.`|<span data-ttu-id="08aad-338">比對後面接著零個或多個文字字元的字母字元 (A-Z) 一次或多次，後面接著句號。</span><span class="sxs-lookup"><span data-stu-id="08aad-338">Match an alphabetical character (A-Z) followed by zero or more word characters one or more times, followed by a period.</span></span> <span data-ttu-id="08aad-339">這項比較不區分大小寫，因為 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法是使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 選項呼叫。</span><span class="sxs-lookup"><span data-stu-id="08aad-339">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`(([A-Z]\w*)+\.)*`|<span data-ttu-id="08aad-340">比對上一個模式零次或多次。</span><span class="sxs-lookup"><span data-stu-id="08aad-340">Match the previous pattern zero or more times.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="08aad-341">比對後面接著零個或多個文字字元的字母字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-341">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="08aad-342">在輸入字串結尾結束比對。</span><span class="sxs-lookup"><span data-stu-id="08aad-342">End the match at the end of the input string.</span></span>|  
  
 <span data-ttu-id="08aad-343">第二個規則運算式模式 `^((?=[A-Z])\w+\.)*[A-Z]\w*$`使用右合樣判斷提示。</span><span class="sxs-lookup"><span data-stu-id="08aad-343">The second regular expression pattern, `^((?=[A-Z])\w+\.)*[A-Z]\w*$`, uses a positive lookahead assertion.</span></span> <span data-ttu-id="08aad-344">其定義方式如下表所示。</span><span class="sxs-lookup"><span data-stu-id="08aad-344">It is defined as shown in the following table.</span></span>  
  
|<span data-ttu-id="08aad-345">模式</span><span class="sxs-lookup"><span data-stu-id="08aad-345">Pattern</span></span>|<span data-ttu-id="08aad-346">說明</span><span class="sxs-lookup"><span data-stu-id="08aad-346">Description</span></span>|  
|-------------|-----------------|  
|`^`|<span data-ttu-id="08aad-347">從字串的開頭開始比對。</span><span class="sxs-lookup"><span data-stu-id="08aad-347">Start the match at the beginning of the string.</span></span>|  
|`(?=[A-Z])`|<span data-ttu-id="08aad-348">如果是字母 (A-Z)，則向右合樣至第一個字元並繼續比對。</span><span class="sxs-lookup"><span data-stu-id="08aad-348">Look ahead to the first character and continue the match if it is alphabetical (A-Z).</span></span> <span data-ttu-id="08aad-349">這項比較不區分大小寫，因為 <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> 方法是使用 <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> 選項呼叫。</span><span class="sxs-lookup"><span data-stu-id="08aad-349">This comparison is case-insensitive, because the <xref:System.Text.RegularExpressions.Regex.IsMatch%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option.</span></span>|  
|`\w+\.`|<span data-ttu-id="08aad-350">比對後面接著句號的零個或多個文字字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-350">Match one or more word characters followed by a period.</span></span>|  
|`((?=[A-Z])\w+\.)*`|<span data-ttu-id="08aad-351">比對後面接句號的一個或多個文字字元這個模式一次或多次。</span><span class="sxs-lookup"><span data-stu-id="08aad-351">Match the pattern of one or more word characters followed by a period zero or more times.</span></span> <span data-ttu-id="08aad-352">初始文字字元必須是字母。</span><span class="sxs-lookup"><span data-stu-id="08aad-352">The initial word character must be alphabetical.</span></span>|  
|`[A-Z]\w*`|<span data-ttu-id="08aad-353">比對後面接著零個或多個文字字元的字母字元。</span><span class="sxs-lookup"><span data-stu-id="08aad-353">Match an alphabetical character followed by zero or more word characters.</span></span>|  
|`$`|<span data-ttu-id="08aad-354">在輸入字串結尾結束比對。</span><span class="sxs-lookup"><span data-stu-id="08aad-354">End the match at the end of the input string.</span></span>|  
  
 [<span data-ttu-id="08aad-355">回到頁首</span><span class="sxs-lookup"><span data-stu-id="08aad-355">Back to top</span></span>](#top)  
  
## <a name="see-also"></a><span data-ttu-id="08aad-356">另請參閱</span><span class="sxs-lookup"><span data-stu-id="08aad-356">See also</span></span>

- [<span data-ttu-id="08aad-357">.NET 規則運算式</span><span class="sxs-lookup"><span data-stu-id="08aad-357">.NET Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)  
- [<span data-ttu-id="08aad-358">規則運算式語言 - 快速參考</span><span class="sxs-lookup"><span data-stu-id="08aad-358">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)  
- [<span data-ttu-id="08aad-359">數量詞</span><span class="sxs-lookup"><span data-stu-id="08aad-359">Quantifiers</span></span>](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md)  
- [<span data-ttu-id="08aad-360">交替建構</span><span class="sxs-lookup"><span data-stu-id="08aad-360">Alternation Constructs</span></span>](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md)  
- [<span data-ttu-id="08aad-361">Grouping Constructs</span><span class="sxs-lookup"><span data-stu-id="08aad-361">Grouping Constructs</span></span>](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md)
