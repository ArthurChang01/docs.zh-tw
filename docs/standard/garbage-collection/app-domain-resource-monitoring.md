---
title: "應用程式定義域資源監視"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- monitoring managed memory use by application domain
- application domains, memory use
- memory use, monitoring
- application domains, resource monitoring
ms.assetid: 318bedf8-7f35-4f00-b34a-2b7b8e3fa315
caps.latest.revision: "8"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 62a514f94857044af5020d36a1cfd6ce06741ac7
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/21/2017
---
# <a name="application-domain-resource-monitoring"></a><span data-ttu-id="168a6-102">應用程式定義域資源監視</span><span class="sxs-lookup"><span data-stu-id="168a6-102">Application Domain Resource Monitoring</span></span>
<span data-ttu-id="168a6-103">應用程式定義域資源監視 (ARM) 可讓主機監視由應用程式定義域的 CPU 和記憶體使用量。</span><span class="sxs-lookup"><span data-stu-id="168a6-103">Application domain resource monitoring (ARM) enables hosts to monitor CPU and memory usage by application domain.</span></span> <span data-ttu-id="168a6-104">這非常有用，例如 ASP.NET 使用長時間執行的處理序中的許多應用程式定義域的主機。</span><span class="sxs-lookup"><span data-stu-id="168a6-104">This is useful for hosts such as ASP.NET that use many application domains in a long-running process.</span></span> <span data-ttu-id="168a6-105">主機可以卸載嚴重影響效能的整個程序，但僅限於如果它可以識別問題的應用程式的應用程式的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="168a6-105">The host can unload the application domain of an application that is adversely affecting the performance of the entire process, but only if it can identify the problematic application.</span></span> <span data-ttu-id="168a6-106">ARM 提供可用來協助您制定這類的資訊。</span><span class="sxs-lookup"><span data-stu-id="168a6-106">ARM provides information that can be used to assist in making such decisions.</span></span>  
  
 <span data-ttu-id="168a6-107">例如，主機服務可能有許多 ASP.NET 伺服器上執行的應用程式。</span><span class="sxs-lookup"><span data-stu-id="168a6-107">For example, a hosting service might have many applications running on an ASP.NET server.</span></span> <span data-ttu-id="168a6-108">如果程序中的一個應用程式開始耗用太多記憶體或太多處理器時間，則裝載服務可以使用 ARM 找出造成問題的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="168a6-108">If one application in the process begins consuming too much memory or too much processor time, the hosting service can use ARM to identify the application domain that is causing the problem.</span></span>  
  
 <span data-ttu-id="168a6-109">ARM 是充分輕量型即時應用程式中使用。</span><span class="sxs-lookup"><span data-stu-id="168a6-109">ARM is sufficiently lightweight to use in live applications.</span></span> <span data-ttu-id="168a6-110">您可以使用 Windows (ETW) 或直接透過 managed 或原生應用程式開發介面的事件追蹤來存取資訊。</span><span class="sxs-lookup"><span data-stu-id="168a6-110">You can access the information by using event tracing for Windows (ETW) or directly through managed or native APIs.</span></span>  
  
## <a name="enabling-resource-monitoring"></a><span data-ttu-id="168a6-111">啟用資源的監視</span><span class="sxs-lookup"><span data-stu-id="168a6-111">Enabling Resource Monitoring</span></span>  
 <span data-ttu-id="168a6-112">ARM 可以用四種方式啟用： 所提供的組態檔，common language runtime (CLR) 啟動時，使用 unmanaged 裝載 API，使用 managed 程式碼，或接聽 ARM ETW 事件。</span><span class="sxs-lookup"><span data-stu-id="168a6-112">ARM can be enabled in four ways: by supplying a configuration file when the common language runtime (CLR) is started, by using an unmanaged hosting API, by using managed code, or by listening to ARM ETW events.</span></span>  
  
 <span data-ttu-id="168a6-113">只要啟用 ARM 時，就會開始收集程序中的所有應用程式定義域的資料。如果啟用 ARM 之前，已建立應用程式定義域，累積資料會啟動啟用 ARM 時，不會在建立應用程式網域。一旦啟用後，就無法停用 ARM。</span><span class="sxs-lookup"><span data-stu-id="168a6-113">As soon as ARM is enabled, it begins collecting data on all application domains in the process.If an application domain was created before ARM is enabled, cumulative data starts when ARM is enabled, not when the application domain was created.Once it is enabled, ARM cannot be disabled.</span></span>  
  
-   <span data-ttu-id="168a6-114">您也可以加入在 CLR 啟動啟用 ARM [ \<appDomainResourceMonitoring >](../../../docs/framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md)組態檔，以及設定項目`enabled`屬性`true`。</span><span class="sxs-lookup"><span data-stu-id="168a6-114">You can enable ARM at CLR startup by adding the [\<appDomainResourceMonitoring>](../../../docs/framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md) element to the configuration file, and setting the `enabled` attribute to `true`.</span></span> <span data-ttu-id="168a6-115">值為`false`（預設值） 只表示 ARM 未啟用在啟動時，您可以啟動它之後使用其中一種其他啟動機制。</span><span class="sxs-lookup"><span data-stu-id="168a6-115">A value of `false` (the default) means only that ARM is not enabled at startup; you can activate it later by using one of the other activation mechanisms.</span></span>  
  
-   <span data-ttu-id="168a6-116">主應用程式可以藉由要求來啟用 ARM [ICLRAppDomainResourceMonitor](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md)裝載介面。</span><span class="sxs-lookup"><span data-stu-id="168a6-116">The host can enable ARM by requesting the [ICLRAppDomainResourceMonitor](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md) hosting interface.</span></span> <span data-ttu-id="168a6-117">一旦成功取得此介面，會啟用 ARM。</span><span class="sxs-lookup"><span data-stu-id="168a6-117">Once this interface is successfully obtained, ARM is enabled.</span></span>  
  
-   <span data-ttu-id="168a6-118">Managed 程式碼可以藉由設定靜態啟用 ARM (`Shared`在 Visual Basic 中)<xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType>屬性`true`。</span><span class="sxs-lookup"><span data-stu-id="168a6-118">Managed code can enable ARM by setting the static (`Shared` in Visual Basic) <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType> property to `true`.</span></span> <span data-ttu-id="168a6-119">一旦設定屬性，則會啟用 ARM。</span><span class="sxs-lookup"><span data-stu-id="168a6-119">As soon as the property is set, ARM is enabled.</span></span>  
  
-   <span data-ttu-id="168a6-120">您可以接聽 ETW 事件，在啟動之後啟用 ARM。</span><span class="sxs-lookup"><span data-stu-id="168a6-120">You can enable ARM after startup by listening to ETW events.</span></span> <span data-ttu-id="168a6-121">ARM 已啟用並開始時啟用公用提供者引發事件的所有應用程式定義域`Microsoft-Windows-DotNETRuntime`使用`AppDomainResourceManagementKeyword`關鍵字。</span><span class="sxs-lookup"><span data-stu-id="168a6-121">ARM is enabled and begins raising events for all application domains when you enable the public provider `Microsoft-Windows-DotNETRuntime` by using the `AppDomainResourceManagementKeyword` keyword.</span></span> <span data-ttu-id="168a6-122">若要讓資料相互關聯與應用程式定義域和執行緒，您必須同時啟用`Microsoft-Windows-DotNETRuntimeRundown`提供者與`ThreadingKeyword`關鍵字。</span><span class="sxs-lookup"><span data-stu-id="168a6-122">To correlate data with application domains and threads, you must also enable the `Microsoft-Windows-DotNETRuntimeRundown` provider with the `ThreadingKeyword` keyword.</span></span>  
  
## <a name="using-arm"></a><span data-ttu-id="168a6-123">使用 ARM</span><span class="sxs-lookup"><span data-stu-id="168a6-123">Using ARM</span></span>  
 <span data-ttu-id="168a6-124">ARM 提供由應用程式定義域和記憶體使用量的相關資訊的三種類型的總處理器時間。</span><span class="sxs-lookup"><span data-stu-id="168a6-124">ARM provides the total processor time that is used by an application domain and three kinds of information about memory use.</span></span>  
  
-   <span data-ttu-id="168a6-125">**應用程式定義域，以秒為單位的處理器時間總計**： 這加上所花費的時間在應用程式定義域中執行其存留期間的所有執行緒的作業系統所回報的執行緒時間計算。</span><span class="sxs-lookup"><span data-stu-id="168a6-125">**Total processor time for an application domain, in seconds**: This is calculated by adding up the thread times reported by the operating system for all threads that spent time executing in the application domain during its lifetime.</span></span> <span data-ttu-id="168a6-126">封鎖或睡眠中的執行緒不會使用處理器時間。</span><span class="sxs-lookup"><span data-stu-id="168a6-126">Blocked or sleeping threads do not use processor time.</span></span> <span data-ttu-id="168a6-127">當執行緒呼叫原生程式碼時，執行緒花在原生程式碼的時間會包含在所呼叫的應用程式定義域計數。</span><span class="sxs-lookup"><span data-stu-id="168a6-127">When a thread calls into native code, the time that the thread spends in native code is included in the count for the application domain where the call was made.</span></span>  
  
    -   <span data-ttu-id="168a6-128">Managed API:<xref:System.AppDomain.MonitoringTotalProcessorTime%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="168a6-128">Managed API: <xref:System.AppDomain.MonitoringTotalProcessorTime%2A?displayProperty=nameWithType> property.</span></span>  
  
    -   <span data-ttu-id="168a6-129">裝載 API: [iclrappdomainresourcemonitor:: Getcurrentcputime](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentcputime-method.md)方法。</span><span class="sxs-lookup"><span data-stu-id="168a6-129">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentCpuTime](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentcputime-method.md) method.</span></span>  
  
    -   <span data-ttu-id="168a6-130">ETW 事件： `ThreadCreated`， `ThreadAppDomainEnter`，和`ThreadTerminated`事件。</span><span class="sxs-lookup"><span data-stu-id="168a6-130">ETW events: `ThreadCreated`, `ThreadAppDomainEnter`, and `ThreadTerminated` events.</span></span> <span data-ttu-id="168a6-131">提供者和關鍵字的相關資訊，請參閱 「 AppDomain 資源監視事件 」，在[CLR ETW 事件](../../../docs/framework/performance/clr-etw-events.md)。</span><span class="sxs-lookup"><span data-stu-id="168a6-131">For information about providers and keywords, see "AppDomain Resource Monitoring Events" in [CLR ETW Events](../../../docs/framework/performance/clr-etw-events.md).</span></span>  
  
-   <span data-ttu-id="168a6-132">**在其生命週期，以位元組為單位進行應用程式定義域的 managed 的配置的總**： 總配置不一定會反映應用程式定義域的記憶體使用因為配置的物件可能存留較短。</span><span class="sxs-lookup"><span data-stu-id="168a6-132">**Total managed allocations made by an application domain during its lifetime, in bytes**: Total allocations do not always reflect memory use by an application domain, because the allocated objects might be short-lived.</span></span> <span data-ttu-id="168a6-133">不過，如果應用程式會配置與釋放大量物件，配置的記憶體成本可能會很大。</span><span class="sxs-lookup"><span data-stu-id="168a6-133">However, if an application allocates and frees huge numbers of objects, the cost of the allocations could be significant.</span></span>  
  
    -   <span data-ttu-id="168a6-134">Managed API:<xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="168a6-134">Managed API: <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A?displayProperty=nameWithType> property.</span></span>  
  
    -   <span data-ttu-id="168a6-135">裝載 API: [iclrappdomainresourcemonitor:: Getcurrentallocated](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentallocated-method.md)方法。</span><span class="sxs-lookup"><span data-stu-id="168a6-135">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentAllocated](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentallocated-method.md) method.</span></span>  
  
    -   <span data-ttu-id="168a6-136">ETW 事件：`AppDomainMemAllocated`事件，`Allocated`欄位。</span><span class="sxs-lookup"><span data-stu-id="168a6-136">ETW events: `AppDomainMemAllocated` event, `Allocated` field.</span></span>  
  
-   <span data-ttu-id="168a6-137">**受管理的記憶體，以位元組為單位，由應用程式定義域所參考且未被記憶體的最新的完整的封鎖集合**： 這個數字之後，即正確只執行完整的封鎖集合。</span><span class="sxs-lookup"><span data-stu-id="168a6-137">**Managed memory, in bytes, that is referenced by an application domain and that survived the most recent full, blocking collection**: This number is accurate only after a full, blocking collection.</span></span> <span data-ttu-id="168a6-138">（這是相較於並行的集合，會在背景進行，而不會封鎖應用程式）。例如，<xref:System.GC.Collect?displayProperty=nameWithType>方法多載會導致執行完整的封鎖集合。</span><span class="sxs-lookup"><span data-stu-id="168a6-138">(This is in contrast to concurrent collections, which occur in the background and do not block the application.) For example, the <xref:System.GC.Collect?displayProperty=nameWithType> method overload causes a full, blocking collection.</span></span>  
  
    -   <span data-ttu-id="168a6-139">Managed API:<xref:System.AppDomain.MonitoringSurvivedMemorySize%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="168a6-139">Managed API: <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A?displayProperty=nameWithType> property.</span></span>  
  
    -   <span data-ttu-id="168a6-140">裝載 API: [iclrappdomainresourcemonitor:: Getcurrentsurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md)方法，`pAppDomainBytesSurvived`參數。</span><span class="sxs-lookup"><span data-stu-id="168a6-140">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) method, `pAppDomainBytesSurvived` parameter.</span></span>  
  
    -   <span data-ttu-id="168a6-141">ETW 事件：`AppDomainMemSurvived`事件，`Survived`欄位。</span><span class="sxs-lookup"><span data-stu-id="168a6-141">ETW events: `AppDomainMemSurvived` event, `Survived` field.</span></span>  
  
-   <span data-ttu-id="168a6-142">**總計受管理的記憶體，以位元組為單位，程序所參考且未被記憶體的最新的完整的封鎖集合**： 這個數字，就可以比較的個別應用程式定義域的未被回收的記憶體。</span><span class="sxs-lookup"><span data-stu-id="168a6-142">**Total managed memory, in bytes, that is referenced by the process and that survived the most recent full, blocking collection**: The survived memory for individual application domains can be compared to this number.</span></span>  
  
    -   <span data-ttu-id="168a6-143">Managed API:<xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="168a6-143">Managed API: <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A?displayProperty=nameWithType> property.</span></span>  
  
    -   <span data-ttu-id="168a6-144">裝載 API: [iclrappdomainresourcemonitor:: Getcurrentsurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md)方法，`pTotalBytesSurvived`參數。</span><span class="sxs-lookup"><span data-stu-id="168a6-144">Hosting API: [ICLRAppDomainResourceMonitor::GetCurrentSurvived](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-getcurrentsurvived-method.md) method, `pTotalBytesSurvived` parameter.</span></span>  
  
    -   <span data-ttu-id="168a6-145">ETW 事件：`AppDomainMemSurvived`事件，`ProcessSurvived`欄位。</span><span class="sxs-lookup"><span data-stu-id="168a6-145">ETW events: `AppDomainMemSurvived` event, `ProcessSurvived` field.</span></span>  
  
### <a name="determining-when-a-full-blocking-collection-occurs"></a><span data-ttu-id="168a6-146">決定完整時，封鎖集合就會發生</span><span class="sxs-lookup"><span data-stu-id="168a6-146">Determining When a Full, Blocking Collection Occurs</span></span>  
 <span data-ttu-id="168a6-147">若要判斷未被回收記憶體的計數是精確時，您需要知道完整的封鎖集合只在發生時。</span><span class="sxs-lookup"><span data-stu-id="168a6-147">To determine when counts of survived memory are accurate, you need to know when a full, blocking collection has just occurred.</span></span> <span data-ttu-id="168a6-148">執行此作業的方法取決於您使用來檢查 ARM 統計資料的 API。</span><span class="sxs-lookup"><span data-stu-id="168a6-148">The method for doing this depends on the API you use to examine ARM statistics.</span></span>  
  
#### <a name="managed-api"></a><span data-ttu-id="168a6-149">受管理的應用程式開發介面</span><span class="sxs-lookup"><span data-stu-id="168a6-149">Managed API</span></span>  
 <span data-ttu-id="168a6-150">如果您使用的屬性<xref:System.AppDomain>類別，您可以使用<xref:System.GC.RegisterForFullGCNotification%2A?displayProperty=nameWithType>方法來註冊通知的完整集合。</span><span class="sxs-lookup"><span data-stu-id="168a6-150">If you use the properties of the <xref:System.AppDomain> class, you can use the <xref:System.GC.RegisterForFullGCNotification%2A?displayProperty=nameWithType> method to register for notification of full collections.</span></span> <span data-ttu-id="168a6-151">您使用的臨界值並不重要，因為您正在等候完成的集合，而不是集合的方法。</span><span class="sxs-lookup"><span data-stu-id="168a6-151">The threshold you use is not important, because you are waiting for the completion of a collection rather than the approach of a collection.</span></span> <span data-ttu-id="168a6-152">您可以接著呼叫<xref:System.GC.WaitForFullGCComplete%2A?displayProperty=nameWithType>方法，這個方法會封鎖，直到完成完整的集合。</span><span class="sxs-lookup"><span data-stu-id="168a6-152">You can then call the <xref:System.GC.WaitForFullGCComplete%2A?displayProperty=nameWithType> method, which blocks until a full collection has completed.</span></span> <span data-ttu-id="168a6-153">您可以建立在迴圈中呼叫的方法，且沒有任何必要的分析，每當此方法會傳回的執行緒。</span><span class="sxs-lookup"><span data-stu-id="168a6-153">You can create a thread that calls the method in a loop and does any necessary analysis whenever the method returns.</span></span>  
  
 <span data-ttu-id="168a6-154">或者，您可以呼叫<xref:System.GC.CollectionCount%2A?displayProperty=nameWithType>定期以查看是否增加的層代 2 回收計數的方法。</span><span class="sxs-lookup"><span data-stu-id="168a6-154">Alternatively, you can call the <xref:System.GC.CollectionCount%2A?displayProperty=nameWithType> method periodically to see if the count of generation 2 collections has increased.</span></span> <span data-ttu-id="168a6-155">根據輪詢頻率，這項技術可能無法提供最精確的完整集合的項目表示。</span><span class="sxs-lookup"><span data-stu-id="168a6-155">Depending on the polling frequency, this technique might not provide as accurate an indication of the occurrence of a full collection.</span></span>  
  
#### <a name="hosting-api"></a><span data-ttu-id="168a6-156">裝載 API</span><span class="sxs-lookup"><span data-stu-id="168a6-156">Hosting API</span></span>  
 <span data-ttu-id="168a6-157">如果您使用未受管理的裝載 API，您的主機必須將傳遞 CLR 的實作[IHostGCManager](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-interface.md)介面。</span><span class="sxs-lookup"><span data-stu-id="168a6-157">If you use the unmanaged hosting API, your host must pass the CLR an implementation of the [IHostGCManager](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-interface.md) interface.</span></span> <span data-ttu-id="168a6-158">CLR 會呼叫[ihostgcmanager:: Suspensionending](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md)方法時，它會繼續執行而回收時已暫止的執行緒。</span><span class="sxs-lookup"><span data-stu-id="168a6-158">The CLR calls the [IHostGCManager::SuspensionEnding](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) method when it resumes execution of threads that have been suspended while a collection occurs.</span></span> <span data-ttu-id="168a6-159">CLR 會產生已完成的集合傳遞做為參數的方法，讓主機可以判斷集合是否完整或部分。</span><span class="sxs-lookup"><span data-stu-id="168a6-159">The CLR passes the generation of the completed collection as a parameter of the method, so the host can determine whether the collection was full or partial.</span></span> <span data-ttu-id="168a6-160">實作[ihostgcmanager:: Suspensionending](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md)方法可以查詢未被回收的記憶體，以確定更新時，已擷取計數。</span><span class="sxs-lookup"><span data-stu-id="168a6-160">Your implementation of the [IHostGCManager::SuspensionEnding](../../../docs/framework/unmanaged-api/hosting/ihostgcmanager-suspensionending-method.md) method can query for survived memory, to ensure that the counts are retrieved as soon as they are updated.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="168a6-161">另請參閱</span><span class="sxs-lookup"><span data-stu-id="168a6-161">See Also</span></span>  
 <xref:System.AppDomain.MonitoringIsEnabled%2A?displayProperty=nameWithType>  
 [<span data-ttu-id="168a6-162">ICLRAppDomainResourceMonitor 介面</span><span class="sxs-lookup"><span data-stu-id="168a6-162">ICLRAppDomainResourceMonitor Interface</span></span>](../../../docs/framework/unmanaged-api/hosting/iclrappdomainresourcemonitor-interface.md)  
 [<span data-ttu-id="168a6-163">\<appDomainResourceMonitoring></span><span class="sxs-lookup"><span data-stu-id="168a6-163">\<appDomainResourceMonitoring></span></span>](../../../docs/framework/configure-apps/file-schema/runtime/appdomainresourcemonitoring-element.md)  
 [<span data-ttu-id="168a6-164">CLR ETW 事件</span><span class="sxs-lookup"><span data-stu-id="168a6-164">CLR ETW Events</span></span>](../../../docs/framework/performance/clr-etw-events.md)
