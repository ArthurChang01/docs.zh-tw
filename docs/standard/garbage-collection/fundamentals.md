---
title: 記憶體回收的基本概念
description: 了解記憶體回收行程如何運作，以及如何為它設定最佳效能。
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: 1fdf7fcd61fb4bf9e8e0cbfe28842208f6eadd00
ms.sourcegitcommit: 73aa9653547a1cd70ee6586221f79cc29b588ebd
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/23/2020
ms.locfileid: "82102433"
---
# <a name="fundamentals-of-garbage-collection"></a>記憶體回收的基本概念

在通用語言運行時 (CLR) 中,垃圾回收器 (GC) 充當自動記憶體管理器。 垃圾回收器管理應用程式的記憶體分配和釋放。 對於使用託管代碼的開發人員,這意味著您不必編寫代碼來執行記憶體管理任務。 自動記憶體管理可以消除常見問題,例如忘記釋放物件並導致記憶體洩漏或嘗試訪問已釋放的物件的記憶體。

本文介紹了垃圾回收的核心概念。

## <a name="benefits"></a>優點

垃圾回收器提供以下優點:

- 使開發人員不必手動釋放記憶體。

- 有效率地在 Managed 堆積上配置物件。

- 回收不再使用的物件、清除其記憶體，並且讓記憶體可供未來的配置使用。 託管物件會自動獲取乾淨的內容,因此其構造函數不必初始化每個數據欄位。

- 確保某個物件無法使用另一個物件的內容，藉以提供記憶體安全性。

## <a name="fundamentals-of-memory"></a>記憶體的基本概念

下列清單摘要說明重要的 CLR 記憶體概念。

- 每個處理序都有各自獨立的虛擬位址空間。 同一台電腦上的所有進程共用相同的實體記憶體和頁面檔(如果有)。

- 根據預設，在 32 位元電腦上，每個處理序都有 2 GB 使用者模式虛擬位址空間。

- 身為應用程式開發人員，您只會處理虛擬位址空間，絕不會直接操作實體記憶體。 記憶體回收行程會在 Managed 堆積上自動配置和釋出虛擬記憶體。

  如果要編寫本機代碼,請使用 Windows 函數來處理虛擬位址空間。 這些函式會在原生堆積上自動配置和釋出虛擬記憶體。

- 虛擬記憶體可以有三種狀態：

  | State | 描述 |
  |---------|---------|
  | 免費 | 記憶體區塊沒有任何參考，可進行配置。 |
  | Reserved | 記憶體區塊可供您使用，但是無法用於任何其他配置要求。 不過，在此記憶體區塊認可之前，您無法將資料儲存到其中。 |
  | 認可 | 記憶體區塊會指派給實體儲存區。 |

- 虛擬位址空間可能會分成片段。 這表示，位址空間中有可用的區塊，也稱為可用的洞 (Hole)。 要求虛擬記憶體配置時，虛擬記憶體管理程式必須找到大小可滿足配置要求的單一可用區塊。 即使您有 2 GB 的可用空間,除非所有可用空間都位於單個位址塊中,否則需要 2 GB 的分配也不會成功。

- 如果沒有足夠的虛擬位址空間來保留或物理空間進行提交,則記憶體可能會耗盡。

  即使物理記憶體壓力(即物理記憶體需求)較低,也會使用頁面檔。 第一次物理記憶體壓力較高時,操作系統必須在物理記憶體中留出空間來存儲數據,並將物理記憶體中的某些數據備份到頁面檔。 在需要數據之前不會分頁,因此在物理記憶體壓力低的情況下可能會遇到分頁。
  
### <a name="memory-allocation"></a>記憶體配置

當您初始化新的處理序 (Process) 時，Runtime 會保留一塊連續的位址空間區域，供處理序使用。 這塊保留的位址空間稱為 Managed 堆積 (Heap)。 Managed 堆積會保留即將配置給堆積中下一個物件的位址指標。 剛開始會將這個指標設定為 Managed 堆積的基底位址 (Base Address)。 所有參考類型都是在 Managed 堆積上進行配置。 當應用程式建立第一個參考型別時，會為該型別配置 Managed 堆積基底位址的記憶體。 當應用程式建立第二個物件時，記憶體回收行程會為它配置緊接在第一個物件後面位址空間的記憶體。 只要有可供使用的位址空間，記憶體回收行程就會繼續用這種方式為新的物件配置空間。

從 Managed 堆積中配置記憶體要比 Unmanaged 記憶體配置快。 由於運行時通過向指標添加值來分配物件的記憶體,因此它幾乎與從堆疊中分配記憶體的速度一樣快。 此外,由於連續分配的新物件連續存儲在託管堆中,因此應用程式可以快速訪問物件。

### <a name="memory-release"></a>記憶體釋放

記憶體回收行程的最佳化引擎會根據所做的配置，決定執行回收的最佳時機。 當記憶體回收行程執行回收時，會將應用程式已經不再使用的物件記憶體釋放出來。 它通過檢查應用程式的*根*來確定不再使用哪些物件。 應用程式的根目錄包括執行緒堆疊上的靜態欄位、區域變數和參數，以及 CPU 暫存器。 每一個根目錄都會參考 Managed 堆積上的物件，要不然就是設定為 Null。 記憶體回收行程可以存取 Just-in-Time (JIT) 編譯器和執行階段所保留的使用中根目錄清單。 使用此清單,垃圾回收器將創建一個圖形,其中包含從根可接觸到的所有物件。

不在圖形中的物件就無法從應用程式的根目錄取得。 垃圾回收器考慮無法訪問的物件垃圾,並釋放為其分配的記憶體。 在回收期間，記憶體回收行程會檢查 Managed 堆積，尋找無法取得的物件所佔用的位址空間區塊。 每找到一個無法取得的物件時，它便會使用記憶體複製功能，壓縮記憶體中可取得的物件，然後釋放出為無法取得的物件所配置的位址空間區塊。 一旦壓縮完可取得物件的記憶體之後，記憶體回收行程會進行必要的指標更正，使應用程式的根目錄指向新位置中的物件。 它也會將 Managed 堆積的指標放在最後取得物件的後面。

僅當集合發現大量無法訪問的物件時,才會壓縮記憶體。 如果 Managed 堆積中的所有物件在回收之後都存留下來，就不需要壓縮記憶體。

為了改善效能，Runtime 會為大型物件配置不同堆積中的記憶體。 記憶體回收行程會自動釋放大型物件的記憶體。 但是,為了避免在記憶體中移動大型物件,通常不壓縮此記憶體。

## <a name="conditions-for-a-garbage-collection"></a>記憶體回收的條件

當下列其中一個條件成立時，就會進行記憶體回收：

- 系統的實體記憶體不足。 這由來自操作系統的低記憶體通知或主機指示的低記憶體檢測到。

- 託管堆上分配的物件使用的記憶體超過可接受的閾值。 這個臨界值會在處理序執行時持續調整。

- 已呼叫 <xref:System.GC.Collect%2A?displayProperty=nameWithType> 方法。 在幾乎所有情況下,您都不必調用此方法,因為垃圾回收器會持續運行。 這個方法主要用於獨特的情況和測試。

## <a name="the-managed-heap"></a>Managed 堆積

CLR 初始化記憶體回收行程之後，記憶體回收行程就會配置用來儲存和管理物件的記憶體區段。 這個記憶體稱為 Managed 堆積，與作業系統中的原生堆積相反。

每個 Managed 處理序都有一個 Managed 堆積。 處理序中的所有執行緒都會對相同堆積上的物件配置記憶體。

為了保留記憶體,垃圾回收器調用 Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)函數,並一次為託管應用程式保留一段記憶體。 垃圾回收器還根據需要保留段,並通過調用 Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree)函數將段釋放回作業系統(清除任何物件後)。

> [!IMPORTANT]
> 記憶體回收行程所配置的區段大小是依實作而定，有可能在任何時間，包括在定期更新時做變更。 您的應用程式永遠都不應該對相關或根據特定區段的大小做出假設，也不應嘗試設定區段配置的可用記憶體數量。

配置在堆積上的物件越少，記憶體回收行程必須進行的工作就越少。 分配物件時,不要使用超出需求的舍入值,例如,當您只需要 15 個字節時分配 32 個字節的陣列。

觸發垃圾回收時,垃圾回收器將回收死物件佔用的記憶體。 回收處理序會壓縮使用中物件，讓它們集合在一起，並且移除無作用物件，因而讓堆積更小。 這可確保一起分配的物件保持在託管堆上,以保留其局部性。

記憶體回收的干擾程度 (頻率和持續期間) 是 Managed 堆積上之配置量和未被回收記憶體數量的結果。

堆可以被視為兩個堆的累積:[大型物件堆](large-object-heap.md)和小物件堆。 大型物件堆包含 85,000 位元組和更大的物件,這些物件通常是陣列。 實例物件很少是非常大的。

> [!TIP]
> 您可以設定物件在大型物件堆上的[閾值大小](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold)。

## <a name="generations"></a>層代

GC 演算法基於以下幾個注意事項:

- 與整個託管堆相比,壓縮託管堆部分的記憶體更快。
- 較新的物件的存留期較短,較舊的物件的存留期更長。
- 較新的物件往往彼此相關,並且應用程式大約在同一時間訪問。

垃圾回收主要與回收短壽命物件一起發生。 為了優化垃圾回收器的性能,託管堆分為三代,0、1 和 2,以便可以分別處理長壽命和短壽命物件。 垃圾回收器將新物件存儲在第 0 代中。 在應用程式存留期初期建立的物件則會升階並儲存在第 1 個和第 2 個層代。 由於壓縮託管堆的一部分比整個堆快,因此此方案允許垃圾回收器在特定生成中釋放記憶體,而不是在每次執行集合時釋放整個託管堆的記憶體。

- **第 0 代**. 這是最新的層代而且包含存留較短的物件。 存留較短的物件範例是暫存變數。 記憶體回收最常在這個層代中進行。

  新分配的對象構成新一代的物件,並且隱式生成 0 集合。 但是,如果它們是大型對象,它們將位於第 2 代集合中的大物件堆上。

  大多數物件在第 0 代中回收用於垃圾回收,並且無法生存到下一代。
  
  如果應用程式嘗試在生成 0 已滿時創建新物件,則垃圾回收器將執行一個集合,以嘗試釋放該物件的位址空間。 記憶體回收行程是從檢查第 0 個層代中的物件開始，而不是檢查 Managed 堆積中的所有物件。 僅第 0 代的集合通常可以回收足夠的記憶體,使應用程式能夠繼續創建新物件。

- **第 1 代**. 這個層代包含存留較短的物件，而且當做存留較短物件與存留較長物件之間的緩衝區。

  垃圾回收器執行第 0 代的收集后,它將可訪問對象的記憶體壓縮,並將其提升為第 1 代。 由於回收之後存留下來的物件通常具有較長的存留期，因此才會將它們提升至較高的層代。 垃圾回收器不必在每次執行第 0 代集合時重新檢查第 1 代和第 2 代中的物件。
  
  如果第 0 代的集合無法回收足夠的記憶體,使應用程式無法創建新物件,則垃圾回收器可以執行第 1 代的回收,然後第 2 代。 在回收之後存留下來的第 1 個層代物件則會提升至第 2 個層代。

- **第 2 代**. 這個層代包含存留較長的物件。 長壽命物件的一個範例是伺服器應用程式中包含在進程持續時間內即時的靜態數據的物件。

  第 2 代中存活在集合中的物件將保留在第 2 代中,直到確定它們在未來的集合中無法訪問為止。

當條件許可時，記憶體回收會針對特定層代進行。 回收層代是指回收該層代中的物件及其所有較新的層代。 第 2 代垃圾回收也稱為完整垃圾回收,因為它會回收所有代的物件(即託管堆中的所有物件)。

### <a name="survival-and-promotions"></a>未回收和提升

垃圾回收中未回收的對象稱為倖存者,並提升為下一代:

- 在第 0 代垃圾回收中存活的物件將提升到第 1 代。
- 在第 1 代垃圾回收中存活的物件將提升到第 2 代。
- 在第 2 代垃圾回收中存活的物件將保留在第 2 代中。

當垃圾回收器檢測到一代人的存活率很高時,它會增加該代的分配閾值。 下一個集合獲得大量回收記憶體。 CLR 不斷平衡兩個優先順序:不要讓應用程式的工作集通過延遲垃圾回收而變得太大,並且不要讓垃圾回收過於頻繁地運行。

### <a name="ephemeral-generations-and-segments"></a>暫時層代和區段

因為第0代和第1代的對像是短暫的,因此這些世代被稱為*短暫的世代*。

臨時代在稱為臨時段的記憶體段中分配。 記憶體回收行程所取得的每個新區段都會成為新的暫時區段，而且包含在層代 0 記憶體回收中未被回收的物件。 舊的暫時區段會成為新的層代 2 區段。

暫存位的大小因系統是 32 位元還是 64 位元以及運行的垃圾回收器類型([工作站或伺服器 GC)](workstation-server-gc.md)而異。 下表顯示了臨時段的預設大小。

|工作站/伺服器 GC|32 位元|64 位元|
|-|-------------|-------------|
|工作站 GC|16 MB|256 MB|
|伺服器 GC|64 MB|4 GB|
|具有多於 4 個邏輯 CPU 的伺服器 GC|32 MB|2 GB|
|具有 > 8 個邏輯 CPU 的伺服器 GC|16 MB|1 GB|

暫時區段可能會包括層代 2 物件。 層代 2 物件可以使用多個區段 (取決於處理序所需而且記憶體允許的數目)。

暫時記憶體回收中釋放記憶體的數量會限制為暫時區段的大小。 所釋放的記憶體數量會與無作用物件所佔據的空間成正比。

## <a name="what-happens-during-a-garbage-collection"></a>記憶體回收期間進行的作業

記憶體回收具有下列階段：

- 標記階段：尋找和建立所有使用中物件的清單。

- 重新配置階段：更新即將壓縮之物件的參考。

- 壓縮階段：回收無作用物件所佔據的空間並壓縮未被回收的物件。 壓縮階段會將記憶體回收中未被回收的物件移至區段的較舊端。

  因為層代 2 回收可能會佔據多個區段，所以提升至層代 2 的物件可能會移至較舊區段。 層代 1 和層代 2 的未回收物件都可能會移至不同的區段，因為它們都會被提升至層代 2。

  通常,大型物件堆 (LOH) 不會壓縮,因為複製大型物件會造成性能損失。 但是,在 .NET Core 和 .NET 框架<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>4.5.1 及更高版本中,可以使用 屬性按需壓縮大型物件堆。 此外,通過指定以下任一條件設置硬限制時,LOH 會自動壓縮:

  - 容器上的記憶體限制。
  - [GCHeapHard 限制](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit)或[GCHeapHard 限制百分比](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent)運行時配置選項。

記憶體回收行程會使用下列資訊來判斷物件是否使用中：

- **堆疊根**。 Just-in-Time (JIT) 編譯器和堆疊查核器所提供的堆疊變數。 JIT 優化可以延長或縮短向垃圾回收器報告堆疊變數的代碼區域。

- **垃圾資源回收桿 。** 會指向 Managed 物件，而且可由使用者程式碼或 Common Language Runtime 配置的控制代碼。

- **靜態資料**。 應用程式定義域中可能參考其他物件的靜態物件。 每個應用程式定義域都會追蹤其靜態物件。

記憶體回收開始之前，所有 Managed 執行緒都會暫停，但觸發記憶體回收的執行緒除外。

下圖顯示觸發記憶體回收且造成其他執行緒暫停的執行緒。

![當執行緒觸發記憶體回收時](./media/gc-triggered.png)

## <a name="unmanaged-resources"></a>非託管資源

對於應用程式創建的大多數物件,可以依賴垃圾回收自動執行必要的記憶體管理任務。 但是，Unmanaged 資源需要明確清除。 最常見的 Unmanaged 資源類型就是包裝作業系統資源 (例如檔案控制代碼、視窗控制代碼或網路連接) 的物件。 儘管垃圾回收器能夠跟蹤封裝非託管資源的託管物件的存留期,但它沒有有關如何清理資源的特定知識。

創建封裝非託管資源的物件時,建議提供必要的代碼來清理公共`Dispose`方法中的非託管資源。 您可以提供 `Dispose` 方法，讓物件的使用者在用完物件後，明確釋放出它所佔用的記憶體。 使用封載非託管資源的物件時,請確保根據需要呼叫`Dispose`。

您必須提供一種釋放非託管資源的方法,以防您類型的消費者忘記呼叫`Dispose`。 可以使用安全句柄包裝非託管資源,也可以重寫 方法<xref:System.Object.Finalize?displayProperty=nameWithType>。

有關清理非託管資源的詳細資訊,請參閱[清理非託管資源](unmanaged.md)。

## <a name="see-also"></a>另請參閱

- [工作站和伺服器記憶體回收](workstation-server-gc.md)
- [後臺垃圾回收](background-gc.md)
- [GC 的設定選項](../../core/run-time-config/garbage-collector.md)
- [記憶體回收](index.md)
