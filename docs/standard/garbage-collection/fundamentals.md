---
title: 記憶體回收的基本概念
description: 了解記憶體回收行程如何運作，以及如何為它設定最佳效能。
ms.date: 11/15/2019
ms.technology: dotnet-standard
helpviewer_keywords:
- garbage collection, generations
- garbage collection, background
- garbage collection, concurrent
- garbage collection, server
- garbage collection, workstation
- garbage collection, managed heap
ms.assetid: 67c5a20d-1be1-4ea7-8a9a-92b0b08658d2
ms.openlocfilehash: ea8aef03d2f5837f35ecb31209e57853c0c8257b
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/15/2020
ms.locfileid: "79400537"
---
# <a name="fundamentals-of-garbage-collection"></a>記憶體回收的基本概念

在通用語言運行時 （CLR） 中，垃圾回收器 （GC） 充當自動記憶體管理器。 它提供了下列優點：

- 使您能夠開發應用程式，而無需手動釋放記憶體。

- 有效率地在 Managed 堆積上配置物件。

- 回收不再使用的物件、清除其記憶體，並且讓記憶體可供未來的配置使用。 Managed 物件在開始時會自動取得乾淨的內容，因此其建構函式不需要初始化每個資料欄位。

- 確保某個物件無法使用另一個物件的內容，藉以提供記憶體安全性。

本文介紹了垃圾回收的核心概念。

## <a name="fundamentals-of-memory"></a>記憶體的基本概念

下列清單摘要說明重要的 CLR 記憶體概念。

- 每個處理序都有各自獨立的虛擬位址空間。 同一台電腦上的所有進程共用相同的實體記憶體和分頁檔（如果有）。

- 根據預設，在 32 位元電腦上，每個處理序都有 2 GB 使用者模式虛擬位址空間。

- 身為應用程式開發人員，您只會處理虛擬位址空間，絕不會直接操作實體記憶體。 記憶體回收行程會在 Managed 堆積上自動配置和釋出虛擬記憶體。

  如果要編寫本機代碼，請使用 Windows 函數來處理虛擬位址空間。 這些函式會在原生堆積上自動配置和釋出虛擬記憶體。

- 虛擬記憶體可以有三種狀態：

  - 可用。 記憶體區塊沒有任何參考，可進行配置。

  - 已保留。 記憶體區塊可供您使用，但是無法用於任何其他配置要求。 不過，在此記憶體區塊認可之前，您無法將資料儲存到其中。

  - 已認可。 記憶體區塊會指派給實體儲存區。

- 虛擬位址空間可能會分成片段。 這表示，位址空間中有可用的區塊，也稱為可用的洞 (Hole)。 要求虛擬記憶體配置時，虛擬記憶體管理程式必須找到大小可滿足配置要求的單一可用區塊。 即使您擁有 2GB 可用空間，要求 2GB 的配置仍然不會成功，除非該可用空間全都在單一位址區塊中。

- 如果沒有足夠的虛擬位址空間來保留或物理空間進行提交，則記憶體可能會耗盡。

  即使實體記憶體壓力（即實體記憶體需求）較低，也會使用分頁檔。 第一次實體記憶體壓力較高時，作業系統必須在實體記憶體中留出空間來存儲資料，並將實體記憶體中的某些資料備份到分頁檔。 在需要資料之前不會分頁，因此在實體記憶體壓力低的情況下可能會遇到分頁。

## <a name="conditions-for-a-garbage-collection"></a>記憶體回收的條件

當下列其中一個條件成立時，就會進行記憶體回收：

- 系統的實體記憶體不足。 這由來自作業系統的低記憶體通知或主機指示的低記憶體檢測到。

- 由 Managed 堆積上之已配置物件所使用的記憶體超過可接受的臨界值。 這個臨界值會在處理序執行時持續調整。

- 已呼叫 <xref:System.GC.Collect%2A?displayProperty=nameWithType> 方法。 在大多數的情況下，您不需要呼叫這個方法，因為記憶體回收行程會持續執行。 這個方法主要用於獨特的情況和測試。

## <a name="the-managed-heap"></a>Managed 堆積

CLR 初始化記憶體回收行程之後，記憶體回收行程就會配置用來儲存和管理物件的記憶體區段。 這個記憶體稱為 Managed 堆積，與作業系統中的原生堆積相反。

每個 Managed 處理序都有一個 Managed 堆積。 處理序中的所有執行緒都會對相同堆積上的物件配置記憶體。

為了保留記憶體，垃圾回收器調用 Windows [VirtualAlloc](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc)函數，並一次為託管應用程式保留一段記憶體。 垃圾回收器還根據需要保留段，並通過調用 Windows [VirtualFree](/windows/desktop/api/memoryapi/nf-memoryapi-virtualfree)函數將段釋放回作業系統（清除任何物件後）。

> [!IMPORTANT]
> 記憶體回收行程所配置的區段大小是依實作而定，有可能在任何時間，包括在定期更新時做變更。 您的應用程式永遠都不應該對相關或根據特定區段的大小做出假設，也不應嘗試設定區段配置的可用記憶體數量。

配置在堆積上的物件越少，記憶體回收行程必須進行的工作就越少。 當您配置物件時，請勿使用超出需求的進位值，例如，當您只需要 15 個位元組時，卻配置 32 個位元組的陣列。

觸發記憶體回收時，記憶體回收行程就會回收無作用物件所佔據的記憶體。 回收處理序會壓縮使用中物件，讓它們集合在一起，並且移除無作用物件，因而讓堆積更小。 這樣可確保一起配置的物件會在 Managed 堆積上集中，以便保持其區域性。

記憶體回收的干擾程度 (頻率和持續期間) 是 Managed 堆積上之配置量和未被回收記憶體數量的結果。

堆可以被視為兩個堆的累積：[大型物件堆](large-object-heap.md)和小物件堆。

[大型物件堆](large-object-heap.md)包含非常大的物件，物件為 85，000 位元組和較大。 大型物件堆積上的物件通常是陣列。 超大型的執行個體物件非常罕見。

> [!TIP]
> 您可以設定物件在大型物件堆上的[閾值大小](../../core/run-time-config/garbage-collector.md#large-object-heap-threshold)。

## <a name="generations"></a>層代

堆積會組織成層代，因此它可以處理存留較久和存留較短的物件。 記憶體回收主要與存留較短物件的回收一起進行，而這些物件通常只佔據堆積的一小部分。 堆積上的物件有三個層代：

- **第 0 代**. 這是最新的層代而且包含存留較短的物件。 存留較短的物件範例是暫存變數。 記憶體回收最常在這個層代中進行。

  新分配的物件構成新一代的物件，並且隱式生成 0 集合。 但是，如果它們是大型物件，它們將位於第 2 代集合中的大物件堆上。

  大部分物件都會在層代 0 的記憶體回收中回收，而且不會存留至下一個層代。

- **第 1 代**. 這個層代包含存留較短的物件，而且當做存留較短物件與存留較長物件之間的緩衝區。

- **第 2 代**. 這個層代包含存留較長的物件。 長壽命物件的一個示例是伺服器應用程式中包含在進程持續時間內即時的靜態資料的物件。

當條件許可時，記憶體回收會針對特定層代進行。 回收層代是指回收該層代中的物件及其所有較新的層代。 層代 2 記憶體回收也稱為完整記憶體回收，因為它會回收所有層代中的所有物件 (亦即，Managed 堆積中的所有物件)。

### <a name="survival-and-promotions"></a>未回收和提升

垃圾回收中未回收的物件稱為倖存者，並提升為下一代。 在層代 0 記憶體回收中未被回收的物件會提升至層代 1、在層代 1 記憶體回收中未被回收的物件會提升至層代 2，而在層代 2 記憶體回收中未被回收的物件則保留在層代 2 中。

當垃圾回收器檢測到一代人的存活率很高時，它會增加該代的分配閾值。 下一個集合獲得大量回收記憶體。 CLR 不斷平衡兩個優先順序：不要讓應用程式的工作集通過延遲垃圾回收而變得太大，並且不要讓垃圾回收過於頻繁地運行。

### <a name="ephemeral-generations-and-segments"></a>暫時層代和區段

因為層代 0 和 1 中的物件存留較短，所以這些層代稱為暫時層代。

暫時層代必須配置於稱為暫時區段的記憶體區段中。 記憶體回收行程所取得的每個新區段都會成為新的暫時區段，而且包含在層代 0 記憶體回收中未被回收的物件。 舊的暫時區段會成為新的層代 2 區段。

臨時段的大小因系統是 32 位還是 64 位以及運行的垃圾回收器類型而異。 下表顯示預設值。

||32 位元|64 位元|
|-|-------------|-------------|
|工作站 GC|16 MB|256 MB|
|伺服器 GC|64 MB|4 GB|
|具有多於 4 個邏輯 CPU 的伺服器 GC|32 MB|2 GB|
|具有 > 8 個邏輯 CPU 的伺服器 GC|16 MB|1 GB|

暫時區段可能會包括層代 2 物件。 層代 2 物件可以使用多個區段 (取決於處理序所需而且記憶體允許的數目)。

暫時記憶體回收中釋放記憶體的數量會限制為暫時區段的大小。 所釋放的記憶體數量會與無作用物件所佔據的空間成正比。

## <a name="what-happens-during-a-garbage-collection"></a>記憶體回收期間進行的作業

記憶體回收具有下列階段：

- 標記階段：尋找和建立所有使用中物件的清單。

- 重新配置階段：更新即將壓縮之物件的參考。

- 壓縮階段：回收無作用物件所佔據的空間並壓縮未被回收的物件。 壓縮階段會將記憶體回收中未被回收的物件移至區段的較舊端。

  因為層代 2 回收可能會佔據多個區段，所以提升至層代 2 的物件可能會移至較舊區段。 層代 1 和層代 2 的未回收物件都可能會移至不同的區段，因為它們都會被提升至層代 2。

  通常，大型物件堆 （LOH） 不會壓縮，因為複製大型物件會造成性能損失。 但是，在 .NET Core 和 .NET 框架 4.5.1 及<xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType>更高版本中，可以使用 屬性按需壓縮大型物件堆。 此外，通過指定以下任一條件設置硬限制時，LOH 會自動壓縮：

  - 容器上的記憶體限制，或
  - [GCHeapHard 限制](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitcomplus_gcheaphardlimit)或[GCHeapHard 限制百分比](../../core/run-time-config/garbage-collector.md#systemgcheaphardlimitpercentcomplus_gcheaphardlimitpercent)運行時配置選項

記憶體回收行程會使用下列資訊來判斷物件是否使用中：

- **堆疊根**。 Just-in-Time (JIT) 編譯器和堆疊查核器所提供的堆疊變數。 JIT 優化可以延長或縮短向垃圾回收器報告堆疊變數的代碼區域。

- **垃圾回收控制碼**。 會指向 Managed 物件，而且可由使用者程式碼或 Common Language Runtime 配置的控制代碼。

- **靜態資料**。 應用程式定義域中可能參考其他物件的靜態物件。 每個應用程式定義域都會追蹤其靜態物件。

記憶體回收開始之前，所有 Managed 執行緒都會暫停，但觸發記憶體回收的執行緒除外。

下圖顯示觸發記憶體回收且造成其他執行緒暫停的執行緒。

![當執行緒觸發記憶體回收時](./media/gc-triggered.png)

## <a name="manipulate-unmanaged-resources"></a>操作非託管資源

如果託管物件使用其本機檔案控制代碼引用非託管物件，則必須顯式釋放非託管物件，因為垃圾回收器僅跟蹤託管堆上的記憶體。

託管物件的使用者可能不會釋放該物件使用的本機資源。 要執行清理，可以使託管物件可最終化。 最終化包括在物件不再使用時執行的清理操作。 當託管物件死亡時，它將執行在其終端子方法中指定的清理操作。

當系統發現某個可最終處理物件無作用時，該物件的完成項就會放入佇列中，以便執行其清除動作，但是物件本身會提升至下一個層代。 因此，您必須等候直到在該層代上進行的下一次記憶體回收 (不一定是下一次記憶體回收)，以便判斷此物件是否已經回收。

有關最終化的詳細資訊，請參閱<xref:System.Object.Finalize?displayProperty=nameWithType>。

## <a name="workstation-and-server-garbage-collection"></a>工作站和伺服器記憶體回收

記憶體回收行程會自行調整而且可在各種案例中運作。 可以使用[設定檔設置](../../core/run-time-config/garbage-collector.md#flavors-of-garbage-collection)根據工作負載的特徵設置垃圾回收的類型。 CLR 會提供下列記憶體回收類型：

- 工作站垃圾回收 （GC） 專為用戶端應用而設計。 它是獨立應用的預設 GC 風格。 對於託管應用（例如，由ASP.NET託管的應用，主機確定預設 GC 風格。

  工作站記憶體回收可能是並行或非並行的。 並行記憶體回收可讓 Managed 執行緒在記憶體回收期間繼續運作。 [後臺垃圾回收](#background-workstation-garbage-collection)將替換 .NET 框架 4 和更高版本中[的併發垃圾回收](#concurrent-garbage-collection)。

- 伺服器記憶體回收，適用於需要高輸送量和延展性的伺服器應用程式。

  - 在 .NET Core 中，伺服器垃圾回收可以是非併發或後臺。

  - 在 .NET Framework 4.5 和更高版本中，伺服器垃圾回收可以是非併發或後臺（後臺垃圾回收將取代併發垃圾回收）。 在 .NET 框架 4 和早期版本中，伺服器垃圾回收是非併發的。

下圖顯示了在伺服器上執行垃圾回收的專用線程：

![伺服器記憶體回收執行緒](./media/gc-server.png)

### <a name="compare-workstation-and-server-garbage-collection"></a>比較工作站和伺服器垃圾回收

以下是工作站記憶體回收的執行緒和效能考量：

- 此回收會針對觸發記憶體回收的使用者執行緒進行，而且維持相同的優先權。 因為使用者執行緒通常會以一般優先權執行，所以記憶體回收行程 (在一般優先權執行緒上執行) 必須與其他執行緒爭用 CPU 時間。 （運行本機代碼的執行緒不會在伺服器或工作站垃圾回收上掛起。

- 工作站垃圾回收始終用於只有一個處理器的電腦，而不考慮[配置設置](../../core/run-time-config/garbage-collector.md#systemgcservercomplus_gcserver)。

以下是伺服器記憶體回收的執行緒和效能考量：

- 此回收會針對以 `THREAD_PRIORITY_HIGHEST` 優先權層級執行的多個專屬執行緒進行。

- 執行記憶體回收的堆積和專屬執行緒是針對每個 CPU 提供的，而且這些堆積會同時回收。 每個堆積都包含小型物件堆積和大型物件堆積，而且所有堆積都可由使用者程式碼存取。 不同堆積上的物件可以彼此參考。

- 因為多個記憶體回收執行緒會一起運作，所以就相同大小堆積而言，伺服器記憶體回收的速度比工作站記憶體回收的速度要快。

- 伺服器記憶體回收通常具有較大的區段。 但是，這只是一個概括：段大小特定于實現，可能會發生變化。 調整應用時，不要對垃圾回收器分配的段大小進行假設。

- 伺服器記憶體回收可能會耗用大量資源。 例如，假設有 12 個進程使用伺服器 GC 運行在具有 4 個處理器的電腦上。 如果所有進程都同時收集垃圾，它們就會相互干擾，因為同一處理器上將安排 12 個執行緒。 如果進程處於活動狀態，則讓所有進程都使用伺服器 GC 不是個好主意。

如果您正在運行應用程式的數百個實例，請考慮使用禁用併發垃圾回收的工作站垃圾回收。 這樣會產生較少的內容切換，因此可能會改善效能。

## <a name="background-workstation-garbage-collection"></a>背景工作站記憶體回收

在後臺工作站垃圾回收中，臨時代（0 和 1）根據需要收集，同時收集第 2 代正在進行。 後臺工作站垃圾回收在專用線程上執行，僅應用於第 2 代集合。

預設情況下，後臺垃圾回收處於啟用狀態，並且可以通過 .NET Framework 應用中[的 gc併發](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)配置設置或 .NET Core 應用中[的 System.GC.併發](../../core/run-time-config/garbage-collector.md#systemgcconcurrentcomplus_gcconcurrent)設置啟用或禁用。

> [!NOTE]
> 後臺垃圾回收將替換[併發垃圾回收](#concurrent-garbage-collection)，並在 .NET 框架 4 和更高版本中提供。 在 .NET 框架 4 中，它僅支援工作站垃圾回收。 從 .NET 框架 4.5 開始，後臺垃圾回收可用於工作站和伺服器垃圾回收。

背景記憶體回收期間，暫時層代的回收稱為前景記憶體回收。 進行前景記憶體回收時，所有 Managed 執行緒都會暫停。

當後臺垃圾回收正在進行，並且您在第 0 代中分配了足夠的物件時，CLR 將執行第 0 代或第 1 代前臺垃圾回收。 專屬的背景記憶體回收執行緒會在經常安全點檢查，以便判斷是否存在前景記憶體回收的要求。 如果有，背景回收就會自行暫停，讓前景記憶體回收能夠進行。 在前景記憶體回收完成之後，專屬的背景記憶體回收執行緒和使用者執行緒就會繼續進行。

背景記憶體回收會移除並行記憶體回收所加諸的配置限制，因為暫時記憶體回收可能會在背景記憶體回收期間進行。 後臺垃圾回收可以刪除臨時代中的死物件。 如果需要，它還可以在第 1 代垃圾回收期間展開堆。

下圖顯示在工作站上另一個專用執行緒上執行的背景記憶體回收：

![背景工作站記憶體回收](./media/fundamentals/background-workstation-garbage-collection.png)

### <a name="background-server-garbage-collection"></a>背景伺服器記憶體回收

從 .NET 框架 4.5 開始，後臺伺服器垃圾回收是伺服器垃圾回收的預設模式。

後臺伺服器垃圾回收功能類似于上一節所述的後臺工作站垃圾回收，但有一些區別：

- 後臺工作站垃圾回收使用一個專用後臺垃圾回收執行緒，而後台伺服器垃圾回收使用多個執行緒。 通常，每個邏輯處理器都有一個專用線程。

- 與工作站背景記憶體回收執行緒不同的是，這些執行緒不會逾時。

下圖顯示在伺服器上另一個專用執行緒上執行的背景記憶體回收：

![背景伺服器記憶體回收](./media/fundamentals/background-server-garbage-collection.png)

## <a name="concurrent-garbage-collection"></a>並行的記憶體回收

> [!TIP]
> 本節適用於：
>
> - .NET 框架 3.5 及更早版本用於工作站垃圾回收
> - .NET 框架 4 及更早版本用於伺服器垃圾回收
>
> 並行垃圾在更高版本中被[後臺垃圾回收](#background-workstation-garbage-collection)替換。

在工作站或伺服器垃圾回收中，可以[啟用併發垃圾回收](../../../docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)，使執行緒與在收集的大部分持續時間內執行垃圾回收的專用線程同時運行。 這個選項只會影響層代 2 中的記憶體回收。層代 0 和 1 一律為非並行，因為它們的完成速度非常快。

並行記憶體回收會將回收期間的暫停降到最低，藉以加快互動式應用程式的回應速度。 當並行記憶體回收執行緒正在執行時，Managed 執行緒幾乎可以繼續執行。 這會在記憶體回收進行時縮短暫停時間。

並行記憶體回收會針對專屬執行緒執行。 根據預設，CLR 會執行工作站記憶體回收並啟用並行記憶體回收。 這種回收適用於單一處理器和多處理器電腦。

下列圖例顯示在分開的專屬執行緒上執行的並行記憶體回收。

![並行記憶體回收執行緒](./media/gc-concurrent.png)

## <a name="see-also"></a>另請參閱

- [GC 的配置選項](../../core/run-time-config/garbage-collector.md)
- [記憶體回收](index.md)
