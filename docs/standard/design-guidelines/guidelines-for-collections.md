---
title: 集合方針
ms.date: 03/30/2017
ms.technology: dotnet-standard
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 3571ebb2fdd2bcdfd8be1f0087d096e01f18790a
ms.sourcegitcommit: 6eac9a01ff5d70c6d18460324c016a3612c5e268
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/16/2018
ms.locfileid: "45674087"
---
# <a name="guidelines-for-collections"></a><span data-ttu-id="099d3-102">集合方針</span><span class="sxs-lookup"><span data-stu-id="099d3-102">Guidelines for Collections</span></span>
<span data-ttu-id="099d3-103">任何型別，專門設計來管理一組具有一些共同的特性的物件可以視為一個集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-103">Any type designed specifically to manipulate a group of objects having some common characteristic can be considered a collection.</span></span> <span data-ttu-id="099d3-104">幾乎都是實作這種類型的適當<xref:System.Collections.IEnumerable>或<xref:System.Collections.Generic.IEnumerable%601>，所以在本節中，我們只考慮實作一個或多個這些介面的型別是集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-104">It is almost always appropriate for such types to implement <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>, so in this section we only consider types implementing one or both of those interfaces to be collections.</span></span>  
  
 <span data-ttu-id="099d3-105">**X DO NOT** 在公用 Api 中使用弱式型別的的集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-105">**X DO NOT** use weakly typed collections in public APIs.</span></span>  
  
 <span data-ttu-id="099d3-106">所有傳回值以及代表集合的項目參數的類型應該是確切的項目類型，不是任何基底類型 （這只適用於集合的公用成員）。</span><span class="sxs-lookup"><span data-stu-id="099d3-106">The type of all return values and parameters representing collection items should be the exact item type, not any of its base types (this applies only to public members of the collection).</span></span>  
  
 <span data-ttu-id="099d3-107">**X DO NOT** 使用 <xref:System.Collections.ArrayList> 或 <xref:System.Collections.Generic.List%601> 在公用 Api。</span><span class="sxs-lookup"><span data-stu-id="099d3-107">**X DO NOT** use <xref:System.Collections.ArrayList> or <xref:System.Collections.Generic.List%601> in public APIs.</span></span>  
  
 <span data-ttu-id="099d3-108">這些類型是設計來在內部實作中，不在公用 Api 中的資料結構。</span><span class="sxs-lookup"><span data-stu-id="099d3-108">These types are data structures designed to be used in internal implementation, not in public APIs.</span></span> <span data-ttu-id="099d3-109">`List<T>` 已針對效能和但要付出的 Api 和彈性的 cleanness 電源最佳化。</span><span class="sxs-lookup"><span data-stu-id="099d3-109">`List<T>` is optimized for performance and power at the cost of cleanness of the APIs and flexibility.</span></span> <span data-ttu-id="099d3-110">例如，如果您傳回`List<T>`，您將以往無法接收通知，當用戶端程式碼會修改集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-110">For example, if you return `List<T>`, you will not ever be able to receive notifications when client code modifies the collection.</span></span> <span data-ttu-id="099d3-111">此外，`List<T>`公開許多成員，例如<xref:System.Collections.Generic.List%601.BinarySearch%2A>，不實用或適用於許多案例。</span><span class="sxs-lookup"><span data-stu-id="099d3-111">Also, `List<T>` exposes many members, such as <xref:System.Collections.Generic.List%601.BinarySearch%2A>, that are not useful or applicable in many scenarios.</span></span> <span data-ttu-id="099d3-112">下列兩節會描述專為使用公用 Api 中的類型 （抽象）。</span><span class="sxs-lookup"><span data-stu-id="099d3-112">The following two sections describe types (abstractions) designed specifically for use in public APIs.</span></span>  
  
 <span data-ttu-id="099d3-113">**X DO NOT** 使用 `Hashtable` 或 `Dictionary<TKey,TValue>` 在公用 Api。</span><span class="sxs-lookup"><span data-stu-id="099d3-113">**X DO NOT** use `Hashtable` or `Dictionary<TKey,TValue>` in public APIs.</span></span>  
  
 <span data-ttu-id="099d3-114">這些類型是設計來在內部實作的資料結構。</span><span class="sxs-lookup"><span data-stu-id="099d3-114">These types are data structures designed to be used in internal implementation.</span></span> <span data-ttu-id="099d3-115">應該使用公用 Api <xref:System.Collections.IDictionary>， `IDictionary <TKey, TValue>`，或實作一或兩個介面的自訂型別。</span><span class="sxs-lookup"><span data-stu-id="099d3-115">Public APIs should use <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, or a custom type implementing one or both of the interfaces.</span></span>  
  
 <span data-ttu-id="099d3-116">**X DO NOT** 使用 <xref:System.Collections.Generic.IEnumerator%601>， <xref:System.Collections.IEnumerator>，或實作介面，其中除了為傳回類型的任何其他型別 `GetEnumerator` 方法。</span><span class="sxs-lookup"><span data-stu-id="099d3-116">**X DO NOT** use <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, or any other type that implements either of these interfaces, except as the return type of a `GetEnumerator` method.</span></span>  
  
 <span data-ttu-id="099d3-117">從方法傳回列舉值以外的類型`GetEnumerator`不能搭配`foreach`陳述式。</span><span class="sxs-lookup"><span data-stu-id="099d3-117">Types returning enumerators from methods other than `GetEnumerator` cannot be used with the `foreach` statement.</span></span>  
  
 <span data-ttu-id="099d3-118">**X DO NOT** 同時實作 `IEnumerator<T>` 和 `IEnumerable<T>` 上相同的型別。</span><span class="sxs-lookup"><span data-stu-id="099d3-118">**X DO NOT** implement both `IEnumerator<T>` and `IEnumerable<T>` on the same type.</span></span> <span data-ttu-id="099d3-119">這同樣適用於非泛型介面`IEnumerator`和`IEnumerable`。</span><span class="sxs-lookup"><span data-stu-id="099d3-119">The same applies to the nongeneric interfaces `IEnumerator` and `IEnumerable`.</span></span>  
  
## <a name="collection-parameters"></a><span data-ttu-id="099d3-120">收集參數</span><span class="sxs-lookup"><span data-stu-id="099d3-120">Collection Parameters</span></span>  
 <span data-ttu-id="099d3-121">**✓ DO** 使用可能的最低特製化類型做為參數類型。</span><span class="sxs-lookup"><span data-stu-id="099d3-121">**✓ DO** use the least-specialized type possible as a parameter type.</span></span> <span data-ttu-id="099d3-122">取得集合，作為參數使用的大部分成員`IEnumerable<T>`介面。</span><span class="sxs-lookup"><span data-stu-id="099d3-122">Most members taking collections as parameters use the `IEnumerable<T>` interface.</span></span>  
  
 <span data-ttu-id="099d3-123">**X AVOID** 使用 <xref:System.Collections.Generic.ICollection%601>或<xref:System.Collections.ICollection> 做為參數，只是為了存取 `Count` 屬性。</span><span class="sxs-lookup"><span data-stu-id="099d3-123">**X AVOID** using <xref:System.Collections.Generic.ICollection%601> or <xref:System.Collections.ICollection> as a parameter just to access the `Count` property.</span></span>  
  
 <span data-ttu-id="099d3-124">請考慮改用`IEnumerable<T>`或是`IEnumerable`並以動態方式檢查物件是否實作`ICollection<T>`或`ICollection`。</span><span class="sxs-lookup"><span data-stu-id="099d3-124">Instead, consider using `IEnumerable<T>` or `IEnumerable` and dynamically checking whether the object implements `ICollection<T>` or `ICollection`.</span></span>  
  
## <a name="collection-properties-and-return-values"></a><span data-ttu-id="099d3-125">集合屬性和傳回值</span><span class="sxs-lookup"><span data-stu-id="099d3-125">Collection Properties and Return Values</span></span>  
 <span data-ttu-id="099d3-126">**X DO NOT** 提供可設定的集合屬性。</span><span class="sxs-lookup"><span data-stu-id="099d3-126">**X DO NOT** provide settable collection properties.</span></span>  
  
 <span data-ttu-id="099d3-127">使用者可以取代集合的內容，先清除集合，然後再將新的內容。</span><span class="sxs-lookup"><span data-stu-id="099d3-127">Users can replace the contents of the collection by clearing the collection first and then adding the new contents.</span></span> <span data-ttu-id="099d3-128">如果取代整個集合是常見的案例，請考慮提供`AddRange`集合上的方法。</span><span class="sxs-lookup"><span data-stu-id="099d3-128">If replacing the whole collection is a common scenario, consider providing the `AddRange` method on the collection.</span></span>  
  
 <span data-ttu-id="099d3-129">**✓ DO** 使用 `Collection<T>` 或的子類別 `Collection<T>` 針對屬性或傳回值表示讀取/寫入集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-129">**✓ DO** use `Collection<T>` or a subclass of `Collection<T>` for properties or return values representing read/write collections.</span></span>  
  
 <span data-ttu-id="099d3-130">如果`Collection<T>`不符合某些需求 (例如，集合必須不會實作<xref:System.Collections.IList>)，藉由實作使用自訂的集合`IEnumerable<T>`， `ICollection<T>`，或<xref:System.Collections.Generic.IList%601>。</span><span class="sxs-lookup"><span data-stu-id="099d3-130">If `Collection<T>` does not meet some requirement (e.g., the collection must not implement <xref:System.Collections.IList>), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or <xref:System.Collections.Generic.IList%601>.</span></span>  
  
 <span data-ttu-id="099d3-131">**✓ DO** 使用 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 的子類別 `ReadOnlyCollection<T>`，或在極少數的情況下 `IEnumerable<T>` 針對屬性或傳回值表示唯讀的集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-131">**✓ DO** use <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, a subclass of `ReadOnlyCollection<T>`, or in rare cases `IEnumerable<T>` for properties or return values representing read-only collections.</span></span>  
  
 <span data-ttu-id="099d3-132">一般情況下，偏好`ReadOnlyCollection<T>`。</span><span class="sxs-lookup"><span data-stu-id="099d3-132">In general, prefer `ReadOnlyCollection<T>`.</span></span> <span data-ttu-id="099d3-133">如果不符合某些需求 (例如，集合必須不會實作`IList`)，藉由實作使用自訂的集合`IEnumerable<T>`， `ICollection<T>`，或`IList<T>`。</span><span class="sxs-lookup"><span data-stu-id="099d3-133">If it does not meet some requirement (e.g., the collection must not implement `IList`), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or `IList<T>`.</span></span> <span data-ttu-id="099d3-134">如果您實作自訂的唯讀集合，實作`ICollection<T>.IsReadOnly`傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="099d3-134">If you do implement a custom read-only collection, implement `ICollection<T>.IsReadOnly` to return `true`.</span></span>  
  
 <span data-ttu-id="099d3-135">在您會確定只有您會想要支援的案例是順向的反覆項目的情況下，您可以直接使用`IEnumerable<T>`。</span><span class="sxs-lookup"><span data-stu-id="099d3-135">In cases where you are sure that the only scenario you will ever want to support is forward-only iteration, you can simply use `IEnumerable<T>`.</span></span>  
  
 <span data-ttu-id="099d3-136">**✓ CONSIDER** 使用泛型基底集合的子類別，而不直接使用集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-136">**✓ CONSIDER** using subclasses of generic base collections instead of using the collections directly.</span></span>  
  
 <span data-ttu-id="099d3-137">這可讓更適合的名稱以及加入未出現在基底的集合型別上的 helper 成員。</span><span class="sxs-lookup"><span data-stu-id="099d3-137">This allows for a better name and for adding helper members that are not present on the base collection types.</span></span> <span data-ttu-id="099d3-138">這是特別適用於高階 Api。</span><span class="sxs-lookup"><span data-stu-id="099d3-138">This is especially applicable to high-level APIs.</span></span>  
  
 <span data-ttu-id="099d3-139">**✓ CONSIDER** 傳回的子類別 `Collection<T>` 或 `ReadOnlyCollection<T>` 從相當常用的方法和屬性。</span><span class="sxs-lookup"><span data-stu-id="099d3-139">**✓ CONSIDER** returning a subclass of `Collection<T>` or `ReadOnlyCollection<T>` from very commonly used methods and properties.</span></span>  
  
 <span data-ttu-id="099d3-140">這會讓您可新增 helper 方法，或變更在未來的集合實作。</span><span class="sxs-lookup"><span data-stu-id="099d3-140">This will make it possible for you to add helper methods or change the collection implementation in the future.</span></span>  
  
 <span data-ttu-id="099d3-141">**✓ CONSIDER** 使用索引鍵的集合，如果儲存在集合中的項目具有唯一索引鍵 （名稱、 識別碼、 等等。）。</span><span class="sxs-lookup"><span data-stu-id="099d3-141">**✓ CONSIDER** using a keyed collection if the items stored in the collection have unique keys (names, IDs, etc.).</span></span> <span data-ttu-id="099d3-142">索引的集合是由整數和索引鍵編製的索引，通常由繼承自集合`KeyedCollection<TKey,TItem>`。</span><span class="sxs-lookup"><span data-stu-id="099d3-142">Keyed collections are collections that can be indexed by both an integer and a key and are usually implemented by inheriting from `KeyedCollection<TKey,TItem>`.</span></span>  
  
 <span data-ttu-id="099d3-143">索引的集合通常會較大的記憶體使用量，而且不應在記憶體額外負荷超過索引鍵的效益。</span><span class="sxs-lookup"><span data-stu-id="099d3-143">Keyed collections usually have larger memory footprints and should not be used if the memory overhead outweighs the benefits of having the keys.</span></span>  
  
 <span data-ttu-id="099d3-144">**X DO NOT** 集合屬性中或從方法傳回集合，傳回 null 值。</span><span class="sxs-lookup"><span data-stu-id="099d3-144">**X DO NOT** return null values from collection properties or from methods returning collections.</span></span> <span data-ttu-id="099d3-145">而是傳回空集合或空陣列。</span><span class="sxs-lookup"><span data-stu-id="099d3-145">Return an empty collection or an empty array instead.</span></span>  
  
 <span data-ttu-id="099d3-146">一般規則是，應該是 null 和空的 （0 個項目） 集合或陣列視為相同。</span><span class="sxs-lookup"><span data-stu-id="099d3-146">The general rule is that null and empty (0 item) collections or arrays should be treated the same.</span></span>  
  
### <a name="snapshots-versus-live-collections"></a><span data-ttu-id="099d3-147">快照集與即時的集合</span><span class="sxs-lookup"><span data-stu-id="099d3-147">Snapshots Versus Live Collections</span></span>  
 <span data-ttu-id="099d3-148">集合表示在某個時間點狀態的時間稱為快照集集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-148">Collections representing a state at some point in time are called snapshot collections.</span></span> <span data-ttu-id="099d3-149">例如，包含從資料庫查詢傳回的資料列的集合會是快照集。</span><span class="sxs-lookup"><span data-stu-id="099d3-149">For example, a collection containing rows returned from a database query would be a snapshot.</span></span> <span data-ttu-id="099d3-150">集合一律會代表目前的狀態，稱為即時的集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-150">Collections that always represent the current state are called live collections.</span></span> <span data-ttu-id="099d3-151">比方說，許多`ComboBox`項目是即時的集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-151">For example, a collection of `ComboBox` items is a live collection.</span></span>  
  
 <span data-ttu-id="099d3-152">**X DO NOT** 屬性從傳回快照集的集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-152">**X DO NOT** return snapshot collections from properties.</span></span> <span data-ttu-id="099d3-153">屬性應該傳回即時的集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-153">Properties should return live collections.</span></span>  
  
 <span data-ttu-id="099d3-154">屬性 getter 應該是非常輕量型的作業。</span><span class="sxs-lookup"><span data-stu-id="099d3-154">Property getters should be very lightweight operations.</span></span> <span data-ttu-id="099d3-155">傳回快照集需要 o （n） 作業中建立一份內部集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-155">Returning a snapshot requires creating a copy of an internal collection in an O(n) operation.</span></span>  
  
 <span data-ttu-id="099d3-156">**✓ DO** 使用快照集收集或即時 `IEnumerable<T>` （或它的子類型） 來表示為變動性的集合 （亦即，可以變更而不需明確修改集合）。</span><span class="sxs-lookup"><span data-stu-id="099d3-156">**✓ DO** use either a snapshot collection or a live `IEnumerable<T>` (or its subtype) to represent collections that are volatile (i.e., that can change without explicitly modifying the collection).</span></span>  
  
 <span data-ttu-id="099d3-157">一般情況下，所有的集合，表示共用的資源 （例如，在目錄中的檔案） 是變動性。</span><span class="sxs-lookup"><span data-stu-id="099d3-157">In general, all collections representing a shared resource (e.g., files in a directory) are volatile.</span></span> <span data-ttu-id="099d3-158">這類集合是很難或無法實作做為即時的集合，除非實作就只是順向的列舉值。</span><span class="sxs-lookup"><span data-stu-id="099d3-158">Such collections are very difficult or impossible to implement as live collections unless the implementation is simply a forward-only enumerator.</span></span>  
  
## <a name="choosing-between-arrays-and-collections"></a><span data-ttu-id="099d3-159">陣列和集合之間進行選擇</span><span class="sxs-lookup"><span data-stu-id="099d3-159">Choosing Between Arrays and Collections</span></span>  
 <span data-ttu-id="099d3-160">**✓ DO** 集合，而不用陣列。</span><span class="sxs-lookup"><span data-stu-id="099d3-160">**✓ DO** prefer collections over arrays.</span></span>  
  
 <span data-ttu-id="099d3-161">集合提供更充分掌控內容，可以隨著時間演進，而且更實用。</span><span class="sxs-lookup"><span data-stu-id="099d3-161">Collections provide more control over contents, can evolve over time, and are more usable.</span></span> <span data-ttu-id="099d3-162">此外，因為複製陣列成本高昂，建議使用陣列的唯讀狀態的案例。</span><span class="sxs-lookup"><span data-stu-id="099d3-162">In addition, using arrays for read-only scenarios is discouraged because the cost of cloning the array is prohibitive.</span></span> <span data-ttu-id="099d3-163">可用性研究顯示，有些開發人員會覺得較喜歡使用以集合為基礎的 Api。</span><span class="sxs-lookup"><span data-stu-id="099d3-163">Usability studies have shown that some developers feel more comfortable using collection-based APIs.</span></span>  
  
 <span data-ttu-id="099d3-164">不過，如果您正在開發的低階 Api，它可能是更好讀寫案例中使用陣列項目。</span><span class="sxs-lookup"><span data-stu-id="099d3-164">However, if you are developing low-level APIs, it might be better to use arrays for read-write scenarios.</span></span> <span data-ttu-id="099d3-165">陣列有較小的記憶體耗用量，進而降低工作集，而且陣列中項目的存取速度，因為它會透過執行階段進行最佳化。</span><span class="sxs-lookup"><span data-stu-id="099d3-165">Arrays have a smaller memory footprint, which helps reduce the working set, and access to elements in an array is faster because it is optimized by the runtime.</span></span>  
  
 <span data-ttu-id="099d3-166">**✓ CONSIDER** 低階 Api 中使用陣列記憶體耗用量降到最低，並將效能最大化。</span><span class="sxs-lookup"><span data-stu-id="099d3-166">**✓ CONSIDER** using arrays in low-level APIs to minimize memory consumption and maximize performance.</span></span>  
  
 <span data-ttu-id="099d3-167">**✓ DO** 使用位元組陣列，而不是位元組的集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-167">**✓ DO** use byte arrays instead of collections of bytes.</span></span>  
  
 <span data-ttu-id="099d3-168">**X DO NOT** 使用屬性的陣列，如果屬性必須在呼叫屬性 getter 的每次會傳回新的陣列 （例如，內部陣列的複本）。</span><span class="sxs-lookup"><span data-stu-id="099d3-168">**X DO NOT** use arrays for properties if the property would have to return a new array (e.g., a copy of an internal array) every time the property getter is called.</span></span>  
  
## <a name="implementing-custom-collections"></a><span data-ttu-id="099d3-169">實作自訂的集合</span><span class="sxs-lookup"><span data-stu-id="099d3-169">Implementing Custom Collections</span></span>  
 <span data-ttu-id="099d3-170">**✓ CONSIDER** 繼承自 `Collection<T>`， `ReadOnlyCollection<T>`，或 `KeyedCollection<TKey,TItem>` 設計新的集合時。</span><span class="sxs-lookup"><span data-stu-id="099d3-170">**✓ CONSIDER** inheriting from `Collection<T>`, `ReadOnlyCollection<T>`, or `KeyedCollection<TKey,TItem>` when designing new collections.</span></span>  
  
 <span data-ttu-id="099d3-171">**✓ DO** 實作 `IEnumerable<T>` 設計新的集合時。</span><span class="sxs-lookup"><span data-stu-id="099d3-171">**✓ DO** implement `IEnumerable<T>` when designing new collections.</span></span> <span data-ttu-id="099d3-172">請考慮實作`ICollection<T>`甚至`IList<T>`派得上用場。</span><span class="sxs-lookup"><span data-stu-id="099d3-172">Consider implementing `ICollection<T>` or even `IList<T>` where it makes sense.</span></span>  
  
 <span data-ttu-id="099d3-173">在實作這類的自訂集合時，請依照下列所建立的 API 模式`Collection<T>`和`ReadOnlyCollection<T>`儘可能密集地。</span><span class="sxs-lookup"><span data-stu-id="099d3-173">When implementing such custom collection, follow the API pattern established by `Collection<T>` and `ReadOnlyCollection<T>` as closely as possible.</span></span> <span data-ttu-id="099d3-174">也就是明確地實作相同的成員，為參數命名，例如這兩個集合名稱，依此類推。</span><span class="sxs-lookup"><span data-stu-id="099d3-174">That is, implement the same members explicitly, name the parameters like these two collections name them, and so on.</span></span>  
  
 <span data-ttu-id="099d3-175">**✓ CONSIDER** 實作非泛型集合介面 (`IList` 和 `ICollection`) 如果集合將通常會傳遞至應用程式開發介面採用這些介面做為輸入。</span><span class="sxs-lookup"><span data-stu-id="099d3-175">**✓ CONSIDER** implementing nongeneric collection interfaces (`IList` and `ICollection`) if the collection will often be passed to APIs taking these interfaces as input.</span></span>  
  
 <span data-ttu-id="099d3-176">**X AVOID** 型別上實作的集合介面具有複雜的應用程式開發介面不相關的概念的集合。</span><span class="sxs-lookup"><span data-stu-id="099d3-176">**X AVOID** implementing collection interfaces on types with complex APIs unrelated to the concept of a collection.</span></span>  
  
 <span data-ttu-id="099d3-177">**X DO NOT** 例如繼承自非泛型基底集合 `CollectionBase`。</span><span class="sxs-lookup"><span data-stu-id="099d3-177">**X DO NOT** inherit from nongeneric base collections such as `CollectionBase`.</span></span> <span data-ttu-id="099d3-178">使用`Collection<T>`， `ReadOnlyCollection<T>`，和`KeyedCollection<TKey,TItem>`改。</span><span class="sxs-lookup"><span data-stu-id="099d3-178">Use `Collection<T>`, `ReadOnlyCollection<T>`, and `KeyedCollection<TKey,TItem>` instead.</span></span>  
  
### <a name="naming-custom-collections"></a><span data-ttu-id="099d3-179">命名自訂集合</span><span class="sxs-lookup"><span data-stu-id="099d3-179">Naming Custom Collections</span></span>  
 <span data-ttu-id="099d3-180">集合 (型別都會實作`IEnumerable`) 會建立主要的原因有二: (1) 若要建立新的資料結構與結構特定作業通常比現有的資料結構的不同效能特性 (例如<xref:System.Collections.Generic.List%601>，<xref:System.Collections.Generic.LinkedList%601>， <xref:System.Collections.Generic.Stack%601>)，以及 (2) 若要建立特製化的集合，用於保存一組特定的項目 (例如<xref:System.Collections.Specialized.StringCollection>)。</span><span class="sxs-lookup"><span data-stu-id="099d3-180">Collections (types that implement `IEnumerable`) are created mainly for two reasons: (1) to create a new data structure with structure-specific operations and often different performance characteristics than existing data structures (e.g.,  <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>), and (2) to create a specialized collection for holding a specific set of items (e.g.,  <xref:System.Collections.Specialized.StringCollection>).</span></span> <span data-ttu-id="099d3-181">在內部實作應用程式和程式庫中最常使用的資料結構。</span><span class="sxs-lookup"><span data-stu-id="099d3-181">Data structures are most often used in the internal implementation of applications and libraries.</span></span> <span data-ttu-id="099d3-182">特製化的集合是主要是為了公開 Api 中 （屬性和參數的型別）。</span><span class="sxs-lookup"><span data-stu-id="099d3-182">Specialized collections are mainly to be exposed in APIs (as property and parameter types).</span></span>  
  
 <span data-ttu-id="099d3-183">**✓ DO** 抽象層實作名稱中使用 「 字典 」 尾碼 `IDictionary` 或 `IDictionary<TKey,TValue>`。</span><span class="sxs-lookup"><span data-stu-id="099d3-183">**✓ DO** use the "Dictionary" suffix in names of abstractions implementing `IDictionary` or `IDictionary<TKey,TValue>`.</span></span>  
  
 <span data-ttu-id="099d3-184">**✓ DO** 實作的型別名稱中使用"Collection"後置詞 `IEnumerable` （或其任何子代） 及表示項目清單。</span><span class="sxs-lookup"><span data-stu-id="099d3-184">**✓ DO** use the "Collection" suffix in names of types implementing `IEnumerable` (or any of its descendants) and representing a list of items.</span></span>  
  
 <span data-ttu-id="099d3-185">**✓ DO** 使用適當的資料結構名稱的自訂資料結構。</span><span class="sxs-lookup"><span data-stu-id="099d3-185">**✓ DO** use the appropriate data structure name for custom data structures.</span></span>  
  
 <span data-ttu-id="099d3-186">**X AVOID** 集合的抽象概念的名稱中使用隱含的特定實作，例如"LinkedList 」 或 「 雜湊表，「 任何尾碼。</span><span class="sxs-lookup"><span data-stu-id="099d3-186">**X AVOID** using any suffixes implying particular implementation, such as "LinkedList" or "Hashtable," in names of collection abstractions.</span></span>  
  
 <span data-ttu-id="099d3-187">**✓ CONSIDER** 前面加上的項目類型名稱的集合名稱。</span><span class="sxs-lookup"><span data-stu-id="099d3-187">**✓ CONSIDER** prefixing collection names with the name of the item type.</span></span> <span data-ttu-id="099d3-188">例如，儲存項目類型的集合`Address`(實作`IEnumerable<Address>`) 應該命名為`AddressCollection`。</span><span class="sxs-lookup"><span data-stu-id="099d3-188">For example, a collection storing items of type `Address` (implementing `IEnumerable<Address>`) should be named `AddressCollection`.</span></span> <span data-ttu-id="099d3-189">如果項目類型是介面，"I"前置詞之項目的型別，則可以省略。</span><span class="sxs-lookup"><span data-stu-id="099d3-189">If the item type is an interface, the "I" prefix of the item type can be omitted.</span></span> <span data-ttu-id="099d3-190">因此，一堆<xref:System.IDisposable>項目可以稱為`DisposableCollection`。</span><span class="sxs-lookup"><span data-stu-id="099d3-190">Thus, a collection of <xref:System.IDisposable> items can be called `DisposableCollection`.</span></span>  
  
 <span data-ttu-id="099d3-191">**✓ CONSIDER** 的唯讀集合的名稱中使用"ReadOnly"前置詞，如果對應的可寫入集合可能會加入或已存在於架構。</span><span class="sxs-lookup"><span data-stu-id="099d3-191">**✓ CONSIDER** using the "ReadOnly" prefix in names of read-only collections if a corresponding writeable collection might be added or already exists in the framework.</span></span>  
  
 <span data-ttu-id="099d3-192">比方說，應該呼叫唯讀的集合，這些字串`ReadOnlyStringCollection`。</span><span class="sxs-lookup"><span data-stu-id="099d3-192">For example, a read-only collection of strings should be called `ReadOnlyStringCollection`.</span></span>  
  
 <span data-ttu-id="099d3-193">*Portions © 2005, 2009 Microsoft Corporation.All rights reserved.*</span><span class="sxs-lookup"><span data-stu-id="099d3-193">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>  
  
 <span data-ttu-id="099d3-194">獲 Pearson Education, Inc. 的授權再版，從 Krzysztof Cwalina 和 Brad Abrams 撰寫，並在 2008 年 10 月 22 日由 Addison-Wesley Professional 出版，作為 Microsoft Windows Development Series 一部份的 [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) 節錄。</span><span class="sxs-lookup"><span data-stu-id="099d3-194">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="099d3-195">另請參閱</span><span class="sxs-lookup"><span data-stu-id="099d3-195">See also</span></span>

- [<span data-ttu-id="099d3-196">Framework 設計方針</span><span class="sxs-lookup"><span data-stu-id="099d3-196">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)  
- [<span data-ttu-id="099d3-197">用法方針</span><span class="sxs-lookup"><span data-stu-id="099d3-197">Usage Guidelines</span></span>](../../../docs/standard/design-guidelines/usage-guidelines.md)
