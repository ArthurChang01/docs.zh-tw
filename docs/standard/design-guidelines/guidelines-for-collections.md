---
title: 集合方針
ms.date: 03/30/2017
ms.technology: dotnet-standard
ms.assetid: 297b8f1d-b11f-4dc6-960a-8e990817304e
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 3d73ff726e9ddfe1ec1d16dd020f53445f984fb9
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/04/2018
ms.locfileid: "33578855"
---
# <a name="guidelines-for-collections"></a><span data-ttu-id="a9f47-102">集合方針</span><span class="sxs-lookup"><span data-stu-id="a9f47-102">Guidelines for Collections</span></span>
<span data-ttu-id="a9f47-103">可以被視為特別設計用來管理群組物件都有某些共同特性的任何類型的集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-103">Any type designed specifically to manipulate a group of objects having some common characteristic can be considered a collection.</span></span> <span data-ttu-id="a9f47-104">這幾乎都適合實作這類類型<xref:System.Collections.IEnumerable>或<xref:System.Collections.Generic.IEnumerable%601>，因此本節中，我們只考慮實作一或兩個介面的型別是集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-104">It is almost always appropriate for such types to implement <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>, so in this section we only consider types implementing one or both of those interfaces to be collections.</span></span>  
  
 <span data-ttu-id="a9f47-105">**X DO NOT**在公用 Api 中使用弱式型別的的集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-105">**X DO NOT** use weakly typed collections in public APIs.</span></span>  
  
 <span data-ttu-id="a9f47-106">所有傳回值以及參數代表集合項目類型應該是正確的項目類型，不其任何基底類型 （這只適用於集合中的公用成員）。</span><span class="sxs-lookup"><span data-stu-id="a9f47-106">The type of all return values and parameters representing collection items should be the exact item type, not any of its base types (this applies only to public members of the collection).</span></span>  
  
 <span data-ttu-id="a9f47-107">**X DO NOT**使用<xref:System.Collections.ArrayList>或<xref:System.Collections.Generic.List%601>在公用 Api。</span><span class="sxs-lookup"><span data-stu-id="a9f47-107">**X DO NOT** use <xref:System.Collections.ArrayList> or <xref:System.Collections.Generic.List%601> in public APIs.</span></span>  
  
 <span data-ttu-id="a9f47-108">這些類型是設計為可在內部實作中，不能在公用 Api 的資料結構。</span><span class="sxs-lookup"><span data-stu-id="a9f47-108">These types are data structures designed to be used in internal implementation, not in public APIs.</span></span> <span data-ttu-id="a9f47-109">`List<T>` 已針對效能，但要付出的應用程式開發介面與彈性 cleanness 電源最佳化。</span><span class="sxs-lookup"><span data-stu-id="a9f47-109">`List<T>` is optimized for performance and power at the cost of cleanness of the APIs and flexibility.</span></span> <span data-ttu-id="a9f47-110">例如，如果您傳回`List<T>`，您將永遠無法接收通知，當用戶端程式碼會修改集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-110">For example, if you return `List<T>`, you will not ever be able to receive notifications when client code modifies the collection.</span></span> <span data-ttu-id="a9f47-111">此外，`List<T>`公開許多成員，例如<xref:System.Collections.Generic.List%601.BinarySearch%2A>，不實用或適用於許多案例。</span><span class="sxs-lookup"><span data-stu-id="a9f47-111">Also, `List<T>` exposes many members, such as <xref:System.Collections.Generic.List%601.BinarySearch%2A>, that are not useful or applicable in many scenarios.</span></span> <span data-ttu-id="a9f47-112">下列兩節則描述專為使用公用 Api 中設計的類型 （抽象）。</span><span class="sxs-lookup"><span data-stu-id="a9f47-112">The following two sections describe types (abstractions) designed specifically for use in public APIs.</span></span>  
  
 <span data-ttu-id="a9f47-113">**X DO NOT**使用`Hashtable`或`Dictionary<TKey,TValue>`在公用 Api。</span><span class="sxs-lookup"><span data-stu-id="a9f47-113">**X DO NOT** use `Hashtable` or `Dictionary<TKey,TValue>` in public APIs.</span></span>  
  
 <span data-ttu-id="a9f47-114">這些類型是設計為可在內部實作的資料結構。</span><span class="sxs-lookup"><span data-stu-id="a9f47-114">These types are data structures designed to be used in internal implementation.</span></span> <span data-ttu-id="a9f47-115">應該使用公用 Api <xref:System.Collections.IDictionary>， `IDictionary <TKey, TValue>`，或實作一或兩個介面的自訂型別。</span><span class="sxs-lookup"><span data-stu-id="a9f47-115">Public APIs should use <xref:System.Collections.IDictionary>, `IDictionary <TKey, TValue>`, or a custom type implementing one or both of the interfaces.</span></span>  
  
 <span data-ttu-id="a9f47-116">**X DO NOT**使用<xref:System.Collections.Generic.IEnumerator%601>， <xref:System.Collections.IEnumerator>，或實作介面，其中除了為傳回類型的任何其他型別`GetEnumerator`方法。</span><span class="sxs-lookup"><span data-stu-id="a9f47-116">**X DO NOT** use <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Collections.IEnumerator>, or any other type that implements either of these interfaces, except as the return type of a `GetEnumerator` method.</span></span>  
  
 <span data-ttu-id="a9f47-117">除了從方法傳回列舉值的型別`GetEnumerator`不能與`foreach`陳述式。</span><span class="sxs-lookup"><span data-stu-id="a9f47-117">Types returning enumerators from methods other than `GetEnumerator` cannot be used with the `foreach` statement.</span></span>  
  
 <span data-ttu-id="a9f47-118">**X DO NOT**同時實作`IEnumerator<T>`和`IEnumerable<T>`上相同的型別。</span><span class="sxs-lookup"><span data-stu-id="a9f47-118">**X DO NOT** implement both `IEnumerator<T>` and `IEnumerable<T>` on the same type.</span></span> <span data-ttu-id="a9f47-119">同樣適用於非泛型介面`IEnumerator`和`IEnumerable`。</span><span class="sxs-lookup"><span data-stu-id="a9f47-119">The same applies to the nongeneric interfaces `IEnumerator` and `IEnumerable`.</span></span>  
  
## <a name="collection-parameters"></a><span data-ttu-id="a9f47-120">集合參數</span><span class="sxs-lookup"><span data-stu-id="a9f47-120">Collection Parameters</span></span>  
 <span data-ttu-id="a9f47-121">**✓ DO**使用可能的最低特製化類型做為參數類型。</span><span class="sxs-lookup"><span data-stu-id="a9f47-121">**✓ DO** use the least-specialized type possible as a parameter type.</span></span> <span data-ttu-id="a9f47-122">取得集合，作為參數使用的大部分成員`IEnumerable<T>`介面。</span><span class="sxs-lookup"><span data-stu-id="a9f47-122">Most members taking collections as parameters use the `IEnumerable<T>` interface.</span></span>  
  
 <span data-ttu-id="a9f47-123">**X AVOID**使用<xref:System.Collections.Generic.ICollection%601>或<xref:System.Collections.ICollection>做為參數，只是為了存取`Count`屬性。</span><span class="sxs-lookup"><span data-stu-id="a9f47-123">**X AVOID** using <xref:System.Collections.Generic.ICollection%601> or <xref:System.Collections.ICollection> as a parameter just to access the `Count` property.</span></span>  
  
 <span data-ttu-id="a9f47-124">相反地，請考慮使用`IEnumerable<T>`或`IEnumerable`和動態檢查物件是否實作`ICollection<T>`或`ICollection`。</span><span class="sxs-lookup"><span data-stu-id="a9f47-124">Instead, consider using `IEnumerable<T>` or `IEnumerable` and dynamically checking whether the object implements `ICollection<T>` or `ICollection`.</span></span>  
  
## <a name="collection-properties-and-return-values"></a><span data-ttu-id="a9f47-125">集合屬性和傳回值</span><span class="sxs-lookup"><span data-stu-id="a9f47-125">Collection Properties and Return Values</span></span>  
 <span data-ttu-id="a9f47-126">**X DO NOT**提供可設定的集合屬性。</span><span class="sxs-lookup"><span data-stu-id="a9f47-126">**X DO NOT** provide settable collection properties.</span></span>  
  
 <span data-ttu-id="a9f47-127">使用者可以先清除集合，然後將加入新的內容取代集合的內容。</span><span class="sxs-lookup"><span data-stu-id="a9f47-127">Users can replace the contents of the collection by clearing the collection first and then adding the new contents.</span></span> <span data-ttu-id="a9f47-128">如果取代整個集合是常見的案例，請考慮提供`AddRange`集合上的方法。</span><span class="sxs-lookup"><span data-stu-id="a9f47-128">If replacing the whole collection is a common scenario, consider providing the `AddRange` method on the collection.</span></span>  
  
 <span data-ttu-id="a9f47-129">**✓ DO**使用`Collection<T>`或的子類別`Collection<T>`針對屬性或傳回值表示讀取/寫入集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-129">**✓ DO** use `Collection<T>` or a subclass of `Collection<T>` for properties or return values representing read/write collections.</span></span>  
  
 <span data-ttu-id="a9f47-130">如果`Collection<T>`不符合某些需求 (例如，集合必須不會實作<xref:System.Collections.IList>)，使用自訂的集合，藉由實作`IEnumerable<T>`， `ICollection<T>`，或<xref:System.Collections.Generic.IList%601>。</span><span class="sxs-lookup"><span data-stu-id="a9f47-130">If `Collection<T>` does not meet some requirement (e.g., the collection must not implement <xref:System.Collections.IList>), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or <xref:System.Collections.Generic.IList%601>.</span></span>  
  
 <span data-ttu-id="a9f47-131">**✓ DO**使用<xref:System.Collections.ObjectModel.ReadOnlyCollection%601>的子類別`ReadOnlyCollection<T>`，或在極少數的情況下`IEnumerable<T>`針對屬性或傳回值表示唯讀的集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-131">**✓ DO** use <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>, a subclass of `ReadOnlyCollection<T>`, or in rare cases `IEnumerable<T>` for properties or return values representing read-only collections.</span></span>  
  
 <span data-ttu-id="a9f47-132">通常，最好`ReadOnlyCollection<T>`。</span><span class="sxs-lookup"><span data-stu-id="a9f47-132">In general, prefer `ReadOnlyCollection<T>`.</span></span> <span data-ttu-id="a9f47-133">如果不符合某些需求 (例如，集合必須不會實作`IList`)，使用自訂的集合，藉由實作`IEnumerable<T>`， `ICollection<T>`，或`IList<T>`。</span><span class="sxs-lookup"><span data-stu-id="a9f47-133">If it does not meet some requirement (e.g., the collection must not implement `IList`), use a custom collection by implementing `IEnumerable<T>`, `ICollection<T>`, or `IList<T>`.</span></span> <span data-ttu-id="a9f47-134">如果您實作自訂的唯讀集合，實作`ICollection<T>.IsReadOnly`傳回`true`。</span><span class="sxs-lookup"><span data-stu-id="a9f47-134">If you do implement a custom read-only collection, implement `ICollection<T>.IsReadOnly` to return `true`.</span></span>  
  
 <span data-ttu-id="a9f47-135">在要確定只有您想要支援的案例是順向的反覆項目的情況下，您可以直接使用`IEnumerable<T>`。</span><span class="sxs-lookup"><span data-stu-id="a9f47-135">In cases where you are sure that the only scenario you will ever want to support is forward-only iteration, you can simply use `IEnumerable<T>`.</span></span>  
  
 <span data-ttu-id="a9f47-136">**✓ CONSIDER**使用泛型基底集合的子類別，而不直接使用集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-136">**✓ CONSIDER** using subclasses of generic base collections instead of using the collections directly.</span></span>  
  
 <span data-ttu-id="a9f47-137">如此可更佳的名稱，以及加入未出現在基底集合類型上的協助程式成員。</span><span class="sxs-lookup"><span data-stu-id="a9f47-137">This allows for a better name and for adding helper members that are not present on the base collection types.</span></span> <span data-ttu-id="a9f47-138">這是特別適用於高階應用程式開發介面。</span><span class="sxs-lookup"><span data-stu-id="a9f47-138">This is especially applicable to high-level APIs.</span></span>  
  
 <span data-ttu-id="a9f47-139">**✓ CONSIDER**傳回的子類別`Collection<T>`或`ReadOnlyCollection<T>`從相當常用的方法和屬性。</span><span class="sxs-lookup"><span data-stu-id="a9f47-139">**✓ CONSIDER** returning a subclass of `Collection<T>` or `ReadOnlyCollection<T>` from very commonly used methods and properties.</span></span>  
  
 <span data-ttu-id="a9f47-140">這會讓您可新增 helper 方法，或變更在未來的集合實作。</span><span class="sxs-lookup"><span data-stu-id="a9f47-140">This will make it possible for you to add helper methods or change the collection implementation in the future.</span></span>  
  
 <span data-ttu-id="a9f47-141">**✓ CONSIDER**使用索引鍵的集合，如果儲存在集合中的項目具有唯一索引鍵 （名稱、 識別碼、 等等。）。</span><span class="sxs-lookup"><span data-stu-id="a9f47-141">**✓ CONSIDER** using a keyed collection if the items stored in the collection have unique keys (names, IDs, etc.).</span></span> <span data-ttu-id="a9f47-142">索引鍵的集合是以一個整數和索引鍵編製的索引，且通常由繼承自集合`KeyedCollection<TKey,TItem>`。</span><span class="sxs-lookup"><span data-stu-id="a9f47-142">Keyed collections are collections that can be indexed by both an integer and a key and are usually implemented by inheriting from `KeyedCollection<TKey,TItem>`.</span></span>  
  
 <span data-ttu-id="a9f47-143">索引的集合通常較大的記憶體使用量，而不是記憶體負擔會超過優點必須要有金鑰。</span><span class="sxs-lookup"><span data-stu-id="a9f47-143">Keyed collections usually have larger memory footprints and should not be used if the memory overhead outweighs the benefits of having the keys.</span></span>  
  
 <span data-ttu-id="a9f47-144">**X DO NOT**集合屬性中或從方法傳回集合，傳回 null 值。</span><span class="sxs-lookup"><span data-stu-id="a9f47-144">**X DO NOT** return null values from collection properties or from methods returning collections.</span></span> <span data-ttu-id="a9f47-145">而是傳回空集合或空陣列。</span><span class="sxs-lookup"><span data-stu-id="a9f47-145">Return an empty collection or an empty array instead.</span></span>  
  
 <span data-ttu-id="a9f47-146">一般規則是應該是 null 和空白 （0 的項目） 的集合或陣列視為相同。</span><span class="sxs-lookup"><span data-stu-id="a9f47-146">The general rule is that null and empty (0 item) collections or arrays should be treated the same.</span></span>  
  
### <a name="snapshots-versus-live-collections"></a><span data-ttu-id="a9f47-147">快照集與即時的集合</span><span class="sxs-lookup"><span data-stu-id="a9f47-147">Snapshots Versus Live Collections</span></span>  
 <span data-ttu-id="a9f47-148">集合表示在某個時間點的狀態的時間稱為快照集的集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-148">Collections representing a state at some point in time are called snapshot collections.</span></span> <span data-ttu-id="a9f47-149">例如，集合，其中包含從資料庫查詢傳回資料列將快照集。</span><span class="sxs-lookup"><span data-stu-id="a9f47-149">For example, a collection containing rows returned from a database query would be a snapshot.</span></span> <span data-ttu-id="a9f47-150">一律代表對目前狀態的集合稱為即時的集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-150">Collections that always represent the current state are called live collections.</span></span> <span data-ttu-id="a9f47-151">例如，集合`ComboBox`項目是即時的集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-151">For example, a collection of `ComboBox` items is a live collection.</span></span>  
  
 <span data-ttu-id="a9f47-152">**X DO NOT**屬性從傳回快照集的集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-152">**X DO NOT** return snapshot collections from properties.</span></span> <span data-ttu-id="a9f47-153">屬性應該會傳回實際的集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-153">Properties should return live collections.</span></span>  
  
 <span data-ttu-id="a9f47-154">屬性 getter 應該非常輕量級的作業。</span><span class="sxs-lookup"><span data-stu-id="a9f47-154">Property getters should be very lightweight operations.</span></span> <span data-ttu-id="a9f47-155">傳回快照集也需要 o （n） 作業中建立的內部集合的複本。</span><span class="sxs-lookup"><span data-stu-id="a9f47-155">Returning a snapshot requires creating a copy of an internal collection in an O(n) operation.</span></span>  
  
 <span data-ttu-id="a9f47-156">**✓ DO**使用快照集收集或即時`IEnumerable<T>`（或它的子類型） 來表示為變動性的集合 （亦即，可以變更而不需明確修改集合）。</span><span class="sxs-lookup"><span data-stu-id="a9f47-156">**✓ DO** use either a snapshot collection or a live `IEnumerable<T>` (or its subtype) to represent collections that are volatile (i.e., that can change without explicitly modifying the collection).</span></span>  
  
 <span data-ttu-id="a9f47-157">一般情況下，表示共用的資源 （例如，在目錄中的檔案） 的所有集合都是動態的。</span><span class="sxs-lookup"><span data-stu-id="a9f47-157">In general, all collections representing a shared resource (e.g., files in a directory) are volatile.</span></span> <span data-ttu-id="a9f47-158">這類集合是很難或難以實作做為即時的集合，除非實作就只是順向的列舉值。</span><span class="sxs-lookup"><span data-stu-id="a9f47-158">Such collections are very difficult or impossible to implement as live collections unless the implementation is simply a forward-only enumerator.</span></span>  
  
## <a name="choosing-between-arrays-and-collections"></a><span data-ttu-id="a9f47-159">陣列和集合之間選擇</span><span class="sxs-lookup"><span data-stu-id="a9f47-159">Choosing Between Arrays and Collections</span></span>  
 <span data-ttu-id="a9f47-160">**✓ DO**集合，而不用陣列。</span><span class="sxs-lookup"><span data-stu-id="a9f47-160">**✓ DO** prefer collections over arrays.</span></span>  
  
 <span data-ttu-id="a9f47-161">集合提供更充分掌控內容、 可以隨著時間，而且更有用。</span><span class="sxs-lookup"><span data-stu-id="a9f47-161">Collections provide more control over contents, can evolve over time, and are more usable.</span></span> <span data-ttu-id="a9f47-162">此外，因為複製陣列的成本為代價，建議使用陣列的唯讀案例。</span><span class="sxs-lookup"><span data-stu-id="a9f47-162">In addition, using arrays for read-only scenarios is discouraged because the cost of cloning the array is prohibitive.</span></span> <span data-ttu-id="a9f47-163">顯示可用性研究的部分開發人員認為更方便使用以集合為基礎的 Api。</span><span class="sxs-lookup"><span data-stu-id="a9f47-163">Usability studies have shown that some developers feel more comfortable using collection-based APIs.</span></span>  
  
 <span data-ttu-id="a9f47-164">不過，如果您正在開發低階 Api，可能最好使用讀寫案例的陣列。</span><span class="sxs-lookup"><span data-stu-id="a9f47-164">However, if you are developing low-level APIs, it might be better to use arrays for read-write scenarios.</span></span> <span data-ttu-id="a9f47-165">陣列有較小的記憶體耗用量，如此有助於減少工作集，以及陣列中項目的存取速度，因為它已由執行階段最佳化。</span><span class="sxs-lookup"><span data-stu-id="a9f47-165">Arrays have a smaller memory footprint, which helps reduce the working set, and access to elements in an array is faster because it is optimized by the runtime.</span></span>  
  
 <span data-ttu-id="a9f47-166">**✓ CONSIDER**低階 Api 中使用陣列記憶體耗用量降到最低，並將效能最大化。</span><span class="sxs-lookup"><span data-stu-id="a9f47-166">**✓ CONSIDER** using arrays in low-level APIs to minimize memory consumption and maximize performance.</span></span>  
  
 <span data-ttu-id="a9f47-167">**✓ DO**使用位元組陣列，而不是位元組的集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-167">**✓ DO** use byte arrays instead of collections of bytes.</span></span>  
  
 <span data-ttu-id="a9f47-168">**X DO NOT**使用屬性的陣列，如果屬性必須在呼叫屬性 getter 的每次會傳回新的陣列 （例如，內部陣列的複本）。</span><span class="sxs-lookup"><span data-stu-id="a9f47-168">**X DO NOT** use arrays for properties if the property would have to return a new array (e.g., a copy of an internal array) every time the property getter is called.</span></span>  
  
## <a name="implementing-custom-collections"></a><span data-ttu-id="a9f47-169">實作自訂集合</span><span class="sxs-lookup"><span data-stu-id="a9f47-169">Implementing Custom Collections</span></span>  
 <span data-ttu-id="a9f47-170">**✓ CONSIDER**繼承自`Collection<T>`， `ReadOnlyCollection<T>`，或`KeyedCollection<TKey,TItem>`設計新的集合時。</span><span class="sxs-lookup"><span data-stu-id="a9f47-170">**✓ CONSIDER** inheriting from `Collection<T>`, `ReadOnlyCollection<T>`, or `KeyedCollection<TKey,TItem>` when designing new collections.</span></span>  
  
 <span data-ttu-id="a9f47-171">**✓ DO**實作`IEnumerable<T>`設計新的集合時。</span><span class="sxs-lookup"><span data-stu-id="a9f47-171">**✓ DO** implement `IEnumerable<T>` when designing new collections.</span></span> <span data-ttu-id="a9f47-172">請考慮實作`ICollection<T>`或甚至`IList<T>`很合理。</span><span class="sxs-lookup"><span data-stu-id="a9f47-172">Consider implementing `ICollection<T>` or even `IList<T>` where it makes sense.</span></span>  
  
 <span data-ttu-id="a9f47-173">當實作這類自訂集合時，請依照下列所建立的應用程式開發介面模式`Collection<T>`和`ReadOnlyCollection<T>`十分接近。</span><span class="sxs-lookup"><span data-stu-id="a9f47-173">When implementing such custom collection, follow the API pattern established by `Collection<T>` and `ReadOnlyCollection<T>` as closely as possible.</span></span> <span data-ttu-id="a9f47-174">也就是明確地實作相同的成員、 name 參數，這兩個集合的名稱，以及等等一樣。</span><span class="sxs-lookup"><span data-stu-id="a9f47-174">That is, implement the same members explicitly, name the parameters like these two collections name them, and so on.</span></span>  
  
 <span data-ttu-id="a9f47-175">**✓ CONSIDER**實作非泛型集合介面 (`IList`和`ICollection`) 如果集合將通常會傳遞至應用程式開發介面採用這些介面做為輸入。</span><span class="sxs-lookup"><span data-stu-id="a9f47-175">**✓ CONSIDER** implementing nongeneric collection interfaces (`IList` and `ICollection`) if the collection will often be passed to APIs taking these interfaces as input.</span></span>  
  
 <span data-ttu-id="a9f47-176">**X AVOID**型別上實作的集合介面具有複雜的應用程式開發介面不相關的概念的集合。</span><span class="sxs-lookup"><span data-stu-id="a9f47-176">**X AVOID** implementing collection interfaces on types with complex APIs unrelated to the concept of a collection.</span></span>  
  
 <span data-ttu-id="a9f47-177">**X DO NOT**例如繼承自非泛型基底集合`CollectionBase`。</span><span class="sxs-lookup"><span data-stu-id="a9f47-177">**X DO NOT** inherit from nongeneric base collections such as `CollectionBase`.</span></span> <span data-ttu-id="a9f47-178">使用`Collection<T>`， `ReadOnlyCollection<T>`，和`KeyedCollection<TKey,TItem>`改為。</span><span class="sxs-lookup"><span data-stu-id="a9f47-178">Use `Collection<T>`, `ReadOnlyCollection<T>`, and `KeyedCollection<TKey,TItem>` instead.</span></span>  
  
### <a name="naming-custom-collections"></a><span data-ttu-id="a9f47-179">命名自訂集合</span><span class="sxs-lookup"><span data-stu-id="a9f47-179">Naming Custom Collections</span></span>  
 <span data-ttu-id="a9f47-180">集合 (型別都會實作`IEnumerable`) 會建立主要是針對兩個原因: (1) 若要建立新的資料結構的特定結構的作業和通常比現有的資料結構的不同效能特性 (例如<xref:System.Collections.Generic.List%601>，<xref:System.Collections.Generic.LinkedList%601>， <xref:System.Collections.Generic.Stack%601>)，以及 (2) 若要建立特製化的集合，用以保存一組特定的項目 (例如<xref:System.Collections.Specialized.StringCollection>)。</span><span class="sxs-lookup"><span data-stu-id="a9f47-180">Collections (types that implement `IEnumerable`) are created mainly for two reasons: (1) to create a new data structure with structure-specific operations and often different performance characteristics than existing data structures (e.g.,  <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.LinkedList%601>, <xref:System.Collections.Generic.Stack%601>), and (2) to create a specialized collection for holding a specific set of items (e.g.,  <xref:System.Collections.Specialized.StringCollection>).</span></span> <span data-ttu-id="a9f47-181">在內部實作中的應用程式和程式庫最常使用的資料結構。</span><span class="sxs-lookup"><span data-stu-id="a9f47-181">Data structures are most often used in the internal implementation of applications and libraries.</span></span> <span data-ttu-id="a9f47-182">特製化的集合是主要是要公開 Api 中 （屬性和參數的型別）。</span><span class="sxs-lookup"><span data-stu-id="a9f47-182">Specialized collections are mainly to be exposed in APIs (as property and parameter types).</span></span>  
  
 <span data-ttu-id="a9f47-183">**✓ DO**抽象層實作名稱中使用 「 字典 」 尾碼`IDictionary`或`IDictionary<TKey,TValue>`。</span><span class="sxs-lookup"><span data-stu-id="a9f47-183">**✓ DO** use the "Dictionary" suffix in names of abstractions implementing `IDictionary` or `IDictionary<TKey,TValue>`.</span></span>  
  
 <span data-ttu-id="a9f47-184">**✓ DO**實作的型別名稱中使用"Collection"後置詞`IEnumerable`（或其任何子代） 及表示項目清單。</span><span class="sxs-lookup"><span data-stu-id="a9f47-184">**✓ DO** use the "Collection" suffix in names of types implementing `IEnumerable` (or any of its descendants) and representing a list of items.</span></span>  
  
 <span data-ttu-id="a9f47-185">**✓ DO**使用適當的資料結構名稱的自訂資料結構。</span><span class="sxs-lookup"><span data-stu-id="a9f47-185">**✓ DO** use the appropriate data structure name for custom data structures.</span></span>  
  
 <span data-ttu-id="a9f47-186">**X AVOID**集合的抽象概念的名稱中使用隱含的特定實作，例如"LinkedList 」 或 「 雜湊表，「 任何尾碼。</span><span class="sxs-lookup"><span data-stu-id="a9f47-186">**X AVOID** using any suffixes implying particular implementation, such as "LinkedList" or "Hashtable," in names of collection abstractions.</span></span>  
  
 <span data-ttu-id="a9f47-187">**✓ CONSIDER**前面加上的項目類型名稱的集合名稱。</span><span class="sxs-lookup"><span data-stu-id="a9f47-187">**✓ CONSIDER** prefixing collection names with the name of the item type.</span></span> <span data-ttu-id="a9f47-188">例如，儲存類型的項目集合`Address`(實作`IEnumerable<Address>`) 應命名為`AddressCollection`。</span><span class="sxs-lookup"><span data-stu-id="a9f47-188">For example, a collection storing items of type `Address` (implementing `IEnumerable<Address>`) should be named `AddressCollection`.</span></span> <span data-ttu-id="a9f47-189">如果項目類型是介面，"I"前置詞的項目類型，則可以省略。</span><span class="sxs-lookup"><span data-stu-id="a9f47-189">If the item type is an interface, the "I" prefix of the item type can be omitted.</span></span> <span data-ttu-id="a9f47-190">因此，集合<xref:System.IDisposable>可以呼叫項目`DisposableCollection`。</span><span class="sxs-lookup"><span data-stu-id="a9f47-190">Thus, a collection of <xref:System.IDisposable> items can be called `DisposableCollection`.</span></span>  
  
 <span data-ttu-id="a9f47-191">**✓ CONSIDER**的唯讀集合的名稱中使用"ReadOnly"前置詞，如果對應的可寫入集合可能會加入或已存在於架構。</span><span class="sxs-lookup"><span data-stu-id="a9f47-191">**✓ CONSIDER** using the "ReadOnly" prefix in names of read-only collections if a corresponding writeable collection might be added or already exists in the framework.</span></span>  
  
 <span data-ttu-id="a9f47-192">例如，應該呼叫字串的唯讀集合`ReadOnlyStringCollection`。</span><span class="sxs-lookup"><span data-stu-id="a9f47-192">For example, a read-only collection of strings should be called `ReadOnlyStringCollection`.</span></span>  
  
 <span data-ttu-id="a9f47-193">*部分 © 2005年，2009 Microsoft Corporation。All rights reserved.*</span><span class="sxs-lookup"><span data-stu-id="a9f47-193">*Portions © 2005, 2009 Microsoft Corporation. All rights reserved.*</span></span>  
  
 <span data-ttu-id="a9f47-194">*皮耳森教育，inc.從權限所印製[Framework 設計方針： 慣例、 慣用語和可重複使用.NET 程式庫，第 2 版的模式](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619)Krzysztof Cwalina 並 Brad Abrams，發行 2008 年 10 月 22 日由Addison Wesley Professional，做為 Microsoft Windows 程式開發系列的一部分。*</span><span class="sxs-lookup"><span data-stu-id="a9f47-194">*Reprinted by permission of Pearson Education, Inc. from [Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 2nd Edition](https://www.informit.com/store/framework-design-guidelines-conventions-idioms-and-9780321545619) by Krzysztof Cwalina and Brad Abrams, published Oct 22, 2008 by Addison-Wesley Professional as part of the Microsoft Windows Development Series.*</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a9f47-195">另請參閱</span><span class="sxs-lookup"><span data-stu-id="a9f47-195">See Also</span></span>  
 [<span data-ttu-id="a9f47-196">Framework 設計方針</span><span class="sxs-lookup"><span data-stu-id="a9f47-196">Framework Design Guidelines</span></span>](../../../docs/standard/design-guidelines/index.md)  
 [<span data-ttu-id="a9f47-197">用法方針</span><span class="sxs-lookup"><span data-stu-id="a9f47-197">Usage Guidelines</span></span>](../../../docs/standard/design-guidelines/usage-guidelines.md)
