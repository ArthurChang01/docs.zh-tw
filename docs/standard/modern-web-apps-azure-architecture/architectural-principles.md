---
title: 架構原則
description: 使用 ASP.NET Core 和 Azure 架構現代化 Web 應用程式 | 架構原則
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: bdb215d64253fb7d22ae2c5648030336850006b5
ms.sourcegitcommit: f28752eab00d2bd97e971542c0f49ce63cfbc239
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/29/2018
---
# <a name="architectural-principles"></a><span data-ttu-id="cb0c0-103">架構原則</span><span class="sxs-lookup"><span data-stu-id="cb0c0-103">Architectural Principles</span></span>

> <span data-ttu-id="cb0c0-104">「如果營造商要像程式設計人員撰寫程式那樣地蓋房子，那麼第一隻經過的啄木鳥將會摧毀文明。」</span><span class="sxs-lookup"><span data-stu-id="cb0c0-104">"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization."</span></span>  
> <span data-ttu-id="cb0c0-105">_\- Gerald Weinberg_</span><span class="sxs-lookup"><span data-stu-id="cb0c0-105">_\- Gerald Weinberg_</span></span>

## <a name="summary"></a><span data-ttu-id="cb0c0-106">總結</span><span class="sxs-lookup"><span data-stu-id="cb0c0-106">Summary</span></span>

<span data-ttu-id="cb0c0-107">您在架構與設計軟體解決方案時，應該惦記著可維護性。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-107">You should architect and design software solutions with maintainability in mind.</span></span> <span data-ttu-id="cb0c0-108">本節中所述的準則可協助引導您做出將產生可維護之全新應用程式的架構決策。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-108">The principles outlined in this section can help guide you toward architectural decisions that will result in clean, maintainable applications.</span></span> <span data-ttu-id="cb0c0-109">一般而言，這些原則會引導您利用與應用程式其他部分未緊密結合，而是透過明確介面或傳訊系統進行通訊的不同元件來建置應用程式。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-109">Generally, these principles will guide you toward building applications out of discrete components that are not tightly coupled to other parts of your application, but rather communicate through explicit interfaces or messaging systems.</span></span>

## <a name="common-design-principles"></a><span data-ttu-id="cb0c0-110">一般設計原則</span><span class="sxs-lookup"><span data-stu-id="cb0c0-110">Common design principles</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="cb0c0-111">關注點分離</span><span class="sxs-lookup"><span data-stu-id="cb0c0-111">Separation of Concerns</span></span>

<span data-ttu-id="cb0c0-112">開發時的一項指導原則是**關注點分離**。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-112">A guiding principle when developing is **Separation of Concerns**.</span></span> <span data-ttu-id="cb0c0-113">這個原則判斷提示軟體應該根據它所執行的工作種類來分離。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-113">This principle asserts that software should be separated based on the kinds of work it performs.</span></span> <span data-ttu-id="cb0c0-114">比方說，假設應用程式中包含邏輯來識別值得注意的項目，以便顯示給使用者，而且特別格式化此類項目，使其更容易被注意到。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-114">For instance, consider an application that includes logic for identifying noteworthy items to display to the user, and which formats such items in a particular way to make them more noticeable.</span></span> <span data-ttu-id="cb0c0-115">負責選擇要格式化之項目的行為，應該與負責格式化項目的行為分離，因為這些分離關注點只是碰巧彼此相關。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-115">The behavior responsible for choosing which items to format should be kept separate from the behavior responsible for formatting the items, since these are separate concerns that are only coincidentally related to one another.</span></span>

<span data-ttu-id="cb0c0-116">在架構上，您可以藉由從基礎結構和使用者介面邏輯分離核心商務行為以邏輯方式來建置應用程式，以遵循這個原則。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-116">Architecturally, applications can be logically built to follow this principle by separating core business behavior from infrastructure and user interface logic.</span></span> <span data-ttu-id="cb0c0-117">在理想情況下，商務規則和邏輯應該位於個別的專案，且不應依賴應用程式中的其他專案。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-117">Ideally, business rules and logic should reside in a separate project, which should not depend on other projects in the application.</span></span> <span data-ttu-id="cb0c0-118">這有助於確保商務模型很容易測試，並且不必緊密結合低層級的實作詳細資料就能持續改進。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-118">This helps ensure that the business model is easy to test and can evolve without being tightly coupled to low-level implementation details.</span></span> <span data-ttu-id="cb0c0-119">關注點分離是在應用程式架構中使用層級背後的一項重要考量。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-119">Separation of concerns is a key consideration behind the use of layers in application architectures.</span></span>

### <a name="encapsulation"></a><span data-ttu-id="cb0c0-120">封裝</span><span class="sxs-lookup"><span data-stu-id="cb0c0-120">Encapsulation</span></span>

<span data-ttu-id="cb0c0-121">應用程式的不同部分應該使用**封裝**，將它們與應用程式的其他部分隔離。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-121">Different parts of an application should use **encapsulation** to insulate them from other parts of the application.</span></span> <span data-ttu-id="cb0c0-122">應用程式元件和層級應該能夠調整內部實作，而且只要不違反外部的合約，便不必中斷其共同作業者。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-122">Application components and layers should be able to adjust their internal implementation without breaking their collaborators as long as external contracts are not violated.</span></span> <span data-ttu-id="cb0c0-123">正確地使用封裝可協助達到應用程式設計中的鬆散結合和模組化，因為物件與套件可以取代為替代的實作，只要維持相同的介面即可。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-123">Proper use of encapsulation helps achieve loose coupling and modularity in application designs, since objects and packages can be replaced with alternative implementations so long as the same interface is maintained.</span></span>

<span data-ttu-id="cb0c0-124">在類別中，封裝是藉由限制對類別內部狀態的外部存取而達成。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-124">In classes, encapsulation is achieved by limiting outside access to the class's internal state.</span></span> <span data-ttu-id="cb0c0-125">如果外部執行者想要操作物件的狀態，則應透過妥善定義的函式 (或屬性 setter) 來達成，而不是直接存取物件的私用狀態。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-125">If an outside actor wants to manipulate the state of the object, it should do so through a well-defined function (or property setter), rather than having direct access to the private state of the object.</span></span> <span data-ttu-id="cb0c0-126">同樣地，應用程式元件和應用程式本身應該公開妥善定義的介面，供它們的共同作業者來使用，而不是允許直接修改它們的狀態。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-126">Likewise, application components and applications themselves should expose well-defined interfaces for their collaborators to use, rather than allowing their state to be modified directly.</span></span> <span data-ttu-id="cb0c0-127">如此應用程式的內部設計便可以隨著時間而持續改進，且不必擔心這麼做會中斷共同作業者，只要維護公用合約即可。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-127">This frees the application's internal design to evolve over time without worrying that doing so will break collaborators, so long as the public contracts are maintained.</span></span>

### <a name="dependency-inversion"></a><span data-ttu-id="cb0c0-128">相依性反轉 (Dependency Inversion)</span><span class="sxs-lookup"><span data-stu-id="cb0c0-128">Dependency Inversion</span></span>

<span data-ttu-id="cb0c0-129">應用程式內的相依性方向應該是抽象的方向，而不是實作詳細資料。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-129">The direction of dependency within the application should be in the direction of abstraction, not implementation details.</span></span> <span data-ttu-id="cb0c0-130">大部分的應用程式撰寫時，編譯時間相依性會以執行階段執行的方向流動。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-130">Most applications are written such that compile-time dependency flows in the direction of runtime execution.</span></span> <span data-ttu-id="cb0c0-131">這會產生直接相依性圖形。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-131">This produces a direct dependency graph.</span></span> <span data-ttu-id="cb0c0-132">也就是說，如果模組 A 呼叫模組 B 中的函式，而它呼叫模組 C 中的函式，則在編譯階段 A 會相依於 B，B 會相依於 C，如圖 4-1 所示。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-132">That is, if module A calls a function in module B, which calls a function in module C, then at compile time A will depend on B which will depend on C, as shown in Figure 4-1.</span></span>

![](./media/image4-1.png)

<span data-ttu-id="cb0c0-133">**圖 4-1.**</span><span class="sxs-lookup"><span data-stu-id="cb0c0-133">**Figure 4-1.**</span></span> <span data-ttu-id="cb0c0-134">直接相依性圖形。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-134">Direct dependency graph.</span></span>

<span data-ttu-id="cb0c0-135">套用相依性反轉原則會允許 A 呼叫由 B 實作之抽象的方法，使得 A 能夠在執行階段呼叫 B，但 B 在編譯階段會相依於由 A 控制的介面 (因此「反轉」一般的編譯階段相依性)。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-135">Applying the dependency inversion principle allows A to call methods on an abstraction that B implements, making it possible for A to call B at runtime, but for B to depend on an interface controlled by A at compile time (thus, *inverting* the typical compile-time dependency).</span></span> <span data-ttu-id="cb0c0-136">在執行階段，程式執行流程維持不變，但是介面的引進表示可以輕鬆地插入這些介面的不同實作。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-136">At run time, the flow of program execution remains unchanged, but the introduction of interfaces means that different implementations of these interfaces can easily be plugged in.</span></span>

![](./media/image4-2.png)

<span data-ttu-id="cb0c0-137">**圖 4-2.**</span><span class="sxs-lookup"><span data-stu-id="cb0c0-137">**Figure 4-2.**</span></span> <span data-ttu-id="cb0c0-138">反轉相依性圖形。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-138">Inverted dependency graph.</span></span>

<span data-ttu-id="cb0c0-139">**相依性反轉**是建置鬆散結合應用程式的重要部分，因為可以撰寫實作詳細資料以相依於和實作較高的抽象層級，而不是利用其他方式。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-139">**Dependency inversion** is a key part of building loosely-coupled applications, since implementation details can be written to depend on and implement higher level abstractions, rather than the other way around.</span></span> <span data-ttu-id="cb0c0-140">因此，所產生的應用程式會比較可測試、模組化且可維護。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-140">The resulting applications are more testable, modular, and maintainable as a result.</span></span> <span data-ttu-id="cb0c0-141">遵循相依性反轉準則，即可達成「相依性插入」。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-141">The practice of *dependency injection* is made possible by following the dependency inversion principle.</span></span>

### <a name="explicit-dependencies"></a><span data-ttu-id="cb0c0-142">明確相依性</span><span class="sxs-lookup"><span data-stu-id="cb0c0-142">Explicit Dependencies</span></span>

<span data-ttu-id="cb0c0-143">**方法和類別應該明確需要正常運作所需的任何共同作業物件。**</span><span class="sxs-lookup"><span data-stu-id="cb0c0-143">**Methods and classes should explicitly require any collaborating objects they need in order to function correctly.**</span></span> <span data-ttu-id="cb0c0-144">類別建構函式會提供一個機會，讓類別能識別它們處於有效狀態並正常運作所需的項目。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-144">Class constructors provide an opportunity for classes to identify the things they need in order to be in a valid state and to function properly.</span></span> <span data-ttu-id="cb0c0-145">如果您定義的類別，可以建構和呼叫，但只有在特定全域或基礎結構元件已就緒時才能正常運作，那麼這些類別對其用戶端便「不誠實」。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-145">If you define classes that can be constructed and called, but which will only function properly if certain global or infrastructure components are in place, these classes are being *dishonest* with their clients.</span></span> <span data-ttu-id="cb0c0-146">建構函式合約告訴用戶端它只需要指定的項目 (如果類別只使用預設建構函式則可能沒有任何項目)，但在執行階段變成物件確實需要其他項目。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-146">The constructor contract is telling the client that it only needs the things specified (possibly nothing if the class is just using a default constructor), but then at runtime it turns out the object really did need something else.</span></span>

<span data-ttu-id="cb0c0-147">藉由遵循明確的相依性原則，您的類別和方法對其用戶端便會誠實告知他們需要要什麼才能運作。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-147">By following the explicit dependencies principle, your classes and methods are being honest with their clients about what they need in order to function.</span></span> <span data-ttu-id="cb0c0-148">這樣讓您的程式碼可以更加自我記錄，且讓程式碼合約更加易懂易記，因為使用者會信任，只要他們以方法或建構函式參數的形式提供所需的項目，他們正在使用的物件便會在執行階段有正確的行為。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-148">This makes your code more self-documenting and your coding contracts more user-friendly, since users will come to trust that as long as they provide what's required in the form of method or constructor parameters, the objects they're working with will behave correctly at runtime.</span></span>

### <a name="single-responsibility"></a><span data-ttu-id="cb0c0-149">單一責任</span><span class="sxs-lookup"><span data-stu-id="cb0c0-149">Single Responsibility</span></span>

<span data-ttu-id="cb0c0-150">單一責任原則適用於物件導向設計，但也可視為類似關注點分離的架構原則。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-150">The single responsibility principle applies to object-oriented design, but can also be considered as an architectural principle similar to separation of concerns.</span></span> <span data-ttu-id="cb0c0-151">它指出物件應該只有一項責任，而且應該只有一個變更的原因。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-151">It states that objects should have only one responsibility and that they should have only one reason to change.</span></span> <span data-ttu-id="cb0c0-152">具體而言，物件唯一應該變更的情況是，它執行它的一項責任的方式必須更新時。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-152">Specifically, the only situation in which the object should change is if the manner in which it performs its one responsibility must be updated.</span></span> <span data-ttu-id="cb0c0-153">遵循此原則有助於產生更鬆散結合且模組化的系統，因為許多種新行為可以實作為新的類別，而不是新增額外的責任給現有類別。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-153">Following this principle helps to produce more loosely-coupled and modular systems, since many kinds of new behavior can be implemented as new classes, rather than by adding additional responsibility to existing classes.</span></span> <span data-ttu-id="cb0c0-154">新增類別一比變更現有類別安全，因為還沒有程式碼相依於新的類別。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-154">Adding new classes is always safer than changing existing classes, since no code yet depends on the new classes.</span></span>

<span data-ttu-id="cb0c0-155">在整合應用程式中，我們可以在高層級套用單一責任原則至應用程式中的層級。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-155">In a monolithic application, we can apply the single responsibility principle at a high level to the layers in the application.</span></span> <span data-ttu-id="cb0c0-156">簡報責任應保留在 UI 專案，而資料存取責任則應保留在基礎結構專案中。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-156">Presentation responsibility should remain in the UI project, while data access responsibility should be kept within an infrastructure project.</span></span> <span data-ttu-id="cb0c0-157">商務邏輯應該保留在應用程式核心專案，在這裡它可以輕鬆地測試，且可以獨立於其他責任之外地持續改進。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-157">Business logic should be kept in the application core project, where it can be easily tested and can evolve independently from other responsibilities.</span></span>

<span data-ttu-id="cb0c0-158">當此原則套用至應用程式架構，並帶到其邏輯端點時，便會得到微服務。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-158">When this principle is applied to application architecture, and taken to its logical endpoint, you get microservices.</span></span> <span data-ttu-id="cb0c0-159">指定的微服務應該具有單一責任。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-159">A given microservice should have a single responsibility.</span></span> <span data-ttu-id="cb0c0-160">如果您需要擴充系統的行為，通常新增其他微服務會比較好，而不要新增責任至現有的微服務。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-160">If you need to extend the behavior of a system, it's usually better to do it by adding additional microservices, rather than by adding responsibility to an existing one.</span></span>

[<span data-ttu-id="cb0c0-161">深入了解微服務架構</span><span class="sxs-lookup"><span data-stu-id="cb0c0-161">Learn more about microservices architecture</span></span>](http://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a><span data-ttu-id="cb0c0-162">不重複原則 (DRY)</span><span class="sxs-lookup"><span data-stu-id="cb0c0-162">Don't Repeat Yourself (DRY)</span></span>

<span data-ttu-id="cb0c0-163">應用程式應避免在多個位置指定與特定概念相關的行為，因為這是常見的錯誤來源。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-163">The application should avoid specifying behavior related to a particular concept in multiple places as this is a frequent source of errors.</span></span> <span data-ttu-id="cb0c0-164">在某個時間點，需求變更將需要變更此行為，而行為的至少一個執行個體無法更新的可能性，會導致系統的行為不一致。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-164">At some point, a change in requirements will require changing this behavior and the likelihood that at least one instance of the behavior will fail to be updated will result in inconsistent behavior of the system.</span></span>

<span data-ttu-id="cb0c0-165">請不要複製邏輯，而是要將它封裝在程式設計建構中。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-165">Rather than duplicating logic, encapsulate it in a programming construct.</span></span> <span data-ttu-id="cb0c0-166">讓此建構成為此行為的單一授權，而且讓應用程式中需要這個行為的任何其他部分都使用新建構。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-166">Make this construct the single authority over this behavior, and have any other part of the application that requires this behavior use the new construct.</span></span>

> [!NOTE]
> <span data-ttu-id="cb0c0-167">避免將湊巧重複的行為繫結在一起。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-167">Avoid binding together behavior that is only coincidentally repetitive.</span></span> <span data-ttu-id="cb0c0-168">例如，只是兩個不同的常數具有相同的值，並不表示您應該只有一個常數，如果在概念上它們是指不同項目的話。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-168">For example, just because two different constants both have the same value, that doesn't mean you should have only one constant, if conceptually they're referring to different things.</span></span>

### <a name="persistence-ignorance"></a><span data-ttu-id="cb0c0-169">持續性無知</span><span class="sxs-lookup"><span data-stu-id="cb0c0-169">Persistence Ignorance</span></span>

<span data-ttu-id="cb0c0-170">**續性無知** (PI) 指的是需要持續的，但其程式碼不會受到持續性技術選項影響的類型。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-170">**Persistence ignorance** (PI) refers to types that need to be persisted, but whose code is unaffected by the choice of persistence technology.</span></span> <span data-ttu-id="cb0c0-171">這類的類型在 .NET 中有時稱為純舊 CLR 物件 (POCO)，因為它們不需要繼承特定的基底類別或實作特定介面。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-171">Such types in .NET are sometimes referred to as Plain Old CLR Objects (POCOs), because they do not need to inherit from a particular base class or implement a particular interface.</span></span> <span data-ttu-id="cb0c0-172">持續性無知的價值在於它允許以多種方式保存相同的商務模型，為應用程式提供額外的彈性。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-172">Persistence ignorance is valuable because it allows the same business model to be persisted in multiple ways, offering additional flexibility to the application.</span></span> <span data-ttu-id="cb0c0-173">持續性選項可能會隨著時間變更，從一種資料庫技術變為另一種技術，或是除了應用程式一開始的選項之外，可能還需要其他形式的持續性 (例如，除了關聯式資料庫之外，還使用 Redis 快取或 Azure DocumentDb)。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-173">Persistence choices might change over time, from one database technology to another, or additional forms of persistence might be required in addition to whatever the application started with (for example, using a Redis cache or Azure DocumentDb in addition to a relational database).</span></span>

<span data-ttu-id="cb0c0-174">違反這個原則的一些範例包括：</span><span class="sxs-lookup"><span data-stu-id="cb0c0-174">Some examples of violations of this principle include:</span></span>

-   <span data-ttu-id="cb0c0-175">必要的基底類別</span><span class="sxs-lookup"><span data-stu-id="cb0c0-175">A required base class</span></span>

-   <span data-ttu-id="cb0c0-176">必要的介面實作</span><span class="sxs-lookup"><span data-stu-id="cb0c0-176">A required interface implementation</span></span>

-   <span data-ttu-id="cb0c0-177">負責自行儲存的類別 (例如使用中的記錄模式)</span><span class="sxs-lookup"><span data-stu-id="cb0c0-177">Classes responsible for saving themselves (such as the Active Record pattern)</span></span>

-   <span data-ttu-id="cb0c0-178">必要的預設建構函式</span><span class="sxs-lookup"><span data-stu-id="cb0c0-178">Required default constructor</span></span>

-   <span data-ttu-id="cb0c0-179">需要虛擬關鍵字的屬性</span><span class="sxs-lookup"><span data-stu-id="cb0c0-179">Properties requiring virtual keyword</span></span>

-   <span data-ttu-id="cb0c0-180">持續性特定的必要屬性</span><span class="sxs-lookup"><span data-stu-id="cb0c0-180">Persistence-specific required attributes</span></span>

<span data-ttu-id="cb0c0-181">類別有任何上述功能或行為的要求，會為要持續保存的類型與持續性技術選擇之間新增結合，使得更難以在未來採用新的資料存取策略。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-181">The requirement that classes have any of the above features or behaviors adds coupling between the types to be persisted and the choice of persistence technology, making it more difficult to adopt new data access strategies in the future.</span></span>

### <a name="bounded-contexts"></a><span data-ttu-id="cb0c0-182">繫結內容</span><span class="sxs-lookup"><span data-stu-id="cb0c0-182">Bounded Contexts</span></span>

<span data-ttu-id="cb0c0-183">**繫結內容**是 Domain-Driven 設計的中心模式。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-183">**Bounded contexts** are a central pattern in Domain-Driven Design.</span></span> <span data-ttu-id="cb0c0-184">它們藉由將大型應用程式或組織的複雜性分成不同的概念模組，提供處理複雜性的方法。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-184">They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules.</span></span> <span data-ttu-id="cb0c0-185">每個概念模組會代表與其他內容不同的內容 (因此而繫結)，並可以獨立持續改進。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-185">Each conceptual module then represents a context which is separated from other contexts (hence, bounded), and can evolve independently.</span></span> <span data-ttu-id="cb0c0-186">每個繫結內容在理想情況下應該能自由選擇自己的概念名稱，而且應該對它自己的持續性存放區具有獨佔存取權。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-186">Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store.</span></span>

<span data-ttu-id="cb0c0-187">至少，個別 Web 應用程式應該致力於成為自己的繫結內容，並且具有自己商務模型的持續性存放區，而不與其他應用程式共用一個資料庫。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-187">At a minimum, individual web applications should strive to be their own bounded context, with their own persistence store for their business model, rather than sharing a database with other applications.</span></span> <span data-ttu-id="cb0c0-188">繫結內容之間的通訊會透過程式設計介面進行，而不是透過共用的資料庫，這樣可讓商務邏輯和事件發生以回應發生的變更。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-188">Communication between bounded contexts occurs through programmatic interfaces, rather than through a shared database, which allows for business logic and events to take place in response to changes that take place.</span></span> <span data-ttu-id="cb0c0-189">繫結內容與微服務密切對應，而微服務在理想的情況下也實作為自己的個別繫結內容。</span><span class="sxs-lookup"><span data-stu-id="cb0c0-189">Bounded contexts map closely to microservices, which also are ideally implemented as their own individual bounded contexts.</span></span>

> ### <a name="references--modern-web-applications"></a><span data-ttu-id="cb0c0-190">參考 – 現代化 Web 應用程式</span><span class="sxs-lookup"><span data-stu-id="cb0c0-190">References – Modern Web Applications</span></span>
> - <span data-ttu-id="cb0c0-191">**關注點分離**</span><span class="sxs-lookup"><span data-stu-id="cb0c0-191">**Separation of Concerns**</span></span>  
> <span data-ttu-id="cb0c0-192"><http://deviq.com/separation-of-concerns/></span><span class="sxs-lookup"><span data-stu-id="cb0c0-192"><http://deviq.com/separation-of-concerns/></span></span>
> - <span data-ttu-id="cb0c0-193">**封裝** <http://deviq.com/encapsulation/></span><span class="sxs-lookup"><span data-stu-id="cb0c0-193">**Encapsulation** <http://deviq.com/encapsulation/></span></span>
> - <span data-ttu-id="cb0c0-194">**相依性反轉準則**</span><span class="sxs-lookup"><span data-stu-id="cb0c0-194">**Dependency Inversion Principle**</span></span>  
> <span data-ttu-id="cb0c0-195"><http://deviq.com/dependency-inversion-principle/></span><span class="sxs-lookup"><span data-stu-id="cb0c0-195"><http://deviq.com/dependency-inversion-principle/></span></span>
> - <span data-ttu-id="cb0c0-196">**明確相依性準則**</span><span class="sxs-lookup"><span data-stu-id="cb0c0-196">**Explicit Dependencies Principle**</span></span>  
> <span data-ttu-id="cb0c0-197"><http://deviq.com/explicit-dependencies-principle/></span><span class="sxs-lookup"><span data-stu-id="cb0c0-197"><http://deviq.com/explicit-dependencies-principle/></span></span>
> - <span data-ttu-id="cb0c0-198">**不重複原則**</span><span class="sxs-lookup"><span data-stu-id="cb0c0-198">**Don't Repeat Yourself**</span></span>  
> <span data-ttu-id="cb0c0-199"><http://deviq.com/don-t-repeat-yourself/></span><span class="sxs-lookup"><span data-stu-id="cb0c0-199"><http://deviq.com/don-t-repeat-yourself/></span></span>
> - <span data-ttu-id="cb0c0-200">**持續性無知**</span><span class="sxs-lookup"><span data-stu-id="cb0c0-200">**Persistence Ignorance**</span></span>  
> <span data-ttu-id="cb0c0-201"><http://deviq.com/persistence-ignorance/></span><span class="sxs-lookup"><span data-stu-id="cb0c0-201"><http://deviq.com/persistence-ignorance/></span></span>
> - <span data-ttu-id="cb0c0-202">**繫結內容**</span><span class="sxs-lookup"><span data-stu-id="cb0c0-202">**Bounded Context**</span></span>  
> <span data-ttu-id="cb0c0-203"><https://martinfowler.com/bliki/BoundedContext.html></span><span class="sxs-lookup"><span data-stu-id="cb0c0-203"><https://martinfowler.com/bliki/BoundedContext.html></span></span>

> [!div class="step-by-step"]
<span data-ttu-id="cb0c0-204">[上一頁] (choose-between-traditional-web-and-single-page-apps.md) [下一頁] (common-web-application-architectures.md)</span><span class="sxs-lookup"><span data-stu-id="cb0c0-204">[Previous] (choose-between-traditional-web-and-single-page-apps.md) [Next] (common-web-application-architectures.md)</span></span>
