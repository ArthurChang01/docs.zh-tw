---
title: "架構原則"
description: "使用 ASP.NET Core 和 Azure 的現代化 Web 應用程式架構設計人員 |架構原則"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: 20524c8aa0e64fd40a1a4a6811063557f74074d2
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/21/2017
---
#<a name="architectural-principles"></a><span data-ttu-id="0430c-103">架構原則</span><span class="sxs-lookup"><span data-stu-id="0430c-103">Architectural Principles</span></span>

> <span data-ttu-id="0430c-104">「如果建築工人像工程師寫軟體那樣蓋房子，那第一隻飛來的啄木鳥就能毀掉人類文明。」</span><span class="sxs-lookup"><span data-stu-id="0430c-104">"If builders built buildings the way programmers wrote programs, then the first woodpecker that came along would destroy civilization."</span></span>  
> <span data-ttu-id="0430c-105">_\-Gerald Weinberg_</span><span class="sxs-lookup"><span data-stu-id="0430c-105">_\- Gerald Weinberg_</span></span>

## <a name="summary"></a><span data-ttu-id="0430c-106">總結</span><span class="sxs-lookup"><span data-stu-id="0430c-106">Summary</span></span>

<span data-ttu-id="0430c-107">您應該架構設計人員和設計軟體解決方案與可維護性記住。</span><span class="sxs-lookup"><span data-stu-id="0430c-107">You should architect and design software solutions with maintainability in mind.</span></span> <span data-ttu-id="0430c-108">本章節中所述的原則可協助引導您向將產生的全新、 可維護應用程式的架構決策。</span><span class="sxs-lookup"><span data-stu-id="0430c-108">The principles outlined in this section can help guide you toward architectural decisions that will result in clean, maintainable applications.</span></span> <span data-ttu-id="0430c-109">一般而言，這些原則會引導您向建置出不同的元件未緊密結合的應用程式其他部分，但而不是透過明確的介面進行通訊的應用程式] 或 [郵件系統。</span><span class="sxs-lookup"><span data-stu-id="0430c-109">Generally, these principles will guide you toward building applications out of discrete components that are not tightly coupled to other parts of your application, but rather communicate through explicit interfaces or messaging systems.</span></span>

## <a name="common-design-principles"></a><span data-ttu-id="0430c-110">常見的設計原則</span><span class="sxs-lookup"><span data-stu-id="0430c-110">Common design principles</span></span>

### <a name="separation-of-concerns"></a><span data-ttu-id="0430c-111">重要性分離</span><span class="sxs-lookup"><span data-stu-id="0430c-111">Separation of Concerns</span></span>

<span data-ttu-id="0430c-112">開發時的指導原則是**分離的考量**。</span><span class="sxs-lookup"><span data-stu-id="0430c-112">A guiding principle when developing is **Separation of Concerns**.</span></span> <span data-ttu-id="0430c-113">這個原則判斷提示的軟體，則應以根據它所執行的工作種類。</span><span class="sxs-lookup"><span data-stu-id="0430c-113">This principle asserts that software should be separated based on the kinds of work it performs.</span></span> <span data-ttu-id="0430c-114">比方說，假設應用程式中包含邏輯來識別值得注意的項目可以顯示給使用者，而且其中格式化此類項目，使其更值得注意的特定方式。</span><span class="sxs-lookup"><span data-stu-id="0430c-114">For instance, consider an application that includes logic for identifying noteworthy items to display to the user, and which formats such items in a particular way to make them more noticeable.</span></span> <span data-ttu-id="0430c-115">選擇要格式化的項目應該有所區隔負責格式項目，因為這些個別考量只正巧彼此相關的行為的責任的行為。</span><span class="sxs-lookup"><span data-stu-id="0430c-115">The behavior responsible for choosing which items to format should be kept separate from the behavior responsible for formatting the items, since these are separate concerns that are only coincidentally related to one another.</span></span>

<span data-ttu-id="0430c-116">在架構上，您可以以邏輯方式分隔從基礎結構和使用者介面邏輯核心商務行為遵循這個原則建立應用程式。</span><span class="sxs-lookup"><span data-stu-id="0430c-116">Architecturally, applications can be logically built to follow this principle by separating core business behavior from infrastructure and user interface logic.</span></span> <span data-ttu-id="0430c-117">在理想情況下，商務規則和邏輯應該位於個別的專案，不應依賴其他應用程式中的專案。</span><span class="sxs-lookup"><span data-stu-id="0430c-117">Ideally, business rules and logic should reside in a separate project, which should not depend on other projects in the application.</span></span> <span data-ttu-id="0430c-118">這有助於確保商務模型很容易測試並沒有緊密結合低層級的實作詳細資料就能持續改進。</span><span class="sxs-lookup"><span data-stu-id="0430c-118">This helps ensure that the business model is easy to test and can evolve without being tightly coupled to low-level implementation details.</span></span> <span data-ttu-id="0430c-119">重要性分離是使用應用程式架構中的圖層的索引鍵的考量。</span><span class="sxs-lookup"><span data-stu-id="0430c-119">Separation of concerns is a key consideration behind the use of layers in application architectures.</span></span>

### <a name="encapsulation"></a><span data-ttu-id="0430c-120">封裝</span><span class="sxs-lookup"><span data-stu-id="0430c-120">Encapsulation</span></span>

<span data-ttu-id="0430c-121">應用程式的不同部分應該使用**封裝**它們的應用程式其他部分隔離。</span><span class="sxs-lookup"><span data-stu-id="0430c-121">Different parts of an application should use **encapsulation** to insulate them from other parts of the application.</span></span> <span data-ttu-id="0430c-122">應用程式元件和層級應該能夠調整的內部實作，而不會中斷其共同作業者，只要不違反外部的合約。</span><span class="sxs-lookup"><span data-stu-id="0430c-122">Application components and layers should be able to adjust their internal implementation without breaking their collaborators as long as external contracts are not violated.</span></span> <span data-ttu-id="0430c-123">正確使用的封裝 （encapsulation） 可協助達到鬆散偶合和應用程式設計中的模組化，因為物件與封裝可以取代為替代的實作，只要維持相同的介面。</span><span class="sxs-lookup"><span data-stu-id="0430c-123">Proper use of encapsulation helps achieve loose coupling and modularity in application designs, since objects and packages can be replaced with alternative implementations so long as the same interface is maintained.</span></span>

<span data-ttu-id="0430c-124">在類別中，封裝達成外部類別的內部狀態的存取限制。</span><span class="sxs-lookup"><span data-stu-id="0430c-124">In classes, encapsulation is achieved by limiting outside access to the class's internal state.</span></span> <span data-ttu-id="0430c-125">如果外部執行者想要管理物件的狀態，則應如此做透過妥善定義的函式 （或屬性 setter），而不是直接存取物件的私用狀態。</span><span class="sxs-lookup"><span data-stu-id="0430c-125">If an outside actor wants to manipulate the state of the object, it should do so through a well-defined function (or property setter), rather than having direct access to the private state of the object.</span></span> <span data-ttu-id="0430c-126">同樣地，應用程式元件和應用程式本身應該公開妥善定義的介面，它們共同作業者來使用，而非讓它們直接進行修改的狀態。</span><span class="sxs-lookup"><span data-stu-id="0430c-126">Likewise, application components and applications themselves should expose well-defined interfaces for their collaborators to use, rather than allowing their state to be modified directly.</span></span> <span data-ttu-id="0430c-127">這會釋出應用程式的內部設計隨著時間而不用，這樣做，將會中斷共同作業者，只要會維護的公用合約。</span><span class="sxs-lookup"><span data-stu-id="0430c-127">This frees the application's internal design to evolve over time without worrying that doing so will break collaborators, so long as the public contracts are maintained.</span></span>

### <a name="dependency-inversion"></a><span data-ttu-id="0430c-128">相依性反向</span><span class="sxs-lookup"><span data-stu-id="0430c-128">Dependency Inversion</span></span>

<span data-ttu-id="0430c-129">在應用程式內的相依性的方向應該是抽象，不實作詳細資料的方向。</span><span class="sxs-lookup"><span data-stu-id="0430c-129">The direction of dependency within the application should be in the direction of abstraction, not implementation details.</span></span> <span data-ttu-id="0430c-130">大部分的應用程式會寫入使執行階段執行的方向流程編譯時間相依性。</span><span class="sxs-lookup"><span data-stu-id="0430c-130">Most applications are written such that compile-time dependency flows in the direction of runtime execution.</span></span> <span data-ttu-id="0430c-131">這會產生直接相依性圖形。</span><span class="sxs-lookup"><span data-stu-id="0430c-131">This produces a direct dependency graph.</span></span> <span data-ttu-id="0430c-132">也就是說，如果模組 A 呼叫 B，模組中的函式呼叫的函式在模組中 C，則在編譯時間的取決於所示圖 4-1，會隨著 C、 B。</span><span class="sxs-lookup"><span data-stu-id="0430c-132">That is, if module A calls a function in module B, which calls a function in module C, then at compile time A will depend on B which will depend on C, as shown in Figure 4-1.</span></span>

![](./media/image4-1.png)

<span data-ttu-id="0430c-133">**圖 4-1。**</span><span class="sxs-lookup"><span data-stu-id="0430c-133">**Figure 4-1.**</span></span> <span data-ttu-id="0430c-134">直接的相依性圖形。</span><span class="sxs-lookup"><span data-stu-id="0430c-134">Direct dependency graph.</span></span>

<span data-ttu-id="0430c-135">套用相依性反向原則允許 A 呼叫 B，讓其能夠 a 呼叫 B，在執行階段，會實作抽象方法但 b 相依於介面由控制的編譯時期 (因此，*反轉*一般編譯時間相依性）。</span><span class="sxs-lookup"><span data-stu-id="0430c-135">Applying the dependency inversion principle allows A to call methods on an abstraction that B implements, making it possible for A to call B at runtime, but for B to depend on an interface controlled by A at compile time (thus, *inverting* the typical compile-time dependency).</span></span> <span data-ttu-id="0430c-136">在執行階段，控制程式執行流程維持不變，但是介面簡介表示不同的實作這些介面可以輕鬆地裝載。</span><span class="sxs-lookup"><span data-stu-id="0430c-136">At run time, the flow of program execution remains unchanged, but the introduction of interfaces means that different implementations of these interfaces can easily be plugged in.</span></span>

![](./media/image4-2.png)

<span data-ttu-id="0430c-137">**圖 4-2。**</span><span class="sxs-lookup"><span data-stu-id="0430c-137">**Figure 4-2.**</span></span> <span data-ttu-id="0430c-138">反向的相依性圖形。</span><span class="sxs-lookup"><span data-stu-id="0430c-138">Inverted dependency graph.</span></span>

<span data-ttu-id="0430c-139">**相依性反向**是建置鬆散偶合的應用程式，因為實作詳細資料可以寫入而定，實作較高的層級抽象概念，而不是利用其他方式的重要部分。</span><span class="sxs-lookup"><span data-stu-id="0430c-139">**Dependency inversion** is a key part of building loosely-coupled applications, since implementation details can be written to depend on and implement higher level abstractions, rather than the other way around.</span></span> <span data-ttu-id="0430c-140">產生的應用程式會因此是可測試、 模組化，和可維護性。</span><span class="sxs-lookup"><span data-stu-id="0430c-140">The resulting applications are more testable, modular, and maintainable as a result.</span></span> <span data-ttu-id="0430c-141">一種作法*相依性插入*即可進行反轉遵循相依性。</span><span class="sxs-lookup"><span data-stu-id="0430c-141">The practice of *dependency injection* is made possible by following the dependency inversion principle.</span></span>

### <a name="explicit-dependencies"></a><span data-ttu-id="0430c-142">明確的相依性</span><span class="sxs-lookup"><span data-stu-id="0430c-142">Explicit Dependencies</span></span>

<span data-ttu-id="0430c-143">**方法和類別應該明確需要共同作業正常運作所需的任何物件。**</span><span class="sxs-lookup"><span data-stu-id="0430c-143">**Methods and classes should explicitly require any collaborating objects they need in order to function correctly.**</span></span> <span data-ttu-id="0430c-144">類別建構函式會提供一個機會，以識別它們需要為了處於有效狀態，並正常運作的項目類別。</span><span class="sxs-lookup"><span data-stu-id="0430c-144">Class constructors provide an opportunity for classes to identify the things they need in order to be in a valid state and to function properly.</span></span> <span data-ttu-id="0430c-145">如果您定義的類別，可以建構和呼叫，但其中只有正常運作特定的全域或基礎結構元件已就緒時，這些類別正在*誠實*其用戶端。</span><span class="sxs-lookup"><span data-stu-id="0430c-145">If you define classes that can be constructed and called, but which will only function properly if certain global or infrastructure components are in place, these classes are being *dishonest* with their clients.</span></span> <span data-ttu-id="0430c-146">建構函式合約告訴它只需要的項目指定 （可能是沒有任何類別只會使用預設建構函式），但接著在結果物件的執行階段的用戶端真的需要其他項目。</span><span class="sxs-lookup"><span data-stu-id="0430c-146">The constructor contract is telling the client that it only needs the things specified (possibly nothing if the class is just using a default constructor), but then at runtime it turns out the object really did need something else.</span></span>

<span data-ttu-id="0430c-147">遵循明確的相依性原則，您的類別和方法正在誠實與他們的用戶端需它們需要才能運作。</span><span class="sxs-lookup"><span data-stu-id="0430c-147">By following the explicit dependencies principle, your classes and methods are being honest with their clients about what they need in order to function.</span></span> <span data-ttu-id="0430c-148">這樣多個可以自我記錄您的程式碼和程式碼合約更加易懂易記，因為使用者會具備信任，只要它們提供所需格式的方法或建構函式參數，他們所處理之物件的行為正確地在執行階段。</span><span class="sxs-lookup"><span data-stu-id="0430c-148">This makes your code more self-documenting and your coding contracts more user-friendly, since users will come to trust that as long as they provide what's required in the form of method or constructor parameters, the objects they're working with will behave correctly at runtime.</span></span>

### <a name="single-responsibility"></a><span data-ttu-id="0430c-149">單一的責任</span><span class="sxs-lookup"><span data-stu-id="0430c-149">Single Responsibility</span></span>

<span data-ttu-id="0430c-150">物件導向設計，適用於單一責任原則，但也可視為類似的重要性分離架構原則。</span><span class="sxs-lookup"><span data-stu-id="0430c-150">The single responsibility principle applies to object-oriented design, but can also be considered as an architectural principle similar to separation of concerns.</span></span> <span data-ttu-id="0430c-151">指出物件應該只有一個責任，而且您應該有只有一個變更的原因。</span><span class="sxs-lookup"><span data-stu-id="0430c-151">It states that objects should have only one responsibility and that they should have only one reason to change.</span></span> <span data-ttu-id="0430c-152">具體而言，唯一物件應該變更的情況是如果必須更新它會執行其一個責任的方式。</span><span class="sxs-lookup"><span data-stu-id="0430c-152">Specifically, the only situation in which the object should change is if the manner in which it performs its one responsibility must be updated.</span></span> <span data-ttu-id="0430c-153">此原則可協助產生更鬆散偶合而模組化系統，因為許多種新行為可以實作做為新的類別，而不是新增至現有類別的額外責任。</span><span class="sxs-lookup"><span data-stu-id="0430c-153">Following this principle helps to produce more loosely-coupled and modular systems, since many kinds of new behavior can be implemented as new classes, rather than by adding additional responsibility to existing classes.</span></span> <span data-ttu-id="0430c-154">加入新類別永遠是比變更現有的類別，因為沒有程式碼更安全，但相依於新的類別。</span><span class="sxs-lookup"><span data-stu-id="0430c-154">Adding new classes is always safer than changing existing classes, since no code yet depends on the new classes.</span></span>

<span data-ttu-id="0430c-155">在整合應用程式中，我們可以套用在高層級的單一責任原則至應用程式中的圖層。</span><span class="sxs-lookup"><span data-stu-id="0430c-155">In a monolithic application, we can apply the single responsibility principle at a high level to the layers in the application.</span></span> <span data-ttu-id="0430c-156">簡報責任應保留在 UI 專案，資料存取時責任應保留在基礎結構專案中。</span><span class="sxs-lookup"><span data-stu-id="0430c-156">Presentation responsibility should remain in the UI project, while data access responsibility should be kept within an infrastructure project.</span></span> <span data-ttu-id="0430c-157">商務邏輯應該放在應用程式核心專案，它可以輕鬆地測試和可以從其他責任的獨立進行。</span><span class="sxs-lookup"><span data-stu-id="0430c-157">Business logic should be kept in the application core project, where it can be easily tested and can evolve independently from other responsibilities.</span></span>

<span data-ttu-id="0430c-158">當此原則會套用至應用程式架構，並採取其邏輯的端點時，您會取得 microservices。</span><span class="sxs-lookup"><span data-stu-id="0430c-158">When this principle is applied to application architecture, and taken to its logical endpoint, you get microservices.</span></span> <span data-ttu-id="0430c-159">給定的微服務應該有單一的責任。</span><span class="sxs-lookup"><span data-stu-id="0430c-159">A given microservice should have a single responsibility.</span></span> <span data-ttu-id="0430c-160">如果您需要擴充系統的行為，它通常會比較好這樣做，藉由新增其他 microservices，而不是新增至現有的責任。</span><span class="sxs-lookup"><span data-stu-id="0430c-160">If you need to extend the behavior of a system, it's usually better to do it by adding additional microservices, rather than by adding responsibility to an existing one.</span></span>

[<span data-ttu-id="0430c-161">深入了解 microservices 架構</span><span class="sxs-lookup"><span data-stu-id="0430c-161">Learn more about microservices architecture</span></span>](http://aka.ms/MicroservicesEbook)

### <a name="dont-repeat-yourself-dry"></a><span data-ttu-id="0430c-162">不要重複自行 （乾）</span><span class="sxs-lookup"><span data-stu-id="0430c-162">Don't Repeat Yourself (DRY)</span></span>

<span data-ttu-id="0430c-163">應用程式應避免指定相關的多個位置的特定概念，因為這是常見的錯誤來源的行為。</span><span class="sxs-lookup"><span data-stu-id="0430c-163">The application should avoid specifying behavior related to a particular concept in multiple places as this is a frequent source of errors.</span></span> <span data-ttu-id="0430c-164">在某個時間點，在需求變更將需要變更此行為與可能性行為至少一個執行個體將會更新失敗會導致系統的不一致的行為。</span><span class="sxs-lookup"><span data-stu-id="0430c-164">At some point, a change in requirements will require changing this behavior and the likelihood that at least one instance of the behavior will fail to be updated will result in inconsistent behavior of the system.</span></span>

<span data-ttu-id="0430c-165">而不是複製邏輯，請將它封裝在程式設計建構。</span><span class="sxs-lookup"><span data-stu-id="0430c-165">Rather than duplicating logic, encapsulate it in a programming construct.</span></span> <span data-ttu-id="0430c-166">將此建構此行為，透過單一的授權單位，而且有應用程式需要這個行為使用新建構的任何其他部分。</span><span class="sxs-lookup"><span data-stu-id="0430c-166">Make this construct the single authority over this behavior, and have any other part of the application that requires this behavior use the new construct.</span></span>

> [!NOTE]
> <span data-ttu-id="0430c-167">避免繫結在一起才正巧重複的行為。</span><span class="sxs-lookup"><span data-stu-id="0430c-167">Avoid binding together behavior that is only coincidentally repetitive.</span></span> <span data-ttu-id="0430c-168">例如，只是兩個不同的常數這兩個具有相同的值，因為這不表示您應該只有一個常數，如果在概念上所指不同的項目。</span><span class="sxs-lookup"><span data-stu-id="0430c-168">For example, just because two different constants both have the same value, that doesn't mean you should have only one constant, if conceptually they're referring to different things.</span></span>

### <a name="persistence-ignorance"></a><span data-ttu-id="0430c-169">永續性無知之</span><span class="sxs-lookup"><span data-stu-id="0430c-169">Persistence Ignorance</span></span>

<span data-ttu-id="0430c-170">**永續性無知之**(PI) 指的是類型，需要保存，但是其程式碼不會受到持續性技術的選項。</span><span class="sxs-lookup"><span data-stu-id="0430c-170">**Persistence ignorance** (PI) refers to types that need to be persisted, but whose code is unaffected by the choice of persistence technology.</span></span> <span data-ttu-id="0430c-171">這種型別在.NET 中的有時稱為純舊 CLR 物件 (POCOs)，因為它們不需要特定的基底類別繼承或實作特定介面。</span><span class="sxs-lookup"><span data-stu-id="0430c-171">Such types in .NET are sometimes referred to as Plain Old CLR Objects (POCOs), because they do not need to inherit from a particular base class or implement a particular interface.</span></span> <span data-ttu-id="0430c-172">永續性無知之是有用的因為它可讓保存在多個方面，提供額外的彈性，應用程式的相同商務模型。</span><span class="sxs-lookup"><span data-stu-id="0430c-172">Persistence ignorance is valuable because it allows the same business model to be persisted in multiple ways, offering additional flexibility to the application.</span></span> <span data-ttu-id="0430c-173">持續性選項可能會隨著時間變更，到另一個資料庫技術或其他形式的持續性系統可能會要求除了與啟動任何應用程式 (例如，使用 Redis 快取或 Azure DocumentDb 除了關聯式資料庫）。</span><span class="sxs-lookup"><span data-stu-id="0430c-173">Persistence choices might change over time, from one database technology to another, or additional forms of persistence might be required in addition to whatever the application started with (for example, using a Redis cache or Azure DocumentDb in addition to a relational database).</span></span>

<span data-ttu-id="0430c-174">違反這個原則的一些範例包括：</span><span class="sxs-lookup"><span data-stu-id="0430c-174">Some examples of violations of this principle include:</span></span>

-   <span data-ttu-id="0430c-175">必要的基底類別</span><span class="sxs-lookup"><span data-stu-id="0430c-175">A required base class</span></span>

-   <span data-ttu-id="0430c-176">所需的介面實作</span><span class="sxs-lookup"><span data-stu-id="0430c-176">A required interface implementation</span></span>

-   <span data-ttu-id="0430c-177">類別負責儲存本身 （例如使用中的記錄模式）</span><span class="sxs-lookup"><span data-stu-id="0430c-177">Classes responsible for saving themselves (such as the Active Record pattern)</span></span>

-   <span data-ttu-id="0430c-178">必要的預設建構函式</span><span class="sxs-lookup"><span data-stu-id="0430c-178">Required default constructor</span></span>

-   <span data-ttu-id="0430c-179">需要 virtual 關鍵字的屬性</span><span class="sxs-lookup"><span data-stu-id="0430c-179">Properties requiring virtual keyword</span></span>

-   <span data-ttu-id="0430c-180">特定的持續性所需的屬性</span><span class="sxs-lookup"><span data-stu-id="0430c-180">Persistence-specific required attributes</span></span>

<span data-ttu-id="0430c-181">類別有任何上述功能或行為的需求加入要保存的類型和持續性技術，使其更難以將來採用新的資料存取策略的選項之間的結合。</span><span class="sxs-lookup"><span data-stu-id="0430c-181">The requirement that classes have any of the above features or behaviors adds coupling between the types to be persisted and the choice of persistence technology, making it more difficult to adopt new data access strategies in the future.</span></span>

### <a name="bounded-contexts"></a><span data-ttu-id="0430c-182">已繫結的內容</span><span class="sxs-lookup"><span data-stu-id="0430c-182">Bounded Contexts</span></span>

<span data-ttu-id="0430c-183">**繫結內容**是中央 Domain-Driven 設計模式。</span><span class="sxs-lookup"><span data-stu-id="0430c-183">**Bounded contexts** are a central pattern in Domain-Driven Design.</span></span> <span data-ttu-id="0430c-184">它們分成不同的概念模組提供一種處理大型應用程式或組織的複雜度。</span><span class="sxs-lookup"><span data-stu-id="0430c-184">They provide a way of tackling complexity in large applications or organizations by breaking it up into separate conceptual modules.</span></span> <span data-ttu-id="0430c-185">每個概念模組則表示可分開其他內容的內容 （因此，界限），並可以獨立進行。</span><span class="sxs-lookup"><span data-stu-id="0430c-185">Each conceptual module then represents a context which is separated from other contexts (hence, bounded), and can evolve independently.</span></span> <span data-ttu-id="0430c-186">每個繫結的內容應在理想情況下自由選擇自己的概念，名稱，而且應該具有獨佔存取權它自己的持續性存放區。</span><span class="sxs-lookup"><span data-stu-id="0430c-186">Each bounded context should ideally be free to choose its own names for concepts within it, and should have exclusive access to its own persistence store.</span></span>

<span data-ttu-id="0430c-187">最少個別 web 應用程式應該致力於自己已繫結的內容中，使用自己的持續性存放區，其商務模型，而不是與其他應用程式共用一個資料庫。</span><span class="sxs-lookup"><span data-stu-id="0430c-187">At a minimum, individual web applications should strive to be their own bounded context, with their own persistence store for their business model, rather than sharing a database with other applications.</span></span> <span data-ttu-id="0430c-188">透過程式設計介面，而不是透過共用的資料庫，可讓商務邏輯，就會發生繫結的內容之間的通訊，事件才會將回應進行的變更。</span><span class="sxs-lookup"><span data-stu-id="0430c-188">Communication between bounded contexts occurs through programmatic interfaces, rather than through a shared database, which allows for business logic and events to take place in response to changes that take place.</span></span> <span data-ttu-id="0430c-189">與 historyinsert-spg 內容地圖密切 microservices，也理想的情況下實作為自己的個別繫結內容。</span><span class="sxs-lookup"><span data-stu-id="0430c-189">Bounded contexts map closely to microservices, which also are ideally implemented as their own individual bounded contexts.</span></span>

> ### <a name="references--modern-web-applications"></a><span data-ttu-id="0430c-190">參考 – 現代化 Web 應用程式</span><span class="sxs-lookup"><span data-stu-id="0430c-190">References – Modern Web Applications</span></span>
> - <span data-ttu-id="0430c-191">**重要性分離**</span><span class="sxs-lookup"><span data-stu-id="0430c-191">**Separation of Concerns**</span></span>  
> <span data-ttu-id="0430c-192"><http://deviq.com/separation-of-concerns/></span><span class="sxs-lookup"><span data-stu-id="0430c-192"><http://deviq.com/separation-of-concerns/></span></span>
> - <span data-ttu-id="0430c-193">**封裝** <http://deviq.com/encapsulation/></span><span class="sxs-lookup"><span data-stu-id="0430c-193">**Encapsulation** <http://deviq.com/encapsulation/></span></span>
> - <span data-ttu-id="0430c-194">**相依性反向原則**</span><span class="sxs-lookup"><span data-stu-id="0430c-194">**Dependency Inversion Principle**</span></span>  
> <span data-ttu-id="0430c-195"><http://deviq.com/dependency-inversion-principle/></span><span class="sxs-lookup"><span data-stu-id="0430c-195"><http://deviq.com/dependency-inversion-principle/></span></span>
> - <span data-ttu-id="0430c-196">**明確的相依性原則**</span><span class="sxs-lookup"><span data-stu-id="0430c-196">**Explicit Dependencies Principle**</span></span>  
> <span data-ttu-id="0430c-197"><http://deviq.com/explicit-dependencies-principle/></span><span class="sxs-lookup"><span data-stu-id="0430c-197"><http://deviq.com/explicit-dependencies-principle/></span></span>
> - <span data-ttu-id="0430c-198">**不要重複自行**</span><span class="sxs-lookup"><span data-stu-id="0430c-198">**Don't Repeat Yourself**</span></span>  
> <span data-ttu-id="0430c-199"><http://deviq.com/don-t-repeat-yourself/></span><span class="sxs-lookup"><span data-stu-id="0430c-199"><http://deviq.com/don-t-repeat-yourself/></span></span>
> - <span data-ttu-id="0430c-200">**永續性無知之**</span><span class="sxs-lookup"><span data-stu-id="0430c-200">**Persistence Ignorance**</span></span>  
> <span data-ttu-id="0430c-201"><http://deviq.com/persistence-ignorance/></span><span class="sxs-lookup"><span data-stu-id="0430c-201"><http://deviq.com/persistence-ignorance/></span></span>
> - <span data-ttu-id="0430c-202">**已繫結的內容**</span><span class="sxs-lookup"><span data-stu-id="0430c-202">**Bounded Context**</span></span>  
> <span data-ttu-id="0430c-203"><https://martinfowler.com/bliki/BoundedContext.html></span><span class="sxs-lookup"><span data-stu-id="0430c-203"><https://martinfowler.com/bliki/BoundedContext.html></span></span>

> [!div class="step-by-step"]
<span data-ttu-id="0430c-204">[上一個](choose-between-traditional-web-and-single-page-apps.md) [下一步] (常見的 web 層應用程式-architectures.md)</span><span class="sxs-lookup"><span data-stu-id="0430c-204">[Previous] (choose-between-traditional-web-and-single-page-apps.md) [Next] (common-web-application-architectures.md)</span></span>
