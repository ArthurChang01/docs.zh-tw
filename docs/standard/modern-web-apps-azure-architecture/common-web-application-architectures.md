---
title: "常見的 web 應用程式架構"
description: "使用 ASP.NET Core 和 Microsoft Azure 的現代化 web 應用程式架構設計人員 |常見的 web 應用程式架構"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.openlocfilehash: b6236cfab290211f930d6a1987075abeade4fd6d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/21/2017
---
#<a name="common-web-application-architectures"></a><span data-ttu-id="a4371-103">常見的 Web 應用程式架構</span><span class="sxs-lookup"><span data-stu-id="a4371-103">Common Web Application Architectures</span></span>

> <span data-ttu-id="a4371-104">「 如果您認為良好的架構是高度耗費資源，請再試一次不正確的架構。"</span><span class="sxs-lookup"><span data-stu-id="a4371-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="a4371-105">_-Brian Foote 和約瑟夫 Yoder_</span><span class="sxs-lookup"><span data-stu-id="a4371-105">_- Brian Foote and Joseph Yoder_</span></span>

## <a name="summary"></a><span data-ttu-id="a4371-106">總結</span><span class="sxs-lookup"><span data-stu-id="a4371-106">Summary</span></span>

<span data-ttu-id="a4371-107">大部分傳統的.NET 應用程式會部署為單一單位對應至可執行檔或執行單一的 IIS appdomain 內的單一 web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4371-107">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="a4371-108">這是最簡單的部署模型，而且很好的做許多內部與較小公用應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4371-108">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="a4371-109">不過，即使指定此單一部署單位，最重要的商務應用程式受益於一些邏輯分割到數個層級。</span><span class="sxs-lookup"><span data-stu-id="a4371-109">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="a4371-110">什麼是整合的應用程式？</span><span class="sxs-lookup"><span data-stu-id="a4371-110">What is a monolithic application?</span></span>

<span data-ttu-id="a4371-111">整合的應用程式是一種是完全獨立，根據其行為。</span><span class="sxs-lookup"><span data-stu-id="a4371-111">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="a4371-112">它可能會與過程中執行其作業時，其他服務或資料存放區互動，但它自己的處理序內執行的行為核心和整個應用程式通常會部署為單一單位。</span><span class="sxs-lookup"><span data-stu-id="a4371-112">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="a4371-113">如果這樣的應用程式需要水平縮放，通常會複製整個應用程式跨多個伺服器或虛擬機器。</span><span class="sxs-lookup"><span data-stu-id="a4371-113">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="a4371-114">全部的一個應用程式</span><span class="sxs-lookup"><span data-stu-id="a4371-114">All-in-One applications</span></span>

<span data-ttu-id="a4371-115">最小可能的應用程式架構的專案數目是其中一個。</span><span class="sxs-lookup"><span data-stu-id="a4371-115">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="a4371-116">以這種架構，應用程式的整個邏輯包含在單一專案，編譯成單一組件，並部署當做單一單位。</span><span class="sxs-lookup"><span data-stu-id="a4371-116">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="a4371-117">新 ASP.NET Core 專案時，是否建立 Visual Studio 中，或從命令列中，一開始為簡單的 「 全部合一"monolith。</span><span class="sxs-lookup"><span data-stu-id="a4371-117">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="a4371-118">它包含的所有應用程式，包括簡報、 商務和資料存取邏輯的行為。</span><span class="sxs-lookup"><span data-stu-id="a4371-118">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="a4371-119">圖 5-1 顯示單一專案的應用程式的檔案結構。</span><span class="sxs-lookup"><span data-stu-id="a4371-119">Figure 5-1 shows the file structure of a single-project app.</span></span>

<span data-ttu-id="a4371-120">**圖 5-1。**</span><span class="sxs-lookup"><span data-stu-id="a4371-120">**Figure 5-1.**</span></span> <span data-ttu-id="a4371-121">在單一專案中 ASP.NET Core 應用程式</span><span class="sxs-lookup"><span data-stu-id="a4371-121">A single project ASP.NET Core app</span></span>

![](./media/image5-1.png)

<span data-ttu-id="a4371-122">在單一專案案例中，重要性分離，達成透過資料夾使用。</span><span class="sxs-lookup"><span data-stu-id="a4371-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="a4371-123">預設範本包含個別資料夾的模型、 檢視和控制器，MVC 模式責任，以及其他資料夾資料和服務。</span><span class="sxs-lookup"><span data-stu-id="a4371-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="a4371-124">在這種安排，應該限制 [檢視] 資料夾中，最大的簡報詳細資料和實作詳細資料的存取應該限制為保留在 [資料] 資料夾中的類別。</span><span class="sxs-lookup"><span data-stu-id="a4371-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="a4371-125">商務邏輯應該位於服務與 [模型] 資料夾內的類別。</span><span class="sxs-lookup"><span data-stu-id="a4371-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="a4371-126">雖然簡單、 單一專案整合解決方案有一些缺點。</span><span class="sxs-lookup"><span data-stu-id="a4371-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="a4371-127">隨著專案的大小和複雜度增加，會繼續成長以及檔案和資料夾的數目。</span><span class="sxs-lookup"><span data-stu-id="a4371-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="a4371-128">UI 考量 （模型、 檢視表、 控制站） 位於不群組在一起依字母順序中的多個資料夾中。</span><span class="sxs-lookup"><span data-stu-id="a4371-128">UI concerns (models, views, controllers) reside in multiple folders, which are not grouped together alphabetically.</span></span> <span data-ttu-id="a4371-129">其他 UI 層級建構，例如篩選或 ModelBinders，加入自己的資料夾中時，此問題只會取得較差。</span><span class="sxs-lookup"><span data-stu-id="a4371-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="a4371-130">商務邏輯散佈之間的模型和服務的資料夾，並沒有清除其中的資料夾中的類別應該依存於其他人的指示。</span><span class="sxs-lookup"><span data-stu-id="a4371-130">Business logic is scattered between the Models and Services folders, and there is no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="a4371-131">這種欠缺在專案層級的組織經常會導致[雜亂無章](http://deviq.com/spaghetti-code/)。</span><span class="sxs-lookup"><span data-stu-id="a4371-131">This lack of organization at the project level frequently leads to [spaghetti code](http://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="a4371-132">若要解決這些問題，應用程式通常不同時在多專案方案，每個專案被視為位於特定*層*應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4371-132">In order to address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular *layer* of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="a4371-133">圖層有哪些？</span><span class="sxs-lookup"><span data-stu-id="a4371-133">What are layers?</span></span>

<span data-ttu-id="a4371-134">應用程式變得更複雜，因為一個方法來管理這種複雜性，是根據其責任或疑慮分解應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4371-134">As applications grow in complexity, one way to manage that complexity is to break the application up according to its responsibilities or concerns.</span></span> <span data-ttu-id="a4371-135">這會遵循的考量原則區隔，並有助於讓日益增加的程式碼庫進行編排，開發人員可以輕鬆地找到，實作特定功能。</span><span class="sxs-lookup"><span data-stu-id="a4371-135">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="a4371-136">分層的架構透過提供許多優勢，只要程式碼組織之外。</span><span class="sxs-lookup"><span data-stu-id="a4371-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="a4371-137">藉由組織程式碼到圖層，就可以重複使用常見的低階功能整個應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4371-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="a4371-138">這種重新使用是有益的因為這表示較少程式碼以供需要寫，因為它可讓應用程式的單一實作，遵循乾標準化。</span><span class="sxs-lookup"><span data-stu-id="a4371-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the DRY principle.</span></span>

<span data-ttu-id="a4371-139">多層式架構，與應用程式可以強制執行的限制的圖層可以與其他圖層通訊。</span><span class="sxs-lookup"><span data-stu-id="a4371-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="a4371-140">這有助於達成封裝 （encapsulation）。</span><span class="sxs-lookup"><span data-stu-id="a4371-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="a4371-141">變更圖層，或取代，當它處理這些圖層應該會受到影響。</span><span class="sxs-lookup"><span data-stu-id="a4371-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="a4371-142">藉由限制的層級而定的其他圖層的變更的影響，就可以緩解，讓單一變更不會影響整個應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4371-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="a4371-143">圖層 （和封裝 （encapsulation）） 讓它更容易取代應用程式中的功能。</span><span class="sxs-lookup"><span data-stu-id="a4371-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="a4371-144">例如，應用程式持續性，一開始可能會使用它自己的 SQL Server 資料庫，但稍後可以選擇使用以雲端為基礎的持續性策略或 web API 之後。</span><span class="sxs-lookup"><span data-stu-id="a4371-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="a4371-145">如果應用程式已正確封裝其邏輯層內的持續性實作，該 SQL Server 的特定層級取代一個新實作相同的公用介面。</span><span class="sxs-lookup"><span data-stu-id="a4371-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="a4371-146">除了的交換中未來以回應變更需求的實作可能會，應用程式層級也也能簡化空出基於測試目的實作。</span><span class="sxs-lookup"><span data-stu-id="a4371-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="a4371-147">不需要撰寫操作的實際資料的圖層或應用程式的 UI 層的測試，這些層級可以在測試階段以取代假的實作，以提供已知的回應至要求。</span><span class="sxs-lookup"><span data-stu-id="a4371-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="a4371-148">這通常可讓測試更容易撰寫且更快速地執行相較於執行一次測試應用程式的實際基礎結構。</span><span class="sxs-lookup"><span data-stu-id="a4371-148">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="a4371-149">邏輯圖層會改善組織的企業軟體應用程式中的程式碼的常見技術，並有數種方式中的程式碼可組織成層級。</span><span class="sxs-lookup"><span data-stu-id="a4371-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
> <span data-ttu-id="a4371-150">*圖層*代表應用程式中的邏輯分隔。</span><span class="sxs-lookup"><span data-stu-id="a4371-150">*Layers* represent logical separation within the application.</span></span> <span data-ttu-id="a4371-151">確認應用程式邏輯實際發佈至不同伺服器或處理程序時，這些個別的實體部署目標指*層*。</span><span class="sxs-lookup"><span data-stu-id="a4371-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as *tiers*.</span></span> <span data-ttu-id="a4371-152">它是可行的而且很常見，讓 N 層應用程式部署到單一層級。</span><span class="sxs-lookup"><span data-stu-id="a4371-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="a4371-153">傳統的 「 N Layer 」 架構應用程式</span><span class="sxs-lookup"><span data-stu-id="a4371-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="a4371-154">最常見的應用程式中插入的邏輯組織層它顯示在圖 5-2 中。</span><span class="sxs-lookup"><span data-stu-id="a4371-154">The most common organization of application logic into layers it shown in Figure 5-2.</span></span>

<span data-ttu-id="a4371-155">**圖 5-2。**</span><span class="sxs-lookup"><span data-stu-id="a4371-155">**Figure 5-2.**</span></span> <span data-ttu-id="a4371-156">一般應用程式層級。</span><span class="sxs-lookup"><span data-stu-id="a4371-156">Typical application layers.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="a4371-157">這些層級常用的縮寫為 UI，BLL 商務邏輯層 （），以及 DAL （資料存取層）。</span><span class="sxs-lookup"><span data-stu-id="a4371-157">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="a4371-158">使用者使用此架構，請透過 UI 層，這只與 BLL 互動的要求。</span><span class="sxs-lookup"><span data-stu-id="a4371-158">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="a4371-159">接著，BLL，可以呼叫 DAL 的資料存取要求。</span><span class="sxs-lookup"><span data-stu-id="a4371-159">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="a4371-160">UI 層應該不會對任何要求 DAL 直接，也不應直接透過其他方式的持續性與它互動。</span><span class="sxs-lookup"><span data-stu-id="a4371-160">The UI layer should not make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="a4371-161">同樣地，BLL 應該只能與互動持續性進行 DAL。</span><span class="sxs-lookup"><span data-stu-id="a4371-161">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="a4371-162">如此一來，每個圖層會有它自己的已知的責任。</span><span class="sxs-lookup"><span data-stu-id="a4371-162">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="a4371-163">這個傳統的分層方法的缺點是編譯時間相依性執行從頂端到底部。</span><span class="sxs-lookup"><span data-stu-id="a4371-163">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="a4371-164">也就是說，UI 層 BLL，取決於 DAL 而定。</span><span class="sxs-lookup"><span data-stu-id="a4371-164">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="a4371-165">這表示 BLL，通常會保存最重要邏輯應用程式中，相依資料存取實作細節 （而且通常資料庫存在）。</span><span class="sxs-lookup"><span data-stu-id="a4371-165">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="a4371-166">在這類架構中測試商務邏輯非常困難，這需要測試資料庫。</span><span class="sxs-lookup"><span data-stu-id="a4371-166">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="a4371-167">相依性反向原則可用來解決這個問題，您會發現下一節。</span><span class="sxs-lookup"><span data-stu-id="a4371-167">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="a4371-168">圖 5-3 顯示範例解決方案，分成三個專案中的應用程式，責任 （或圖層）。</span><span class="sxs-lookup"><span data-stu-id="a4371-168">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

<span data-ttu-id="a4371-169">**圖 5-3。**</span><span class="sxs-lookup"><span data-stu-id="a4371-169">**Figure 5-3.**</span></span> <span data-ttu-id="a4371-170">簡單整合的應用程式包含三個專案。</span><span class="sxs-lookup"><span data-stu-id="a4371-170">A simple monolithic application with three projects.</span></span>

![](./media/image5-3.png)

<span data-ttu-id="a4371-171">雖然此應用程式會使用數個專案，供組織使用，但它仍會部署為單一單位，而其用戶端會與它互動做為單一的 web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4371-171">Although this application uses several projects for organizational purposes, it is still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="a4371-172">這可讓您非常簡單的部署程序。</span><span class="sxs-lookup"><span data-stu-id="a4371-172">This allows for very simple deployment process.</span></span> <span data-ttu-id="a4371-173">圖 5-4 將示範這類應用程式可能會如何使用 Windows Azure 裝載。</span><span class="sxs-lookup"><span data-stu-id="a4371-173">Figure 5-4 shows how such an app might be hosted using Windows Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="a4371-174">**圖 5-4。**</span><span class="sxs-lookup"><span data-stu-id="a4371-174">**Figure 5-4.**</span></span> <span data-ttu-id="a4371-175">簡單之部署的 Azure Web 應用程式</span><span class="sxs-lookup"><span data-stu-id="a4371-175">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="a4371-176">當應用程式需求成長，則可能需要更複雜且功能強大的部署解決方案。</span><span class="sxs-lookup"><span data-stu-id="a4371-176">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="a4371-177">圖 5-5 示範更複雜的部署計劃支援額外的功能。</span><span class="sxs-lookup"><span data-stu-id="a4371-177">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="a4371-178">**圖 5-5。**</span><span class="sxs-lookup"><span data-stu-id="a4371-178">**Figure 5-5.**</span></span> <span data-ttu-id="a4371-179">將 web 應用程式部署至 Azure 應用程式服務</span><span class="sxs-lookup"><span data-stu-id="a4371-179">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="a4371-180">就內部而言，此專案的組織有責任為基礎的多個專案可以改善應用程式的可維護性。</span><span class="sxs-lookup"><span data-stu-id="a4371-180">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="a4371-181">此單位可以增加或放大調整以充分利用雲端隨延展性。</span><span class="sxs-lookup"><span data-stu-id="a4371-181">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="a4371-182">向上擴充時，表示將額外的 CPU、 記憶體、 磁碟空間或其他資源新增至裝載您的應用程式伺服器。</span><span class="sxs-lookup"><span data-stu-id="a4371-182">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="a4371-183">向外延展表示新增這類伺服器的其他執行個體是否這些實體伺服器或虛擬機器。</span><span class="sxs-lookup"><span data-stu-id="a4371-183">Scaling out means adding additional instances of such servers, whether these are physical servers or virtual machines.</span></span> <span data-ttu-id="a4371-184">當您的應用程式裝載多個執行個體時，負載平衡器會用於將要求指派給個別的應用程式執行個體。</span><span class="sxs-lookup"><span data-stu-id="a4371-184">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="a4371-185">在 Azure 中調整 web 應用程式最簡單的方式是設定手動調整應用程式的 App Service 方案中。</span><span class="sxs-lookup"><span data-stu-id="a4371-185">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="a4371-186">圖 5-6 顯示適當的 Azure 儀表板畫面設定多少個執行個體正在提供應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4371-186">Figure 5-6 show the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="a4371-187">**圖 5-6。**</span><span class="sxs-lookup"><span data-stu-id="a4371-187">**Figure 5-6.**</span></span> <span data-ttu-id="a4371-188">在 Azure 中調整應用程式服務方案。</span><span class="sxs-lookup"><span data-stu-id="a4371-188">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="a4371-189">全新的架構</span><span class="sxs-lookup"><span data-stu-id="a4371-189">Clean architecture</span></span>

<span data-ttu-id="a4371-190">請依照下列相依性反向原則以及 Domain-Driven 設計 (DDD) 原則的應用程式通常以達到類似的架構。</span><span class="sxs-lookup"><span data-stu-id="a4371-190">Applications that follow the Dependency Inversion Principle as well as Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="a4371-191">這個架構已經由許多名稱多年。</span><span class="sxs-lookup"><span data-stu-id="a4371-191">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="a4371-192">其中一個名字是六角架構，後面接著連接埠和介面卡。</span><span class="sxs-lookup"><span data-stu-id="a4371-192">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="a4371-193">還要新，它已所引用為[洋蔥架構](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/)或[全新架構](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)。</span><span class="sxs-lookup"><span data-stu-id="a4371-193">More recently, it's been cited as the [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="a4371-194">它是這個最後一個名稱，全新的架構，用來描述此的電子書中的架構為基礎。</span><span class="sxs-lookup"><span data-stu-id="a4371-194">It is this last name, Clean Architecture, that is used as the basis for describing the architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="a4371-195">使用 DDD 建置全新的架構可以套用至應用程式，而不使用 DDD 原則以及建立的詞彙。</span><span class="sxs-lookup"><span data-stu-id="a4371-195">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="a4371-196">先前，在這種組合可能會稱為 「 全新 DDD 架構 」。</span><span class="sxs-lookup"><span data-stu-id="a4371-196">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="a4371-197">全新的架構會將商務邏輯和應用程式模型應用程式的中央位置。</span><span class="sxs-lookup"><span data-stu-id="a4371-197">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="a4371-198">需要商務邏輯取決於資料存取或其他基礎結構的問題，而此相依性已反轉： 取決於應用程式核心的基礎結構和實作詳細資料。</span><span class="sxs-lookup"><span data-stu-id="a4371-198">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="a4371-199">藉由定義在應用程式核心，則會由基礎結構層中定義的型別實作的抽象概念或介面，可達到此目的。</span><span class="sxs-lookup"><span data-stu-id="a4371-199">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="a4371-200">視覺化這個架構的常見方式是使用一系列的同心圓，類似於洋蔥。</span><span class="sxs-lookup"><span data-stu-id="a4371-200">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="a4371-201">圖 5-X 示範這種架構的表示法。</span><span class="sxs-lookup"><span data-stu-id="a4371-201">Figure 5-X shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="a4371-202">**圖 5-7。**</span><span class="sxs-lookup"><span data-stu-id="a4371-202">**Figure 5-7.**</span></span> <span data-ttu-id="a4371-203">全新的架構。洋蔥檢視</span><span class="sxs-lookup"><span data-stu-id="a4371-203">Clean Architecture; onion view</span></span>

<span data-ttu-id="a4371-204">在此圖中，相依性流程朝最內層的圓形。</span><span class="sxs-lookup"><span data-stu-id="a4371-204">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="a4371-205">因此，您可以看到應用程式核心 （這會從它的核心這張圖表的位置，取得其名稱） 具有其他應用程式層級的任何相依性。</span><span class="sxs-lookup"><span data-stu-id="a4371-205">Thus, you can see that the Application Core (which takes its name from its position at the core of this diagram) has no dependencies on other application layers.</span></span> <span data-ttu-id="a4371-206">在極正為應用程式的實體和介面。</span><span class="sxs-lookup"><span data-stu-id="a4371-206">At the very center are the application's entities and interfaces.</span></span> <span data-ttu-id="a4371-207">只在外，但仍在應用程式核心中，為網域服務，通常會實作內部圓形中有定義介面。</span><span class="sxs-lookup"><span data-stu-id="a4371-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="a4371-208">外部應用程式的核心，使用者介面與基礎結構層級取決於應用程式的核心，但在另一個 （一定）。</span><span class="sxs-lookup"><span data-stu-id="a4371-208">Outside of the Application Core, both the User Interface and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="a4371-209">圖 5-X 顯示更傳統的水平的分層圖，更能反映出 UI 和其他圖層之間的相依性。</span><span class="sxs-lookup"><span data-stu-id="a4371-209">Figure 5-X shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="a4371-210">**圖 5-8。**</span><span class="sxs-lookup"><span data-stu-id="a4371-210">**Figure 5-8.**</span></span> <span data-ttu-id="a4371-211">全新的架構。水平的層級檢視</span><span class="sxs-lookup"><span data-stu-id="a4371-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="a4371-212">請注意實心箭號代表編譯時期相依，而的虛線的箭頭表示僅執行階段相依性。</span><span class="sxs-lookup"><span data-stu-id="a4371-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="a4371-213">使用全新的架構，UI 層適用於在編譯時期，應用程式核心中定義的介面，並在理想情況下應該有任何知識的實作類型中未定義基礎結構層級。</span><span class="sxs-lookup"><span data-stu-id="a4371-213">Using the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally should not have any knowledge of the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="a4371-214">在執行階段，不過，這些實作類型必須為應用程式執行，因此它們必須存在和應用程式核心介面，透過相依性插入至有線。</span><span class="sxs-lookup"><span data-stu-id="a4371-214">At runtime, however, these implementation types will be required for the app to execute, so they will need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="a4371-215">圖 5-9 顯示 ASP.NET Core 應用程式的架構，遵循這些建議建置時的更詳細的檢視。</span><span class="sxs-lookup"><span data-stu-id="a4371-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![ASPNET 核心架構](./media/image5-9.png)

<span data-ttu-id="a4371-217">**圖 5-9。**</span><span class="sxs-lookup"><span data-stu-id="a4371-217">**Figure 5-9.**</span></span> <span data-ttu-id="a4371-218">ASP.NET Core 架構圖表下列全新的架構。</span><span class="sxs-lookup"><span data-stu-id="a4371-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="a4371-219">因為應用程式核心不會相依於基礎結構，所以很容易就能撰寫自動化的單元測試，此圖層。</span><span class="sxs-lookup"><span data-stu-id="a4371-219">Because the Application Core doesn't depend on Infrastructure, it is very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="a4371-220">圖 5-10，5-11 顯示測試如何配合這個架構。</span><span class="sxs-lookup"><span data-stu-id="a4371-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="a4371-222">**圖 5-10。**</span><span class="sxs-lookup"><span data-stu-id="a4371-222">**Figure 5-10.**</span></span> <span data-ttu-id="a4371-223">單元測試中隔離的應用程式的核心。</span><span class="sxs-lookup"><span data-stu-id="a4371-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="a4371-225">**圖 5-11。**</span><span class="sxs-lookup"><span data-stu-id="a4371-225">**Figure 5-11.**</span></span> <span data-ttu-id="a4371-226">整合測試基礎結構實作具有外部相依性。</span><span class="sxs-lookup"><span data-stu-id="a4371-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="a4371-227">UI 層基礎結構的專案中定義的型別上沒有直接的相依性，因為它是同樣很容易就能交換出實作中，以促進測試或在偵測到應用程式需求的變更。</span><span class="sxs-lookup"><span data-stu-id="a4371-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it is likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="a4371-228">ASP.NET Core 的內建的使用及相依性插入的支援可讓此架構結構非一般的整合應用程式的最適當方式。</span><span class="sxs-lookup"><span data-stu-id="a4371-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="a4371-229">整合應用程式的應用程式核心、 基礎結構，以及使用者介面專案是所有執行單一應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4371-229">For monolithic applications the Application Core, Infrastructure, and User Interface projects are all run as a single application.</span></span> <span data-ttu-id="a4371-230">執行階段應用程式架構看起來可能像圖 5-12 版。</span><span class="sxs-lookup"><span data-stu-id="a4371-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASPNET 核心架構 2](./media/image5-12.png)

<span data-ttu-id="a4371-232">**圖 5-12。**</span><span class="sxs-lookup"><span data-stu-id="a4371-232">**Figure 5-12.**</span></span> <span data-ttu-id="a4371-233">範例 ASP.NET Core 應用程式的執行階段架構。</span><span class="sxs-lookup"><span data-stu-id="a4371-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="a4371-234">組織全新的架構中的程式碼</span><span class="sxs-lookup"><span data-stu-id="a4371-234">Organizing Code in Clean Architecture</span></span>

<span data-ttu-id="a4371-235">在全新的架構解決方案中，每個專案都有的職責。</span><span class="sxs-lookup"><span data-stu-id="a4371-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="a4371-236">因此，某些類型將屬於的每個專案，而您經常可以找到對應至適當的專案中的這些類型的資料夾。</span><span class="sxs-lookup"><span data-stu-id="a4371-236">As such, certain types will belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="a4371-237">應用程式核心保存的商務模型，其中包含實體、 服務和介面。</span><span class="sxs-lookup"><span data-stu-id="a4371-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="a4371-238">這些介面包含抽象將會使用基礎結構，例如資料存取、 檔案系統存取權、 網路呼叫等執行的作業。有時服務或介面定義這一層將會需要使用沒有 UI 或基礎結構上的任何相依性的非實體類型。</span><span class="sxs-lookup"><span data-stu-id="a4371-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="a4371-239">這些可以定義為簡單的資料傳輸物件 (Dto)。</span><span class="sxs-lookup"><span data-stu-id="a4371-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

> ### <a name="application-core-types"></a><span data-ttu-id="a4371-240">應用程式的核心類型</span><span class="sxs-lookup"><span data-stu-id="a4371-240">Application Core Types</span></span>
> -   <span data-ttu-id="a4371-241">實體 （商務模型類別保存）</span><span class="sxs-lookup"><span data-stu-id="a4371-241">Entities (business model classes that are persisted)</span></span>
> -   <span data-ttu-id="a4371-242">介面</span><span class="sxs-lookup"><span data-stu-id="a4371-242">Interfaces</span></span>
> -   <span data-ttu-id="a4371-243">服務</span><span class="sxs-lookup"><span data-stu-id="a4371-243">Services</span></span>
> -   <span data-ttu-id="a4371-244">DTOs</span><span class="sxs-lookup"><span data-stu-id="a4371-244">DTOs</span></span>

<span data-ttu-id="a4371-245">基礎結構專案通常會包含資料存取實作。</span><span class="sxs-lookup"><span data-stu-id="a4371-245">The Infrastructure project will typically include data access implementations.</span></span> <span data-ttu-id="a4371-246">在一般的 ASP.NET Core web 應用程式，這包括 Entity Framework DbContext、 已定義的任何 EF 核心移轉和資料存取實作類別。</span><span class="sxs-lookup"><span data-stu-id="a4371-246">In a typical ASP.NET Core web application, this will include the Entity Framework DbContext, any EF Core Migrations that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="a4371-247">抽象資料存取實作程式碼的最常見方式是透過使用的[儲存機制的設計模式](http://deviq.com/repository-pattern/)。</span><span class="sxs-lookup"><span data-stu-id="a4371-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](http://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="a4371-248">資料存取實作中，除了基礎結構專案應包含必須與基礎結構互動的服務的實作。</span><span class="sxs-lookup"><span data-stu-id="a4371-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="a4371-249">這些服務都應該實作應用程式核心中定義的介面，因此基礎結構應該有應用程式核心專案的參考。</span><span class="sxs-lookup"><span data-stu-id="a4371-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

> ### <a name="infrastructure-types"></a><span data-ttu-id="a4371-250">基礎結構類型</span><span class="sxs-lookup"><span data-stu-id="a4371-250">Infrastructure Types</span></span>
> -   <span data-ttu-id="a4371-251">EF 核心型別 （DbContext，移轉）</span><span class="sxs-lookup"><span data-stu-id="a4371-251">EF Core types (DbContext, Migrations)</span></span>
> -   <span data-ttu-id="a4371-252">資料存取實作類型 （儲存機制）</span><span class="sxs-lookup"><span data-stu-id="a4371-252">Data access implementation types (Repositories)</span></span>
> -   <span data-ttu-id="a4371-253">基礎結構特定服務 （FileLogger、 SmtpNotifier 等等）</span><span class="sxs-lookup"><span data-stu-id="a4371-253">Infrastructure-specific services (FileLogger, SmtpNotifier, etc.)</span></span>

<span data-ttu-id="a4371-254">使用者介面層，ASP.NET Core MVC 應用程式中的將應用程式的進入點，且將 ASP.NET Core MVC 專案。</span><span class="sxs-lookup"><span data-stu-id="a4371-254">The user interface layer in an ASP.NET Core MVC application will be the entry point for the application, and will be an ASP.NET Core MVC project.</span></span> <span data-ttu-id="a4371-255">這個專案應參考該應用程式核心專案和其類型應與嚴格透過定義在應用程式核心介面的基礎結構互動。</span><span class="sxs-lookup"><span data-stu-id="a4371-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="a4371-256">沒有直接具現化 （或靜態的呼叫） 基礎結構層類型應該獲得許可 UI 層中。</span><span class="sxs-lookup"><span data-stu-id="a4371-256">No direct instantiation of (or static calls to) Infrastructure layer types should be permitted in the UI layer.</span></span>

> ### <a name="ui-layer-types"></a><span data-ttu-id="a4371-257">圖層的 UI 類型</span><span class="sxs-lookup"><span data-stu-id="a4371-257">UI Layer Types</span></span>
> -   <span data-ttu-id="a4371-258">控制站</span><span class="sxs-lookup"><span data-stu-id="a4371-258">Controllers</span></span>
> -   <span data-ttu-id="a4371-259">篩選條件</span><span class="sxs-lookup"><span data-stu-id="a4371-259">Filters</span></span>
> -   <span data-ttu-id="a4371-260">檢視</span><span class="sxs-lookup"><span data-stu-id="a4371-260">Views</span></span>
> -   <span data-ttu-id="a4371-261">ViewModels</span><span class="sxs-lookup"><span data-stu-id="a4371-261">ViewModels</span></span>
> -   <span data-ttu-id="a4371-262">啟動</span><span class="sxs-lookup"><span data-stu-id="a4371-262">Startup</span></span>

<span data-ttu-id="a4371-263">啟動類別會負責設定應用程式，以及實作類型連接至介面，讓才能正常運作，在執行階段相依性插入。</span><span class="sxs-lookup"><span data-stu-id="a4371-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="a4371-264">若要連接中 ConfigureServices Startup.cs 檔案中的相依性插入的 UI 專案，專案可能需要參考基礎結構專案。</span><span class="sxs-lookup"><span data-stu-id="a4371-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="a4371-265">此相依性可以排除，最容易使用的自訂 DI 容器。</span><span class="sxs-lookup"><span data-stu-id="a4371-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="a4371-266">基於此範例的目的，是讓 UI 專案，以參考基礎結構專案最簡單的方法。</span><span class="sxs-lookup"><span data-stu-id="a4371-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="a4371-267">整合應用程式和容器</span><span class="sxs-lookup"><span data-stu-id="a4371-267">Monolithic Applications and Containers</span></span> 

<span data-ttu-id="a4371-268">您可以建立單一且整合型部署 Web 應用程式或服務，並將其部署為容器。</span><span class="sxs-lookup"><span data-stu-id="a4371-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="a4371-269">在應用程式可能不很龐大但組織成幾個程式庫、 元件或圖層。</span><span class="sxs-lookup"><span data-stu-id="a4371-269">Within the application, it might not be monolithic but organized into several libraries, components or layers.</span></span> <span data-ttu-id="a4371-270">外部，它是單一的容器，例如單一處理程序、 單一 web 應用程式或單一服務。</span><span class="sxs-lookup"><span data-stu-id="a4371-270">Externally it is a single container like a single process, single web application or single service.</span></span>

<span data-ttu-id="a4371-271">若要管理此模型，您可以部署單一容器來表示應用程式。</span><span class="sxs-lookup"><span data-stu-id="a4371-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="a4371-272">若要調整，只要加入使用前方負載平衡器的額外複本。</span><span class="sxs-lookup"><span data-stu-id="a4371-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="a4371-273">管理單一容器或 VM 中的單一部署來自簡易性。</span><span class="sxs-lookup"><span data-stu-id="a4371-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="a4371-274">您可以包含多個元件/程式庫或內部的圖層中每個容器，如圖 5-X 所示。</span><span class="sxs-lookup"><span data-stu-id="a4371-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-X.</span></span> <span data-ttu-id="a4371-275">但是，下列的容器主體*」 容器沒有一件事，和一個處理序中運作*"，整合模式可能會發生衝突。</span><span class="sxs-lookup"><span data-stu-id="a4371-275">But, following the container principal of *"a container does one thing, and does it in one process*", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="a4371-276">這種方法的缺點是，如果/當應用程式成長時，需要調整。</span><span class="sxs-lookup"><span data-stu-id="a4371-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="a4371-277">如果縮放整個應用程式，它並非真正的問題。</span><span class="sxs-lookup"><span data-stu-id="a4371-277">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="a4371-278">不過，在大部分情況下，應用程式的某些部分會使用需要調整其他元件時淺壓深點小於。</span><span class="sxs-lookup"><span data-stu-id="a4371-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="a4371-279">使用一般的電子商務範例;您可能需要調整的是產品資訊元件。</span><span class="sxs-lookup"><span data-stu-id="a4371-279">Using the typical eCommerce example; what you likely need to scale is the product information component.</span></span> <span data-ttu-id="a4371-280">更多其他客戶瀏覽產品，比購買。</span><span class="sxs-lookup"><span data-stu-id="a4371-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="a4371-281">更多的客戶使用及其購物籃，比使用付款管線。</span><span class="sxs-lookup"><span data-stu-id="a4371-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="a4371-282">較少的客戶加入註解或檢視其採購歷程記錄。</span><span class="sxs-lookup"><span data-stu-id="a4371-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="a4371-283">而且，您可能只需要少數幾個員工，在單一區域中，需要管理內容和行銷活動。</span><span class="sxs-lookup"><span data-stu-id="a4371-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="a4371-284">藉由調整僵化設計，所有的程式碼是多次部署。</span><span class="sxs-lookup"><span data-stu-id="a4371-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="a4371-285">除了標尺問題，所有項目變更單一元件需要完整測試整個應用程式，以及完整的重新部署的所有執行個體。</span><span class="sxs-lookup"><span data-stu-id="a4371-285">In addition to the scale everything problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="a4371-286">是很常見，整合的方法，許多組織正在開發使用這個架構的方法。</span><span class="sxs-lookup"><span data-stu-id="a4371-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="a4371-287">許多有良好足夠的結果，其他人到達限制時。</span><span class="sxs-lookup"><span data-stu-id="a4371-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="a4371-288">許多設計在這個模型中，其應用程式，因為工具與基礎結構太難建置服務導向架構 (SOA)，而且他們沒有看到需要-，直到應用程式成長。</span><span class="sxs-lookup"><span data-stu-id="a4371-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service oriented architectures (SOA), and they didn't see the need - until the app grew.</span></span> <span data-ttu-id="a4371-289">如果您發現您遇到整合型方法的限制，以便讓它更充分利用容器和 microservices 分解成的應用程式可能是下一步。</span><span class="sxs-lookup"><span data-stu-id="a4371-289">If you find you're hitting the limits of the monolithic approach, breaking the app up to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="a4371-290">部署 Microsoft Azure 中的整合應用程式即可達成每個執行個體使用專用的 Vm。</span><span class="sxs-lookup"><span data-stu-id="a4371-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="a4371-291">使用[Azure VM 規模集](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)，您可以輕鬆地調整 Vm。</span><span class="sxs-lookup"><span data-stu-id="a4371-291">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="a4371-292">[Azure 應用程式服務](https://azure.microsoft.com/services/app-service/)可以執行整合的應用程式並輕鬆擴充執行個體，而不需要管理 Vm。</span><span class="sxs-lookup"><span data-stu-id="a4371-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="a4371-293">Azure 應用程式服務可以執行簡化部署，Docker 容器的單一執行個體。</span><span class="sxs-lookup"><span data-stu-id="a4371-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="a4371-294">使用 Docker 時，您可以部署單一 VM 為 Docker 主機，並執行多個執行個體。</span><span class="sxs-lookup"><span data-stu-id="a4371-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="a4371-295">使用 Azure 平衡器，顯示在圖 5-14，您可以管理縮放比例。</span><span class="sxs-lookup"><span data-stu-id="a4371-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="a4371-296">部署到不同主機都可以使用傳統部署技術來管理。</span><span class="sxs-lookup"><span data-stu-id="a4371-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="a4371-297">Docker 主機可以使用類似的命令來管理**執行 docker**執行手動方式或透過自動化，例如持續傳遞 (CD) 管線。</span><span class="sxs-lookup"><span data-stu-id="a4371-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="a4371-298">整合應用程式部署為容器</span><span class="sxs-lookup"><span data-stu-id="a4371-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="a4371-299">有許多優點的使用來管理整合的應用程式部署的容器。</span><span class="sxs-lookup"><span data-stu-id="a4371-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="a4371-300">調整容器的執行個體是遠比快速而且容易部署額外的 Vm。</span><span class="sxs-lookup"><span data-stu-id="a4371-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="a4371-301">使用調整 Vm 的 VM 規模集，即使它們需要的時間執行個體。</span><span class="sxs-lookup"><span data-stu-id="a4371-301">Even when using VM Scale Sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="a4371-302">當部署為應用程式執行個體，應用程式的組態管理 VM 的一部分。</span><span class="sxs-lookup"><span data-stu-id="a4371-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="a4371-303">部署更新的 Docker 映像的速度遠和有效率的網路。</span><span class="sxs-lookup"><span data-stu-id="a4371-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="a4371-304">Docker Images 一開始通常以秒為單位，加速首度發行。</span><span class="sxs-lookup"><span data-stu-id="a4371-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="a4371-305">破壞的 Docker 執行個體非常簡單，只要發出**docker stop**命令，通常少於一秒內完成。</span><span class="sxs-lookup"><span data-stu-id="a4371-305">Tearing down a Docker instance is as easy as issuing a **docker stop** command, typically completing in less than a second.</span></span>

<span data-ttu-id="a4371-306">容器是由設計原本就是不可變的因為您永遠不需要擔心損毀的 Vm，而更新指令碼，可能會忘記要部分特定組態或剩餘檔上的磁碟。</span><span class="sxs-lookup"><span data-stu-id="a4371-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="a4371-307">時整合的應用程式可受益於 Docker，分解成可縮放的 sub 系統整合應用程式開發，並個別部署，可能是領域的 microservices 您進入點。</span><span class="sxs-lookup"><span data-stu-id="a4371-307">While monolithic apps can benefit from Docker, breaking up the monolithic application into sub systems which can be scaled, developed and deployed individually may be your entry point into the realm of microservices.</span></span>

> ### <a name="references--common-web-architectures"></a><span data-ttu-id="a4371-308">參考 – 常見的 Web 架構</span><span class="sxs-lookup"><span data-stu-id="a4371-308">References – Common Web Architectures</span></span>
> - <span data-ttu-id="a4371-309">**全新的架構**</span><span class="sxs-lookup"><span data-stu-id="a4371-309">**The Clean Architecture**</span></span>  
> <span data-ttu-id="a4371-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span><span class="sxs-lookup"><span data-stu-id="a4371-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span></span>
> - <span data-ttu-id="a4371-311">**洋蔥架構**</span><span class="sxs-lookup"><span data-stu-id="a4371-311">**The Onion Architecture**</span></span>  
> <span data-ttu-id="a4371-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span><span class="sxs-lookup"><span data-stu-id="a4371-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span></span>
> - <span data-ttu-id="a4371-313">**儲存機制模式**</span><span class="sxs-lookup"><span data-stu-id="a4371-313">**The Repository Pattern**</span></span>  
> <span data-ttu-id="a4371-314"><http://deviq.com/repository-pattern/></span><span class="sxs-lookup"><span data-stu-id="a4371-314"><http://deviq.com/repository-pattern/></span></span>
> - <span data-ttu-id="a4371-315">**清理架構方案範例**</span><span class="sxs-lookup"><span data-stu-id="a4371-315">**Clean Architecture Solution Sample**</span></span>  
> <span data-ttu-id="a4371-316"><https://github.com/ardalis/cleanarchitecture></span><span class="sxs-lookup"><span data-stu-id="a4371-316"><https://github.com/ardalis/cleanarchitecture></span></span>
> - <span data-ttu-id="a4371-317">**架構 Microservices 電子書** <http://aka.ms/MicroservicesEbook></span><span class="sxs-lookup"><span data-stu-id="a4371-317">**Architecting Microservices e-book** <http://aka.ms/MicroservicesEbook></span></span>

>[!div class="step-by-step"]
<span data-ttu-id="a4371-318">[上一個](架構-principles.md) [下一步] (常見的用戶端-側邊-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="a4371-318">[Previous] (architectural-principles.md) [Next] (common-client-side-web-technologies.md)</span></span>
