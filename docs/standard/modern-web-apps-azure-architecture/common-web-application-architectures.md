---
title: "常見的 web 應用程式架構"
description: "使用 ASP.NET Core 和 Microsoft Azure 的現代化 web 應用程式架構設計人員 |常見的 web 應用程式架構"
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: dc5580d38ac29a5e923a4b7d84f9d7e077d5cdb2
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/23/2017
---
#<a name="common-web-application-architectures"></a>常見的 Web 應用程式架構

> 「 如果您認為良好的架構是高度耗費資源，請再試一次不正確的架構。"  
> _-Brian Foote 和約瑟夫 Yoder_

## <a name="summary"></a>總結

大部分傳統的.NET 應用程式會部署為單一單位對應至可執行檔或執行單一的 IIS appdomain 內的單一 web 應用程式。 這是最簡單的部署模型，而且很好的做許多內部與較小公用應用程式。 不過，即使指定此單一部署單位，最重要的商務應用程式受益於一些邏輯分割到數個層級。

## <a name="what-is-a-monolithic-application"></a>什麼是整合的應用程式？

整合的應用程式是一種是完全獨立，根據其行為。 它可能會與過程中執行其作業時，其他服務或資料存放區互動，但它自己的處理序內執行的行為核心和整個應用程式通常會部署為單一單位。 如果這樣的應用程式需要水平縮放，通常會複製整個應用程式跨多個伺服器或虛擬機器。

## <a name="all-in-one-applications"></a>全部的一個應用程式

最小可能的應用程式架構的專案數目是其中一個。 以這種架構，應用程式的整個邏輯包含在單一專案，編譯成單一組件，並部署當做單一單位。

新 ASP.NET Core 專案時，是否建立 Visual Studio 中，或從命令列中，一開始為簡單的 「 全部合一"monolith。 它包含的所有應用程式，包括簡報、 商務和資料存取邏輯的行為。 圖 5-1 顯示單一專案的應用程式的檔案結構。

**圖 5-1。** 在單一專案中 ASP.NET Core 應用程式

![](./media/image5-1.png)

在單一專案案例中，重要性分離，達成透過資料夾使用。 預設範本包含個別資料夾的模型、 檢視和控制器，MVC 模式責任，以及其他資料夾資料和服務。 在這種安排，應該限制 [檢視] 資料夾中，最大的簡報詳細資料和實作詳細資料的存取應該限制為保留在 [資料] 資料夾中的類別。 商務邏輯應該位於服務與 [模型] 資料夾內的類別。

雖然簡單、 單一專案整合解決方案有一些缺點。 隨著專案的大小和複雜度增加，會繼續成長以及檔案和資料夾的數目。 UI 考量 （模型、 檢視表、 控制站） 位於不群組在一起依字母順序中的多個資料夾中。 其他 UI 層級建構，例如篩選或 ModelBinders，加入自己的資料夾中時，此問題只會取得較差。 商務邏輯散佈之間的模型和服務的資料夾，並沒有清除其中的資料夾中的類別應該依存於其他人的指示。 這種欠缺在專案層級的組織經常會導致[雜亂無章](http://deviq.com/spaghetti-code/)。

若要解決這些問題，應用程式通常不同時在多專案方案，每個專案被視為位於特定*層*應用程式。

## <a name="what-are-layers"></a>圖層有哪些？

應用程式變得更複雜，因為一個方法來管理這種複雜性，是根據其責任或疑慮分解應用程式。 這會遵循的考量原則區隔，並有助於讓日益增加的程式碼庫進行編排，開發人員可以輕鬆地找到，實作特定功能。 分層的架構透過提供許多優勢，只要程式碼組織之外。

藉由組織程式碼到圖層，就可以重複使用常見的低階功能整個應用程式。 這種重新使用是有益的因為這表示較少程式碼以供需要寫，因為它可讓應用程式的單一實作，遵循乾標準化。

多層式架構，與應用程式可以強制執行的限制的圖層可以與其他圖層通訊。 這有助於達成封裝 （encapsulation）。 變更圖層，或取代，當它處理這些圖層應該會受到影響。 藉由限制的層級而定的其他圖層的變更的影響，就可以緩解，讓單一變更不會影響整個應用程式。

圖層 （和封裝 （encapsulation）） 讓它更容易取代應用程式中的功能。 例如，應用程式持續性，一開始可能會使用它自己的 SQL Server 資料庫，但稍後可以選擇使用以雲端為基礎的持續性策略或 web API 之後。 如果應用程式已正確封裝其邏輯層內的持續性實作，該 SQL Server 的特定層級取代一個新實作相同的公用介面。

除了的交換中未來以回應變更需求的實作可能會，應用程式層級也也能簡化空出基於測試目的實作。 不需要撰寫操作的實際資料的圖層或應用程式的 UI 層的測試，這些層級可以在測試階段以取代假的實作，以提供已知的回應至要求。 這通常可讓測試更容易撰寫且更快速地執行相較於執行一次測試應用程式的實際基礎結構。

邏輯圖層會改善組織的企業軟體應用程式中的程式碼的常見技術，並有數種方式中的程式碼可組織成層級。

> [!NOTE]
> *圖層*代表應用程式中的邏輯分隔。 確認應用程式邏輯實際發佈至不同伺服器或處理程序時，這些個別的實體部署目標指*層*。 它是可行的而且很常見，讓 N 層應用程式部署到單一層級。

## <a name="traditional-n-layer-architecture-applications"></a>傳統的 「 N Layer 」 架構應用程式

最常見的應用程式中插入的邏輯組織層它顯示在圖 5-2 中。

**圖 5-2。** 一般應用程式層級。

![](./media/image5-2.png)

這些層級常用的縮寫為 UI，BLL 商務邏輯層 （），以及 DAL （資料存取層）。 使用者使用此架構，請透過 UI 層，這只與 BLL 互動的要求。 接著，BLL，可以呼叫 DAL 的資料存取要求。 UI 層應該不會對任何要求 DAL 直接，也不應直接透過其他方式的持續性與它互動。 同樣地，BLL 應該只能與互動持續性進行 DAL。 如此一來，每個圖層會有它自己的已知的責任。

這個傳統的分層方法的缺點是編譯時間相依性執行從頂端到底部。 也就是說，UI 層 BLL，取決於 DAL 而定。 這表示 BLL，通常會保存最重要邏輯應用程式中，相依資料存取實作細節 （而且通常資料庫存在）。 在這類架構中測試商務邏輯非常困難，這需要測試資料庫。 相依性反向原則可用來解決這個問題，您會發現下一節。

圖 5-3 顯示範例解決方案，分成三個專案中的應用程式，責任 （或圖層）。

**圖 5-3。** 簡單整合的應用程式包含三個專案。

![](./media/image5-3.png)

雖然此應用程式會使用數個專案，供組織使用，但它仍會部署為單一單位，而其用戶端會與它互動做為單一的 web 應用程式。 這可讓您非常簡單的部署程序。 圖 5-4 將示範這類應用程式可能會如何使用 Windows Azure 裝載。

![](./media/image5-4.png)

**圖 5-4。** 簡單之部署的 Azure Web 應用程式

當應用程式需求成長，則可能需要更複雜且功能強大的部署解決方案。 圖 5-5 示範更複雜的部署計劃支援額外的功能。

![](./media/image5-5.png)

**圖 5-5。** 將 web 應用程式部署至 Azure 應用程式服務

就內部而言，此專案的組織有責任為基礎的多個專案可以改善應用程式的可維護性。

此單位可以增加或放大調整以充分利用雲端隨延展性。 向上擴充時，表示將額外的 CPU、 記憶體、 磁碟空間或其他資源新增至裝載您的應用程式伺服器。 向外延展表示新增這類伺服器的其他執行個體是否這些實體伺服器或虛擬機器。 當您的應用程式裝載多個執行個體時，負載平衡器會用於將要求指派給個別的應用程式執行個體。

在 Azure 中調整 web 應用程式最簡單的方式是設定手動調整應用程式的 App Service 方案中。 圖 5-6 顯示適當的 Azure 儀表板畫面設定多少個執行個體正在提供應用程式。

![](./media/image5-6.png)

**圖 5-6。** 在 Azure 中調整應用程式服務方案。

## <a name="clean-architecture"></a>全新的架構

請依照下列相依性反向原則以及 Domain-Driven 設計 (DDD) 原則的應用程式通常以達到類似的架構。 這個架構已經由許多名稱多年。 其中一個名字是六角架構，後面接著連接埠和介面卡。 還要新，它已所引用為[洋蔥架構](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/)或[全新架構](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)。 它是這個最後一個名稱，全新的架構，用來描述此的電子書中的架構為基礎。

> [!NOTE]
> 使用 DDD 建置全新的架構可以套用至應用程式，而不使用 DDD 原則以及建立的詞彙。 先前，在這種組合可能會稱為 「 全新 DDD 架構 」。

全新的架構會將商務邏輯和應用程式模型應用程式的中央位置。 需要商務邏輯取決於資料存取或其他基礎結構的問題，而此相依性已反轉： 取決於應用程式核心的基礎結構和實作詳細資料。 藉由定義在應用程式核心，則會由基礎結構層中定義的型別實作的抽象概念或介面，可達到此目的。 視覺化這個架構的常見方式是使用一系列的同心圓，類似於洋蔥。 圖 5-X 示範這種架構的表示法。

![](./media/image5-7.png)

**圖 5-7。** 全新的架構。洋蔥檢視

在此圖中，相依性流程朝最內層的圓形。 因此，您可以看到應用程式核心 （這會從它的核心這張圖表的位置，取得其名稱） 具有其他應用程式層級的任何相依性。 在極正為應用程式的實體和介面。 只在外，但仍在應用程式核心中，為網域服務，通常會實作內部圓形中有定義介面。 外部應用程式的核心，使用者介面與基礎結構層級取決於應用程式的核心，但在另一個 （一定）。

圖 5-X 顯示更傳統的水平的分層圖，更能反映出 UI 和其他圖層之間的相依性。

![](./media/image5-8.png)

**圖 5-8。** 全新的架構。水平的層級檢視

請注意實心箭號代表編譯時期相依，而的虛線的箭頭表示僅執行階段相依性。 使用全新的架構，UI 層適用於在編譯時期，應用程式核心中定義的介面，並在理想情況下應該有任何知識的實作類型中未定義基礎結構層級。 在執行階段，不過，這些實作類型必須為應用程式執行，因此它們必須存在和應用程式核心介面，透過相依性插入至有線。

圖 5-9 顯示 ASP.NET Core 應用程式的架構，遵循這些建議建置時的更詳細的檢視。

![ASPNET 核心架構](./media/image5-9.png)

**圖 5-9。** ASP.NET Core 架構圖表下列全新的架構。

因為應用程式核心不會相依於基礎結構，所以很容易就能撰寫自動化的單元測試，此圖層。 圖 5-10，5-11 顯示測試如何配合這個架構。

![UnitTestCore](./media/image5-10.png)

**圖 5-10。** 單元測試中隔離的應用程式的核心。

![IntegrationTests](./media/image5-11.png)

**圖 5-11。** 整合測試基礎結構實作具有外部相依性。

UI 層基礎結構的專案中定義的型別上沒有直接的相依性，因為它是同樣很容易就能交換出實作中，以促進測試或在偵測到應用程式需求的變更。 ASP.NET Core 的內建的使用及相依性插入的支援可讓此架構結構非一般的整合應用程式的最適當方式。

整合應用程式的應用程式核心、 基礎結構，以及使用者介面專案是所有執行單一應用程式。 執行階段應用程式架構看起來可能像圖 5-12 版。

![ASPNET 核心架構 2](./media/image5-12.png)

**圖 5-12。** 範例 ASP.NET Core 應用程式的執行階段架構。

### <a name="organizing-code-in-clean-architecture"></a>組織全新的架構中的程式碼

在全新的架構解決方案中，每個專案都有的職責。 因此，某些類型將屬於的每個專案，而您經常可以找到對應至適當的專案中的這些類型的資料夾。

應用程式核心保存的商務模型，其中包含實體、 服務和介面。 這些介面包含抽象將會使用基礎結構，例如資料存取、 檔案系統存取權、 網路呼叫等執行的作業。有時服務或介面定義這一層將會需要使用沒有 UI 或基礎結構上的任何相依性的非實體類型。 這些可以定義為簡單的資料傳輸物件 (Dto)。

> ### <a name="application-core-types"></a>應用程式的核心類型
> -   實體 （商務模型類別保存）
> -   介面
> -   服務
> -   DTOs

基礎結構專案通常會包含資料存取實作。 在一般的 ASP.NET Core web 應用程式，這包括 Entity Framework DbContext、 已定義的任何 EF 核心移轉和資料存取實作類別。 抽象資料存取實作程式碼的最常見方式是透過使用的[儲存機制的設計模式](http://deviq.com/repository-pattern/)。

資料存取實作中，除了基礎結構專案應包含必須與基礎結構互動的服務的實作。 這些服務都應該實作應用程式核心中定義的介面，因此基礎結構應該有應用程式核心專案的參考。

> ### <a name="infrastructure-types"></a>基礎結構類型
> -   EF 核心型別 （DbContext，移轉）
> -   資料存取實作類型 （儲存機制）
> -   基礎結構特定服務 （FileLogger、 SmtpNotifier 等等）

使用者介面層，ASP.NET Core MVC 應用程式中的將應用程式的進入點，且將 ASP.NET Core MVC 專案。 這個專案應參考該應用程式核心專案和其類型應與嚴格透過定義在應用程式核心介面的基礎結構互動。 沒有直接具現化 （或靜態的呼叫） 基礎結構層類型應該獲得許可 UI 層中。

> ### <a name="ui-layer-types"></a>圖層的 UI 類型
> -   Controllers
> -   篩選條件
> -   檢視
> -   ViewModels
> -   啟動

啟動類別會負責設定應用程式，以及實作類型連接至介面，讓才能正常運作，在執行階段相依性插入。

> [!NOTE]
> 若要連接中 ConfigureServices Startup.cs 檔案中的相依性插入的 UI 專案，專案可能需要參考基礎結構專案。 此相依性可以排除，最容易使用的自訂 DI 容器。 基於此範例的目的，是讓 UI 專案，以參考基礎結構專案最簡單的方法。

## <a name="monolithic-applications-and-containers"></a>整合應用程式和容器 

您可以建立單一且整合型部署 Web 應用程式或服務，並將其部署為容器。 在應用程式可能不很龐大但組織成幾個程式庫、 元件或圖層。 外部，它是單一的容器，例如單一處理程序、 單一 web 應用程式或單一服務。

若要管理此模型，您可以部署單一容器來表示應用程式。 若要調整，只要加入使用前方負載平衡器的額外複本。 管理單一容器或 VM 中的單一部署來自簡易性。

![](./media/image5-13.png)

您可以包含多個元件/程式庫或內部的圖層中每個容器，如圖 5-X 所示。 但是，下列的容器主體*」 容器沒有一件事，和一個處理序中運作*"，整合模式可能會發生衝突。

這種方法的缺點是，如果/當應用程式成長時，需要調整。 如果縮放整個應用程式，它並非真正的問題。 不過，在大部分情況下，應用程式的某些部分會使用需要調整其他元件時淺壓深點小於。

使用一般的電子商務範例;您可能需要調整的是產品資訊元件。 更多其他客戶瀏覽產品，比購買。 更多的客戶使用及其購物籃，比使用付款管線。 較少的客戶加入註解或檢視其採購歷程記錄。 而且，您可能只需要少數幾個員工，在單一區域中，需要管理內容和行銷活動。 藉由調整僵化設計，所有的程式碼是多次部署。

除了標尺問題，所有項目變更單一元件需要完整測試整個應用程式，以及完整的重新部署的所有執行個體。

是很常見，整合的方法，許多組織正在開發使用這個架構的方法。 許多有良好足夠的結果，其他人到達限制時。 許多設計在這個模型中，其應用程式，因為工具與基礎結構太難建置服務導向架構 (SOA)，而且他們沒有看到需要-，直到應用程式成長。 如果您發現您遇到整合型方法的限制，以便讓它更充分利用容器和 microservices 分解成的應用程式可能是下一步。

![](./media/image5-14.png)

部署 Microsoft Azure 中的整合應用程式即可達成每個執行個體使用專用的 Vm。 使用[Azure VM 規模集](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)，您可以輕鬆地調整 Vm。 [Azure 應用程式服務](https://azure.microsoft.com/services/app-service/)可以執行整合的應用程式並輕鬆擴充執行個體，而不需要管理 Vm。 Azure 應用程式服務可以執行簡化部署，Docker 容器的單一執行個體。 使用 Docker 時，您可以部署單一 VM 為 Docker 主機，並執行多個執行個體。 使用 Azure 平衡器，顯示在圖 5-14，您可以管理縮放比例。

部署到不同主機都可以使用傳統部署技術來管理。 Docker 主機可以使用類似的命令來管理**執行 docker**執行手動方式或透過自動化，例如持續傳遞 (CD) 管線。

### <a name="monolithic-application-deployed-as-a-container"></a>整合應用程式部署為容器

有許多優點的使用來管理整合的應用程式部署的容器。 調整容器的執行個體是遠比快速而且容易部署額外的 Vm。 使用調整 Vm 的 VM 規模集，即使它們需要的時間執行個體。 當部署為應用程式執行個體，應用程式的組態管理 VM 的一部分。

部署更新的 Docker 映像的速度遠和有效率的網路。 Docker Images 一開始通常以秒為單位，加速首度發行。 破壞的 Docker 執行個體非常簡單，只要發出**docker stop**命令，通常少於一秒內完成。

容器是由設計原本就是不可變的因為您永遠不需要擔心損毀的 Vm，而更新指令碼，可能會忘記要部分特定組態或剩餘檔上的磁碟。

時整合的應用程式可受益於 Docker，分解成可縮放的 sub 系統整合應用程式開發，並個別部署，可能是領域的 microservices 您進入點。

> ### <a name="references--common-web-architectures"></a>參考 – 常見的 Web 架構
> - **全新的架構**  
> <https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html>
> - **洋蔥架構**  
> <http://jeffreypalermo.com/blog/the-onion-architecture-part-1/>
> - **儲存機制模式**  
> <http://deviq.com/repository-pattern/>
> - **清理架構方案範例**  
> <https://github.com/ardalis/cleanarchitecture>
> - **架構 Microservices 電子書** <http://aka.ms/MicroservicesEbook>

>[!div class="step-by-step"]
[上一個](架構-principles.md) [下一步] (常見的用戶端-側邊-web-technologies.md)
