---
title: 一般 Web 應用程式架構
description: 使用 ASP.NET Core 和 Microsoft Azure 架構現代化 Web 應用程式 | 一般 Web 應用程式架構
author: ardalis
ms.author: wiwagn
ms.date: 10/06/2017
ms.prod: .net-core
ms.technology: dotnet-docker
ms.workload:
- dotnet
- dotnetcore
ms.openlocfilehash: dc5580d38ac29a5e923a4b7d84f9d7e077d5cdb2
ms.sourcegitcommit: e7f04439d78909229506b56935a1105a4149ff3d
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/23/2017
---
#<a name="common-web-application-architectures"></a><span data-ttu-id="418d1-103">一般 Web 應用程式架構</span><span class="sxs-lookup"><span data-stu-id="418d1-103">Common Web Application Architectures</span></span>

> <span data-ttu-id="418d1-104">「如果您認為好的架構很昂貴，那就試試壞的架構吧。」</span><span class="sxs-lookup"><span data-stu-id="418d1-104">"If you think good architecture is expensive, try bad architecture."</span></span>  
> <span data-ttu-id="418d1-105">_- Brian Foote 和 Joseph Yoder_</span><span class="sxs-lookup"><span data-stu-id="418d1-105">_- Brian Foote and Joseph Yoder_</span></span>

## <a name="summary"></a><span data-ttu-id="418d1-106">總結</span><span class="sxs-lookup"><span data-stu-id="418d1-106">Summary</span></span>

<span data-ttu-id="418d1-107">大部分傳統的 .NET 應用程式會部署為單一單位，對應至在單一 IIS appdomain 內執行的可執行檔或單一 Web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="418d1-107">Most traditional .NET applications are deployed as single units corresponding to an executable or a single web application running within a single IIS appdomain.</span></span> <span data-ttu-id="418d1-108">這是最簡單的部署模型，而且很妥善地服務許多與小型的內部公用應用程式。</span><span class="sxs-lookup"><span data-stu-id="418d1-108">This is the simplest deployment model and serves many internal and smaller public applications very well.</span></span> <span data-ttu-id="418d1-109">不過，即使指定這種單一部署單位，大部分重要的商務應用程式都能受益於將邏輯稍微分割到數個層級。</span><span class="sxs-lookup"><span data-stu-id="418d1-109">However, even given this single unit of deployment, most non-trivial business applications benefit from some logical separation into several layers.</span></span>

## <a name="what-is-a-monolithic-application"></a><span data-ttu-id="418d1-110">什麼是整合型應用程式？</span><span class="sxs-lookup"><span data-stu-id="418d1-110">What is a monolithic application?</span></span>

<span data-ttu-id="418d1-111">整合型應用程式是在行為方面完全獨立的應用程式。</span><span class="sxs-lookup"><span data-stu-id="418d1-111">A monolithic application is one that is entirely self-contained, in terms of its behavior.</span></span> <span data-ttu-id="418d1-112">它可能會在執行作業的過程中，與其他服務或資料存放區互動，但它的行為核心會在自己的處理序內執行，且整個應用程式通常會部署為單一單位。</span><span class="sxs-lookup"><span data-stu-id="418d1-112">It may interact with other services or data stores in the course of performing its operations, but the core of its behavior runs within its own process and the entire application is typically deployed as a single unit.</span></span> <span data-ttu-id="418d1-113">如果這樣的應用程式需要水平縮放，通常會在多個伺服器或虛擬機器之間複製整個應用程式。</span><span class="sxs-lookup"><span data-stu-id="418d1-113">If such an application needs to scale horizontally, typically the entire application is duplicated across multiple servers or virtual machines.</span></span>

## <a name="all-in-one-applications"></a><span data-ttu-id="418d1-114">全方位應用程式</span><span class="sxs-lookup"><span data-stu-id="418d1-114">All-in-One applications</span></span>

<span data-ttu-id="418d1-115">應用程式架構專案的最小可能數目是一個。</span><span class="sxs-lookup"><span data-stu-id="418d1-115">The smallest possible number of projects for an application architecture is one.</span></span> <span data-ttu-id="418d1-116">在這種架構中，應用程式的整個邏輯都包含在單一專案內、編譯成單一組件，並部署為單一單位。</span><span class="sxs-lookup"><span data-stu-id="418d1-116">In this architecture, the entire logic of the application is contained in a single project, compiled to a single assembly, and deployed as a single unit.</span></span>

<span data-ttu-id="418d1-117">新的 ASP.NET Core 專案，不論是在 Visual Studio 或從命令列建立，一開始都是簡單的「全方位」整合型。</span><span class="sxs-lookup"><span data-stu-id="418d1-117">A new ASP.NET Core project, whether created in Visual Studio or from the command line, starts out as a simple "all-in-one" monolith.</span></span> <span data-ttu-id="418d1-118">它包含應用程式的所有行為，包括簡報、商務和資料存取邏輯。</span><span class="sxs-lookup"><span data-stu-id="418d1-118">It contains all of the behavior of the application, including presentation, business, and data access logic.</span></span> <span data-ttu-id="418d1-119">圖 5-1 顯示單一專案應用程式的檔案結構。</span><span class="sxs-lookup"><span data-stu-id="418d1-119">Figure 5-1 shows the file structure of a single-project app.</span></span>

<span data-ttu-id="418d1-120">**圖 5-1。**</span><span class="sxs-lookup"><span data-stu-id="418d1-120">**Figure 5-1.**</span></span> <span data-ttu-id="418d1-121">單一專案 ASP.NET Core 應用程式</span><span class="sxs-lookup"><span data-stu-id="418d1-121">A single project ASP.NET Core app</span></span>

![](./media/image5-1.png)

<span data-ttu-id="418d1-122">在單一專案案例中，關注點分離是透過資料夾的使用而達成。</span><span class="sxs-lookup"><span data-stu-id="418d1-122">In a single project scenario, separation of concerns is achieved through the use of folders.</span></span> <span data-ttu-id="418d1-123">預設範本包含 Models、Views 和 Controllers 等 MVC 模式責任的個別資料夾，以及適用於資料和服務的其他資料夾。</span><span class="sxs-lookup"><span data-stu-id="418d1-123">The default template includes separate folders for MVC pattern responsibilities of Models, Views, and Controllers, as well as additional folders for Data and Services.</span></span> <span data-ttu-id="418d1-124">在這種安排中，應該盡量將簡報詳細資料限制在 Views 資料夾，且資料存取實作詳細資料應該限制為保留在 Data 資料夾中的類別。</span><span class="sxs-lookup"><span data-stu-id="418d1-124">In this arrangement, presentation details should be limited as much as possible to the Views folder, and data access implementation details should be limited to classes kept in the Data folder.</span></span> <span data-ttu-id="418d1-125">商務邏輯應該位於 Models 資料夾內的服務和類別。</span><span class="sxs-lookup"><span data-stu-id="418d1-125">Business logic should reside in services and classes within the Models folder.</span></span>

<span data-ttu-id="418d1-126">雖然簡單，但單一專案整合型解決方案有一些缺點。</span><span class="sxs-lookup"><span data-stu-id="418d1-126">Although simple, the single-project monolithic solution has some disadvantages.</span></span> <span data-ttu-id="418d1-127">隨著專案的大小和複雜度增加，檔案和資料夾的數目也會持續成長。</span><span class="sxs-lookup"><span data-stu-id="418d1-127">As the project's size and complexity grows, the number of files and folders will continue to grow as well.</span></span> <span data-ttu-id="418d1-128">UI 考量 (模型、檢視、控制器) 位於不依字母順序分組在一起的多個資料夾中。</span><span class="sxs-lookup"><span data-stu-id="418d1-128">UI concerns (models, views, controllers) reside in multiple folders, which are not grouped together alphabetically.</span></span> <span data-ttu-id="418d1-129">當有其他 UI 層級建構，例如 Filter 或 ModelBinder ，新增到它們自己的資料夾中時，此問題只會惡化。</span><span class="sxs-lookup"><span data-stu-id="418d1-129">This issue only gets worse when additional UI-level constructs, such as Filters or ModelBinders, are added in their own folders.</span></span> <span data-ttu-id="418d1-130">商務邏輯散佈在 Models 和 Services 資料夾之間，且不會清楚指出哪些資料夾中的哪些類別應該相依於哪些其他類別。</span><span class="sxs-lookup"><span data-stu-id="418d1-130">Business logic is scattered between the Models and Services folders, and there is no clear indication of which classes in which folders should depend on which others.</span></span> <span data-ttu-id="418d1-131">這種在專案層級缺乏組織的情形經常會導致 [Spaghetti Code](http://deviq.com/spaghetti-code/) (非結構程式碼)。</span><span class="sxs-lookup"><span data-stu-id="418d1-131">This lack of organization at the project level frequently leads to [spaghetti code](http://deviq.com/spaghetti-code/).</span></span>

<span data-ttu-id="418d1-132">為了解決這些問題，應用程式經常演化成多專案解決方案，其中每個專案被視為位於應用程式的特定「層級」。</span><span class="sxs-lookup"><span data-stu-id="418d1-132">In order to address these issues, applications often evolve into multi-project solutions, where each project is considered to reside in a particular *layer* of the application.</span></span>

## <a name="what-are-layers"></a><span data-ttu-id="418d1-133">什麼是「層級」？</span><span class="sxs-lookup"><span data-stu-id="418d1-133">What are layers?</span></span>

<span data-ttu-id="418d1-134">當應用程式變得越來越複雜時，管理這種複雜性的一種方法，是根據應用程式的責任或關注點來分解應用程式。</span><span class="sxs-lookup"><span data-stu-id="418d1-134">As applications grow in complexity, one way to manage that complexity is to break the application up according to its responsibilities or concerns.</span></span> <span data-ttu-id="418d1-135">這會遵循關注點分離原則，並有助於成長中的程式碼庫維持井井有條，以便開發人員可以輕鬆地找到特定的功能實作在哪裡。</span><span class="sxs-lookup"><span data-stu-id="418d1-135">This follows the separation of concerns principle, and can help keep a growing codebase organized so that developers can easily find where certain functionality is implemented.</span></span> <span data-ttu-id="418d1-136">不過，除了程式碼組織之外，分層的架構還提供許多優勢。</span><span class="sxs-lookup"><span data-stu-id="418d1-136">Layered architecture offers a number of advantages beyond just code organization, though.</span></span>

<span data-ttu-id="418d1-137">藉由將程式碼組織成層級，就可以在整個應用程式重複使用通用的低階功能。</span><span class="sxs-lookup"><span data-stu-id="418d1-137">By organizing code into layers, common low-level functionality can be reused throughout the application.</span></span> <span data-ttu-id="418d1-138">這種重複使用是有益的，因為這表示需要撰寫較少的程式碼，且因為它可讓應用程式在單一實作標準化，遵循 DRY 準則。</span><span class="sxs-lookup"><span data-stu-id="418d1-138">This reuse is beneficial because it means less code needs to be written and because it can allow the application to standardize on a single implementation, following the DRY principle.</span></span>

<span data-ttu-id="418d1-139">使用分層式架構，應用程式可以強制限制哪些層級可以與其他層級通訊。</span><span class="sxs-lookup"><span data-stu-id="418d1-139">With a layered architecture, applications can enforce restrictions on which layers can communicate with other layers.</span></span> <span data-ttu-id="418d1-140">這有助於達成封裝。</span><span class="sxs-lookup"><span data-stu-id="418d1-140">This helps to achieve encapsulation.</span></span> <span data-ttu-id="418d1-141">變更或取代層級時，只有處理該層級的層級會受到影響。</span><span class="sxs-lookup"><span data-stu-id="418d1-141">When a layer is changed or replaced, only those layers that work with it should be impacted.</span></span> <span data-ttu-id="418d1-142">藉由限制哪些層級相依於哪些其他層級，變更的影響可以得到緩解，讓單一變更不會影響整個應用程式。</span><span class="sxs-lookup"><span data-stu-id="418d1-142">By limiting which layers depend on which other layers, the impact of changes can be mitigated so that a single change doesn't impact the entire application.</span></span>

<span data-ttu-id="418d1-143">層級 (和封裝) 使得可以更容易取代應用程式中的功能。</span><span class="sxs-lookup"><span data-stu-id="418d1-143">Layers (and encapsulation) make it much easier to replace functionality within the application.</span></span> <span data-ttu-id="418d1-144">例如，針對持續性，應用程式一開始可能使用自己的 SQL Server 資料庫，但後來可以選擇使用以雲端為基礎的持續性策略，或 Web API 之後的策略。</span><span class="sxs-lookup"><span data-stu-id="418d1-144">For example, an application might initially use its own SQL Server database for persistence, but later could choose to use a cloud-based persistence strategy, or one behind a web API.</span></span> <span data-ttu-id="418d1-145">如果應用程式已將其持續性實作正確封裝在邏輯層內，該 SQL Server 特定的層級可以取代為實作相同公用介面的新層級。</span><span class="sxs-lookup"><span data-stu-id="418d1-145">If the application has properly encapsulated its persistence implementation within a logical layer, that SQL Server specific layer could be replaced by a new one implementing the same public interface.</span></span>

<span data-ttu-id="418d1-146">除了為了回應未來的需求變更而換掉實作的可能性，應用程式層級也能更輕鬆地基於測試目的而換掉實作。</span><span class="sxs-lookup"><span data-stu-id="418d1-146">In addition to the potential of swapping out implementations in response to future changes in requirements, application layers can also make it easier to swap out implementations for testing purposes.</span></span> <span data-ttu-id="418d1-147">您不必撰寫測試來操作應用程式的實際資料層級或 UI 層級，這些層級可以在測試階段取代為假的實作，以提供已知的回應給要求。</span><span class="sxs-lookup"><span data-stu-id="418d1-147">Instead of having to write tests that operate against the real data layer or UI layer of the application, these layers can be replaced at test time with fake implementations that provide known responses to requests.</span></span> <span data-ttu-id="418d1-148">這通常可讓測試更容易撰寫且更快速地執行 (相較於針對應用程式的實際基礎結構來執行測試)。</span><span class="sxs-lookup"><span data-stu-id="418d1-148">This typically makes tests much easier to write and much faster to run when compared to running tests again the application's real infrastructure.</span></span>

<span data-ttu-id="418d1-149">邏輯分層是改善企業軟體應用程式中的程式碼組織的常見技術，並且有數種方式可以將程式碼組織成層級。</span><span class="sxs-lookup"><span data-stu-id="418d1-149">Logical layering is a common technique for improving the organization of code in enterprise software applications, and there are several ways in which code can be organized into layers.</span></span>

> [!NOTE]
> <span data-ttu-id="418d1-150">「層級」代表應用程式中的邏輯分隔。</span><span class="sxs-lookup"><span data-stu-id="418d1-150">*Layers* represent logical separation within the application.</span></span> <span data-ttu-id="418d1-151">應用程式邏輯實際上分佈至不同伺服器或處理程序時，這些個別的實體部署目標稱為「層」。</span><span class="sxs-lookup"><span data-stu-id="418d1-151">In the event that application logic is physically distributed to separate servers or processes, these separate physical deployment targets are referred to as *tiers*.</span></span> <span data-ttu-id="418d1-152">可能 (而且很常見) 會有 N 層應用程式部署到單一層。</span><span class="sxs-lookup"><span data-stu-id="418d1-152">It's possible, and quite common, to have an N-Layer application that is deployed to a single tier.</span></span>

## <a name="traditional-n-layer-architecture-applications"></a><span data-ttu-id="418d1-153">傳統的「N 層」架構應用程式</span><span class="sxs-lookup"><span data-stu-id="418d1-153">Traditional "N-Layer" architecture applications</span></span>

<span data-ttu-id="418d1-154">將應用程式邏輯組織成為層級的最常見方式顯示在圖 5-2 中。</span><span class="sxs-lookup"><span data-stu-id="418d1-154">The most common organization of application logic into layers it shown in Figure 5-2.</span></span>

<span data-ttu-id="418d1-155">**圖 5-2.**</span><span class="sxs-lookup"><span data-stu-id="418d1-155">**Figure 5-2.**</span></span> <span data-ttu-id="418d1-156">一般應用程式層級。</span><span class="sxs-lookup"><span data-stu-id="418d1-156">Typical application layers.</span></span>

![](./media/image5-2.png)

<span data-ttu-id="418d1-157">這些層級經常縮寫為 UI、BLL (商務邏輯層)，以及 DAL (資料存取層)。</span><span class="sxs-lookup"><span data-stu-id="418d1-157">These layers are frequently abbreviated as UI, BLL (Business Logic Layer), and DAL (Data Access Layer).</span></span> <span data-ttu-id="418d1-158">使用此架構，使用者會透過 UI 層提出要求，這個層級只與 BLL 互動。</span><span class="sxs-lookup"><span data-stu-id="418d1-158">Using this architecture, users make requests through the UI layer, which interacts only with the BLL.</span></span> <span data-ttu-id="418d1-159">接著，BLL 可以呼叫 DAL 以處理資料存取要求。</span><span class="sxs-lookup"><span data-stu-id="418d1-159">The BLL, in turn, can call the DAL for data access requests.</span></span> <span data-ttu-id="418d1-160">UI 層應該不會對 DAL 直接提出任何要求，也不應直接透過其他方式與持續性互動。</span><span class="sxs-lookup"><span data-stu-id="418d1-160">The UI layer should not make any requests to the DAL directly, nor should it interact with persistence directly through other means.</span></span> <span data-ttu-id="418d1-161">同樣地，BLL 應該只能透過 DAL 與持續性互動。</span><span class="sxs-lookup"><span data-stu-id="418d1-161">Likewise, the BLL should only interact with persistence by going through the DAL.</span></span> <span data-ttu-id="418d1-162">如此一來，每個層級都會有自己的已知責任。</span><span class="sxs-lookup"><span data-stu-id="418d1-162">In this way, each layer has its own well-known responsibility.</span></span>

<span data-ttu-id="418d1-163">這種傳統分層方法的一項缺點是編譯時間相依性會從頂端一直到底部。</span><span class="sxs-lookup"><span data-stu-id="418d1-163">One disadvantage of this traditional layering approach is that compile-time dependencies run from the top to the bottom.</span></span> <span data-ttu-id="418d1-164">也就是說，UI 層相依於 BLL，BLL 相依於 DAL。</span><span class="sxs-lookup"><span data-stu-id="418d1-164">That is, the UI layer depends on the BLL, which depends on the DAL.</span></span> <span data-ttu-id="418d1-165">這表示，通常保存應用程式中最重要邏輯的 BLL，會相依於資料存取實作細節 (且通常相依於資料庫的存在)。</span><span class="sxs-lookup"><span data-stu-id="418d1-165">This means that the BLL, which usually holds the most important logic in the application, is dependent on data access implementation details (and often on the existence of a database).</span></span> <span data-ttu-id="418d1-166">在這類架構中測試商務邏輯經常會很困難，需要一個測試資料庫。</span><span class="sxs-lookup"><span data-stu-id="418d1-166">Testing business logic in such an architecture is often difficult, requiring a test database.</span></span> <span data-ttu-id="418d1-167">相依性反轉原則可用來解決這個問題，您將會在下一節看到。</span><span class="sxs-lookup"><span data-stu-id="418d1-167">The dependency inversion principle can be used to address this issue, as you'll see in the next section.</span></span>

<span data-ttu-id="418d1-168">圖 5-3 顯示範例解決方案，會依責任 (或層級) 將應用程式分成三個專案。</span><span class="sxs-lookup"><span data-stu-id="418d1-168">Figure 5-3 shows an example solution, breaking the application into three projects by responsibility (or layer).</span></span>

<span data-ttu-id="418d1-169">**圖 5-3.**</span><span class="sxs-lookup"><span data-stu-id="418d1-169">**Figure 5-3.**</span></span> <span data-ttu-id="418d1-170">簡單的整合型應用程式，含三個專案。</span><span class="sxs-lookup"><span data-stu-id="418d1-170">A simple monolithic application with three projects.</span></span>

![](./media/image5-3.png)

<span data-ttu-id="418d1-171">雖然此應用程式為了組織的目的而使用數個專案，但它仍會部署為單一單位，且其用戶端會以單一 Web 應用程式與它互動。</span><span class="sxs-lookup"><span data-stu-id="418d1-171">Although this application uses several projects for organizational purposes, it is still deployed as a single unit and its clients will interact with it as a single web app.</span></span> <span data-ttu-id="418d1-172">這樣能有非常簡單的部署程序。</span><span class="sxs-lookup"><span data-stu-id="418d1-172">This allows for very simple deployment process.</span></span> <span data-ttu-id="418d1-173">圖 5-4 將示範這類應用程式可如何使用 Windows Azure 來裝載。</span><span class="sxs-lookup"><span data-stu-id="418d1-173">Figure 5-4 shows how such an app might be hosted using Windows Azure.</span></span>

![](./media/image5-4.png)

<span data-ttu-id="418d1-174">**圖 5-4.**</span><span class="sxs-lookup"><span data-stu-id="418d1-174">**Figure 5-4.**</span></span> <span data-ttu-id="418d1-175">Azure Web 應用程式的簡單部署</span><span class="sxs-lookup"><span data-stu-id="418d1-175">Simple deployment of Azure Web App</span></span>

<span data-ttu-id="418d1-176">當應用程式需求成長，可能需要更複雜且功能強大的部署解決方案。</span><span class="sxs-lookup"><span data-stu-id="418d1-176">As application needs grow, more complex and robust deployment solutions may be required.</span></span> <span data-ttu-id="418d1-177">圖 5-5 示範更複雜的部署計劃範例，它支援額外的功能。</span><span class="sxs-lookup"><span data-stu-id="418d1-177">Figure 5-5 shows an example of a more complex deployment plan that supports additional capabilities.</span></span>

![](./media/image5-5.png)

<span data-ttu-id="418d1-178">**圖 5-5.**</span><span class="sxs-lookup"><span data-stu-id="418d1-178">**Figure 5-5.**</span></span> <span data-ttu-id="418d1-179">將 Web 應用程式部署至 Azure App Service</span><span class="sxs-lookup"><span data-stu-id="418d1-179">Deploying a web app to an Azure App Service</span></span>

<span data-ttu-id="418d1-180">就內部而言，根據責任將此專案組織成多個專案，可以改善應用程式的可維護性。</span><span class="sxs-lookup"><span data-stu-id="418d1-180">Internally, this project's organization into multiple projects based on responsibility improves the maintainability of the application.</span></span>

<span data-ttu-id="418d1-181">此單位可以相應增加或相應放大以充分利用雲端隨選延展性。</span><span class="sxs-lookup"><span data-stu-id="418d1-181">This unit can be scaled up or out to take advantage of cloud-based on-demand scalability.</span></span> <span data-ttu-id="418d1-182">相應增加意思是新增額外的 CPU、記憶體、磁碟空間或其他資源到裝載應用程式的伺服器。</span><span class="sxs-lookup"><span data-stu-id="418d1-182">Scaling up means adding additional CPU, memory, disk space, or other resources to the server(s) hosting your app.</span></span> <span data-ttu-id="418d1-183">相應放大意思是新增這類伺服器的額外執行個體，不論這些是實體伺服器還是虛擬機器。</span><span class="sxs-lookup"><span data-stu-id="418d1-183">Scaling out means adding additional instances of such servers, whether these are physical servers or virtual machines.</span></span> <span data-ttu-id="418d1-184">當您的應用程式裝載於多個執行個體時，負載平衡器會用於將要求指派給個別的應用程式執行個體。</span><span class="sxs-lookup"><span data-stu-id="418d1-184">When your app is hosted across multiple instances, a load balancer is used to assign requests to individual app instances.</span></span>

<span data-ttu-id="418d1-185">在 Azure 中調整 Web 應用程式最簡單的方式，是在應用程式的 App Service 方案中手動設定調整。</span><span class="sxs-lookup"><span data-stu-id="418d1-185">The simplest approach to scaling a web application in Azure is to configure scaling manually in the application's App Service Plan.</span></span> <span data-ttu-id="418d1-186">圖 5-6 顯示適當的 Azure 儀表板畫面，以設定多少個執行個體正在服務應用程式。</span><span class="sxs-lookup"><span data-stu-id="418d1-186">Figure 5-6 show the appropriate Azure dashboard screen to configure how many instances are serving an app.</span></span>

![](./media/image5-6.png)

<span data-ttu-id="418d1-187">**圖 5-6。**</span><span class="sxs-lookup"><span data-stu-id="418d1-187">**Figure 5-6.**</span></span> <span data-ttu-id="418d1-188">在 Azure 中調整應用程式服務方案。</span><span class="sxs-lookup"><span data-stu-id="418d1-188">App Service Plan scaling in Azure.</span></span>

## <a name="clean-architecture"></a><span data-ttu-id="418d1-189">Clean Architecture</span><span class="sxs-lookup"><span data-stu-id="418d1-189">Clean architecture</span></span>

<span data-ttu-id="418d1-190">遵循相依性反轉原則以及 Domain-Driven 設計 (DDD) 原則的應用程式通常會達到類似的架構。</span><span class="sxs-lookup"><span data-stu-id="418d1-190">Applications that follow the Dependency Inversion Principle as well as Domain-Driven Design (DDD) principles tend to arrive at a similar architecture.</span></span> <span data-ttu-id="418d1-191">這個架構多年來有了許多名稱。</span><span class="sxs-lookup"><span data-stu-id="418d1-191">This architecture has gone by many names over the years.</span></span> <span data-ttu-id="418d1-192">最早的其中一個名稱是 Hexagonal Architecture，後來則是 Ports-and-Adapters。</span><span class="sxs-lookup"><span data-stu-id="418d1-192">One of the first names was Hexagonal Architecture, followed by Ports-and-Adapters.</span></span> <span data-ttu-id="418d1-193">最近，它被引用為 [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) 或 [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)。</span><span class="sxs-lookup"><span data-stu-id="418d1-193">More recently, it's been cited as the [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or [Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html).</span></span> <span data-ttu-id="418d1-194">最後這個名稱 Clean Architecture，在本電子書中用來作為描述架構的基礎。</span><span class="sxs-lookup"><span data-stu-id="418d1-194">It is this last name, Clean Architecture, that is used as the basis for describing the architecture in this e-book.</span></span>

> [!NOTE]
> <span data-ttu-id="418d1-195">Clean Architecture 一詞可以套用至使用 DDD 原則建置的應用程式，以及不是使用 DDD 原則建置的應用程式。</span><span class="sxs-lookup"><span data-stu-id="418d1-195">The term Clean Architecture can be applied to applications that are built using DDD Principles as well as to those that are not built using DDD.</span></span> <span data-ttu-id="418d1-196">在前者的案例，這種組合可能會稱為 Clean DDD Architecture。</span><span class="sxs-lookup"><span data-stu-id="418d1-196">In the case of the former, this combination may be referred to as "Clean DDD Architecture".</span></span>

<span data-ttu-id="418d1-197">Clean Architecture 會將商務邏輯和應用程式模型放在應用程式的中央位置。</span><span class="sxs-lookup"><span data-stu-id="418d1-197">Clean architecture puts the business logic and application model at the center of the application.</span></span> <span data-ttu-id="418d1-198">不讓商務邏輯相依於資料存取或其他基礎結構的關注點，而是反轉此相依性：基礎結構和實作詳細資料相依於應用程式核心。</span><span class="sxs-lookup"><span data-stu-id="418d1-198">Instead of having business logic depend on data access or other infrastructure concerns, this dependency is inverted: infrastructure and implementation details depend on the Application Core.</span></span> <span data-ttu-id="418d1-199">藉由在應用程式核心定義抽象或介面，然後它們會由基礎結構層中定義的類型所實作，即可達到此目的。</span><span class="sxs-lookup"><span data-stu-id="418d1-199">This is achieved by defining abstractions, or interfaces, in the Application Core, which are then implemented by types defined in the Infrastructure layer.</span></span> <span data-ttu-id="418d1-200">視覺化這個架構的常見方式是使用一系列的同心圓，類似於洋蔥。</span><span class="sxs-lookup"><span data-stu-id="418d1-200">A common way of visualizing this architecture is to use a series of concentric circles, similar to an onion.</span></span> <span data-ttu-id="418d1-201">圖 5-X 示範這種架構的表示法。</span><span class="sxs-lookup"><span data-stu-id="418d1-201">Figure 5-X shows an example of this style of architectural representation.</span></span>

![](./media/image5-7.png)

<span data-ttu-id="418d1-202">**圖 5-7.**</span><span class="sxs-lookup"><span data-stu-id="418d1-202">**Figure 5-7.**</span></span> <span data-ttu-id="418d1-203">Clean Architecture；洋蔥檢視</span><span class="sxs-lookup"><span data-stu-id="418d1-203">Clean Architecture; onion view</span></span>

<span data-ttu-id="418d1-204">在此圖中，相依性會流向最內層的圓形。</span><span class="sxs-lookup"><span data-stu-id="418d1-204">In this diagram, dependencies flow toward the innermost circle.</span></span> <span data-ttu-id="418d1-205">因此，您可以看到應用程式核心 (名字取自於它在此圖核心的位置) 對於其他應用程式層級沒有任何相依性。</span><span class="sxs-lookup"><span data-stu-id="418d1-205">Thus, you can see that the Application Core (which takes its name from its position at the core of this diagram) has no dependencies on other application layers.</span></span> <span data-ttu-id="418d1-206">在正中心是應用程式的實體和介面。</span><span class="sxs-lookup"><span data-stu-id="418d1-206">At the very center are the application's entities and interfaces.</span></span> <span data-ttu-id="418d1-207">在外面一點，但仍在應用程式核心中，則是網域服務，它們通常會實作內部圓形中定義的介面。</span><span class="sxs-lookup"><span data-stu-id="418d1-207">Just outside, but still in the Application Core, are domain services, which typically implement interfaces defined in the inner circle.</span></span> <span data-ttu-id="418d1-208">在應用程式核心外面，使用者介面與基礎結構層級都相依於應用程式核心，但彼此不一定相依。</span><span class="sxs-lookup"><span data-stu-id="418d1-208">Outside of the Application Core, both the User Interface and the Infrastructure layers depend on the Application Core, but not on one another (necessarily).</span></span>

<span data-ttu-id="418d1-209">圖 5-X 顯示更傳統的水平分層圖，更能反映出 UI 和其他層級之間的相依性。</span><span class="sxs-lookup"><span data-stu-id="418d1-209">Figure 5-X shows a more traditional horizontal layer diagram that better reflects the dependency between the UI and other layers.</span></span>

![](./media/image5-8.png)

<span data-ttu-id="418d1-210">**圖 5-8.**</span><span class="sxs-lookup"><span data-stu-id="418d1-210">**Figure 5-8.**</span></span> <span data-ttu-id="418d1-211">Clean Architecture；水平層檢視</span><span class="sxs-lookup"><span data-stu-id="418d1-211">Clean Architecture; horizontal layer view</span></span>

<span data-ttu-id="418d1-212">請注意，實心箭號代表編譯時期相依性，而虛線箭頭代表僅限執行階段的相依性。</span><span class="sxs-lookup"><span data-stu-id="418d1-212">Note that the solid arrows represent compile-time dependencies, while the dashed arrow represents a runtime-only dependency.</span></span> <span data-ttu-id="418d1-213">使用 Clean Architecture，UI 層適用於在編譯時期，在應用程式核心中定義的介面，並且在理想情況下，應該完全不知道基礎結構層定義的實作類型。</span><span class="sxs-lookup"><span data-stu-id="418d1-213">Using the clean architecture, the UI layer works with interfaces defined in the Application Core at compile time, and ideally should not have any knowledge of the implementation types defined in the Infrastructure layer.</span></span> <span data-ttu-id="418d1-214">不過，在執行階段，必須有這些實作類型，應用程式才能執行，因此它們必須存在並透過相依性插入而連接到應用程式核心介面。</span><span class="sxs-lookup"><span data-stu-id="418d1-214">At runtime, however, these implementation types will be required for the app to execute, so they will need to be present and wired up to the Application Core interfaces via dependency injection.</span></span>

<span data-ttu-id="418d1-215">圖 5-9 顯示遵循這些建議建置時，更詳細的 ASP.NET Core 應用程式架構。</span><span class="sxs-lookup"><span data-stu-id="418d1-215">Figure 5-9 shows a more detailed view of an ASP.NET Core application's architecture when built following these recommendations.</span></span>

![ASPNET Core 架構](./media/image5-9.png)

<span data-ttu-id="418d1-217">**圖 5-9.**</span><span class="sxs-lookup"><span data-stu-id="418d1-217">**Figure 5-9.**</span></span> <span data-ttu-id="418d1-218">遵循 Clean Architecture 的 ASP.NET Core 架構圖表。</span><span class="sxs-lookup"><span data-stu-id="418d1-218">ASP.NET Core architecture diagram following Clean Architecture.</span></span>

<span data-ttu-id="418d1-219">因為應用程式核心不會相依於基礎結構，所以很容易就能為此層級撰寫自動化的單元測試。</span><span class="sxs-lookup"><span data-stu-id="418d1-219">Because the Application Core doesn't depend on Infrastructure, it is very easy to write automated unit tests for this layer.</span></span> <span data-ttu-id="418d1-220">圖 5-10 和 5-11 顯示測試如何配合這個架構。</span><span class="sxs-lookup"><span data-stu-id="418d1-220">Figures 5-10 and 5-11 show how tests fit into this architecture.</span></span>

![UnitTestCore](./media/image5-10.png)

<span data-ttu-id="418d1-222">**圖 5-10.**</span><span class="sxs-lookup"><span data-stu-id="418d1-222">**Figure 5-10.**</span></span> <span data-ttu-id="418d1-223">隔離進行應用程式核心的單元測試。</span><span class="sxs-lookup"><span data-stu-id="418d1-223">Unit testing Application Core in isolation.</span></span>

![IntegrationTests](./media/image5-11.png)

<span data-ttu-id="418d1-225">**圖 5-11.**</span><span class="sxs-lookup"><span data-stu-id="418d1-225">**Figure 5-11.**</span></span> <span data-ttu-id="418d1-226">整合測試具有外部相依性的基礎結構實作。</span><span class="sxs-lookup"><span data-stu-id="418d1-226">Integration testing Infrastructure implementations with external dependencies.</span></span>

<span data-ttu-id="418d1-227">因為 UI 層對於基礎結構專案中定義的類型沒有直接的相依性，所以同樣很容易就能換掉實作，以方便測試或回應不斷變更的應用程式需求。</span><span class="sxs-lookup"><span data-stu-id="418d1-227">Since the UI layer doesn't have any direct dependency on types defined in the Infrastructure project, it is likewise very easy to swap out implementations, either to facilitate testing or in response to changing application requirements.</span></span> <span data-ttu-id="418d1-228">ASP.NET Core 的內建相依性插入使用和支援，可讓此架構成為建構重要整合型應用程式的最適當方式。</span><span class="sxs-lookup"><span data-stu-id="418d1-228">ASP.NET Core's built-in use of and support for dependency injection makes this architecture the most appropriate way to structure non-trivial monolithic applications.</span></span>

<span data-ttu-id="418d1-229">對於整合型應用程式，應用程式核心、基礎結構，以及使用者介面專案全都執行為單一應用程式。</span><span class="sxs-lookup"><span data-stu-id="418d1-229">For monolithic applications the Application Core, Infrastructure, and User Interface projects are all run as a single application.</span></span> <span data-ttu-id="418d1-230">執行階段應用程式架構看起來可能圖 5-12。</span><span class="sxs-lookup"><span data-stu-id="418d1-230">The runtime application architecture might look something like Figure 5-12.</span></span>

![ASPNET Core 架構 2](./media/image5-12.png)

<span data-ttu-id="418d1-232">**圖 5-12.**</span><span class="sxs-lookup"><span data-stu-id="418d1-232">**Figure 5-12.**</span></span> <span data-ttu-id="418d1-233">範例 ASP.NET Core 應用程式的執行階段架構。</span><span class="sxs-lookup"><span data-stu-id="418d1-233">A sample ASP.NET Core app's runtime architecture.</span></span>

### <a name="organizing-code-in-clean-architecture"></a><span data-ttu-id="418d1-234">以 Clean Architecture 組織程式碼</span><span class="sxs-lookup"><span data-stu-id="418d1-234">Organizing Code in Clean Architecture</span></span>

<span data-ttu-id="418d1-235">在 Clean Architecture 解決方案中，每個專案都有清楚的責任。</span><span class="sxs-lookup"><span data-stu-id="418d1-235">In a Clean Architecture solution, each project has clear responsibilities.</span></span> <span data-ttu-id="418d1-236">因此，某些類型將屬於每個專案，而您將經常找到對應至適當專案中的這些類型的資料夾。</span><span class="sxs-lookup"><span data-stu-id="418d1-236">As such, certain types will belong in each project and you'll frequently find folders corresponding to these types in the appropriate project.</span></span>

<span data-ttu-id="418d1-237">應用程式核心會保存商務模型，其中包含實體、服務和介面。</span><span class="sxs-lookup"><span data-stu-id="418d1-237">The Application Core holds the business model, which includes entities, services, and interfaces.</span></span> <span data-ttu-id="418d1-238">這些介面包含將使用基礎結構執行的作業抽象，例如資料存取、檔案系統存取、網路呼叫等。有時在這個層級定義的服務或介面會需要使用不相依於 UI 或基礎結構的非實體類型。</span><span class="sxs-lookup"><span data-stu-id="418d1-238">These interfaces include abstractions for operations that will be performed using Infrastructure, such as data access, file system access, network calls, etc. Sometimes services or interfaces defined at this layer will need to work with non-entity types that have no dependencies on UI or Infrastructure.</span></span> <span data-ttu-id="418d1-239">這些可以定義為簡單的資料傳輸物件 (DTO)。</span><span class="sxs-lookup"><span data-stu-id="418d1-239">These can be defined as simple Data Transfer Objects (DTOs).</span></span>

> ### <a name="application-core-types"></a><span data-ttu-id="418d1-240">應用程式核心類型</span><span class="sxs-lookup"><span data-stu-id="418d1-240">Application Core Types</span></span>
> -   <span data-ttu-id="418d1-241">實體 (持續保存的商務模型類別)</span><span class="sxs-lookup"><span data-stu-id="418d1-241">Entities (business model classes that are persisted)</span></span>
> -   <span data-ttu-id="418d1-242">介面</span><span class="sxs-lookup"><span data-stu-id="418d1-242">Interfaces</span></span>
> -   <span data-ttu-id="418d1-243">服務</span><span class="sxs-lookup"><span data-stu-id="418d1-243">Services</span></span>
> -   <span data-ttu-id="418d1-244">DTO</span><span class="sxs-lookup"><span data-stu-id="418d1-244">DTOs</span></span>

<span data-ttu-id="418d1-245">基礎結構專案通常會包含資料存取實作。</span><span class="sxs-lookup"><span data-stu-id="418d1-245">The Infrastructure project will typically include data access implementations.</span></span> <span data-ttu-id="418d1-246">在一般的 ASP.NET Core Web 應用程式中，這會包括 Entity Framework DbContext、已定義的任何 EF Core 移轉和資料存取實作類別。</span><span class="sxs-lookup"><span data-stu-id="418d1-246">In a typical ASP.NET Core web application, this will include the Entity Framework DbContext, any EF Core Migrations that have been defined, and data access implementation classes.</span></span> <span data-ttu-id="418d1-247">擷取資料存取實作程式碼的最常見方式，是透過使用 [Repository design pattern](http://deviq.com/repository-pattern/) (存放庫設計模式)。</span><span class="sxs-lookup"><span data-stu-id="418d1-247">The most common way to abstract data access implementation code is through the use of the [Repository design pattern](http://deviq.com/repository-pattern/).</span></span>

<span data-ttu-id="418d1-248">除了資料存取實作，基礎結構專案也應包含必須與基礎結構關注點互動的服務實作。</span><span class="sxs-lookup"><span data-stu-id="418d1-248">In addition to data access implementations, the Infrastructure project should contain implementations of services that must interact with infrastructure concerns.</span></span> <span data-ttu-id="418d1-249">這些服務應該實作在應用程式核心定義的介面，且基礎結構應該有應用程式核心專案的參考。</span><span class="sxs-lookup"><span data-stu-id="418d1-249">These services should implement interfaces defined in the Application Core, and so Infrastructure should have a reference to the Application Core project.</span></span>

> ### <a name="infrastructure-types"></a><span data-ttu-id="418d1-250">基礎結構類型</span><span class="sxs-lookup"><span data-stu-id="418d1-250">Infrastructure Types</span></span>
> -   <span data-ttu-id="418d1-251">EF Core 類型 (DbContext、移轉)</span><span class="sxs-lookup"><span data-stu-id="418d1-251">EF Core types (DbContext, Migrations)</span></span>
> -   <span data-ttu-id="418d1-252">資料存取實作類型 (存放庫)</span><span class="sxs-lookup"><span data-stu-id="418d1-252">Data access implementation types (Repositories)</span></span>
> -   <span data-ttu-id="418d1-253">基礎結構特定服務 (FileLogger、SmtpNotifier 等等)</span><span class="sxs-lookup"><span data-stu-id="418d1-253">Infrastructure-specific services (FileLogger, SmtpNotifier, etc.)</span></span>

<span data-ttu-id="418d1-254">ASP.NET Core MVC 應用程式中的使用者介面層將是應用程式的進入點，且將是 ASP.NET Core MVC 專案。</span><span class="sxs-lookup"><span data-stu-id="418d1-254">The user interface layer in an ASP.NET Core MVC application will be the entry point for the application, and will be an ASP.NET Core MVC project.</span></span> <span data-ttu-id="418d1-255">這個專案應該參考應用程式核心專案，而其類型應該嚴格地透過應用程式核心中定義的介面與基礎結構互動。</span><span class="sxs-lookup"><span data-stu-id="418d1-255">This project should reference the Application Core project, and its types should interact with infrastructure strictly through interfaces defined in Application Core.</span></span> <span data-ttu-id="418d1-256">在 UI 層不應該允許基礎結構層類型的任何直接具現化 (或靜態呼叫)。</span><span class="sxs-lookup"><span data-stu-id="418d1-256">No direct instantiation of (or static calls to) Infrastructure layer types should be permitted in the UI layer.</span></span>

> ### <a name="ui-layer-types"></a><span data-ttu-id="418d1-257">UI 層類型</span><span class="sxs-lookup"><span data-stu-id="418d1-257">UI Layer Types</span></span>
> -   <span data-ttu-id="418d1-258">Controllers</span><span class="sxs-lookup"><span data-stu-id="418d1-258">Controllers</span></span>
> -   <span data-ttu-id="418d1-259">篩選條件</span><span class="sxs-lookup"><span data-stu-id="418d1-259">Filters</span></span>
> -   <span data-ttu-id="418d1-260">檢視</span><span class="sxs-lookup"><span data-stu-id="418d1-260">Views</span></span>
> -   <span data-ttu-id="418d1-261">ViewModels</span><span class="sxs-lookup"><span data-stu-id="418d1-261">ViewModels</span></span>
> -   <span data-ttu-id="418d1-262">啟動</span><span class="sxs-lookup"><span data-stu-id="418d1-262">Startup</span></span>

<span data-ttu-id="418d1-263">啟動類別負責設定應用程式，以及將實作類型連接至介面，讓相依性插入能在執行階段正常運作。</span><span class="sxs-lookup"><span data-stu-id="418d1-263">The Startup class is responsible for configuring the application, and for wiring up implementation types to interfaces, allowing dependency injection to work properly at run time.</span></span>

> [!NOTE]
> <span data-ttu-id="418d1-264">若要在 UI 專案之 Startup.cs 檔的 ConfigureServices 中連接相依性插入，專案可能需要參考基礎結構專案。</span><span class="sxs-lookup"><span data-stu-id="418d1-264">In order to wire up dependency injection in ConfigureServices in the Startup.cs file of the UI project, the project may need to reference the Infrastructure project.</span></span> <span data-ttu-id="418d1-265">此相依性可以使用自訂 DI 容器來輕易地去除。</span><span class="sxs-lookup"><span data-stu-id="418d1-265">This dependency can be eliminated, most easily by using a custom DI container.</span></span> <span data-ttu-id="418d1-266">基於此範例的目的，最簡單的方法是允許 UI 專案參考基礎結構專案。</span><span class="sxs-lookup"><span data-stu-id="418d1-266">For the purposes of this sample, the simplest approach is to allow the UI project to reference the Infrastructure project.</span></span>

## <a name="monolithic-applications-and-containers"></a><span data-ttu-id="418d1-267">整合型應用程式和容器</span><span class="sxs-lookup"><span data-stu-id="418d1-267">Monolithic Applications and Containers</span></span> 

<span data-ttu-id="418d1-268">您可以建置單一且以整合型部署為基礎的 Web 應用程式或服務，並將它部署為容器。</span><span class="sxs-lookup"><span data-stu-id="418d1-268">You can build a single and monolithic-deployment based Web Application or Service and deploy it as a container.</span></span> <span data-ttu-id="418d1-269">在應用程式內，它可能不是整合型，而是組織成幾個程式庫、元件或層級。</span><span class="sxs-lookup"><span data-stu-id="418d1-269">Within the application, it might not be monolithic but organized into several libraries, components or layers.</span></span> <span data-ttu-id="418d1-270">從外部來看，它是單一容器，像是單一處理序、單一 Web 應用程式或單一服務。</span><span class="sxs-lookup"><span data-stu-id="418d1-270">Externally it is a single container like a single process, single web application or single service.</span></span>

<span data-ttu-id="418d1-271">為了管理此模型，您會部署單一容器來代表應用程式。</span><span class="sxs-lookup"><span data-stu-id="418d1-271">To manage this model, you deploy a single container to represent the application.</span></span> <span data-ttu-id="418d1-272">若要調整，只要透過前端負載平衡器新增額外的複本即可。</span><span class="sxs-lookup"><span data-stu-id="418d1-272">To scale, just add additional copies with a load balancer in front.</span></span> <span data-ttu-id="418d1-273">由於是在單一容器或 VM 中管理單一部署，因此很簡單。</span><span class="sxs-lookup"><span data-stu-id="418d1-273">The simplicity comes from managing a single deployment in a single container or VM.</span></span>

![](./media/image5-13.png)

<span data-ttu-id="418d1-274">您可以在每個容器中包含多個元件/程式庫或內部層級，如圖 5-X 所示。</span><span class="sxs-lookup"><span data-stu-id="418d1-274">You can include multiple components/libraries or internal layers within each container, as illustrated in Figure 5-X.</span></span> <span data-ttu-id="418d1-275">不過，遵循「容器執行一項動作並在一個處理序中執行該動作」的容器原則時，整合型模式可能會是一項衝突。</span><span class="sxs-lookup"><span data-stu-id="418d1-275">But, following the container principal of *"a container does one thing, and does it in one process*", the monolithic pattern might be a conflict.</span></span>

<span data-ttu-id="418d1-276">如果應用程式成長而需要擴充，此方法的缺點便會浮現。</span><span class="sxs-lookup"><span data-stu-id="418d1-276">The downside of this approach comes if/when the application grows, requiring it to scale.</span></span> <span data-ttu-id="418d1-277">若整個應用程式都擴充，則不成問題。</span><span class="sxs-lookup"><span data-stu-id="418d1-277">If the entire application scaled, it's not really a problem.</span></span> <span data-ttu-id="418d1-278">不過，在大多數情況下，應用程式只需要調整幾個造成阻礙的部分，其他元件則較少使用。</span><span class="sxs-lookup"><span data-stu-id="418d1-278">However, in most cases, a few parts of the application are the choke points requiring scaling, while other components are used less.</span></span>

<span data-ttu-id="418d1-279">使用一般的電子商務範例；您可能需要調整的是產品資訊元件。</span><span class="sxs-lookup"><span data-stu-id="418d1-279">Using the typical eCommerce example; what you likely need to scale is the product information component.</span></span> <span data-ttu-id="418d1-280">瀏覽產品的客戶比購買的人多。</span><span class="sxs-lookup"><span data-stu-id="418d1-280">Many more customers browse products than purchase them.</span></span> <span data-ttu-id="418d1-281">比起使用付款管道，會有更多客戶使用其購物籃。</span><span class="sxs-lookup"><span data-stu-id="418d1-281">More customers use their basket than use the payment pipeline.</span></span> <span data-ttu-id="418d1-282">新增留言或檢視其購買歷程記錄的客戶較少。</span><span class="sxs-lookup"><span data-stu-id="418d1-282">Fewer customers add comments or view their purchase history.</span></span> <span data-ttu-id="418d1-283">而且在單一區域中，您可能只有少數幾個員工，需要管理內容和行銷活動。</span><span class="sxs-lookup"><span data-stu-id="418d1-283">And you likely only have a handful of employees, in a single region, that need to manage the content and marketing campaigns.</span></span> <span data-ttu-id="418d1-284">藉由調整整合型設計，所有的程式碼會多次部署。</span><span class="sxs-lookup"><span data-stu-id="418d1-284">By scaling the monolithic design, all the code is deployed multiple times.</span></span>

<span data-ttu-id="418d1-285">除了全部調整的問題之外，單一元件的變更都需要完整地重新測試整個應用程式，並完整重新部署所有執行個體。</span><span class="sxs-lookup"><span data-stu-id="418d1-285">In addition to the scale everything problem, changes to a single component require complete retesting of the entire application, and a complete redeployment of all the instances.</span></span>

<span data-ttu-id="418d1-286">整合型方法很常見，許多組織也正在使用這個架構方法進行開發。</span><span class="sxs-lookup"><span data-stu-id="418d1-286">The monolithic approach is common, and many organizations are developing with this architectural approach.</span></span> <span data-ttu-id="418d1-287">許多有足夠好的結果，但其他則只是達到限制。</span><span class="sxs-lookup"><span data-stu-id="418d1-287">Many are having good enough results, while others are hitting limits.</span></span> <span data-ttu-id="418d1-288">許多組織使用此模型來設計其應用程式，因為工具和基礎結構很難建置服務導向架構 (SOA)，他們也看不到需求 - 直到應用程式成長。</span><span class="sxs-lookup"><span data-stu-id="418d1-288">Many designed their applications in this model, because the tools and infrastructure were too difficult to build service oriented architectures (SOA), and they didn't see the need - until the app grew.</span></span> <span data-ttu-id="418d1-289">如果您發現您達到整合型方法的限制，下個邏輯步驟可能是分解應用程式，以便讓它能更充分利用容器和微服務。</span><span class="sxs-lookup"><span data-stu-id="418d1-289">If you find you're hitting the limits of the monolithic approach, breaking the app up to enable it to better leverage containers and microservices may be the next logical step.</span></span>

![](./media/image5-14.png)

<span data-ttu-id="418d1-290">您可以針對每個執行個體使用專用 VM，在 Microsoft Azure 中部署整合型應用程式。</span><span class="sxs-lookup"><span data-stu-id="418d1-290">Deploying monolithic applications in Microsoft Azure can be achieved using dedicated VMs for each instance.</span></span> <span data-ttu-id="418d1-291">您可以使用 [Azure VM 擴展集](https://docs.microsoft.com/azure/virtual-machine-scale-sets/)輕鬆地調整 VM。</span><span class="sxs-lookup"><span data-stu-id="418d1-291">Using [Azure VM Scale Sets](https://docs.microsoft.com/azure/virtual-machine-scale-sets/), you can easily scale the VMs.</span></span> <span data-ttu-id="418d1-292">[Azure App Service](https://azure.microsoft.com/services/app-service/) 可以執行整合型應用程式並輕鬆地調整執行個體，而不必管理 VM。</span><span class="sxs-lookup"><span data-stu-id="418d1-292">[Azure App Services](https://azure.microsoft.com/services/app-service/) can run monolithic applications and easily scale instances without having to manage the VMs.</span></span> <span data-ttu-id="418d1-293">Azure App Service 也可以執行 Docker 容器的單一執行個體，以簡化部署。</span><span class="sxs-lookup"><span data-stu-id="418d1-293">Azure App Services can run single instances of Docker containers as well, simplifying the deployment.</span></span> <span data-ttu-id="418d1-294">使用 Docker 時，您可以部署單一 VM 作為 Docker 主機，並執行多個執行個體。</span><span class="sxs-lookup"><span data-stu-id="418d1-294">Using Docker, you can deploy a single VM as a Docker host, and run multiple instances.</span></span> <span data-ttu-id="418d1-295">使用 Azure 平衡器，如圖 5-14 中所示，您可以管理調整。</span><span class="sxs-lookup"><span data-stu-id="418d1-295">Using the Azure balancer, as shown in the Figure 5-14, you can manage scaling.</span></span>

<span data-ttu-id="418d1-296">您可以透過傳統部署技術來管理不同主機的部署，</span><span class="sxs-lookup"><span data-stu-id="418d1-296">The deployment to the various hosts can be managed with traditional deployment techniques.</span></span> <span data-ttu-id="418d1-297">並可以手動執行 **docker run** 等命令，或是透過持續傳遞 (CD) 管線等自動化方法來管理 Docker 主機。</span><span class="sxs-lookup"><span data-stu-id="418d1-297">The Docker hosts can be managed with commands like **docker run** performed manually, or through automation such as Continuous Delivery (CD) pipelines.</span></span>

### <a name="monolithic-application-deployed-as-a-container"></a><span data-ttu-id="418d1-298">整合型應用程式部署為容器</span><span class="sxs-lookup"><span data-stu-id="418d1-298">Monolithic application deployed as a container</span></span>

<span data-ttu-id="418d1-299">使用容器來管理整合型應用程式部署有許多優點。</span><span class="sxs-lookup"><span data-stu-id="418d1-299">There are benefits of using containers to manage monolithic application deployments.</span></span> <span data-ttu-id="418d1-300">調整容器執行個體遠比部署額外的 VM 更輕鬆快速。</span><span class="sxs-lookup"><span data-stu-id="418d1-300">Scaling the instances of containers is far faster and easier than deploying additional VMs.</span></span> <span data-ttu-id="418d1-301">即使是使用VM 擴展集來調整 VM，它們也需要時間具現化。</span><span class="sxs-lookup"><span data-stu-id="418d1-301">Even when using VM Scale Sets to scale VMs, they take time to instance.</span></span> <span data-ttu-id="418d1-302">當部署為應用程式執行個體時，應用程式的設定是作為 VM 的一部分管理。</span><span class="sxs-lookup"><span data-stu-id="418d1-302">When deployed as app instances, the configuration of the app is managed as part of the VM.</span></span>

<span data-ttu-id="418d1-303">以 Docker 映像來部署更新會更快且網路效率更高。</span><span class="sxs-lookup"><span data-stu-id="418d1-303">Deploying updates as Docker images is far faster and network efficient.</span></span> <span data-ttu-id="418d1-304">Docker 映像通常只要幾秒鐘就能啟動，因此可加速推出。</span><span class="sxs-lookup"><span data-stu-id="418d1-304">Docker Images typically start in seconds, speeding rollouts.</span></span> <span data-ttu-id="418d1-305">卸除 Docker 執行個體很容易，只要發出 **docker stop** 命令即可，而且通常不到一秒就會完成。</span><span class="sxs-lookup"><span data-stu-id="418d1-305">Tearing down a Docker instance is as easy as issuing a **docker stop** command, typically completing in less than a second.</span></span>

<span data-ttu-id="418d1-306">容器的設計原本就是不可變的，您永遠不需要擔心 VM 損毀，而更新指令碼可能會忘記處理部分特定設定或是檔案殘留在磁碟上。</span><span class="sxs-lookup"><span data-stu-id="418d1-306">As containers are inherently immutable by design, you never need to worry about corrupted VMs, whereas update scripts might forget to account for some specific configuration or file left on disk.</span></span>

<span data-ttu-id="418d1-307">雖然整合型應用程式可以從 Docker 受益，但將整合型應用程式分成可個別調整、開發及部署的多個子系統，是您開始使用微服務的不錯起點。</span><span class="sxs-lookup"><span data-stu-id="418d1-307">While monolithic apps can benefit from Docker, breaking up the monolithic application into sub systems which can be scaled, developed and deployed individually may be your entry point into the realm of microservices.</span></span>

> ### <a name="references--common-web-architectures"></a><span data-ttu-id="418d1-308">參考 – 常見的 Web 架構</span><span class="sxs-lookup"><span data-stu-id="418d1-308">References – Common Web Architectures</span></span>
> - <span data-ttu-id="418d1-309">**Clean Architecture**</span><span class="sxs-lookup"><span data-stu-id="418d1-309">**The Clean Architecture**</span></span>  
> <span data-ttu-id="418d1-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span><span class="sxs-lookup"><span data-stu-id="418d1-310"><https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html></span></span>
> - <span data-ttu-id="418d1-311">**Onion Architecture**</span><span class="sxs-lookup"><span data-stu-id="418d1-311">**The Onion Architecture**</span></span>  
> <span data-ttu-id="418d1-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span><span class="sxs-lookup"><span data-stu-id="418d1-312"><http://jeffreypalermo.com/blog/the-onion-architecture-part-1/></span></span>
> - <span data-ttu-id="418d1-313">**存放庫模式**</span><span class="sxs-lookup"><span data-stu-id="418d1-313">**The Repository Pattern**</span></span>  
> <span data-ttu-id="418d1-314"><http://deviq.com/repository-pattern/></span><span class="sxs-lookup"><span data-stu-id="418d1-314"><http://deviq.com/repository-pattern/></span></span>
> - <span data-ttu-id="418d1-315">**Clean Architecture 解決方案範例**</span><span class="sxs-lookup"><span data-stu-id="418d1-315">**Clean Architecture Solution Sample**</span></span>  
> <span data-ttu-id="418d1-316"><https://github.com/ardalis/cleanarchitecture></span><span class="sxs-lookup"><span data-stu-id="418d1-316"><https://github.com/ardalis/cleanarchitecture></span></span>
> - <span data-ttu-id="418d1-317">**Architecting Microservices e-book** (架構微服務電子書) <http://aka.ms/MicroservicesEbook></span><span class="sxs-lookup"><span data-stu-id="418d1-317">**Architecting Microservices e-book** <http://aka.ms/MicroservicesEbook></span></span>

>[!div class="step-by-step"]
<span data-ttu-id="418d1-318">[上一頁] (architectural-principles.md) [下一頁] (common-client-side-web-technologies.md)</span><span class="sxs-lookup"><span data-stu-id="418d1-318">[Previous] (architectural-principles.md) [Next] (common-client-side-web-technologies.md)</span></span>
