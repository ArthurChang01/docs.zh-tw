---
title: 參考組件
description: 瞭解引用程式集，這是 .NET 中一種僅包含庫公共 API 曲面的特殊類型的程式集
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: 938942caf81c54a8aa9207dbe87559438ffb252e
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/15/2020
ms.locfileid: "79141064"
---
# <a name="reference-assemblies"></a><span data-ttu-id="4ef77-103">參考組件</span><span class="sxs-lookup"><span data-stu-id="4ef77-103">Reference assemblies</span></span>

<span data-ttu-id="4ef77-104">*引用程式集*是一種特殊類型的程式集，僅包含表示庫的公共 API 曲面所需的最小中繼資料量。</span><span class="sxs-lookup"><span data-stu-id="4ef77-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="4ef77-105">它們包括在生成工具中引用程式集時具有重大意義的所有成員的聲明，但不包括對其 API 協定沒有可觀察到影響的所有成員的實現和聲明。</span><span class="sxs-lookup"><span data-stu-id="4ef77-105">They include declarations for all members that are significant when referencing an assembly in build tools, but exclude all member implementations and declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="4ef77-106">相反，常規程式集稱為*實現程式集*。</span><span class="sxs-lookup"><span data-stu-id="4ef77-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span>

<span data-ttu-id="4ef77-107">無法載入引用程式集以執行，但它們可以以與實現程式集相同的方式作為編譯器輸入傳遞。</span><span class="sxs-lookup"><span data-stu-id="4ef77-107">Reference assemblies can't be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="4ef77-108">參考程式集通常與特定平臺或庫的軟體發展工具組 （SDK） 一起分發。</span><span class="sxs-lookup"><span data-stu-id="4ef77-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library.</span></span>

<span data-ttu-id="4ef77-109">使用引用程式集使開發人員能夠構建針對特定庫版本的程式，而無需為該版本提供完整的實現程式集。</span><span class="sxs-lookup"><span data-stu-id="4ef77-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="4ef77-110">假設電腦上只有某些庫的最新版本，但您希望構建針對該庫的早期版本的程式。</span><span class="sxs-lookup"><span data-stu-id="4ef77-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets an earlier version of that library.</span></span> <span data-ttu-id="4ef77-111">如果直接針對實現程式集進行編譯，則可能會無意中使用早期版本中不可用的 API 成員。</span><span class="sxs-lookup"><span data-stu-id="4ef77-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version.</span></span> <span data-ttu-id="4ef77-112">只有在目的電腦上測試程式時，您才會發現此錯誤。</span><span class="sxs-lookup"><span data-stu-id="4ef77-112">You'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="4ef77-113">如果針對早期版本的引用程式集進行編譯，則將立即收到編譯時間錯誤。</span><span class="sxs-lookup"><span data-stu-id="4ef77-113">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="4ef77-114">引用程式集還可以表示協定，即一組與具體實現程式集不對應的 API。</span><span class="sxs-lookup"><span data-stu-id="4ef77-114">A reference assembly can also represent a contract, that is, a set of APIs that don't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="4ef77-115">此類引用程式集稱為*協定程式集*，可用於定位支援同一組 API 的多個平臺。</span><span class="sxs-lookup"><span data-stu-id="4ef77-115">Such reference assemblies, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="4ef77-116">例如，.NET 標準提供合同程式集*netstandard.dll*，表示不同 .NET 平臺之間共用的一組公共 API。</span><span class="sxs-lookup"><span data-stu-id="4ef77-116">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="4ef77-117">這些 API 的實現包含在不同平臺上的不同程式集中，例如 .NET 框架或系統上的 mscorlib.dll.private.CoreLib.dll. *mscorlib.dll* *System.Private.CoreLib.dll*</span><span class="sxs-lookup"><span data-stu-id="4ef77-117">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="4ef77-118">面向 .NET 標準庫的庫可以在支援 .NET 標準的所有平臺上運行。</span><span class="sxs-lookup"><span data-stu-id="4ef77-118">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span>

## <a name="using-reference-assemblies"></a><span data-ttu-id="4ef77-119">使用參考程式集</span><span class="sxs-lookup"><span data-stu-id="4ef77-119">Using reference assemblies</span></span>

<span data-ttu-id="4ef77-120">要使用專案中的某些 API，必須添加對其程式集的引用。</span><span class="sxs-lookup"><span data-stu-id="4ef77-120">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="4ef77-121">您可以添加對實現程式集或引用程式集的引用。</span><span class="sxs-lookup"><span data-stu-id="4ef77-121">You can add references to either implementation assemblies or to reference assemblies.</span></span> <span data-ttu-id="4ef77-122">建議您在可用時使用參考程式集。</span><span class="sxs-lookup"><span data-stu-id="4ef77-122">It's recommended you use reference assemblies whenever they're available.</span></span> <span data-ttu-id="4ef77-123">這樣做可確保僅使用目標版本中受支援的 API 成員，該成員供 API 設計人員使用。</span><span class="sxs-lookup"><span data-stu-id="4ef77-123">Doing so ensures that you're using only the supported API members in the target version, meant to be used by API designers.</span></span> <span data-ttu-id="4ef77-124">使用引用程式集可確保不會依賴于實現詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="4ef77-124">Using the reference assembly ensures you're not taking a dependency on implementation details.</span></span>

<span data-ttu-id="4ef77-125">.NET 框架庫的引用程式集與目標包一起分發。</span><span class="sxs-lookup"><span data-stu-id="4ef77-125">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="4ef77-126">您可以通過下載獨立安裝程式或在 Visual Studio 安裝程式中選擇元件來獲取它們。</span><span class="sxs-lookup"><span data-stu-id="4ef77-126">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="4ef77-127">有關詳細資訊，請參閱[為開發人員安裝 .NET 框架](../../framework/install/guide-for-developers.md)。</span><span class="sxs-lookup"><span data-stu-id="4ef77-127">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="4ef77-128">對於 .NET 核心和 .NET 標準，參考程式集根據需要自動下載（通過 NuGet）並引用。</span><span class="sxs-lookup"><span data-stu-id="4ef77-128">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="4ef77-129">對於 .NET Core 3.0 及更高版本，核心框架的引用程式集位於[Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref)包中[（Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App)包用於 3.0 之前的版本）。</span><span class="sxs-lookup"><span data-stu-id="4ef77-129">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span> <span data-ttu-id="4ef77-130">有關詳細資訊，請參閱 .NET 核心指南中的[包、元包和框架](../../core/packages.md)。</span><span class="sxs-lookup"><span data-stu-id="4ef77-130">For more information, see [Packages, metapackages, and frameworks](../../core/packages.md) in the .NET Core Guide.</span></span>

<span data-ttu-id="4ef77-131">使用"增加參考"對話方塊在 Visual Studio 中添加對 .NET 框架程式集**的引用**時，將從清單中選擇一個程式集，Visual Studio 會自動查找與專案中選擇的目標框架版本對應的引用程式集。</span><span class="sxs-lookup"><span data-stu-id="4ef77-131">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="4ef77-132">這同樣適用于使用[引用](/visualstudio/msbuild/common-msbuild-project-items#reference)專案項直接將引用添加到 MSBuild 專案中：您只需指定程式集名稱，而無需指定完整檔路徑。</span><span class="sxs-lookup"><span data-stu-id="4ef77-132">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="4ef77-133">當您通過使用`-reference`編譯器選項（[在 C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md)和 Visual [Basic](../../visual-basic/reference/command-line-compiler/reference.md)中）或使用 Roslyn API<xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType>中的方法在命令列中添加對這些程式集的引用時，必須手動指定正確目標平臺版本的引用程式集檔。</span><span class="sxs-lookup"><span data-stu-id="4ef77-133">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="4ef77-134">.NET 框架參考程式集檔位於 *%程式檔 （x86）%\\引用\\程式集\\微軟\\框架 中。NETFramework*目錄。</span><span class="sxs-lookup"><span data-stu-id="4ef77-134">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="4ef77-135">對於 .NET Core，通過將`PreserveCompilationContext`專案屬性設置為`true`，可以強制發佈操作將目標平臺的引用程式集複製到輸出目錄的*發佈/refs*子目錄中。</span><span class="sxs-lookup"><span data-stu-id="4ef77-135">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="4ef77-136">然後，您可以將這些引用程式集檔傳遞給編譯器。</span><span class="sxs-lookup"><span data-stu-id="4ef77-136">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="4ef77-137">使用`DependencyContext` [Microsoft.擴展.依賴模型](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/)包可以説明查找其路徑。</span><span class="sxs-lookup"><span data-stu-id="4ef77-137">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="4ef77-138">因為它們不包含實現，因此無法載入引用程式集以執行。</span><span class="sxs-lookup"><span data-stu-id="4ef77-138">Because they contain no implementation, reference assemblies can't be loaded for execution.</span></span> <span data-ttu-id="4ef77-139">嘗試這樣做會導致 。 <xref:System.BadImageFormatException?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="4ef77-139">Trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4ef77-140">如果要檢查引用程式集的內容，可以將其載入到 .NET 框架中的僅反射上下文（使用<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>方法）或<xref:System.Reflection.MetadataLoadContext>in .NET Core 中。</span><span class="sxs-lookup"><span data-stu-id="4ef77-140">If you want to examine the contents of a reference assembly, you can load it into the reflection-only context in .NET Framework (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method) or into the <xref:System.Reflection.MetadataLoadContext> in .NET Core.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="4ef77-141">生成引用程式集</span><span class="sxs-lookup"><span data-stu-id="4ef77-141">Generating reference assemblies</span></span>

<span data-ttu-id="4ef77-142">當庫消費者需要根據許多不同版本的庫構建其程式時，為庫生成引用程式集非常有用。</span><span class="sxs-lookup"><span data-stu-id="4ef77-142">Generating reference assemblies for your libraries can be useful when your library consumers need to build their programs against many different versions of the library.</span></span> <span data-ttu-id="4ef77-143">分發所有這些版本的實現程式集可能由於其大大小而不切實際。</span><span class="sxs-lookup"><span data-stu-id="4ef77-143">Distributing implementation assemblies for all these versions might be impractical because of their large size.</span></span> <span data-ttu-id="4ef77-144">參考程式集的大小較小，將它們分發到庫的 SDK 中會減小下載大小並節省磁碟空間。</span><span class="sxs-lookup"><span data-stu-id="4ef77-144">Reference assemblies are smaller in size, and distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="4ef77-145">IDI 和生成工具還可以利用參考程式集來縮短包含多個類庫的大型解決方案的生成時間。</span><span class="sxs-lookup"><span data-stu-id="4ef77-145">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="4ef77-146">通常，在增量生成方案中，當專案的任何輸入檔（包括它所依賴的程式集）發生更改時，將重新生成專案。</span><span class="sxs-lookup"><span data-stu-id="4ef77-146">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="4ef77-147">每當程式師更改任何成員的實現時，實現程式集都會更改。</span><span class="sxs-lookup"><span data-stu-id="4ef77-147">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="4ef77-148">僅當其公共 API 受到影響時，引用程式集才會更改。</span><span class="sxs-lookup"><span data-stu-id="4ef77-148">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="4ef77-149">因此，在某些情況下，使用引用程式集作為輸入檔而不是實現程式集允許跳過從屬專案的生成。</span><span class="sxs-lookup"><span data-stu-id="4ef77-149">So, using the reference assembly as an input file instead of the implementation assembly allows skipping the build of the dependent project in some cases.</span></span>

<span data-ttu-id="4ef77-150">您可以生成引用程式集：</span><span class="sxs-lookup"><span data-stu-id="4ef77-150">You can generate reference assemblies:</span></span>

- <span data-ttu-id="4ef77-151">在 MSBuild 專案中，通過使用[`ProduceReferenceAssembly`專案屬性](/visualstudio/msbuild/common-msbuild-project-properties)。</span><span class="sxs-lookup"><span data-stu-id="4ef77-151">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="4ef77-152">`-refonly`從命令列編譯器時，通過指定 （[C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [視覺基本](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md)）`-refout`或 （[C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [視覺化基本](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)） 編譯器選項。</span><span class="sxs-lookup"><span data-stu-id="4ef77-152">When compiling program from command line, by specifiying `-refonly` ([C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md) / [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="4ef77-153">使用 Roslyn API 時，<xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType>通過`true`設置<xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType>到`false`和 到 傳遞給<xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType>方法的物件。</span><span class="sxs-lookup"><span data-stu-id="4ef77-153">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="4ef77-154">如果要使用 NuGet 包分發引用程式集，則必須將它們包含在包目錄下的*ref\\*子目錄中，而不是用於實現程式集的*lib\\*子目錄中。</span><span class="sxs-lookup"><span data-stu-id="4ef77-154">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="4ef77-155">參考程式集結構</span><span class="sxs-lookup"><span data-stu-id="4ef77-155">Reference assemblies structure</span></span>

<span data-ttu-id="4ef77-156">引用程式集是相關概念（*僅中繼資料程式集）的*擴展。</span><span class="sxs-lookup"><span data-stu-id="4ef77-156">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="4ef77-157">僅中繼資料組件以單一的 `throw null` 主體取代其方法主體，但包含匿名型別以外的所有成員。</span><span class="sxs-lookup"><span data-stu-id="4ef77-157">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="4ef77-158">使用`throw null`實體（而不是沒有實體）的原因是**PEVerify**可以運行和傳遞（從而驗證中繼資料的完整性）。</span><span class="sxs-lookup"><span data-stu-id="4ef77-158">The reason for using `throw null` bodies (as opposed to no bodies) is so that **PEVerify** can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="4ef77-159">參考組件會進一步移除來自僅中繼資料組件的中繼資料 (私用成員)：</span><span class="sxs-lookup"><span data-stu-id="4ef77-159">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="4ef77-160">參考組件只有在 API 介面中所需項目的參考。</span><span class="sxs-lookup"><span data-stu-id="4ef77-160">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="4ef77-161">實際的組件可能有與特定實作相關的其他參考。</span><span class="sxs-lookup"><span data-stu-id="4ef77-161">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="4ef77-162">例如，的`class C { private void M() { dynamic d = 1; ... } }`引用程式集不引用 所需的`dynamic`任何類型。</span><span class="sxs-lookup"><span data-stu-id="4ef77-162">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` doesn't reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="4ef77-163">如果移除它們不會明顯影響編譯的話，則會移除私用函式的成員 (方法、屬性和事件)。</span><span class="sxs-lookup"><span data-stu-id="4ef77-163">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="4ef77-164">如果沒有[內部可見到](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute)屬性，也會刪除內建函式成員。</span><span class="sxs-lookup"><span data-stu-id="4ef77-164">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="4ef77-165">引用程式集中的中繼資料繼續保留以下資訊：</span><span class="sxs-lookup"><span data-stu-id="4ef77-165">The metadata in reference assemblies continues to keep the following information:</span></span>

- <span data-ttu-id="4ef77-166">所有類型，包括私有類型和巢狀型別。</span><span class="sxs-lookup"><span data-stu-id="4ef77-166">All types, including private and nested types.</span></span>
- <span data-ttu-id="4ef77-167">所有屬性，甚至是內部屬性。</span><span class="sxs-lookup"><span data-stu-id="4ef77-167">All attributes, even internal ones.</span></span>
- <span data-ttu-id="4ef77-168">所有虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="4ef77-168">All virtual methods.</span></span>
- <span data-ttu-id="4ef77-169">明確介面實作。</span><span class="sxs-lookup"><span data-stu-id="4ef77-169">Explicit interface implementations.</span></span>
- <span data-ttu-id="4ef77-170">顯式實現的屬性和事件，因為它們的訪問器是虛擬的。</span><span class="sxs-lookup"><span data-stu-id="4ef77-170">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="4ef77-171">結構的所有欄位。</span><span class="sxs-lookup"><span data-stu-id="4ef77-171">All fields of structures.</span></span>

<span data-ttu-id="4ef77-172">參考程式集包括程式集級[參考程式集](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute)屬性。</span><span class="sxs-lookup"><span data-stu-id="4ef77-172">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="4ef77-173">此屬性可以在源中指定;但是，此屬性可以在源中指定。然後編譯器不需要合成它。</span><span class="sxs-lookup"><span data-stu-id="4ef77-173">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="4ef77-174">由於此屬性，運行時將拒絕載入引用程式集以執行（但它們可以在僅反射模式下載入）。</span><span class="sxs-lookup"><span data-stu-id="4ef77-174">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can be loaded in reflection-only mode).</span></span>

<span data-ttu-id="4ef77-175">確切的引用程式集結構詳細資訊取決於編譯器版本。</span><span class="sxs-lookup"><span data-stu-id="4ef77-175">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="4ef77-176">如果較新版本被確定為不影響公共 API 表面，則可能會選擇排除更多中繼資料。</span><span class="sxs-lookup"><span data-stu-id="4ef77-176">Newer versions may choose to exclude more metadata if it's determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="4ef77-177">本節中的資訊僅適用于 Roslyn 編譯器從 C# 版本 7.1 或 Visual Basic 版本 15.3 開始的引用程式集。</span><span class="sxs-lookup"><span data-stu-id="4ef77-177">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="4ef77-178">.NET 框架和 .NET 核心庫的引用程式集的結構在某些細節上可能有所不同，因為它們使用它們自己的生成引用程式集的機制。</span><span class="sxs-lookup"><span data-stu-id="4ef77-178">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="4ef77-179">例如，它們可能具有完全空的方法體，而不是`throw null`正文。</span><span class="sxs-lookup"><span data-stu-id="4ef77-179">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="4ef77-180">但一般原則仍然適用：它們沒有可用的方法實現，並且僅包含從公共 API 角度具有可觀察影響的成員的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="4ef77-180">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="4ef77-181">另請參閱</span><span class="sxs-lookup"><span data-stu-id="4ef77-181">See also</span></span>

- [<span data-ttu-id="4ef77-182">.NET 中的組件</span><span class="sxs-lookup"><span data-stu-id="4ef77-182">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="4ef77-183">Framework 目標概觀</span><span class="sxs-lookup"><span data-stu-id="4ef77-183">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="4ef77-184">如何：使用參考管理器添加或刪除引用</span><span class="sxs-lookup"><span data-stu-id="4ef77-184">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
