---
title: 參考組件
description: 瞭解參考元件，這是 .NET 中只包含程式庫公用 API 介面的特殊元件類型
author: MSDN-WhiteKnight
ms.date: 09/12/2019
ms.technology: dotnet-standard
ms.openlocfilehash: f509397f5cb48a004b800014b2b071721e0d68b8
ms.sourcegitcommit: 1f12db2d852d05bed8c53845f0b5a57a762979c8
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/18/2019
ms.locfileid: "72582847"
---
# <a name="reference-assemblies"></a><span data-ttu-id="a0f3d-103">參考組件</span><span class="sxs-lookup"><span data-stu-id="a0f3d-103">Reference assemblies</span></span>

<span data-ttu-id="a0f3d-104">*參考元件*是一種特殊類型的元件，其中只包含代表程式庫公用 API 介面所需的最小中繼資料量。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-104">*Reference assemblies* are a special type of assembly that contain only the minimum amount of metadata required to represent the library's public API surface.</span></span> <span data-ttu-id="a0f3d-105">其中包括在建立工具中參考元件時，所有重要成員的宣告（也就是名稱），但會排除所有成員的執行，以及不會對其 API 合約造成明顯影響的私用成員宣告。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-105">They include declarations for all members that are significant when referencing an assembly in build tools (hence the name), but exclude all member implementations as well as declarations of private members that have no observable impact on their API contract.</span></span> <span data-ttu-id="a0f3d-106">相反地，一般元件稱為「*實做元件*」。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-106">In contrast, regular assemblies are called *implementation assemblies*.</span></span> 

<span data-ttu-id="a0f3d-107">無法載入參考元件來執行，但是可以用相同的方式，將它們當做編譯器輸入來傳遞。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-107">Reference assemblies cannot be loaded for execution, but they can be passed as compiler input in the same way as implementation assemblies.</span></span> <span data-ttu-id="a0f3d-108">參考元件通常會與特定平臺或程式庫的軟體發展工具組（SDK）一起散發，這個特殊軟體元件只會安裝在開發人員電腦上。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-108">Reference assemblies are usually distributed with the Software Development Kit (SDK) of a particular platform or library, a special software component installed only on developer machines.</span></span>

<span data-ttu-id="a0f3d-109">使用參考元件可讓開發人員建立以特定程式庫版本為目標的程式，而不需要該版本的完整執行元件。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-109">Using a reference assembly enables developers to build programs that target a specific library version without having the full implementation assembly for that version.</span></span> <span data-ttu-id="a0f3d-110">假設您的電腦上只有部分程式庫的最新版本，但您想要建立以具有舊版該程式庫的電腦為目標的程式。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-110">Suppose, you have only the latest version of some library on your machine, but you want to build a program that targets a machine with an earlier version of that library.</span></span> <span data-ttu-id="a0f3d-111">如果您直接針對執行元件進行編譯，可能會不小心使用舊版中未提供的 API 成員，而且您只會在目的電腦上測試程式時發現此錯誤。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-111">If you compile directly against the implementation assembly, you might inadvertently use API members that aren't available in the earlier version, and you'll only find this mistake when testing the program on the target machine.</span></span> <span data-ttu-id="a0f3d-112">如果您針對較早版本的參考元件進行編譯，則會立即收到編譯時期錯誤。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-112">If you compile against the reference assembly for the earlier version, you'll immediately get a compile-time error.</span></span>

<span data-ttu-id="a0f3d-113">此外，參考元件可以代表合約，也就是不會對應到具體執行元件的一組 Api。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-113">Additionally, a reference assembly can represent a contract, that is, a set of APIs that doesn't correspond to the concrete implementation assembly.</span></span> <span data-ttu-id="a0f3d-114">這類參考元件（稱為*合約元件*）可用來以支援同一組 api 的多個平臺為目標。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-114">Such reference assembly, called the *contract assembly*, can be used to target multiple platforms that support the same set of APIs.</span></span> <span data-ttu-id="a0f3d-115">例如，.NET Standard 提供合約元件*netstandard*，代表不同 .net 平臺之間共用的一組通用 api。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-115">For example, .NET Standard provides the contract assembly, *netstandard.dll*, that represents the set of common APIs shared between different .NET platforms.</span></span> <span data-ttu-id="a0f3d-116">這些 Api 的執行包含在不同平臺的不同元件中，例如在 .NET Core 上 .NET Framework 或*CoreLib*上的*mscorlib.dll* 。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-116">The implementations of these APIs are contained in different assemblies on different platforms, such as *mscorlib.dll* on .NET Framework or *System.Private.CoreLib.dll* on .NET Core.</span></span> <span data-ttu-id="a0f3d-117">以 .NET Standard 為目標的程式庫可以在支援 .NET Standard 的所有平臺上執行。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-117">A library that targets .NET Standard can run on all platforms that support .NET Standard.</span></span> 

## <a name="using-reference-assemblies"></a><span data-ttu-id="a0f3d-118">使用參考元件</span><span class="sxs-lookup"><span data-stu-id="a0f3d-118">Using reference assemblies</span></span>

<span data-ttu-id="a0f3d-119">若要使用專案中的特定 Api，您必須加入其元件的參考。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-119">To use certain APIs from your project, you must add references to their assemblies.</span></span> <span data-ttu-id="a0f3d-120">您可以直接將參考加入至實作為執行元件或參考元件。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-120">You can add references either to implementation assemblies directly or to reference assemblies.</span></span> <span data-ttu-id="a0f3d-121">我們強烈建議您隨時使用參考元件，因為這麼做可確保您只會使用目標版本中支援的 API 成員，且應供 API 設計人員使用（換句話說，不會採用相依性）。在 [執行詳細資料] 上）。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-121">We strongly recommend that you use reference assemblies whenever they are available, because doing so ensures that you are using only API members that are supported in the target version and are meant to be used by API designers (in other words, not taking a dependency on implementation details).</span></span>

<span data-ttu-id="a0f3d-122">.NET Framework 程式庫的參考元件會與目標套件一起散發。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-122">Reference assemblies for the .NET Framework libraries are distributed with targeting packs.</span></span> <span data-ttu-id="a0f3d-123">您可以藉由下載獨立安裝程式或在 Visual Studio 安裝程式中選取元件來取得它們。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-123">You can obtain them by downloading a standalone installer or by selecting a component in Visual Studio installer.</span></span> <span data-ttu-id="a0f3d-124">如需詳細資訊，請參閱[安裝適用于開發人員的 .NET Framework](../../framework/install/guide-for-developers.md)。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-124">For more information, see [Install the .NET Framework for developers](../../framework/install/guide-for-developers.md).</span></span> <span data-ttu-id="a0f3d-125">針對 .NET Core 和 .NET Standard，參考元件會視需要自動下載（透過 NuGet）並加以參考。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-125">For .NET Core and .NET Standard, reference assemblies are automatically downloaded as necessary (via NuGet) and referenced.</span></span> <span data-ttu-id="a0f3d-126">針對 .NET Core 3.0 和更新版本，核心架構的參考元件位於[NETCore](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref)中，而不是使用[NETCore 應用程式](https://www.nuget.org/packages/Microsoft.NETCore.App)套件（3.0 之前的版本）。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-126">For .NET Core 3.0 and higher, the reference assemblies for the core framework are in the [Microsoft.NETCore.App.Ref](https://www.nuget.org/packages/Microsoft.NETCore.App.Ref) package (the [Microsoft.NETCore.App](https://www.nuget.org/packages/Microsoft.NETCore.App) package is used instead for versions before 3.0).</span></span> <span data-ttu-id="a0f3d-127">如需詳細資訊，請參閱 .NET Core 指南中的[封裝、中繼套件和](../../core/packages.md)架構。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-127">For more information, see [Packages, metapackages and frameworks](../../core/packages.md) in the .NET Core Guide.</span></span>

<span data-ttu-id="a0f3d-128">當您使用 [**加入參考**] 對話方塊，在 Visual Studio 中加入 .NET Framework 元件的參考時，您可以從清單中選取元件，然後 Visual Studio 自動尋找對應至目標 Framework 版本的參考元件。已在您的專案中選取。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-128">When you add references to .NET Framework assemblies in Visual Studio using the **Add reference** dialog, you select an assembly from the list, and Visual Studio automatically finds reference assemblies that correspond to the target framework version selected in your project.</span></span> <span data-ttu-id="a0f3d-129">這同樣適用于使用[參考](/visualstudio/msbuild/common-msbuild-project-items#reference)專案專案，直接在 MSBuild 專案中加入參考：您只需要指定元件名稱，而不是完整的檔案路徑。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-129">The same applies to adding references directly into MSBuild project using the  [Reference](/visualstudio/msbuild/common-msbuild-project-items#reference) project item: you only need to specify the assembly name, not the full file path.</span></span> <span data-ttu-id="a0f3d-130">當您在命令列中使用 `-reference` 編譯器選項（[在C# ](../../csharp/language-reference/compiler-options/reference-compiler-option.md)和中[Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)）新增這些元件的參考，或在 Roslyn API 中使用 <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> 方法時，您必須手動指定的參考元件檔案。正確的目標平臺版本。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-130">When you add references to these assemblies in the command line by using the `-reference` compiler option ([in C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) and in [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md)) or by using the <xref:Microsoft.CodeAnalysis.Compilation.AddReferences%2A?displayProperty=nameWithType> method in the Roslyn API, you must manually specify reference assembly files for the correct target platform version.</span></span> <span data-ttu-id="a0f3d-131">.NET Framework 參考元件檔案位於 *% ProgramFiles （x86）% \\Reference 元件 \\Microsoft \\Framework \\. .netframework*目錄中。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-131">.NET Framework reference assembly files are located in the *%ProgramFiles(x86)%\\Reference Assemblies\\Microsoft\\Framework\\.NETFramework* directory.</span></span> <span data-ttu-id="a0f3d-132">針對 .NET Core，您可以藉由將 `PreserveCompilationContext` 專案屬性設定為 `true`，強制發行作業將目標平臺的參考元件複製到輸出目錄的*publish/refs*子目錄中。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-132">For .NET Core, you can force publish operation to copy reference assemblies for your target platform into the *publish/refs* subdirectory of your output directory by setting the `PreserveCompilationContext` project property to `true`.</span></span> <span data-ttu-id="a0f3d-133">然後您可以將這些參考元件檔案傳遞給編譯器。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-133">Then you can pass these reference assembly files to the compiler.</span></span> <span data-ttu-id="a0f3d-134">使用[DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/)套件中的 `DependencyContext` 有助於找出其路徑。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-134">Using `DependencyContext` from [Microsoft.Extensions.DependencyModel](https://www.nuget.org/packages/Microsoft.Extensions.DependencyModel/) package can help locate their paths.</span></span>

<span data-ttu-id="a0f3d-135">因為它們不包含任何實作為，所以無法載入參考元件來執行;嘗試這麼做會導致 <xref:System.BadImageFormatException?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-135">Because they contain no implementation, reference assemblies cannot be loaded for execution; trying to do so results in a <xref:System.BadImageFormatException?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a0f3d-136">不過，如果您需要檢查其內容，它們仍然可以載入僅限反映的內容（使用 <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>）方法。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-136">However, they still can be loaded into the reflection-only context (using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>) method, if you need to examine their contents.</span></span>

## <a name="generating-reference-assemblies"></a><span data-ttu-id="a0f3d-137">產生參考元件</span><span class="sxs-lookup"><span data-stu-id="a0f3d-137">Generating reference assemblies</span></span>

<span data-ttu-id="a0f3d-138">當您的程式庫取用者經常需要針對許多不同版本的程式庫建立其程式時（亦即，當您需要執行類似于 .NET Framework 目標套件的功能時），產生程式庫的參考元件會很有用。以上所述，適用于您自己的專案）。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-138">Generating reference assemblies for your libraries can be useful when your library consumers often need to build their programs against many different versions of the library (that is, when you need to implement a feature similar to .NET Framework Targeting Packs mentioned above for your own project).</span></span> <span data-ttu-id="a0f3d-139">散發所有這些版本的實做元件，可能會因為大小龐大而不可行。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-139">Distributing implementation assemblies for all these versions might be impractical due to their large size.</span></span> <span data-ttu-id="a0f3d-140">參考元件的大小較小，因此將它們散發為程式庫 SDK 的一部分可減少下載大小並節省磁碟空間。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-140">Reference assemblies are smaller in size, so distributing them as a part of your library's SDK reduces download size and saves disk space.</span></span>

<span data-ttu-id="a0f3d-141">Ide 和 build 工具也可以利用參考元件，在包含多個類別庫的大型解決方案時，減少組建時間。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-141">IDEs and build tools also can take advantage of reference assemblies to reduce build times in case of large solutions consisting of multiple class libraries.</span></span> <span data-ttu-id="a0f3d-142">通常，在累加組建案例中，當任何輸入檔變更時，會重建專案，包括它所相依的元件。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-142">Usually, in incremental build scenarios a project is rebuilt when any of its input files are changed, including the assemblies it depends on.</span></span> <span data-ttu-id="a0f3d-143">每當程式設計人員變更任何成員的執行時，就會變更執行元件。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-143">The implementation assembly changes whenever the programmer changes the implementation of any member.</span></span> <span data-ttu-id="a0f3d-144">參考元件只會在其公用 API 受到影響時變更。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-144">The reference assembly only changes when its public API is affected.</span></span> <span data-ttu-id="a0f3d-145">因此，在某些情況下，使用參考元件做為輸入檔，而不是執行元件，可讓略過相依專案的組建。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-145">Therefore, using the reference assembly as an input file instead of the implementation assembly allows to skip the build of the dependent project in some cases.</span></span> 

<span data-ttu-id="a0f3d-146">您可以產生參考元件：</span><span class="sxs-lookup"><span data-stu-id="a0f3d-146">You can generate reference assemblies:</span></span>

- <span data-ttu-id="a0f3d-147">在 MSBuild 專案中，使用[`ProduceReferenceAssembly` 專案屬性](/visualstudio/msbuild/common-msbuild-project-properties)。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-147">In an MSBuild project, by using the [`ProduceReferenceAssembly` project property](/visualstudio/msbuild/common-msbuild-project-properties).</span></span>
- <span data-ttu-id="a0f3d-148">從命令列編譯器時，請指定 `-refonly` （[在C# ](../../csharp/language-reference/compiler-options/refonly-compiler-option.md) [Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md)中）或 `-refout` （[in C# ](../../csharp/language-reference/compiler-options/refout-compiler-option.md) [Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)）編譯器選項。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-148">When compiling program from command line, by specifiying `-refonly` ([in C#](../../csharp/language-reference/compiler-options/refonly-compiler-option.md), [in Visual Basic](../../visual-basic/reference/command-line-compiler/refonly-compiler-option.md) ) or `-refout` ([in C#](../../csharp/language-reference/compiler-options/refout-compiler-option.md), [in Visual Basic](../../visual-basic/reference/command-line-compiler/refout-compiler-option.md)) compiler options.</span></span>
- <span data-ttu-id="a0f3d-149">使用 Roslyn API 時，藉由將 <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> 設定為 `true`，並在傳遞至 <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> 方法的物件中 <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> `false`。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-149">When using the Roslyn API, by setting <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.EmitMetadataOnly?displayProperty=nameWithType> to `true` and <xref:Microsoft.CodeAnalysis.Emit.EmitOptions.IncludePrivateMembers?displayProperty=nameWithType> to `false` in an object passed to the <xref:Microsoft.CodeAnalysis.Compilation.Emit%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="a0f3d-150">如果您想要使用 NuGet 套件散發參考元件，您必須將它們包含在封裝目錄下的*ref \\* 子目錄中，而不是在用於執行元件的*lib \\* 子目錄中。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-150">If you want to distribute reference assemblies with NuGet packages, you must include them in the *ref\\* subdirectory under the package directory instead of in the *lib\\* subdirectory used for implementation assemblies.</span></span>

## <a name="reference-assemblies-structure"></a><span data-ttu-id="a0f3d-151">參考元件結構</span><span class="sxs-lookup"><span data-stu-id="a0f3d-151">Reference assemblies structure</span></span>

<span data-ttu-id="a0f3d-152">參考元件是相關概念的擴充，*僅限中繼資料的元件*。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-152">Reference assemblies are an expansion of the related concept, *metadata-only assemblies*.</span></span> <span data-ttu-id="a0f3d-153">僅中繼資料組件以單一的 `throw null` 主體取代其方法主體，但包含匿名型別以外的所有成員。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-153">Metadata-only assemblies have their method bodies replaced with a single `throw null` body, but include all members except anonymous types.</span></span> <span data-ttu-id="a0f3d-154">使用 `throw null` 主體（而不是任何主體）的原因，是為了讓 PEVerify 能夠執行和傳遞（藉此驗證中繼資料的完整性）。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-154">The reason for using `throw null` bodies (as opposed to no bodies) is so that PEVerify can run and pass (thus validating the completeness of the metadata).</span></span>

<span data-ttu-id="a0f3d-155">參考組件會進一步移除來自僅中繼資料組件的中繼資料 (私用成員)：</span><span class="sxs-lookup"><span data-stu-id="a0f3d-155">Reference assemblies further remove metadata (private members) from metadata-only assemblies:</span></span>

- <span data-ttu-id="a0f3d-156">參考組件只有在 API 介面中所需項目的參考。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-156">A reference assembly only has references for what it needs in the API surface.</span></span> <span data-ttu-id="a0f3d-157">實際的組件可能有與特定實作相關的其他參考。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-157">The real assembly may have additional references related to specific implementations.</span></span> <span data-ttu-id="a0f3d-158">例如，`class C { private void M() { dynamic d = 1; ... } }` 的參考組件不參考 `dynamic` 所需的任何類型。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-158">For instance, the reference assembly for `class C { private void M() { dynamic d = 1; ... } }` does not reference any types required for `dynamic`.</span></span>
- <span data-ttu-id="a0f3d-159">如果移除它們不會明顯影響編譯的話，則會移除私用函式的成員 (方法、屬性和事件)。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-159">Private function-members (methods, properties, and events) are removed in cases where their removal doesn't observably impact compilation.</span></span> <span data-ttu-id="a0f3d-160">如果沒有[InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute)屬性，內部函式成員也會一併移除。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-160">If there are no [InternalsVisibleTo](xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute) attributes, internal function members are also removed.</span></span>

<span data-ttu-id="a0f3d-161">參考元件中的中繼資料會繼續保留下列資訊：</span><span class="sxs-lookup"><span data-stu-id="a0f3d-161">The metadata in reference assemblies continues to retain information about the following:</span></span>

- <span data-ttu-id="a0f3d-162">所有類型，包括私用和巢狀型別。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-162">All types, including private and nested types.</span></span>
- <span data-ttu-id="a0f3d-163">所有屬性，甚至是內部屬性。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-163">All attributes, even internal ones.</span></span>
- <span data-ttu-id="a0f3d-164">所有的虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-164">All virtual methods.</span></span>
- <span data-ttu-id="a0f3d-165">明確介面的實現。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-165">Explicit interface implementations.</span></span> 
- <span data-ttu-id="a0f3d-166">明確實作為屬性和事件，因為它們的存取子是虛擬的。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-166">Explicitly implemented properties and events, because their accessors are virtual.</span></span>
- <span data-ttu-id="a0f3d-167">結構的所有欄位。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-167">All fields of structures.</span></span> 

<span data-ttu-id="a0f3d-168">參考元件包含元件層級的[ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute)屬性。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-168">Reference assemblies include an assembly-level [ReferenceAssembly](xref:System.Runtime.CompilerServices.ReferenceAssemblyAttribute) attribute.</span></span> <span data-ttu-id="a0f3d-169">可以在來源中指定這個屬性。然後編譯器不需要合成它。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-169">This attribute may be specified in source; then the compiler won't need to synthesize it.</span></span> <span data-ttu-id="a0f3d-170">因為這個屬性，執行階段會拒絕載入參考組件以供執行 (但仍可載入僅限反映模式)。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-170">Because of this attribute, runtimes will refuse to load reference assemblies for execution (but they can still be loaded in reflection-only mode).</span></span>

<span data-ttu-id="a0f3d-171">確切的參考元件結構詳細資料取決於編譯器版本。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-171">Exact reference assembly structure details depend on the compiler version.</span></span> <span data-ttu-id="a0f3d-172">如果判斷為不會影響公用 API 介面，較新版本可能會選擇排除更多的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-172">Newer versions may choose to exclude more metadata if it is determined as not affecting the public API surface.</span></span>

> [!NOTE]
> <span data-ttu-id="a0f3d-173">本節中的資訊僅適用于從C# 7.1 版或 Visual Basic 版本15.3 開始的 Roslyn 編譯器所產生的參考元件。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-173">Information in this section is applicable only to reference assemblies generated by Roslyn compilers starting from C# version 7.1 or Visual Basic version 15.3.</span></span> <span data-ttu-id="a0f3d-174">.NET Framework 和 .NET Core 程式庫的參考元件結構在某些詳細資料中可能會有不同，因為它們會使用自己產生參考元件的機制。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-174">The structure of reference assemblies for .NET Framework and .NET Core libraries can differ in some details, because they use their own mechanism of generating reference assemblies.</span></span> <span data-ttu-id="a0f3d-175">例如，它們可能會有完全空白的方法主體，而不是 `throw null` 主體。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-175">For example, they might have totally empty method bodies instead of the `throw null` body.</span></span> <span data-ttu-id="a0f3d-176">但是一般原則仍然適用：它們沒有可使用的方法，而且只包含對公用 API 觀點有明顯影響的成員的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="a0f3d-176">But the general principle still applies: they don't have usable method implementations and contain metadata only for members that have an observable impact from a public API perspective.</span></span>

## <a name="see-also"></a><span data-ttu-id="a0f3d-177">請參閱</span><span class="sxs-lookup"><span data-stu-id="a0f3d-177">See also</span></span>

- [<span data-ttu-id="a0f3d-178">.NET 中的組件</span><span class="sxs-lookup"><span data-stu-id="a0f3d-178">Assemblies in .NET</span></span>](index.md)
- [<span data-ttu-id="a0f3d-179">具有元件的程式</span><span class="sxs-lookup"><span data-stu-id="a0f3d-179">Program with assemblies</span></span>](program.md)
- [<span data-ttu-id="a0f3d-180">Framework 目標概觀</span><span class="sxs-lookup"><span data-stu-id="a0f3d-180">Framework targeting overview</span></span>](/visualstudio/ide/visual-studio-multi-targeting-overview)
- [<span data-ttu-id="a0f3d-181">如何：使用參考管理員加入或移除參考</span><span class="sxs-lookup"><span data-stu-id="a0f3d-181">How to: Add or remove references by using the Reference Manager</span></span>](/visualstudio/ide/how-to-add-or-remove-references-by-using-the-reference-manager)
