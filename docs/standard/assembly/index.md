---
title: .NET 中的組件
ms.date: 08/15/2019
ms.assetid: 149f5ca5-5b34-4746-9542-1ae43b2d0256
helpviewer_keywords:
- dynamic assemblies
- security [.NET Framework], boundaries
- boundaries of assemblies
- assemblies [.NET Framework], about
- assemblies [.NET Framework], boundaries
- reference scope boundaries
- assemblies [.NET Framework]
- version boundaries
- type boundaries
ms.openlocfilehash: b61d079a86bdd4a809d44ad128f19a7b358c8384
ms.sourcegitcommit: b75a45f0cfe012b71b45dd9bf723adf32369d40c
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/24/2020
ms.locfileid: "80228670"
---
# <a name="assemblies-in-net"></a><span data-ttu-id="4fb12-102">.NET 中的組件</span><span class="sxs-lookup"><span data-stu-id="4fb12-102">Assemblies in .NET</span></span>

<span data-ttu-id="4fb12-103">程式集構成 部署、版本控制、重用、啟動範圍和 的安全許可權的基本單位。基於 NET 的應用程式。</span><span class="sxs-lookup"><span data-stu-id="4fb12-103">Assemblies form the fundamental units of deployment, version control, reuse, activation scoping, and security permissions for .NET-based applications.</span></span> <span data-ttu-id="4fb12-104">組件是建置來共同運作及構成一個功能邏輯單位的型別與資源集合。</span><span class="sxs-lookup"><span data-stu-id="4fb12-104">An assembly is a collection of types and resources that are built to work together and form a logical unit of functionality.</span></span> <span data-ttu-id="4fb12-105">程式集採用可執行 （*.exe*） 或動態連結程式庫 （*.dll*） 檔的形式， 是 .NET 應用程式的構建基塊.</span><span class="sxs-lookup"><span data-stu-id="4fb12-105">Assemblies take the form of executable (*.exe*) or dynamic link library (*.dll*) files, and are the building blocks of .NET applications.</span></span> <span data-ttu-id="4fb12-106">它們為通用語言執行平台提供了感知型別實作所需的資訊。</span><span class="sxs-lookup"><span data-stu-id="4fb12-106">They provide the common language runtime with the information it needs to be aware of type implementations.</span></span>

<span data-ttu-id="4fb12-107">在 .NET Core 和 .NET 框架中，可以從一個或多個原始程式碼檔構建程式集。</span><span class="sxs-lookup"><span data-stu-id="4fb12-107">In .NET Core and .NET Framework, you can build an assembly from one or more source code files.</span></span> <span data-ttu-id="4fb12-108">在 .NET Framework 中，組件可以包含一或多個模組。</span><span class="sxs-lookup"><span data-stu-id="4fb12-108">In .NET Framework, assemblies can contain one or more modules.</span></span> <span data-ttu-id="4fb12-109">這允許規劃更大的專案，以便多個開發人員可以處理單獨的原始程式碼檔或模組，這些檔或模組組合起來以創建單個程式集。</span><span class="sxs-lookup"><span data-stu-id="4fb12-109">This allows larger projects to be planned so that several developers can work on separate source code files or modules, which are combined to create a single assembly.</span></span> <span data-ttu-id="4fb12-110">有關模組的詳細資訊，請參閱[如何：構建多檔程式集](../../framework/app-domains/build-multifile-assembly.md)。</span><span class="sxs-lookup"><span data-stu-id="4fb12-110">For more information about modules, see [How to: Build a multifile assembly](../../framework/app-domains/build-multifile-assembly.md).</span></span>

<span data-ttu-id="4fb12-111">組件包含下列屬性：</span><span class="sxs-lookup"><span data-stu-id="4fb12-111">Assemblies have the following properties:</span></span>

- <span data-ttu-id="4fb12-112">程式集作為 *.exe*或 *.dll*檔實現。</span><span class="sxs-lookup"><span data-stu-id="4fb12-112">Assemblies are implemented as *.exe* or *.dll* files.</span></span>

- <span data-ttu-id="4fb12-113">對於以 .NET 框架為目標的庫，可以通過將程式集放在[全域組件快取 （GAC）](../../framework/app-domains/gac.md)中來在應用程式之間共用組件。</span><span class="sxs-lookup"><span data-stu-id="4fb12-113">For libraries that target the .NET Framework, you can share assemblies between applications by putting them in the [global assembly cache (GAC)](../../framework/app-domains/gac.md).</span></span> <span data-ttu-id="4fb12-114">必須先強式名稱程式集，然後才能將它們包含在 GAC 中。</span><span class="sxs-lookup"><span data-stu-id="4fb12-114">You must strong-name assemblies before you can include them in the GAC.</span></span> <span data-ttu-id="4fb12-115">有關詳細資訊，請參閱[強命名程式集](strong-named.md)。</span><span class="sxs-lookup"><span data-stu-id="4fb12-115">For more information, see [Strong-named assemblies](strong-named.md).</span></span>

- <span data-ttu-id="4fb12-116">系統只會在需要時才將組件載入到記憶體。</span><span class="sxs-lookup"><span data-stu-id="4fb12-116">Assemblies are only loaded into memory if they are required.</span></span> <span data-ttu-id="4fb12-117">如果未使用它們，則未載入它們。</span><span class="sxs-lookup"><span data-stu-id="4fb12-117">If they aren't used, they aren't loaded.</span></span> <span data-ttu-id="4fb12-118">這表示使用組件可以有效地管理大型專案中的資源。</span><span class="sxs-lookup"><span data-stu-id="4fb12-118">This means that assemblies can be an efficient way to manage resources in larger projects.</span></span>

- <span data-ttu-id="4fb12-119">藉由使用反映，您能以程式設計方式取得組件的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="4fb12-119">You can programmatically obtain information about an assembly by using reflection.</span></span> <span data-ttu-id="4fb12-120">如需詳細資訊，請參閱[反映 (C#)](../../csharp/programming-guide/concepts/reflection.md) 或 [Reflection (Visual Basic)](../../visual-basic/programming-guide/concepts/reflection.md) (反映 (Visual Basic))。</span><span class="sxs-lookup"><span data-stu-id="4fb12-120">For more information, see [Reflection (C#)](../../csharp/programming-guide/concepts/reflection.md) or [Reflection (Visual Basic)](../../visual-basic/programming-guide/concepts/reflection.md).</span></span>

- <span data-ttu-id="4fb12-121">只需使用 .NET Core 中的<xref:System.Reflection.MetadataLoadContext>類和 .NET Core 和<xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType>.NET 框架中的 or<xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A?displayProperty=nameWithType>方法，即可載入程式集以對其進行檢查。</span><span class="sxs-lookup"><span data-stu-id="4fb12-121">You can load an assembly just to inspect it by using the <xref:System.Reflection.MetadataLoadContext> class in .NET Core and the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A?displayProperty=nameWithType> methods in .NET Core and .NET Framework.</span></span>

## <a name="assemblies-in-the-common-language-runtime"></a><span data-ttu-id="4fb12-122">通用語言運行時中的程式集</span><span class="sxs-lookup"><span data-stu-id="4fb12-122">Assemblies in the common language runtime</span></span>

<span data-ttu-id="4fb12-123">程式集為通用語言運行時提供需要瞭解類型實現的資訊。</span><span class="sxs-lookup"><span data-stu-id="4fb12-123">Assemblies provide the common language runtime with the information it needs to be aware of type implementations.</span></span> <span data-ttu-id="4fb12-124">對於執行階段而言，型別不會存在於組件的內容以外。</span><span class="sxs-lookup"><span data-stu-id="4fb12-124">To the runtime, a type does not exist outside the context of an assembly.</span></span>

<span data-ttu-id="4fb12-125">程式集定義以下資訊：</span><span class="sxs-lookup"><span data-stu-id="4fb12-125">An assembly defines the following information:</span></span>

- <span data-ttu-id="4fb12-126">公共語言運行時執行的代碼。</span><span class="sxs-lookup"><span data-stu-id="4fb12-126">Code that the common language runtime executes.</span></span> <span data-ttu-id="4fb12-127">請注意，每個程式集只能有一個進入點： `DllMain` `WinMain`、`Main`或 。</span><span class="sxs-lookup"><span data-stu-id="4fb12-127">Note that each assembly can have only one entry point: `DllMain`, `WinMain`, or `Main`.</span></span>

- <span data-ttu-id="4fb12-128">安全邊界。</span><span class="sxs-lookup"><span data-stu-id="4fb12-128">Security boundary.</span></span> <span data-ttu-id="4fb12-129">組件是要求和授與權限的單位。</span><span class="sxs-lookup"><span data-stu-id="4fb12-129">An assembly is the unit at which permissions are requested and granted.</span></span> <span data-ttu-id="4fb12-130">有關程式集中的安全邊界的詳細資訊，請參閱[程式集安全注意事項](security-considerations.md)。</span><span class="sxs-lookup"><span data-stu-id="4fb12-130">For more information about security boundaries in assemblies, see [Assembly security considerations](security-considerations.md).</span></span>

- <span data-ttu-id="4fb12-131">類型邊界。</span><span class="sxs-lookup"><span data-stu-id="4fb12-131">Type boundary.</span></span> <span data-ttu-id="4fb12-132">每種型別的識別都包含該型別所在之組件的名稱。</span><span class="sxs-lookup"><span data-stu-id="4fb12-132">Every type's identity includes the name of the assembly in which it resides.</span></span> <span data-ttu-id="4fb12-133">在某個組件範圍中載入的型別 `MyType` 與在另一個組件範圍中載入的型別 `MyType` 不同。</span><span class="sxs-lookup"><span data-stu-id="4fb12-133">A type called `MyType` that is loaded in the scope of one assembly is not the same as a type called `MyType` that is loaded in the scope of another assembly.</span></span>

- <span data-ttu-id="4fb12-134">引用範圍邊界。</span><span class="sxs-lookup"><span data-stu-id="4fb12-134">Reference scope boundary.</span></span> <span data-ttu-id="4fb12-135">[組件資訊清單](#assembly-manifest)具有用於解析類型和滿足資源請求的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="4fb12-135">The [assembly manifest](#assembly-manifest) has metadata that is used for resolving types and satisfying resource requests.</span></span> <span data-ttu-id="4fb12-136">清單指定要在程式集外部公開的類型和資源，並枚舉它所依賴的其他程式集。</span><span class="sxs-lookup"><span data-stu-id="4fb12-136">The manifest specifies the types and resources to expose outside the assembly, and enumerates other assemblies on which it depends.</span></span> <span data-ttu-id="4fb12-137">微軟中間語言 （MSIL） 代碼在可移植可執行 （PE） 檔中將不會執行，除非它有一個關聯的[組件資訊清單](#assembly-manifest)。</span><span class="sxs-lookup"><span data-stu-id="4fb12-137">Microsoft intermediate language (MSIL) code in a portable executable (PE) file won't be executed unless it has an associated [assembly manifest](#assembly-manifest).</span></span>

- <span data-ttu-id="4fb12-138">版本邊界。</span><span class="sxs-lookup"><span data-stu-id="4fb12-138">Version boundary.</span></span> <span data-ttu-id="4fb12-139">程式集是通用語言運行時中最小的可版本單元。</span><span class="sxs-lookup"><span data-stu-id="4fb12-139">The assembly is the smallest versionable unit in the common language runtime.</span></span> <span data-ttu-id="4fb12-140">同一程式集中的所有類型和資源都作為一個單元進行版本控制。</span><span class="sxs-lookup"><span data-stu-id="4fb12-140">All types and resources in the same assembly are versioned as a unit.</span></span> <span data-ttu-id="4fb12-141">[組件資訊清單](#assembly-manifest)描述為任何依存性程式集指定的版本依賴項。</span><span class="sxs-lookup"><span data-stu-id="4fb12-141">The [assembly manifest](#assembly-manifest) describes the version dependencies you specify for any dependent assemblies.</span></span> <span data-ttu-id="4fb12-142">有關版本控制的詳細資訊，請參閱[程式集版本控制](versioning.md)。</span><span class="sxs-lookup"><span data-stu-id="4fb12-142">For more information about versioning, see [Assembly versioning](versioning.md).</span></span>

- <span data-ttu-id="4fb12-143">部署單元。</span><span class="sxs-lookup"><span data-stu-id="4fb12-143">Deployment unit.</span></span> <span data-ttu-id="4fb12-144">當應用程式啟動時，一定要有應用程式一開始所呼叫的組件。</span><span class="sxs-lookup"><span data-stu-id="4fb12-144">When an application starts, only the assemblies that the application initially calls must be present.</span></span> <span data-ttu-id="4fb12-145">可以按需檢索其他程式集，如包含當地語系化資源或實用程式類的程式集。</span><span class="sxs-lookup"><span data-stu-id="4fb12-145">Other assemblies, such as assemblies containing localization resources or utility classes, can be retrieved on demand.</span></span> <span data-ttu-id="4fb12-146">這允許應用程式在首次下載時簡單而精簡。</span><span class="sxs-lookup"><span data-stu-id="4fb12-146">This allows apps to be simple and thin when first downloaded.</span></span> <span data-ttu-id="4fb12-147">有關部署程式集的詳細資訊，請參閱[部署應用程式](../../framework/deployment/index.md)。</span><span class="sxs-lookup"><span data-stu-id="4fb12-147">For more information about deploying assemblies, see [Deploy applications](../../framework/deployment/index.md).</span></span>

- <span data-ttu-id="4fb12-148">並排執行單元。</span><span class="sxs-lookup"><span data-stu-id="4fb12-148">Side-by-side execution unit.</span></span> <span data-ttu-id="4fb12-149">有關運行程式集的多個版本的詳細資訊，請參閱[程式集和並存執行](side-by-side-execution.md)。</span><span class="sxs-lookup"><span data-stu-id="4fb12-149">For more information about running multiple versions of an assembly, see [Assemblies and side-by-side execution](side-by-side-execution.md).</span></span>

## <a name="create-an-assembly"></a><span data-ttu-id="4fb12-150">創建程式集</span><span class="sxs-lookup"><span data-stu-id="4fb12-150">Create an assembly</span></span>

<span data-ttu-id="4fb12-151">組件可以是靜態，也可以是動態。</span><span class="sxs-lookup"><span data-stu-id="4fb12-151">Assemblies can be static or dynamic.</span></span> <span data-ttu-id="4fb12-152">靜態組件儲存在磁碟上的可攜式執行檔 (PE) 中。</span><span class="sxs-lookup"><span data-stu-id="4fb12-152">Static assemblies are stored on disk in portable executable (PE) files.</span></span> <span data-ttu-id="4fb12-153">靜態程式集可以包括介面、類和資源，如點陣圖、JPEG 檔和其他資源檔。</span><span class="sxs-lookup"><span data-stu-id="4fb12-153">Static assemblies can include interfaces, classes, and resources like bitmaps, JPEG files, and other resource files.</span></span> <span data-ttu-id="4fb12-154">您還可以創建動態程式集，這些程式集直接從記憶體運行，在執行之前不會保存到磁片。</span><span class="sxs-lookup"><span data-stu-id="4fb12-154">You can also create dynamic assemblies, which are run directly from memory and aren't saved to disk before execution.</span></span> <span data-ttu-id="4fb12-155">您可以在執行動態組件之後，再將其儲存至磁碟。</span><span class="sxs-lookup"><span data-stu-id="4fb12-155">You can save dynamic assemblies to disk after they have executed.</span></span>

<span data-ttu-id="4fb12-156">您可以使用幾種方式建立組件。</span><span class="sxs-lookup"><span data-stu-id="4fb12-156">There are several ways to create assemblies.</span></span> <span data-ttu-id="4fb12-157">您可以使用開發工具（如 Visual Studio）來創建 *.dll*或 *.exe*檔。</span><span class="sxs-lookup"><span data-stu-id="4fb12-157">You can use development tools, such as Visual Studio, that can create *.dll* or *.exe* files.</span></span> <span data-ttu-id="4fb12-158">您可以使用 Windows SDK 中的工具創建包含來自其他開發環境的模組的程式集。</span><span class="sxs-lookup"><span data-stu-id="4fb12-158">You can use tools in the Windows SDK to create assemblies with modules from other development environments.</span></span> <span data-ttu-id="4fb12-159">您也可以使用 Common Language Runtime API (例如 <xref:System.Reflection.Emit?displayProperty=nameWithType>) 來建立動態組件。</span><span class="sxs-lookup"><span data-stu-id="4fb12-159">You can also use common language runtime APIs, such as <xref:System.Reflection.Emit?displayProperty=nameWithType>, to create dynamic assemblies.</span></span>

<span data-ttu-id="4fb12-160">通過在 Visual Studio 中構建程式集、使用 .NET Core 命令列介面工具構建程式集或使用命令列編譯器構建 .NET 框架程式集來編譯器集。</span><span class="sxs-lookup"><span data-stu-id="4fb12-160">Compile assemblies by building them in Visual Studio, building them with .NET Core command-line interface tools, or building .NET Framework assemblies with a command-line compiler.</span></span> <span data-ttu-id="4fb12-161">有關使用 .NET 核心 CLI 構建程式集的詳細資訊，請參閱[.NET 核心 CLI 概述](../../core/tools/index.md)。</span><span class="sxs-lookup"><span data-stu-id="4fb12-161">For more information about building assemblies using .NET Core CLI, see [.NET Core CLI overview](../../core/tools/index.md).</span></span> <span data-ttu-id="4fb12-162">有關使用命令列編譯器構建程式集，請參閱 C#[使用 csc.exe 構建命令列，](../../csharp/language-reference/compiler-options/command-line-building-with-csc-exe.md)或從 Visual Basic[的命令列生成](../../visual-basic/reference/command-line-compiler/building-from-the-command-line.md)。</span><span class="sxs-lookup"><span data-stu-id="4fb12-162">For building assemblies with the command-line compilers, see [Command-line build with csc.exe](../../csharp/language-reference/compiler-options/command-line-building-with-csc-exe.md) for C#, or [Build from the command line](../../visual-basic/reference/command-line-compiler/building-from-the-command-line.md) for Visual Basic.</span></span>

> [!NOTE]
> <span data-ttu-id="4fb12-163">要在 Visual Studio 中構建程式集，請在 **"生成"** 功能表上，選擇 **"生成**"。</span><span class="sxs-lookup"><span data-stu-id="4fb12-163">To build an assembly in Visual Studio, on the **Build** menu, select **Build**.</span></span>

## <a name="assembly-manifest"></a><span data-ttu-id="4fb12-164">資訊清單</span><span class="sxs-lookup"><span data-stu-id="4fb12-164">Assembly manifest</span></span>

<span data-ttu-id="4fb12-165">每個程式集都有一個*組件資訊清單*檔。</span><span class="sxs-lookup"><span data-stu-id="4fb12-165">Every assembly has an *assembly manifest* file.</span></span> <span data-ttu-id="4fb12-166">與目錄類似，組件資訊清單包含：</span><span class="sxs-lookup"><span data-stu-id="4fb12-166">Similar to a table of contents, the assembly manifest contains:</span></span>

- <span data-ttu-id="4fb12-167">組件的身分識別 (其名稱和版本)。</span><span class="sxs-lookup"><span data-stu-id="4fb12-167">The assembly's identity (its name and version).</span></span>

- <span data-ttu-id="4fb12-168">描述構成程式集的所有其他檔的檔表，例如您創建的其他程式集，您的 *.exe*或 *.dll*檔依賴于這些程式集、點陣圖檔或 Readme 檔。</span><span class="sxs-lookup"><span data-stu-id="4fb12-168">A file table describing all the other files that make up the assembly, such as other assemblies you created that your *.exe* or *.dll* file relies on, bitmap files, or Readme files.</span></span>

- <span data-ttu-id="4fb12-169">*程式集引用清單*，它是所有外部依賴項（如 *.dll*s 或其他檔）的清單。</span><span class="sxs-lookup"><span data-stu-id="4fb12-169">An *assembly reference list*, which is a list of all external dependencies, such as *.dll*s or other files.</span></span> <span data-ttu-id="4fb12-170">組件參考同時包含全域和私用物件的參考。</span><span class="sxs-lookup"><span data-stu-id="4fb12-170">Assembly references contain references to both global and private objects.</span></span> <span data-ttu-id="4fb12-171">所有其他應用程式皆可使用全域物件。</span><span class="sxs-lookup"><span data-stu-id="4fb12-171">Global objects are available to all other applications.</span></span> <span data-ttu-id="4fb12-172">在 .NET Core 中，全域物件與特定的 .NET Core 運行時耦合。</span><span class="sxs-lookup"><span data-stu-id="4fb12-172">In .NET Core, global objects are coupled with a particular .NET Core runtime.</span></span> <span data-ttu-id="4fb12-173">在 .NET 框架中，全域物件駐留在全域組件快取 （GAC）。</span><span class="sxs-lookup"><span data-stu-id="4fb12-173">In .NET Framework, global objects reside in the global assembly cache (GAC).</span></span> <span data-ttu-id="4fb12-174">*System.IO.dll*是 GAC 中程式集的示例。</span><span class="sxs-lookup"><span data-stu-id="4fb12-174">*System.IO.dll* is an example of an assembly in the GAC.</span></span> <span data-ttu-id="4fb12-175">私有物件必須位於安裝應用的目錄或下方的目錄級別。</span><span class="sxs-lookup"><span data-stu-id="4fb12-175">Private objects must be in a directory level at or below the directory in which your app is installed.</span></span>

<span data-ttu-id="4fb12-176">由於程式集包含有關內容、版本控制和保護項的資訊，因此使用它們的應用程式不必依賴外部源（如 Windows 系統上的註冊表）來正常運行。</span><span class="sxs-lookup"><span data-stu-id="4fb12-176">Because assemblies contain information about content, versioning, and dependencies, the applications that use them needn't rely on external sources, such as the registry on Windows systems, to function properly.</span></span> <span data-ttu-id="4fb12-177">程式集可減少 *.dll*衝突，並使應用程式更可靠且更易於部署。</span><span class="sxs-lookup"><span data-stu-id="4fb12-177">Assemblies reduce *.dll* conflicts and make your applications more reliable and easier to deploy.</span></span> <span data-ttu-id="4fb12-178">在許多情況下，您只要將 .NET 型應用程式的檔案複製到目標電腦，即完成安裝。</span><span class="sxs-lookup"><span data-stu-id="4fb12-178">In many cases, you can install a .NET-based application simply by copying its files to the target computer.</span></span> <span data-ttu-id="4fb12-179">有關詳細資訊，請參閱[組件資訊清單](manifest.md)。</span><span class="sxs-lookup"><span data-stu-id="4fb12-179">For more information, see [Assembly manifest](manifest.md).</span></span>

## <a name="add-a-reference-to-an-assembly"></a><span data-ttu-id="4fb12-180">添加對程式集的引用</span><span class="sxs-lookup"><span data-stu-id="4fb12-180">Add a reference to an assembly</span></span>

<span data-ttu-id="4fb12-181">要在應用程式中使用程式集，必須添加對程式集的引用。</span><span class="sxs-lookup"><span data-stu-id="4fb12-181">To use an assembly in an application, you must add a reference to it.</span></span> <span data-ttu-id="4fb12-182">引用程式集後，應用程式可以使用其命名空間的所有可訪問類型、屬性、方法和其他成員，就像其代碼是原始檔案的一部分一樣。</span><span class="sxs-lookup"><span data-stu-id="4fb12-182">Once an assembly is referenced, all the accessible types, properties, methods, and other members of its namespaces are available to your application as if their code were part of your source file.</span></span>

> [!NOTE]
> <span data-ttu-id="4fb12-183">系統會自動參考 .NET 類別庫中的大多數組件。</span><span class="sxs-lookup"><span data-stu-id="4fb12-183">Most assemblies from the .NET Class Library are referenced automatically.</span></span> <span data-ttu-id="4fb12-184">如果未自動引用系統程式集，對於 .NET Core，則可以添加對包含程式集的 NuGet 包的引用。</span><span class="sxs-lookup"><span data-stu-id="4fb12-184">If a system assembly isn't automatically referenced, for .NET Core, you can add a reference to the NuGet package that contains the assembly.</span></span> <span data-ttu-id="4fb12-185">在 Visual Studio 中使用 NuGet 包管理器，或者將程式集的[\<包參考>](../../core/tools/dependencies.md#the-packagereference-element)元素添加到 *.csproj*或 *.vbproj*專案中。</span><span class="sxs-lookup"><span data-stu-id="4fb12-185">Either use the NuGet Package Manager in Visual Studio, or add a [\<PackageReference>](../../core/tools/dependencies.md#the-packagereference-element) element for the assembly to the *.csproj* or *.vbproj* project.</span></span> <span data-ttu-id="4fb12-186">在 .NET 框架中，可以使用 Visual Studio 中的 **"增加參考"** 對話方塊或使用[C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md)或`-reference`Visual [Basic](../../visual-basic/reference/command-line-compiler/reference.md)編譯器的命令列選項來添加對程式集的引用。</span><span class="sxs-lookup"><span data-stu-id="4fb12-186">In .NET Framework, you can add a reference to the assembly by using the **Add Reference** dialog in Visual Studio, or by using the `-reference` command line option for the [C#](../../csharp/language-reference/compiler-options/reference-compiler-option.md) or [Visual Basic](../../visual-basic/reference/command-line-compiler/reference.md) compilers.</span></span>

<span data-ttu-id="4fb12-187">在 C# 中，您可以在單個應用程式中使用同一程式集的兩個版本。</span><span class="sxs-lookup"><span data-stu-id="4fb12-187">In C#, you can use two versions of the same assembly in a single application.</span></span> <span data-ttu-id="4fb12-188">如需詳細資訊，請參閱[外部別名](../../csharp/language-reference/keywords/extern-alias.md)。</span><span class="sxs-lookup"><span data-stu-id="4fb12-188">For more information, see [extern alias](../../csharp/language-reference/keywords/extern-alias.md).</span></span>

## <a name="related-content"></a><span data-ttu-id="4fb12-189">相關內容</span><span class="sxs-lookup"><span data-stu-id="4fb12-189">Related content</span></span>

|<span data-ttu-id="4fb12-190">Title</span><span class="sxs-lookup"><span data-stu-id="4fb12-190">Title</span></span>|<span data-ttu-id="4fb12-191">描述</span><span class="sxs-lookup"><span data-stu-id="4fb12-191">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="4fb12-192">組件內容</span><span class="sxs-lookup"><span data-stu-id="4fb12-192">Assembly contents</span></span>](contents.md)|<span data-ttu-id="4fb12-193">組成程式集的元素。</span><span class="sxs-lookup"><span data-stu-id="4fb12-193">Elements that make up an assembly.</span></span>|
|[<span data-ttu-id="4fb12-194">組件資訊清單</span><span class="sxs-lookup"><span data-stu-id="4fb12-194">Assembly manifest</span></span>](manifest.md)|<span data-ttu-id="4fb12-195">組件資訊清單中的資料，以及如何在程式集中存儲資料。</span><span class="sxs-lookup"><span data-stu-id="4fb12-195">Data in the assembly manifest, and how it is stored in assemblies.</span></span>|
|[<span data-ttu-id="4fb12-196">全域組件快取</span><span class="sxs-lookup"><span data-stu-id="4fb12-196">Global assembly cache</span></span>](../../framework/app-domains/gac.md)|<span data-ttu-id="4fb12-197">GAC 如何存儲和使用程式集。</span><span class="sxs-lookup"><span data-stu-id="4fb12-197">How the GAC stores and uses assemblies.</span></span>|
|[<span data-ttu-id="4fb12-198">強命名程式集</span><span class="sxs-lookup"><span data-stu-id="4fb12-198">Strong-named assemblies</span></span>](strong-named.md)|<span data-ttu-id="4fb12-199">強命名程式集的特徵。</span><span class="sxs-lookup"><span data-stu-id="4fb12-199">Characteristics of strong-named assemblies.</span></span>|
|[<span data-ttu-id="4fb12-200">組件安全性考量</span><span class="sxs-lookup"><span data-stu-id="4fb12-200">Assembly security considerations</span></span>](security-considerations.md)|<span data-ttu-id="4fb12-201">安全性如何與程式集配合使用。</span><span class="sxs-lookup"><span data-stu-id="4fb12-201">How security works with assemblies.</span></span>|
|[<span data-ttu-id="4fb12-202">組件版本控制</span><span class="sxs-lookup"><span data-stu-id="4fb12-202">Assembly versioning</span></span>](versioning.md)|<span data-ttu-id="4fb12-203">.NET 框架版本控制策略的概述。</span><span class="sxs-lookup"><span data-stu-id="4fb12-203">Overview of the .NET Framework versioning policy.</span></span>|
|[<span data-ttu-id="4fb12-204">組件放置</span><span class="sxs-lookup"><span data-stu-id="4fb12-204">Assembly placement</span></span>](../../framework/app-domains/assembly-placement.md)|<span data-ttu-id="4fb12-205">位置可定位程式集。</span><span class="sxs-lookup"><span data-stu-id="4fb12-205">Where to locate assemblies.</span></span>|
|[<span data-ttu-id="4fb12-206">組件和並存執行</span><span class="sxs-lookup"><span data-stu-id="4fb12-206">Assemblies and side-by-side execution</span></span>](side-by-side-execution.md)|<span data-ttu-id="4fb12-207">同時使用多個版本的運行時或程式集。</span><span class="sxs-lookup"><span data-stu-id="4fb12-207">Use multiple versions of the runtime or an assembly simultaneously.</span></span>|
|[<span data-ttu-id="4fb12-208">發出動態方法和組件</span><span class="sxs-lookup"><span data-stu-id="4fb12-208">Emit dynamic methods and assemblies</span></span>](../../../docs/framework/reflection-and-codedom/emitting-dynamic-methods-and-assemblies.md)|<span data-ttu-id="4fb12-209">如何創建動態程式集。</span><span class="sxs-lookup"><span data-stu-id="4fb12-209">How to create dynamic assemblies.</span></span>|
|[<span data-ttu-id="4fb12-210">運行時如何定位程式集</span><span class="sxs-lookup"><span data-stu-id="4fb12-210">How the runtime locates assemblies</span></span>](../../../docs/framework/deployment/how-the-runtime-locates-assemblies.md)|<span data-ttu-id="4fb12-211">.NET 框架如何在運行時解析程式集引用。</span><span class="sxs-lookup"><span data-stu-id="4fb12-211">How the .NET Framework resolves assembly references at run time.</span></span>|

## <a name="reference"></a><span data-ttu-id="4fb12-212">參考資料</span><span class="sxs-lookup"><span data-stu-id="4fb12-212">Reference</span></span>

<xref:System.Reflection.Assembly?displayProperty=nameWithType>

## <a name="see-also"></a><span data-ttu-id="4fb12-213">另請參閱</span><span class="sxs-lookup"><span data-stu-id="4fb12-213">See also</span></span>

- [<span data-ttu-id="4fb12-214">.NET 組件檔格式</span><span class="sxs-lookup"><span data-stu-id="4fb12-214">.NET assembly file format</span></span>](file-format.md)
- [<span data-ttu-id="4fb12-215">好友程式集</span><span class="sxs-lookup"><span data-stu-id="4fb12-215">Friend assemblies</span></span>](friend.md)
- [<span data-ttu-id="4fb12-216">參考組件</span><span class="sxs-lookup"><span data-stu-id="4fb12-216">Reference assemblies</span></span>](reference-assemblies.md)
- [<span data-ttu-id="4fb12-217">如何：載入和卸載程式集</span><span class="sxs-lookup"><span data-stu-id="4fb12-217">How to: Load and unload assemblies</span></span>](load-unload.md)
- [<span data-ttu-id="4fb12-218">如何：在 .NET Core 中使用和偵錯工具集卸載</span><span class="sxs-lookup"><span data-stu-id="4fb12-218">How to: Use and debug assembly unloadability in .NET Core</span></span>](unloadability.md)
- [<span data-ttu-id="4fb12-219">如何：確定檔是否為程式集</span><span class="sxs-lookup"><span data-stu-id="4fb12-219">How to: Determine if a file is an assembly</span></span>](identify.md)
- [<span data-ttu-id="4fb12-220">如何：使用中繼資料載入上下文檢查程式集內容</span><span class="sxs-lookup"><span data-stu-id="4fb12-220">How to: Inspect assembly contents using MetadataLoadContext</span></span>](inspect-contents-using-metadataloadcontext.md)
