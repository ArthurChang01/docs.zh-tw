---
title: 如何:使用中繼資料載入中文檢查程式集內容
description: 瞭解如何使用中繼資料 LoadContext,這是 API,讓您能夠載入 .NET 程式集以進行檢查。
author: MSDN-WhiteKnight
ms.date: 03/10/2020
ms.technology: dotnet-standard
ms.openlocfilehash: d2589d51a6e0611504c0133d293d3fdfae32553c
ms.sourcegitcommit: 7980a91f90ae5eca859db7e6bfa03e23e76a1a50
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/13/2020
ms.locfileid: "81242656"
---
# <a name="how-to-inspect-assembly-contents-using-metadataloadcontext"></a><span data-ttu-id="9a34a-103">如何:使用中繼資料載入中文檢查程式集內容</span><span class="sxs-lookup"><span data-stu-id="9a34a-103">How to: Inspect assembly contents using MetadataLoadContext</span></span>

<span data-ttu-id="9a34a-104">默認情況下,.NET 中的反射 API 使開發人員能夠檢查載入主執行上下文中的程式集的內容。</span><span class="sxs-lookup"><span data-stu-id="9a34a-104">The reflection API in .NET by default enables developers to inspect the contents of assemblies loaded into the main execution context.</span></span> <span data-ttu-id="9a34a-105">但是,有時無法將程式集載入到執行上下文中,例如,因為它是為另一個平臺或處理器體系結構編譯的,或者它是[一個引用程式集](reference-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="9a34a-105">However, sometimes it isn't possible to load an assembly into the execution context, for example, because it was compiled for another platform or processor architecture, or it's a [reference assembly](reference-assemblies.md).</span></span> <span data-ttu-id="9a34a-106">API<xref:System.Reflection.MetadataLoadContext?displayProperty=fullName>允許您載入和檢查此類程式集。</span><span class="sxs-lookup"><span data-stu-id="9a34a-106">The <xref:System.Reflection.MetadataLoadContext?displayProperty=fullName> API allows you to load and inspect such assemblies.</span></span> <span data-ttu-id="9a34a-107">載入的<xref:System.Reflection.MetadataLoadContext>程式集僅被視為元數據,也就是說,可以檢查程式集中的類型,但不能執行其中包含的任何代碼。</span><span class="sxs-lookup"><span data-stu-id="9a34a-107">Assemblies loaded into the <xref:System.Reflection.MetadataLoadContext> are treated only as metadata, that is, you can examine types in the assembly, but you can't execute any code contained in it.</span></span> <span data-ttu-id="9a34a-108">與主執行上下文不同,不會<xref:System.Reflection.MetadataLoadContext>自動載入來自當前目錄的依賴項;因此,不會從當前目錄中載入依賴項。相反,它使用傳遞給它提供的<xref:System.Reflection.MetadataAssemblyResolver>自定義綁定邏輯。</span><span class="sxs-lookup"><span data-stu-id="9a34a-108">Unlike the main execution context, the <xref:System.Reflection.MetadataLoadContext> doesn't automatically load dependencies from the current directory; instead it uses the custom binding logic provided by the <xref:System.Reflection.MetadataAssemblyResolver> passed to it.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="9a34a-109">Prerequisites</span><span class="sxs-lookup"><span data-stu-id="9a34a-109">Prerequisites</span></span>

<span data-ttu-id="9a34a-110">要使用<xref:System.Reflection.MetadataLoadContext>,請安裝[系統。反射.元數據載入上下文](https://www.nuget.org/packages/System.Reflection.MetadataLoadContext)NuGet 包。</span><span class="sxs-lookup"><span data-stu-id="9a34a-110">To use <xref:System.Reflection.MetadataLoadContext>, install the [System.Reflection.MetadataLoadContext](https://www.nuget.org/packages/System.Reflection.MetadataLoadContext) NuGet package.</span></span> <span data-ttu-id="9a34a-111">它支援任何 .NET 標準 2.0 標準,例如 .NET 核心 2.0 或 .NET 框架 4.6.1。</span><span class="sxs-lookup"><span data-stu-id="9a34a-111">It is supported on any .NET Standard 2.0-compliant target framework, for example, .NET Core 2.0 or .NET Framework 4.6.1.</span></span>

## <a name="create-metadataassemblyresolver-for-metadataloadcontext"></a><span data-ttu-id="9a34a-112">為中繼資料載入中建立中繼資料程式集解析器</span><span class="sxs-lookup"><span data-stu-id="9a34a-112">Create MetadataAssemblyResolver for MetadataLoadContext</span></span>

<span data-ttu-id="9a34a-113">創建<xref:System.Reflection.MetadataLoadContext>需要提供的<xref:System.Reflection.MetadataAssemblyResolver>實例。</span><span class="sxs-lookup"><span data-stu-id="9a34a-113">Creating the <xref:System.Reflection.MetadataLoadContext> requires providing the instance of the <xref:System.Reflection.MetadataAssemblyResolver>.</span></span> <span data-ttu-id="9a34a-114">提供一個最簡單的方法是使用,<xref:System.Reflection.PathAssemblyResolver>它解析來自給定程式集路徑字串集合中的程式集。</span><span class="sxs-lookup"><span data-stu-id="9a34a-114">The simplest way to provide one is to use the <xref:System.Reflection.PathAssemblyResolver>, which resolves assemblies from the given collection of assembly path strings.</span></span> <span data-ttu-id="9a34a-115">除了要直接檢查的程式集之外,此集合還應包含所有所需的依賴項。</span><span class="sxs-lookup"><span data-stu-id="9a34a-115">This collection, besides assemblies you want to inspect directly, should also include all needed dependencies.</span></span> <span data-ttu-id="9a34a-116">例如,要讀取位於外部程式集中的自定義屬性,應包含該程式集,否則將引發異常。</span><span class="sxs-lookup"><span data-stu-id="9a34a-116">For example, to read the custom attribute located in an external assembly, you should include that assembly or an exception will be thrown.</span></span> <span data-ttu-id="9a34a-117">在大多數情況下,應至少包括*核心程式集*,即包含內建系統類型的程式集,如<xref:System.Object?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="9a34a-117">In most cases, you should include at least the *core assembly*, that is, the assembly containing built-in system types, such as <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="9a34a-118">以下程式碼示範<xref:System.Reflection.PathAssemblyResolver>如何 使用由已檢查程式集與目前執行時的核心程式集組成的集合建立:</span><span class="sxs-lookup"><span data-stu-id="9a34a-118">The following code shows how to create the <xref:System.Reflection.PathAssemblyResolver> using the collection consisting of the inspected assembly and the current runtime's core assembly:</span></span>

[!code-csharp[](snippets/inspect-contents-using-metadataloadcontext/MetadataLoadContextSnippets.cs#CoreAssembly)]

<span data-ttu-id="9a34a-119">如果需要存取所有 BCL 類型,可以在集合中包括所有運行時程式集。</span><span class="sxs-lookup"><span data-stu-id="9a34a-119">If you need access to all BCL types, you can include all runtime assemblies in the collection.</span></span> <span data-ttu-id="9a34a-120">以下程式碼示範<xref:System.Reflection.PathAssemblyResolver>如何 使用由已檢查的程式集與目前執行時的所有程式集組成的集合建立:</span><span class="sxs-lookup"><span data-stu-id="9a34a-120">The following code shows how to create the <xref:System.Reflection.PathAssemblyResolver> using the collection consisting of the inspected assembly and all assemblies of the current runtime:</span></span>

[!code-csharp[](snippets/inspect-contents-using-metadataloadcontext/MetadataLoadContextSnippets.cs#RuntimeAssemblies)]

## <a name="create-metadataloadcontext"></a><span data-ttu-id="9a34a-121">建立中繼資料載入中文</span><span class="sxs-lookup"><span data-stu-id="9a34a-121">Create MetadataLoadContext</span></span>

<span data-ttu-id="9a34a-122">要創建<xref:System.Reflection.MetadataLoadContext>調用其建構函<xref:System.Reflection.MetadataLoadContext.%23ctor%28System.Reflection.MetadataAssemblyResolver%2CSystem.String%29>數 ,將以前<xref:System.Reflection.MetadataAssemblyResolver>創建的 參數傳遞為第一個參數,將核心程式集名稱傳遞給第二個參數。</span><span class="sxs-lookup"><span data-stu-id="9a34a-122">To create the <xref:System.Reflection.MetadataLoadContext>, invoke its constructor <xref:System.Reflection.MetadataLoadContext.%23ctor%28System.Reflection.MetadataAssemblyResolver%2CSystem.String%29>, passing the previously created <xref:System.Reflection.MetadataAssemblyResolver> as the first parameter and the core assembly name as the second parameter.</span></span> <span data-ttu-id="9a34a-123">您可以省略核心程式集名稱,在這種情況下,構造函數將嘗試使用預設名稱:"mscorlib"、"System.Runtime"或"net標準"。</span><span class="sxs-lookup"><span data-stu-id="9a34a-123">You can omit the core assembly name, in which case the constructor will attempt to use default names: "mscorlib", "System.Runtime", or "netstandard".</span></span>

<span data-ttu-id="9a34a-124">創建上下文後,可以使用方法(如<xref:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath%2A>) 將程式集載入其中。</span><span class="sxs-lookup"><span data-stu-id="9a34a-124">After you've created the context, you can load assemblies into it using methods such as <xref:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath%2A>.</span></span> <span data-ttu-id="9a34a-125">您可以在載入的程式集上使用所有反射 API,但涉及代碼執行的程式集除外。</span><span class="sxs-lookup"><span data-stu-id="9a34a-125">You can use all reflection APIs on loaded assemblies except ones that involve code execution.</span></span> <span data-ttu-id="9a34a-126">該方法<xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>確實涉及建構函數的執行,因此,當您需要在中<xref:System.Reflection.MemberInfo.GetCustomAttributesData%2A>檢查 自訂屬性時,請<xref:System.Reflection.MetadataLoadContext>使用方法 。</span><span class="sxs-lookup"><span data-stu-id="9a34a-126">The <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method does involve the execution of constructors, so use the <xref:System.Reflection.MemberInfo.GetCustomAttributesData%2A> method instead when you need to examine custom attributes in the <xref:System.Reflection.MetadataLoadContext>.</span></span>

<span data-ttu-id="9a34a-127">以下代碼範例建立<xref:System.Reflection.MetadataLoadContext>,將程式集載入到控制台中,並將程式集屬性輸出到控制台中:</span><span class="sxs-lookup"><span data-stu-id="9a34a-127">The following code sample creates <xref:System.Reflection.MetadataLoadContext>, loads the assembly into it, and outputs assembly attributes into the console:</span></span>

[!code-csharp[](snippets/inspect-contents-using-metadataloadcontext/MetadataLoadContextSnippets.cs#CreateContext)]

## <a name="example"></a><span data-ttu-id="9a34a-128">範例</span><span class="sxs-lookup"><span data-stu-id="9a34a-128">Example</span></span>

<span data-ttu-id="9a34a-129">有關完整的程式碼範例,請參考[使用中繼資料載入的文字範例](https://github.com/dotnet/samples/tree/master/core/assembly/MetadataLoadContext)。</span><span class="sxs-lookup"><span data-stu-id="9a34a-129">For a complete code example, see the [Inspect assembly contents using MetadataLoadContext sample](https://github.com/dotnet/samples/tree/master/core/assembly/MetadataLoadContext).</span></span>
