---
title: 如何：使用 MetadataLoadCoNtext 檢查元件內容
description: 瞭解如何使用 MetadataLoadCoNtext，這是一個 API，可讓您載入 .NET 元件以供檢查之用。
author: MSDN-WhiteKnight
ms.date: 03/10/2020
ms.technology: dotnet-standard
ms.openlocfilehash: 90c84147c52199afc42a2efc297bc7fe40658ec7
ms.sourcegitcommit: 839777281a281684a7e2906dccb3acd7f6a32023
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/24/2020
ms.locfileid: "82141192"
---
# <a name="how-to-inspect-assembly-contents-using-metadataloadcontext"></a><span data-ttu-id="b14d1-103">如何：使用 MetadataLoadCoNtext 檢查元件內容</span><span class="sxs-lookup"><span data-stu-id="b14d1-103">How to: Inspect assembly contents using MetadataLoadContext</span></span>

<span data-ttu-id="b14d1-104">.NET 中的反映 API 預設可讓開發人員檢查載入主要執行內容之元件的內容。</span><span class="sxs-lookup"><span data-stu-id="b14d1-104">The reflection API in .NET by default enables developers to inspect the contents of assemblies loaded into the main execution context.</span></span> <span data-ttu-id="b14d1-105">不過，有時無法將元件載入執行內容中，例如，它是針對另一個平臺或處理器架構所編譯，或是[參考元件](reference-assemblies.md)。</span><span class="sxs-lookup"><span data-stu-id="b14d1-105">However, sometimes it isn't possible to load an assembly into the execution context, for example, because it was compiled for another platform or processor architecture, or it's a [reference assembly](reference-assemblies.md).</span></span> <span data-ttu-id="b14d1-106"><xref:System.Reflection.MetadataLoadContext?displayProperty=fullName> API 可讓您載入及檢查這類元件。</span><span class="sxs-lookup"><span data-stu-id="b14d1-106">The <xref:System.Reflection.MetadataLoadContext?displayProperty=fullName> API allows you to load and inspect such assemblies.</span></span> <span data-ttu-id="b14d1-107">載入至的<xref:System.Reflection.MetadataLoadContext>元件只會被視為中繼資料，也就是說，您可以檢查元件中的類型，但無法執行其中包含的任何程式碼。</span><span class="sxs-lookup"><span data-stu-id="b14d1-107">Assemblies loaded into the <xref:System.Reflection.MetadataLoadContext> are treated only as metadata, that is, you can examine types in the assembly, but you can't execute any code contained in it.</span></span> <span data-ttu-id="b14d1-108">與主要執行內容不同的是<xref:System.Reflection.MetadataLoadContext> ，不會自動從目前目錄載入相依性;相反地，它會使用傳遞給它的<xref:System.Reflection.MetadataAssemblyResolver>所提供的自訂系結邏輯。</span><span class="sxs-lookup"><span data-stu-id="b14d1-108">Unlike the main execution context, the <xref:System.Reflection.MetadataLoadContext> doesn't automatically load dependencies from the current directory; instead it uses the custom binding logic provided by the <xref:System.Reflection.MetadataAssemblyResolver> passed to it.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="b14d1-109">先決條件</span><span class="sxs-lookup"><span data-stu-id="b14d1-109">Prerequisites</span></span>

<span data-ttu-id="b14d1-110">若要<xref:System.Reflection.MetadataLoadContext>使用，請安裝[MetadataLoadCoNtext](https://www.nuget.org/packages/System.Reflection.MetadataLoadContext) NuGet 套件。</span><span class="sxs-lookup"><span data-stu-id="b14d1-110">To use <xref:System.Reflection.MetadataLoadContext>, install the [System.Reflection.MetadataLoadContext](https://www.nuget.org/packages/System.Reflection.MetadataLoadContext) NuGet package.</span></span> <span data-ttu-id="b14d1-111">這在任何 .NET Standard 2.0 相容的目標架構（例如 .NET Core 2.0 或 .NET Framework 4.6.1）上都受到支援。</span><span class="sxs-lookup"><span data-stu-id="b14d1-111">It is supported on any .NET Standard 2.0-compliant target framework, for example, .NET Core 2.0 or .NET Framework 4.6.1.</span></span>

## <a name="create-metadataassemblyresolver-for-metadataloadcontext"></a><span data-ttu-id="b14d1-112">建立 MetadataLoadCoNtext 的 MetadataAssemblyResolver</span><span class="sxs-lookup"><span data-stu-id="b14d1-112">Create MetadataAssemblyResolver for MetadataLoadContext</span></span>

<span data-ttu-id="b14d1-113">建立<xref:System.Reflection.MetadataLoadContext>需要提供的實例<xref:System.Reflection.MetadataAssemblyResolver>。</span><span class="sxs-lookup"><span data-stu-id="b14d1-113">Creating the <xref:System.Reflection.MetadataLoadContext> requires providing the instance of the <xref:System.Reflection.MetadataAssemblyResolver>.</span></span> <span data-ttu-id="b14d1-114">提供一個最簡單的方法是使用<xref:System.Reflection.PathAssemblyResolver>，它會解析指定的元件路徑字串集合中的元件。</span><span class="sxs-lookup"><span data-stu-id="b14d1-114">The simplest way to provide one is to use the <xref:System.Reflection.PathAssemblyResolver>, which resolves assemblies from the given collection of assembly path strings.</span></span> <span data-ttu-id="b14d1-115">除了您想要直接檢查的元件之外，此集合也應包含所有必要的相依性。</span><span class="sxs-lookup"><span data-stu-id="b14d1-115">This collection, besides assemblies you want to inspect directly, should also include all needed dependencies.</span></span> <span data-ttu-id="b14d1-116">例如，若要讀取位於外部元件中的自訂屬性，您應該包含該元件，否則會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="b14d1-116">For example, to read the custom attribute located in an external assembly, you should include that assembly or an exception will be thrown.</span></span> <span data-ttu-id="b14d1-117">在大部分情況下，您應該至少包含*核心元件*，也就是包含內建系統類型的元件，例如<xref:System.Object?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b14d1-117">In most cases, you should include at least the *core assembly*, that is, the assembly containing built-in system types, such as <xref:System.Object?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b14d1-118">下列程式碼示範如何<xref:System.Reflection.PathAssemblyResolver>使用由已檢查元件和目前執行時間核心元件所組成的集合，來建立。</span><span class="sxs-lookup"><span data-stu-id="b14d1-118">The following code shows how to create the <xref:System.Reflection.PathAssemblyResolver> using the collection consisting of the inspected assembly and the current runtime's core assembly:</span></span>

[!code-csharp[](snippets/inspect-contents-using-metadataloadcontext/MetadataLoadContextSnippets.cs#CoreAssembly)]

<span data-ttu-id="b14d1-119">如果您需要存取所有 BCL 類型，您可以在集合中包含所有執行時間元件。</span><span class="sxs-lookup"><span data-stu-id="b14d1-119">If you need access to all BCL types, you can include all runtime assemblies in the collection.</span></span> <span data-ttu-id="b14d1-120">下列程式碼示範如何<xref:System.Reflection.PathAssemblyResolver>使用由已檢查元件和目前執行時間的所有元件所組成的集合，來建立。</span><span class="sxs-lookup"><span data-stu-id="b14d1-120">The following code shows how to create the <xref:System.Reflection.PathAssemblyResolver> using the collection consisting of the inspected assembly and all assemblies of the current runtime:</span></span>

[!code-csharp[](snippets/inspect-contents-using-metadataloadcontext/MetadataLoadContextSnippets.cs#RuntimeAssemblies)]

## <a name="create-metadataloadcontext"></a><span data-ttu-id="b14d1-121">建立 MetadataLoadCoNtext</span><span class="sxs-lookup"><span data-stu-id="b14d1-121">Create MetadataLoadContext</span></span>

<span data-ttu-id="b14d1-122">若要建立<xref:System.Reflection.MetadataLoadContext>，請叫用<xref:System.Reflection.MetadataLoadContext.%23ctor%28System.Reflection.MetadataAssemblyResolver%2CSystem.String%29>其函式，並<xref:System.Reflection.MetadataAssemblyResolver>將先前建立的當做第一個參數，並將核心元件名稱傳遞為第二個參數。</span><span class="sxs-lookup"><span data-stu-id="b14d1-122">To create the <xref:System.Reflection.MetadataLoadContext>, invoke its constructor <xref:System.Reflection.MetadataLoadContext.%23ctor%28System.Reflection.MetadataAssemblyResolver%2CSystem.String%29>, passing the previously created <xref:System.Reflection.MetadataAssemblyResolver> as the first parameter and the core assembly name as the second parameter.</span></span> <span data-ttu-id="b14d1-123">您可以省略核心元件名稱，在此情況下，此函式會嘗試使用預設名稱： "mscorlib"、"System.web" 或 "netstandard"。</span><span class="sxs-lookup"><span data-stu-id="b14d1-123">You can omit the core assembly name, in which case the constructor will attempt to use default names: "mscorlib", "System.Runtime", or "netstandard".</span></span>

<span data-ttu-id="b14d1-124">建立內容之後，您可以使用之類的方法，將元件載入其中<xref:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath%2A>。</span><span class="sxs-lookup"><span data-stu-id="b14d1-124">After you've created the context, you can load assemblies into it using methods such as <xref:System.Reflection.MetadataLoadContext.LoadFromAssemblyPath%2A>.</span></span> <span data-ttu-id="b14d1-125">除了涉及程式碼執行的元件以外，您可以在載入的元件上使用所有反映 Api。</span><span class="sxs-lookup"><span data-stu-id="b14d1-125">You can use all reflection APIs on loaded assemblies except ones that involve code execution.</span></span> <span data-ttu-id="b14d1-126"><xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>方法包含執行的函式，因此，當您需要<xref:System.Reflection.MemberInfo.GetCustomAttributesData%2A>檢查中的自訂屬性時，請改用方法<xref:System.Reflection.MetadataLoadContext>。</span><span class="sxs-lookup"><span data-stu-id="b14d1-126">The <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method does involve the execution of constructors, so use the <xref:System.Reflection.MemberInfo.GetCustomAttributesData%2A> method instead when you need to examine custom attributes in the <xref:System.Reflection.MetadataLoadContext>.</span></span>

<span data-ttu-id="b14d1-127">下列程式碼範例會<xref:System.Reflection.MetadataLoadContext>建立、將元件載入其中，並將元件屬性輸出到主控台：</span><span class="sxs-lookup"><span data-stu-id="b14d1-127">The following code sample creates <xref:System.Reflection.MetadataLoadContext>, loads the assembly into it, and outputs assembly attributes into the console:</span></span>

[!code-csharp[](snippets/inspect-contents-using-metadataloadcontext/MetadataLoadContextSnippets.cs#CreateContext)]

## <a name="example"></a><span data-ttu-id="b14d1-128">範例</span><span class="sxs-lookup"><span data-stu-id="b14d1-128">Example</span></span>

<span data-ttu-id="b14d1-129">如需完整的程式碼範例，請參閱[使用 MetadataLoadCoNtext 檢查元件內容範例](https://docs.microsoft.com/samples/dotnet/samples/inspect-assembly-contents-using-metadataloadcontext/)。</span><span class="sxs-lookup"><span data-stu-id="b14d1-129">For a complete code example, see the [Inspect assembly contents using MetadataLoadContext sample](https://docs.microsoft.com/samples/dotnet/samples/inspect-assembly-contents-using-metadataloadcontext/).</span></span>
