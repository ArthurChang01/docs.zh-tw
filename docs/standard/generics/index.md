---
title: ".NET Framework 中的泛型"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- generic methods, type inference
- generics [.NET Framework], collections
- generic interfaces [.NET Framework]
- constructed generic types
- nested generic types
- generic type definitions
- generic classes [.NET Framework]
- generics [.NET Framework], interfaces
- generics [.NET Framework], about
- generics [.NET Framework]
- generic collections [.NET Framework]
- generic delegates [.NET Framework]
- generic type arguments
- generics [.NET Framework], delegates
- generics [.NET Framework], features
- constraints [.NET Framework]
- generic types
- generic type parameters
ms.assetid: 2994d786-c5c7-4666-ab23-4c83129fe39c
caps.latest.revision: 23
author: mairaw
ms.author: mairaw
manager: wpickett
ms.translationtype: HT
ms.sourcegitcommit: 306c608dc7f97594ef6f72ae0f5aaba596c936e1
ms.openlocfilehash: ef0b251add573c7aaed75b866523b5fdcd3d8e5a
ms.contentlocale: zh-tw
ms.lasthandoff: 09/05/2017

---
# <a name="generics-in-the-net-framework"></a><span data-ttu-id="45c1e-102">.NET Framework 中的泛型</span><span class="sxs-lookup"><span data-stu-id="45c1e-102">Generics in the .NET Framework</span></span>
<span data-ttu-id="45c1e-103"><a name="top"></a> 泛型可讓您將方法、類別、結構或介面，修改成其發揮作用的精確資料類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-103"><a name="top"></a> Generics let you tailor a method, class, structure, or interface to the precise data type it acts upon.</span></span> <span data-ttu-id="45c1e-104">例如，不使用 <xref:System.Collections.Hashtable> 類別，讓索引鍵和值可為任何類型；而改用 <xref:System.Collections.Generic.Dictionary%602> 泛型類別，指定索引鍵所允許的類型以及值所允許的類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-104">For example, instead of using the <xref:System.Collections.Hashtable> class, which allows keys and values to be of any type, you can use the <xref:System.Collections.Generic.Dictionary%602> generic class and specify the type allowed for the key and the type allowed for the value.</span></span> <span data-ttu-id="45c1e-105">泛型的優點包括加強程式碼的重複使用程度以及類型安全性。</span><span class="sxs-lookup"><span data-stu-id="45c1e-105">Among the benefits of generics are increased code reusability and type safety.</span></span>  
  
 <span data-ttu-id="45c1e-106">本主題提供.NET Framework 中的泛型概觀，以及泛型類型或方法的摘要。</span><span class="sxs-lookup"><span data-stu-id="45c1e-106">This topic provides an overview of generics in the .NET Framework and a summary of generic types or methods.</span></span> <span data-ttu-id="45c1e-107">它包含以下各節：</span><span class="sxs-lookup"><span data-stu-id="45c1e-107">It contains the following sections:</span></span>  
  
-   [<span data-ttu-id="45c1e-108">定義和使用泛型</span><span class="sxs-lookup"><span data-stu-id="45c1e-108">Defining and Using Generics</span></span>](#defining_and_using_generics)  
  
-   [<span data-ttu-id="45c1e-109">泛型術語</span><span class="sxs-lookup"><span data-stu-id="45c1e-109">Generics Terminology</span></span>](#generics_terminology)  
  
-   [<span data-ttu-id="45c1e-110">類別庫和語言支援</span><span class="sxs-lookup"><span data-stu-id="45c1e-110">Class Library and Language Support</span></span>](#class_library_and_language_support)  
  
-   [<span data-ttu-id="45c1e-111">巢狀類型和泛型</span><span class="sxs-lookup"><span data-stu-id="45c1e-111">Nested Types and Generics</span></span>](#nested_types_and_generics)  
  
-   [<span data-ttu-id="45c1e-112">相關主題</span><span class="sxs-lookup"><span data-stu-id="45c1e-112">Related Topics</span></span>](#related_topics)  
  
-   [<span data-ttu-id="45c1e-113">參考資料</span><span class="sxs-lookup"><span data-stu-id="45c1e-113">Reference</span></span>](#reference)  
  
<a name="defining_and_using_generics"></a>   
## <a name="defining-and-using-generics"></a><span data-ttu-id="45c1e-114">定義和使用泛型</span><span class="sxs-lookup"><span data-stu-id="45c1e-114">Defining and Using Generics</span></span>  
 <span data-ttu-id="45c1e-115">泛型是指一些類別、結構、介面與方法，其具有所儲存或使用之一或多個類型的預留位置 (類型參數)。</span><span class="sxs-lookup"><span data-stu-id="45c1e-115">Generics are classes, structures, interfaces, and methods that have placeholders (type parameters) for one or more of the types that they store or use.</span></span> <span data-ttu-id="45c1e-116">泛型集合類別可能會針對所儲存的物件類型，使用類型參數做為預留位置；這些類型參數會顯示為其欄位的類型，和其方法的參數類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-116">A generic collection class might use a type parameter as a placeholder for the type of objects that it stores; the type parameters appear as the types of its fields and the parameter types of its methods.</span></span> <span data-ttu-id="45c1e-117">泛型方法可能會使用其類型參數，做為其傳回值的類型，或其型式參數之一的類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-117">A generic method might use its type parameter as the type of its return value or as the type of one of its formal parameters.</span></span> <span data-ttu-id="45c1e-118">下列程式碼將會示範簡單的泛型類別定義。</span><span class="sxs-lookup"><span data-stu-id="45c1e-118">The following code illustrates a simple generic class definition.</span></span>  
  
 <span data-ttu-id="45c1e-119">[!code-cpp[Conceptual.Generics.Overview#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#2)] [!code-csharp[Conceptual.Generics.Overview#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#2)] [!code-vb[Conceptual.Generics.Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="45c1e-119">[!code-cpp[Conceptual.Generics.Overview#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#2)] [!code-csharp[Conceptual.Generics.Overview#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#2)] [!code-vb[Conceptual.Generics.Overview#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#2)]</span></span>  
  
 <span data-ttu-id="45c1e-120">當您建立泛型類別的執行個體時，您會指定實際的類型來替代類型參數。</span><span class="sxs-lookup"><span data-stu-id="45c1e-120">When you create an instance of a generic class, you specify the actual types to substitute for the type parameters.</span></span> <span data-ttu-id="45c1e-121">這會建立新的泛型類別，稱為建構的泛型類別，且在類型參數出現的任何地方，都有您所選擇的替代類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-121">This establishes a new generic class, referred to as a constructed generic class, with your chosen types substituted everywhere that the type parameters appear.</span></span> <span data-ttu-id="45c1e-122">此結果是適合您選擇之類型的類型安全類別，如下程式碼所示。</span><span class="sxs-lookup"><span data-stu-id="45c1e-122">The result is a type-safe class that is tailored to your choice of types, as the following code illustrates.</span></span>  
  
 <span data-ttu-id="45c1e-123">[!code-cpp[Conceptual.Generics.Overview#3](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#3)] [!code-csharp[Conceptual.Generics.Overview#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#3)] [!code-vb[Conceptual.Generics.Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#3)]</span><span class="sxs-lookup"><span data-stu-id="45c1e-123">[!code-cpp[Conceptual.Generics.Overview#3](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#3)] [!code-csharp[Conceptual.Generics.Overview#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#3)] [!code-vb[Conceptual.Generics.Overview#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#3)]</span></span>  
  
<a name="generics_terminology"></a>   
### <a name="generics-terminology"></a><span data-ttu-id="45c1e-124">泛型術語</span><span class="sxs-lookup"><span data-stu-id="45c1e-124">Generics terminology</span></span>  
 <span data-ttu-id="45c1e-125">下列詞彙可用以討論在 .NET Framework 中的泛型：</span><span class="sxs-lookup"><span data-stu-id="45c1e-125">The following terms are used to discuss generics in the .NET Framework:</span></span>  
  
-   <span data-ttu-id="45c1e-126">*「泛型類型定義」* (generic type definition)，是做為範本的類別、結構或介面宣告，且具有可包含或使用之類型的預留位置。</span><span class="sxs-lookup"><span data-stu-id="45c1e-126">A *generic type definition* is a class, structure, or interface declaration that functions as a template, with placeholders for the types that it can contain or use.</span></span> <span data-ttu-id="45c1e-127">例如， <xref:System.Collections.Generic.Dictionary%602?displayProperty=fullName> 類別可包含兩種類型：索引鍵和值。</span><span class="sxs-lookup"><span data-stu-id="45c1e-127">For example, the <xref:System.Collections.Generic.Dictionary%602?displayProperty=fullName> class can contain two types: keys and values.</span></span> <span data-ttu-id="45c1e-128">因為泛型類型定義是只是範本，您無法建立泛型類型定義之類別、結構或介面的執行個體。</span><span class="sxs-lookup"><span data-stu-id="45c1e-128">Because a generic type definition is only a template, you cannot create instances of a class, structure, or interface that is a generic type definition.</span></span>  
  
-   <span data-ttu-id="45c1e-129">*「泛型類型參數」*(Generic type parameter) 或 *「類型參數」*(type parameter)，是泛型類型或方法定義中的預留位置。</span><span class="sxs-lookup"><span data-stu-id="45c1e-129">*Generic type parameters*, or *type parameters*, are the placeholders in a generic type or method definition.</span></span> <span data-ttu-id="45c1e-130"><xref:System.Collections.Generic.Dictionary%602?displayProperty=fullName> 泛型類型有兩個類型參數， `TKey` 和 `TValue`，分別代表其索引鍵和值的類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-130">The <xref:System.Collections.Generic.Dictionary%602?displayProperty=fullName> generic type has two type parameters, `TKey` and `TValue`, that represent the types of its keys and values.</span></span>  
  
-   <span data-ttu-id="45c1e-131">*「建構的泛型類型」*(constructed generic type) 或 *「建構的類型」*(constructed type)，是為泛型類型定義的泛型類型參數所指定之類型的結果。</span><span class="sxs-lookup"><span data-stu-id="45c1e-131">A *constructed generic type*, or *constructed type*, is the result of specifying types for the generic type parameters of a generic type definition.</span></span>  
  
-   <span data-ttu-id="45c1e-132">*「泛型類型引數」* (generic type argument) 是要替換泛型類型參數的所有類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-132">A *generic type argument* is any type that is substituted for a generic type parameter.</span></span>  
  
-   <span data-ttu-id="45c1e-133">一般詞彙 *「泛型類型」* (generic type) 包括建構的類型和泛型類型定義。</span><span class="sxs-lookup"><span data-stu-id="45c1e-133">The general term *generic type* includes both constructed types and generic type definitions.</span></span>  
  
-   <span data-ttu-id="45c1e-134">泛型類型參數的*「共變數」* (covariance) 和 *「反變數」* of generic type parameters enable you to use constructed generic types whose type arguments are more derived (covariance) or less derived (「反變數」) than a target constructed type.</span><span class="sxs-lookup"><span data-stu-id="45c1e-134">*Covariance* and *contravariance* of generic type parameters enable you to use constructed generic types whose type arguments are more derived (covariance) or less derived (contravariance) than a target constructed type.</span></span> <span data-ttu-id="45c1e-135">共變數和反變數合稱為「變異數」。</span><span class="sxs-lookup"><span data-stu-id="45c1e-135">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="45c1e-136">如需詳細資訊，請參閱 [Covariance and Contravariance](../../../docs/standard/generics/covariance-and-contravariance.md) (共變數和反變數)。</span><span class="sxs-lookup"><span data-stu-id="45c1e-136">For more information, see [Covariance and Contravariance](../../../docs/standard/generics/covariance-and-contravariance.md).</span></span>  
  
-   <span data-ttu-id="45c1e-137">*「條件約束」* (Constraint)，是在泛型類型參數上的限制。</span><span class="sxs-lookup"><span data-stu-id="45c1e-137">*Constraints* are limits placed on generic type parameters.</span></span> <span data-ttu-id="45c1e-138">例如，您可以限制類型參數為實作 <xref:System.Collections.Generic.IComparer%601?displayProperty=fullName> 泛型介面的類型，以確保能夠排序類型的執行個體。</span><span class="sxs-lookup"><span data-stu-id="45c1e-138">For example, you might limit a type parameter to types that implement the <xref:System.Collections.Generic.IComparer%601?displayProperty=fullName> generic interface, to ensure that instances of the type can be ordered.</span></span> <span data-ttu-id="45c1e-139">您也可以將類型參數限制為具有特定基底類別的類型，或是具有預設建構函式的類型，或為參考類型或實值類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-139">You can also constrain type parameters to types that have a particular base class, that have a default constructor, or that are reference types or value types.</span></span> <span data-ttu-id="45c1e-140">的泛型類型的使用者無法替換沒有滿足這些條件約束的類型引數。</span><span class="sxs-lookup"><span data-stu-id="45c1e-140">Users of the generic type cannot substitute type arguments that do not satisfy the constraints.</span></span>  
  
-   <span data-ttu-id="45c1e-141">*「泛型方法定義」* (generic method definition)，是一種有兩個參數清單的方法：泛型類型參數清單和型式參數清單。</span><span class="sxs-lookup"><span data-stu-id="45c1e-141">A *generic method definition* is a method with two parameter lists: a list of generic type parameters and a list of formal parameters.</span></span> <span data-ttu-id="45c1e-142">類型參數會顯示為傳回類型或型式參數的類型，如下程式碼所示。</span><span class="sxs-lookup"><span data-stu-id="45c1e-142">Type parameters can appear as the return type or as the types of the formal parameters, as the following code shows.</span></span>  
  
 <span data-ttu-id="45c1e-143">[!code-cpp[Conceptual.Generics.Overview#4](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#4)] [!code-csharp[Conceptual.Generics.Overview#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#4)] [!code-vb[Conceptual.Generics.Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#4)]</span><span class="sxs-lookup"><span data-stu-id="45c1e-143">[!code-cpp[Conceptual.Generics.Overview#4](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#4)] [!code-csharp[Conceptual.Generics.Overview#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#4)] [!code-vb[Conceptual.Generics.Overview#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#4)]</span></span>  
  
 <span data-ttu-id="45c1e-144">泛型方法可能會出現在泛型或非泛型類型上。</span><span class="sxs-lookup"><span data-stu-id="45c1e-144">Generic methods can appear on generic or nongeneric types.</span></span> <span data-ttu-id="45c1e-145">請務必注意，不會只因為某個方法屬於泛型類型，或只是因為它型式參數的類型是封入類型的泛用參數，此方法就成為泛型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-145">It is important to note that a method is not generic just because it belongs to a generic type, or even because it has formal parameters whose types are the generic parameters of the enclosing type.</span></span> <span data-ttu-id="45c1e-146">只有當方法有它自己的類型參數清單時，它才會是泛型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-146">A method is generic only if it has its own list of type parameters.</span></span> <span data-ttu-id="45c1e-147">在下列程式碼中，只有方法 `G` 是泛型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-147">In the following code, only method `G` is generic.</span></span>  
  
 <span data-ttu-id="45c1e-148">[!code-cpp[Conceptual.Generics.Overview#5](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#5)] [!code-csharp[Conceptual.Generics.Overview#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#5)] [!code-vb[Conceptual.Generics.Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#5)]</span><span class="sxs-lookup"><span data-stu-id="45c1e-148">[!code-cpp[Conceptual.Generics.Overview#5](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.generics.overview/cpp/source.cpp#5)] [!code-csharp[Conceptual.Generics.Overview#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.generics.overview/cs/source.cs#5)] [!code-vb[Conceptual.Generics.Overview#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.generics.overview/vb/source.vb#5)]</span></span>  
  
 [<span data-ttu-id="45c1e-149">回到頁首</span><span class="sxs-lookup"><span data-stu-id="45c1e-149">Back to top</span></span>](#top)  
  
<a name="advantages_limitations"></a>   
## <a name="advantages-and-disadvantages-of-generics"></a><span data-ttu-id="45c1e-150">泛型的優缺點</span><span class="sxs-lookup"><span data-stu-id="45c1e-150">Advantages and disadvantages of generics</span></span>  
 <span data-ttu-id="45c1e-151">使用泛型集合和委派有許多優點：</span><span class="sxs-lookup"><span data-stu-id="45c1e-151">There are many advantages to using generic collections and delegates:</span></span>  
  
-   <span data-ttu-id="45c1e-152">類型安全。</span><span class="sxs-lookup"><span data-stu-id="45c1e-152">Type safety.</span></span> <span data-ttu-id="45c1e-153">泛型會將類型安全的負擔轉移給編譯器。</span><span class="sxs-lookup"><span data-stu-id="45c1e-153">Generics shift the burden of type safety from you to the compiler.</span></span> <span data-ttu-id="45c1e-154">並不需要撰寫程式碼以測試是否為正確的資料類型，因為它在編譯時期會強制執行。</span><span class="sxs-lookup"><span data-stu-id="45c1e-154">There is no need to write code to test for the correct data type because it is enforced at compile time.</span></span> <span data-ttu-id="45c1e-155">降低了類型轉換的需求以及執行階段錯誤的可能性。</span><span class="sxs-lookup"><span data-stu-id="45c1e-155">The need for type casting and the possibility of run-time errors are reduced.</span></span>  
  
-   <span data-ttu-id="45c1e-156">程式碼較少且更容易重複使用程式碼。</span><span class="sxs-lookup"><span data-stu-id="45c1e-156">Less code and code is more easily reused.</span></span> <span data-ttu-id="45c1e-157">沒有需要從基底類型繼承，並覆寫成員。</span><span class="sxs-lookup"><span data-stu-id="45c1e-157">There is no need to inherit from a base type and override members.</span></span> <span data-ttu-id="45c1e-158">例如， <xref:System.Collections.Generic.LinkedList%601> 可以立即使用。</span><span class="sxs-lookup"><span data-stu-id="45c1e-158">For example, the <xref:System.Collections.Generic.LinkedList%601> is ready for immediate use.</span></span> <span data-ttu-id="45c1e-159">例如，您可以下列變數宣告，建立字串的連結清單：</span><span class="sxs-lookup"><span data-stu-id="45c1e-159">For example, you can create a linked list of strings with the following variable declaration:</span></span>  
  
     <span data-ttu-id="45c1e-160">[!code-cpp[HowToGeneric#24](../../../samples/snippets/cpp/VS_Snippets_CLR/HowToGeneric/cpp/source2.cpp#24)]  [!code-csharp[HowToGeneric#24](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToGeneric/CS/source2.cs#24)]  [!code-vb[HowToGeneric#24](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToGeneric/VB/source2.vb#24)]</span><span class="sxs-lookup"><span data-stu-id="45c1e-160">[!code-cpp[HowToGeneric#24](../../../samples/snippets/cpp/VS_Snippets_CLR/HowToGeneric/cpp/source2.cpp#24)]  [!code-csharp[HowToGeneric#24](../../../samples/snippets/csharp/VS_Snippets_CLR/HowToGeneric/CS/source2.cs#24)]  [!code-vb[HowToGeneric#24](../../../samples/snippets/visualbasic/VS_Snippets_CLR/HowToGeneric/VB/source2.vb#24)]</span></span>  
  
-   <span data-ttu-id="45c1e-161">效能較佳。</span><span class="sxs-lookup"><span data-stu-id="45c1e-161">Better performance.</span></span> <span data-ttu-id="45c1e-162">泛型集合類型在儲存和管理實值類型上，通常有較好的表現，因為不需要 box 實值類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-162">Generic collection types generally perform better for storing and manipulating value types because there is no need to box the value types.</span></span>  
  
-   <span data-ttu-id="45c1e-163">泛型委派讓類型安全回呼不需要建立多個委派類別。</span><span class="sxs-lookup"><span data-stu-id="45c1e-163">Generic delegates enable type-safe callbacks without the need to create multiple delegate classes.</span></span> <span data-ttu-id="45c1e-164">例如， <xref:System.Predicate%601> 泛型委派可讓您建立一種方法，為特定類型實作您自己的搜尋條件，以及讓您搭配 <xref:System.Array> 類型的方法 (例如 <xref:System.Array.Find%2A>、 <xref:System.Array.FindLast%2A>和 <xref:System.Array.FindAll%2A>) 使用方法。</span><span class="sxs-lookup"><span data-stu-id="45c1e-164">For example, the <xref:System.Predicate%601> generic delegate allows you to create a method that implements your own search criteria for a particular type and to use your method with methods of the <xref:System.Array> type such as <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, and <xref:System.Array.FindAll%2A>.</span></span>  
  
-   <span data-ttu-id="45c1e-165">泛型簡化了動態產生的程式碼。</span><span class="sxs-lookup"><span data-stu-id="45c1e-165">Generics streamline dynamically generated code.</span></span> <span data-ttu-id="45c1e-166">當您搭配動態產生的程式碼使用泛型時，不需要產生類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-166">When you use generics with dynamically generated code you do not need to generate the type.</span></span> <span data-ttu-id="45c1e-167">這會增加您使用輕量動態方法而非產生整個組件的時機。</span><span class="sxs-lookup"><span data-stu-id="45c1e-167">This increases the number of scenarios in which you can use lightweight dynamic methods instead of generating entire assemblies.</span></span> <span data-ttu-id="45c1e-168">如需詳細資訊，請參閱＜如何：定義和執行動態方法及 DynamicMethod＞。</span><span class="sxs-lookup"><span data-stu-id="45c1e-168">For more information, see How to: Define and Execute Dynamic Methods and DynamicMethod.</span></span>  
  
 <span data-ttu-id="45c1e-169">下列是泛型的一些限制：</span><span class="sxs-lookup"><span data-stu-id="45c1e-169">The following are some limitations of generics:</span></span>  
  
-   <span data-ttu-id="45c1e-170">泛型類型可以從大部分的基底類別衍生，例如 <xref:System.MarshalByRefObject> (且可使用條件約束要求泛型類型參數衍生自基底類別，例如 <xref:System.MarshalByRefObject>)。</span><span class="sxs-lookup"><span data-stu-id="45c1e-170">Generic types can be derived from most base classes, such as <xref:System.MarshalByRefObject> (and constraints can be used to require that generic type parameters derive from base classes like <xref:System.MarshalByRefObject>).</span></span> <span data-ttu-id="45c1e-171">不過， [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] 不支援內容繫結的泛型類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-171">However, the [!INCLUDE[dnprdnshort](../../../includes/dnprdnshort-md.md)] does not support context-bound generic types.</span></span> <span data-ttu-id="45c1e-172">泛型類型可以衍生自 <xref:System.ContextBoundObject>，但嘗試建立該類型的執行個體會導致 <xref:System.TypeLoadException>。</span><span class="sxs-lookup"><span data-stu-id="45c1e-172">A generic type can be derived from <xref:System.ContextBoundObject>, but trying to create an instance of that type causes a <xref:System.TypeLoadException>.</span></span>  
  
-   <span data-ttu-id="45c1e-173">列舉不能有泛型類型參數。</span><span class="sxs-lookup"><span data-stu-id="45c1e-173">Enumerations cannot have generic type parameters.</span></span> <span data-ttu-id="45c1e-174">列舉只能偶爾做為泛型 (例如，因為它位於使用 Visual Basic、C# 或 C++ 所定義的泛型類型中)。</span><span class="sxs-lookup"><span data-stu-id="45c1e-174">An enumeration can be generic only incidentally (for example, because it is nested in a generic type that is defined using Visual Basic, C#, or C++).</span></span> <span data-ttu-id="45c1e-175">如需詳細資訊，請參閱 [Common Type System](../../../docs/standard/base-types/common-type-system.md)中的＜列舉＞。</span><span class="sxs-lookup"><span data-stu-id="45c1e-175">For more information, see "Enumerations" in [Common Type System](../../../docs/standard/base-types/common-type-system.md).</span></span>  
  
-   <span data-ttu-id="45c1e-176">輕量動態方法不可為泛型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-176">Lightweight dynamic methods cannot be generic.</span></span>  
  
-   <span data-ttu-id="45c1e-177">在 Visual Basic、C# 和 C++ 中，括在泛型類型中的巢狀類型無法具現化，除非已將指派給類型所有封入類型的類型參數。</span><span class="sxs-lookup"><span data-stu-id="45c1e-177">In Visual Basic, C#, and C++, a nested type that is enclosed in a generic type cannot be instantiated unless types have been assigned to the type parameters of all enclosing types.</span></span> <span data-ttu-id="45c1e-178">另一個說法是，在反映中，已定義使用這些語言的巢狀類型，包括了其所有封入類型的類型參數。</span><span class="sxs-lookup"><span data-stu-id="45c1e-178">Another way of saying this is that in reflection, a nested type that is defined using these languages includes the type parameters of all its enclosing types.</span></span> <span data-ttu-id="45c1e-179">這讓封入類型的類型參數，可用於巢狀類型的成員定義中。</span><span class="sxs-lookup"><span data-stu-id="45c1e-179">This allows the type parameters of enclosing types to be used in the member definitions of a nested type.</span></span> <span data-ttu-id="45c1e-180">如需詳細資訊，請參閱 <xref:System.Type.MakeGenericType%2A>中的「巢狀類型」。</span><span class="sxs-lookup"><span data-stu-id="45c1e-180">For more information, see "Nested Types" in <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="45c1e-181">透過發出動態組件中的程式碼或使用 [Ilasm.exe (IL Assembler)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) 所定義的巢狀型別，不一定要包含其封入型別的型別參數；不過，如果它不包含這些，型別參數就不在巢狀類別的範圍中。</span><span class="sxs-lookup"><span data-stu-id="45c1e-181">A nested type that is defined by emitting code in a dynamic assembly or by using the [Ilasm.exe (IL Assembler)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) is not required to include the type parameters of its enclosing types; however, if it does not include them, the type parameters are not in scope in the nested class.</span></span>  
  
     <span data-ttu-id="45c1e-182">如需詳細資訊，請參閱 <xref:System.Type.MakeGenericType%2A>中的「巢狀類型」。</span><span class="sxs-lookup"><span data-stu-id="45c1e-182">For more information, see "Nested Types" in <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 [<span data-ttu-id="45c1e-183">回到頁首</span><span class="sxs-lookup"><span data-stu-id="45c1e-183">Back to top</span></span>](#top)  
  
<a name="class_library_and_language_support"></a>   
## <a name="class-library-and-language-support"></a><span data-ttu-id="45c1e-184">類別庫和語言支援</span><span class="sxs-lookup"><span data-stu-id="45c1e-184">Class Library and Language Support</span></span>  
 <span data-ttu-id="45c1e-185">.NET Framework 在下列命名空間中提供數個泛型集合類別：</span><span class="sxs-lookup"><span data-stu-id="45c1e-185">The .NET Framework provides a number of generic collection classes in the following namespaces:</span></span>  
  
-   <span data-ttu-id="45c1e-186"><xref:System.Collections.Generic> 命名空間分類了 .NET Framework 所提供的大部分泛型集合類型，例如 <xref:System.Collections.Generic.List%601> 和 <xref:System.Collections.Generic.Dictionary%602> 泛型類別。</span><span class="sxs-lookup"><span data-stu-id="45c1e-186">The <xref:System.Collections.Generic> namespace catalogs most of the generic collection types provided by the .NET Framework, such as the <xref:System.Collections.Generic.List%601> and <xref:System.Collections.Generic.Dictionary%602> generic classes.</span></span>  
  
-   <span data-ttu-id="45c1e-187"><xref:System.Collections.ObjectModel> 命名空間也分類了其他泛型集合類型，例如 <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> 泛型類別，其對您類別之使用者公開物件模型很有用。</span><span class="sxs-lookup"><span data-stu-id="45c1e-187">The <xref:System.Collections.ObjectModel> namespace catalogs additional generic collection types, such as the <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> generic class, that are useful for exposing object models to users of your classes.</span></span>  
  
 <span data-ttu-id="45c1e-188">實作排序及相等比較的泛型介面，和事件處理常式、轉換及搜尋述詞的泛型委派類型，一起提供於 <xref:System> 命名空間中。</span><span class="sxs-lookup"><span data-stu-id="45c1e-188">Generic interfaces for implementing sort and equality comparisons are provided in the <xref:System> namespace, along with generic delegate types for event handlers, conversions, and search predicates.</span></span>  
  
 <span data-ttu-id="45c1e-189">對泛型的支援已加入 <xref:System.Reflection> 命名空間，以檢查泛型類型和泛型方法；也加入 <xref:System.Reflection.Emit> ，以發出包含泛型類型和方法的動態組件；同時還加入 <xref:System.CodeDom> ，以產生包含泛型的來源圖形。</span><span class="sxs-lookup"><span data-stu-id="45c1e-189">Support for generics has been added to the <xref:System.Reflection> namespace for examining generic types and generic methods, to <xref:System.Reflection.Emit> for emitting dynamic assemblies that contain generic types and methods, and to <xref:System.CodeDom> for generating source graphs that include generics.</span></span>  
  
 <span data-ttu-id="45c1e-190">Common Language Runtime 提供新的 opcode 及前置詞，以支援 Microsoft 中繼語言 (MSIL) 中的泛型類型，包括 <xref:System.Reflection.Emit.OpCodes.Stelem>、 <xref:System.Reflection.Emit.OpCodes.Ldelem>、 <xref:System.Reflection.Emit.OpCodes.Unbox_Any>、 <xref:System.Reflection.Emit.OpCodes.Constrained>和 <xref:System.Reflection.Emit.OpCodes.Readonly>。</span><span class="sxs-lookup"><span data-stu-id="45c1e-190">The common language runtime provides new opcodes and prefixes to support generic types in Microsoft intermediate language (MSIL), including <xref:System.Reflection.Emit.OpCodes.Stelem>, <xref:System.Reflection.Emit.OpCodes.Ldelem>, <xref:System.Reflection.Emit.OpCodes.Unbox_Any>, <xref:System.Reflection.Emit.OpCodes.Constrained>, and <xref:System.Reflection.Emit.OpCodes.Readonly>.</span></span>  
  
 <span data-ttu-id="45c1e-191">Visual C++、C# 和 Visual Basic 均提供定義及使用泛型的完整支援。</span><span class="sxs-lookup"><span data-stu-id="45c1e-191">Visual C++, C#, and Visual Basic all provide full support for defining and using generics.</span></span> <span data-ttu-id="45c1e-192">如需語言支援的詳細資訊，請參閱 [Visual Basic 中的泛型型別](~/docs/visual-basic/programming-guide/language-features/data-types/generic-types.md)、[泛型簡介](~/docs/csharp/programming-guide/generics/introduction-to-generics.md)和 [Visual C++ 中的泛型概觀](/cpp/windows/overview-of-generics-in-visual-cpp)。</span><span class="sxs-lookup"><span data-stu-id="45c1e-192">For more information about language support, see [Generic Types in Visual Basic](~/docs/visual-basic/programming-guide/language-features/data-types/generic-types.md), [Introduction to Generics](~/docs/csharp/programming-guide/generics/introduction-to-generics.md), and [Overview of Generics in Visual C++](/cpp/windows/overview-of-generics-in-visual-cpp).</span></span>  
  
 [<span data-ttu-id="45c1e-193">回到頁首</span><span class="sxs-lookup"><span data-stu-id="45c1e-193">Back to top</span></span>](#top)  
  
<a name="nested_types_and_generics"></a>   
## <a name="nested-types-and-generics"></a><span data-ttu-id="45c1e-194">巢狀類型和泛型</span><span class="sxs-lookup"><span data-stu-id="45c1e-194">Nested Types and Generics</span></span>  
 <span data-ttu-id="45c1e-195">泛型類型中的巢狀類型，可取決於封入泛型類型的類型參數。</span><span class="sxs-lookup"><span data-stu-id="45c1e-195">A type that is nested in a generic type can depend on the type parameters of the enclosing generic type.</span></span> <span data-ttu-id="45c1e-196">Common Language Runtime 會將巢狀類型視為泛型，即使它們沒有自己的泛型類型參數。</span><span class="sxs-lookup"><span data-stu-id="45c1e-196">The common language runtime considers nested types to be generic, even if they do not have generic type parameters of their own.</span></span> <span data-ttu-id="45c1e-197">當您建立巢狀類型的執行個體時，必須為所有封入泛型類型指定類型引數。</span><span class="sxs-lookup"><span data-stu-id="45c1e-197">When you create an instance of a nested type, you must specify type arguments for all enclosing generic types.</span></span>  
  
 [<span data-ttu-id="45c1e-198">回到頁首</span><span class="sxs-lookup"><span data-stu-id="45c1e-198">Back to top</span></span>](#top)  
  
<a name="related_topics"></a>   
## <a name="related-topics"></a><span data-ttu-id="45c1e-199">相關主題</span><span class="sxs-lookup"><span data-stu-id="45c1e-199">Related Topics</span></span>  
  
|<span data-ttu-id="45c1e-200">標題</span><span class="sxs-lookup"><span data-stu-id="45c1e-200">Title</span></span>|<span data-ttu-id="45c1e-201">說明</span><span class="sxs-lookup"><span data-stu-id="45c1e-201">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="45c1e-202">.NET Framework 中的泛型集合</span><span class="sxs-lookup"><span data-stu-id="45c1e-202">Generic Collections in the .NET Framework</span></span>](../../../docs/standard/generics/collections.md)|<span data-ttu-id="45c1e-203">描述 .NET Framework 中的泛型集合類別以及其他泛型類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-203">Describes generic collection classes and other generic types in the .NET Framework.</span></span>|  
|[<span data-ttu-id="45c1e-204">管理陣列和清單的泛型委派</span><span class="sxs-lookup"><span data-stu-id="45c1e-204">Generic Delegates for Manipulating Arrays and Lists</span></span>](../../../docs/standard/generics/delegates-for-manipulating-arrays-and-lists.md)|<span data-ttu-id="45c1e-205">描述轉換、搜尋述詞以及要在陣列或集合的元素上採取之動作的泛型委派。</span><span class="sxs-lookup"><span data-stu-id="45c1e-205">Describes generic delegates for conversions, search predicates, and actions to be taken on elements of an array or collection.</span></span>|  
|[<span data-ttu-id="45c1e-206">泛型介面</span><span class="sxs-lookup"><span data-stu-id="45c1e-206">Generic Interfaces</span></span>](../../../docs/standard/generics/interfaces.md)|<span data-ttu-id="45c1e-207">描述提供泛型類型系列中常見功能的泛型介面。</span><span class="sxs-lookup"><span data-stu-id="45c1e-207">Describes generic interfaces that provide common functionality across families of generic types.</span></span>|  
|[<span data-ttu-id="45c1e-208">共變數和反變數</span><span class="sxs-lookup"><span data-stu-id="45c1e-208">Covariance and Contravariance</span></span>](../../../docs/standard/generics/covariance-and-contravariance.md)|<span data-ttu-id="45c1e-209">描述泛型類型參數的共變數和反變數。</span><span class="sxs-lookup"><span data-stu-id="45c1e-209">Describes covariance and contravariance in generic type parameters.</span></span>|  
|[<span data-ttu-id="45c1e-210">常用的集合類型</span><span class="sxs-lookup"><span data-stu-id="45c1e-210">Commonly Used Collection Types</span></span>](../../../docs/standard/collections/commonly-used-collection-types.md)|<span data-ttu-id="45c1e-211">提供 .NET Framework 中集合類型的特性和使用方式案例的摘要資訊，包括泛型類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-211">Provides summary information about the characteristics and usage scenarios of the collection types in the .NET Framework, including generic types.</span></span>|  
|[<span data-ttu-id="45c1e-212">何時使用泛型集合</span><span class="sxs-lookup"><span data-stu-id="45c1e-212">When to Use Generic Collections</span></span>](../../../docs/standard/collections/when-to-use-generic-collections.md)|<span data-ttu-id="45c1e-213">描述一般的規則，以判斷何時使用泛型集合類型。</span><span class="sxs-lookup"><span data-stu-id="45c1e-213">Describes general rules for determining when to use generic collection types.</span></span>|  
|[<span data-ttu-id="45c1e-214">操作說明：使用反映發出定義泛型型別</span><span class="sxs-lookup"><span data-stu-id="45c1e-214">How to: Define a Generic Type with Reflection Emit</span></span>](../../../docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md)|<span data-ttu-id="45c1e-215">說明如何產生包括泛型類型和方法的動態組件。</span><span class="sxs-lookup"><span data-stu-id="45c1e-215">Explains how to generate dynamic assemblies that include generic types and methods.</span></span>|  
|[<span data-ttu-id="45c1e-216">Generic Types in Visual Basic</span><span class="sxs-lookup"><span data-stu-id="45c1e-216">Generic Types in Visual Basic</span></span>](~/docs/visual-basic/programming-guide/language-features/data-types/generic-types.md)|<span data-ttu-id="45c1e-217">為 Visual Basic 使用者描述泛型功能，包括使用及定義泛型類型的「操作說明」主題。</span><span class="sxs-lookup"><span data-stu-id="45c1e-217">Describes the generics feature for Visual Basic users, including how-to topics for using and defining generic types.</span></span>|  
|[<span data-ttu-id="45c1e-218">泛型簡介</span><span class="sxs-lookup"><span data-stu-id="45c1e-218">Introduction to Generics</span></span>](~/docs/csharp/programming-guide/generics/introduction-to-generics.md)|<span data-ttu-id="45c1e-219">為 C# 使用者提供定義和使用泛型類型的概觀。</span><span class="sxs-lookup"><span data-stu-id="45c1e-219">Provides an overview of defining and using generic types for C# users.</span></span>|  
|[<span data-ttu-id="45c1e-220">Visual C++ 中的泛型概觀</span><span class="sxs-lookup"><span data-stu-id="45c1e-220">Overview of Generics in Visual C++</span></span>](/cpp/windows/overview-of-generics-in-visual-cpp)|<span data-ttu-id="45c1e-221">描述 C++ 使用者的泛型功能，包括泛型和範本之間的差異。</span><span class="sxs-lookup"><span data-stu-id="45c1e-221">Describes the generics feature for C++ users, including the differences between generics and templates.</span></span>|  
  
<a name="reference"></a>   
## <a name="reference"></a><span data-ttu-id="45c1e-222">參考資料</span><span class="sxs-lookup"><span data-stu-id="45c1e-222">Reference</span></span>  
 <xref:System.Collections.Generic>  
  
 <xref:System.Collections.ObjectModel>  
  
 <xref:System.Reflection.Emit.OpCodes?displayProperty=fullName>  
  
 [<span data-ttu-id="45c1e-223">回到頁首</span><span class="sxs-lookup"><span data-stu-id="45c1e-223">Back to top</span></span>](#top)

