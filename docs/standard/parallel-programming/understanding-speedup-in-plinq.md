---
title: "認識 PLINQ 中的加速"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: PLINQ queries, performance tuning
ms.assetid: 53706c7e-397d-467a-98cd-c0d1fd63ba5e
caps.latest.revision: "14"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: c3373cb6a2c535bd7d42eb062e1f9727952f7cfb
ms.sourcegitcommit: bd1ef61f4bb794b25383d3d72e71041a5ced172e
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/18/2017
---
# <a name="understanding-speedup-in-plinq"></a><span data-ttu-id="5cb9a-102">認識 PLINQ 中的加速</span><span class="sxs-lookup"><span data-stu-id="5cb9a-102">Understanding Speedup in PLINQ</span></span>
<span data-ttu-id="5cb9a-103">PLINQ 的主要目的是加速執行 LINQ 查詢物件藉由在多核心電腦上平行執行查詢委派。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-103">The primary purpose of PLINQ is to speed up the execution of LINQ to Objects queries by executing the query delegates in parallel on multi-core computers.</span></span> <span data-ttu-id="5cb9a-104">每個項目的來源集合中的處理序無關，各自有涉及在個別的委派之間共用的狀態時，PLINQ 的執行效果最好。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-104">PLINQ performs best when the processing of each element in a source collection is independent, with no shared state involved among the individual delegates.</span></span> <span data-ttu-id="5cb9a-105">這類作業在 LINQ to Objects 和 PLINQ 中很常見，和通常稱為 「*delightfully 平行*"因為它們出借本身輕鬆地與多個執行緒上排程。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-105">Such operations are common in LINQ to Objects and PLINQ, and are often called "*delightfully parallel*" because they lend themselves easily to scheduling on multiple threads.</span></span> <span data-ttu-id="5cb9a-106">不過，並非所有的查詢包含完全個 delightfully 平行作業。在大部分情況下，查詢牽涉到某些運算子是無法平行處理，或降低平行執行的速度。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-106">However, not all queries consist entirely of delightfully parallel operations; in most cases, a query involves some operators that either cannot be parallelized, or that slow down parallel execution.</span></span> <span data-ttu-id="5cb9a-107">即使是完全 delightfully 平行查詢，使用 PLINQ 必須並仍資料分割的資料來源和上排程工作的執行緒，通常是在查詢完成時的結果合併。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-107">And even with queries that are entirely delightfully parallel, PLINQ must still partition the data source and schedule the work on the threads, and usually merge the results when the query completes.</span></span> <span data-ttu-id="5cb9a-108">所有這些作業新增計算成本的平行化作業;這些將加入的平行處理的成本會呼叫*負擔*。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-108">All these operations add to the computational cost of parallelization; these costs of adding parallelization are called *overhead*.</span></span> <span data-ttu-id="5cb9a-109">若要達到最佳效能 PLINQ 查詢中的，目標是最大化 delightfully 平行的組件的組件，需要額外負荷降到最低。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-109">To achieve optimum performance in a PLINQ query, the goal is to maximize the parts that are delightfully parallel and minimize the parts that require overhead.</span></span> <span data-ttu-id="5cb9a-110">本文章提供可協助您撰寫時仍會產生正確的結果會盡可能有效率的 PLINQ 查詢的資訊。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-110">This article provides information that will help you write PLINQ queries that are as efficient as possible while still yielding correct results.</span></span>  
  
## <a name="factors-that-impact-plinq-query-performance"></a><span data-ttu-id="5cb9a-111">影響 PLINQ 查詢效能的因素</span><span class="sxs-lookup"><span data-stu-id="5cb9a-111">Factors that Impact PLINQ Query Performance</span></span>  
 <span data-ttu-id="5cb9a-112">下列各節列出一些最重要的因素影響平行查詢效能。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-112">The following sections lists some of the most important factors that impact parallel query performance.</span></span> <span data-ttu-id="5cb9a-113">這些是一般陳述式本身並不足夠預測查詢效能，在所有情況下。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-113">These are general statements that by themselves are not sufficient to predict query performance in all cases.</span></span> <span data-ttu-id="5cb9a-114">如往常，請務必測量利用某個範圍的代表性的組態和負載在電腦上的特定查詢的效能。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-114">As always, it is important to measure actual performance of specific queries on computers with a range of representative configurations and loads.</span></span>  
  
1.  <span data-ttu-id="5cb9a-115">計算整體工作的成本。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-115">Computational cost of the overall work.</span></span>  
  
     <span data-ttu-id="5cb9a-116">若要達到加速，PLINQ 查詢必須足夠 delightfully 平行的工作，來彌補額外負荷。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-116">To achieve speedup, a PLINQ query must have enough delightfully parallel work to offset the overhead.</span></span> <span data-ttu-id="5cb9a-117">工作可以表示為乘以來源集合中的項目數的每個委派的運算成本。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-117">The work can be expressed as the computational cost of each delegate multiplied by the number of elements in the source collection.</span></span> <span data-ttu-id="5cb9a-118">假設作業可平行處理，更多計算它的昂貴，大於加速的機會。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-118">Assuming that an operation can be parallelized, the more computationally expensive it is, the greater the opportunity for speedup.</span></span> <span data-ttu-id="5cb9a-119">例如，如果函式執行的一毫秒，循序查詢超過 1000年項目將會接受一個第二個執行這項操作，而平行查詢具有四個核心的電腦上可能只 250 毫秒。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-119">For example, if a function takes one millisecond to execute, a sequential query over 1000 elements will take one second to perform that operation, whereas a parallel query on a computer with four cores might take only 250 milliseconds.</span></span> <span data-ttu-id="5cb9a-120">這會產生 750 毫秒的加速效果。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-120">This yields a speedup of 750 milliseconds.</span></span> <span data-ttu-id="5cb9a-121">如果函式需要每個項目執行一秒，通常會是 750 秒。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-121">If the function required one second to execute for each element, then the speedup would be 750 seconds.</span></span> <span data-ttu-id="5cb9a-122">如果委派是很昂貴，PLINQ 可能會提供顯著的加速效果，與來源集合中只有幾個項目。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-122">If the delegate is very expensive, then PLINQ might offer significant speedup with only a few items in the source collection.</span></span> <span data-ttu-id="5cb9a-123">相反地，小型的來源集合具有 trivial 委派通常不是 PLINQ 的理想候選項。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-123">Conversely, small source collections with trivial delegates are generally not good candidates for PLINQ.</span></span>  
  
     <span data-ttu-id="5cb9a-124">在下列範例中，queryA 可能是工作的適合做為 PLINQ，假設其選取的函式牽涉到大量。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-124">In the following example, queryA is probably a good candidate for PLINQ, assuming that its Select function involves a lot of work.</span></span> <span data-ttu-id="5cb9a-125">queryB 可能就不適合的候選項，因此沒有足夠的工作，在 Select 陳述式中，平行化作業帶來的額外負荷將位移大部分或所有的加速效果。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-125">queryB is probably not a good candidate because there is not enough work in the Select statement, and the overhead of parallelization will offset most or all of the speedup.</span></span>  
  
    ```vb  
    Dim queryA = From num In numberList.AsParallel()  
                 Select ExpensiveFunction(num); 'good for PLINQ  
  
    Dim queryB = From num In numberList.AsParallel()  
                 Where num Mod 2 > 0  
                 Select num; 'not as good for PLINQ  
    ```  
  
    ```csharp  
    var queryA = from num in numberList.AsParallel()  
                 select ExpensiveFunction(num); //good for PLINQ  
  
    var queryB = from num in numberList.AsParallel()  
                 where num % 2 > 0  
                 select num; //not as good for PLINQ  
    ```  
  
2.  <span data-ttu-id="5cb9a-126">系統 （平行處理原則的程度） 上的邏輯核心數目。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-126">The number of logical cores on the system (degree of parallelism).</span></span>  
  
     <span data-ttu-id="5cb9a-127">這點明顯推論上一節，delightfully 平行查詢執行速度在電腦上具有多個核心因為工作可以分配給更多並行執行緒。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-127">This point is an obvious corollary to the previous section, queries that are delightfully parallel run faster on machines with more cores because the work can be divided among more concurrent threads.</span></span> <span data-ttu-id="5cb9a-128">整體的加速效果量取決於整體的查詢工作的百分比是可並行。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-128">The overall amount of speedup depends on what percentage of the overall work of the query is parallelizable.</span></span> <span data-ttu-id="5cb9a-129">不過，不會假設所有查詢都會都執行兩次以快速在八個核心的電腦上做為四個核心的電腦。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-129">However, do not assume that all queries will run twice as fast on an eight core computer as a four core computer.</span></span> <span data-ttu-id="5cb9a-130">微調查詢，以獲得最佳效能時, 務必測量在具有不同的數字的核心電腦上的實際結果。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-130">When tuning queries for optimal performance, it is important to measure actual results on computers with various numbers of cores.</span></span> <span data-ttu-id="5cb9a-131">這點與點 #1： 較大的資料集，才能利用大於運算資源。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-131">This point is related to point #1: larger datasets are required to take advantage of greater computing resources.</span></span>  
  
3.  <span data-ttu-id="5cb9a-132">數目和類型的作業。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-132">The number and kind of operations.</span></span>  
  
     <span data-ttu-id="5cb9a-133">PLINQ 提供 AsOrdered 運算子的情況下，它是為了維持來源序列中項目的順序。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-133">PLINQ provides the AsOrdered operator for situations in which it is necessary to maintain the order of elements in the source sequence.</span></span> <span data-ttu-id="5cb9a-134">與順序相關聯的成本，但此成本是通常太大。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-134">There is a cost associated with ordering, but this cost is usually modest.</span></span> <span data-ttu-id="5cb9a-135">同樣地，GroupBy 和聯結作業會產生負擔。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-135">GroupBy and Join operations likewise incur overhead.</span></span> <span data-ttu-id="5cb9a-136">當處理以任何順序，來源集合中的項目，並將其傳遞至下一個運算子，他們就可以為允許時，PLINQ 的執行效果最好。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-136">PLINQ performs best when it is allowed to process elements in the source collection in any order, and pass them to the next operator as soon as they are ready.</span></span> <span data-ttu-id="5cb9a-137">如需詳細資訊，請參閱 [PLINQ 中的順序保留](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-137">For more information, see [Order Preservation in PLINQ](../../../docs/standard/parallel-programming/order-preservation-in-plinq.md).</span></span>  
  
4.  <span data-ttu-id="5cb9a-138">查詢執行的表單。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-138">The form of query execution.</span></span>  
  
     <span data-ttu-id="5cb9a-139">如果您透過呼叫 ToArray 或 ToList 儲存查詢的結果，所有平行執行緒的結果必須合併成單一的資料結構。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-139">If you are storing the results of a query by calling ToArray or ToList, then the results from all parallel threads must be merged into the single data structure.</span></span> <span data-ttu-id="5cb9a-140">這牽涉到無可避免的運算成本。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-140">This involves an unavoidable computational cost.</span></span> <span data-ttu-id="5cb9a-141">同樣地，如果您來使用 （針對每個 Visual Basic 中） 的 「 foreach 迴圈，逐一查看結果，背景工作執行緒的結果必須序列化到列舉程式執行緒。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-141">Likewise, if you iterate the results by using a foreach (For Each in Visual Basic) loop, the results from the worker threads need to be serialized onto the enumerator thread.</span></span> <span data-ttu-id="5cb9a-142">但是，如果您只想執行某些動作，根據每個執行緒的結果，您可以在多個執行緒上執行這項工作使用 ForAll 方法。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-142">But if you just want to perform some action based on the result from each thread, you can use the ForAll method to perform this work on multiple threads.</span></span>  
  
5.  <span data-ttu-id="5cb9a-143">合併選項類型。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-143">The type of merge options.</span></span>  
  
     <span data-ttu-id="5cb9a-144">PLINQ 可以緩衝的輸出，並產生區塊 （chunk） 或一次之後整個結果集產生，或資料流的個別結果時，會產生這些設定。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-144">PLINQ can be configured to either buffer its output, and produce it in chunks or all at once after the entire result set is produced, or else to stream individual results as they are produced.</span></span> <span data-ttu-id="5cb9a-145">先前的結果是減少整體的執行時間並降低延遲，產生的項目之間的第二個結果。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-145">The former result is decreased overall execution time and the latter results in decreased latency between yielded elements.</span></span>  <span data-ttu-id="5cb9a-146">雖然的合併選項執行不一定都有重大影響整體查詢效能，它們就會影響認知的效能，因為它們可以控制使用者必須等候以查看結果。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-146">While the merge options do not always have a major impact on overall query performance, they can impact perceived performance because they control how long a user must wait to see results.</span></span> <span data-ttu-id="5cb9a-147">如需詳細資訊，請參閱 [PLINQ 中的合併選項](../../../docs/standard/parallel-programming/merge-options-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-147">For more information, see [Merge Options in PLINQ](../../../docs/standard/parallel-programming/merge-options-in-plinq.md).</span></span>  
  
6.  <span data-ttu-id="5cb9a-148">類型的資料分割。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-148">The kind of partitioning.</span></span>  
  
     <span data-ttu-id="5cb9a-149">在某些情況下，透過索引的來源集合 PLINQ 查詢可能會導致不平衡的工作負載。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-149">In some cases, a PLINQ query over an indexable source collection may result in an unbalanced work load.</span></span> <span data-ttu-id="5cb9a-150">當發生這種情況時，您可以藉由建立自訂 partitioner 增加查詢效能。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-150">When this occurs, you might be able to increase the query performance by creating a custom partitioner.</span></span> <span data-ttu-id="5cb9a-151">如需詳細資訊，請參閱 [PLINQ 和 TPL 的自訂 Partitioner](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md)。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-151">For more information, see [Custom Partitioners for PLINQ and TPL](../../../docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md).</span></span>  
  
## <a name="when-plinq-chooses-sequential-mode"></a><span data-ttu-id="5cb9a-152">當 PLINQ 選擇循序模式</span><span class="sxs-lookup"><span data-stu-id="5cb9a-152">When PLINQ Chooses Sequential Mode</span></span>  
 <span data-ttu-id="5cb9a-153">PLINQ 將一律嘗試執行至少以最快速度會以循序方式執行查詢的查詢。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-153">PLINQ will always attempt to execute a query at least as fast as the query would run sequentially.</span></span> <span data-ttu-id="5cb9a-154">雖然 PLINQ 看起來如何計算高度耗費資源的使用者委派，或有多大的輸入的來源是，它看起來特定的查詢 「 圖形 」。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-154">Although PLINQ does not look at how computationally expensive the user delegates are, or how big the input source is, it does look for certain query "shapes."</span></span> <span data-ttu-id="5cb9a-155">具體來說，它會尋找查詢運算子或通常會導致查詢執行速度變慢，在平行模式中的運算子的組合。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-155">Specifically, it looks for query operators or combinations of operators that typically cause a query to execute more slowly in parallel mode.</span></span> <span data-ttu-id="5cb9a-156">發現這類圖形，根據預設 PLINQ 會回復為循序模式。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-156">When it finds such shapes, PLINQ by default falls back to sequential mode.</span></span>  
  
 <span data-ttu-id="5cb9a-157">不過之後測量特定的查詢效能，您可能決定實際執行速度在平行模式。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-157">However, after measuring a specific query's performance, you may determine that it actually runs faster in parallel mode.</span></span> <span data-ttu-id="5cb9a-158">在此情況下，您可以使用<xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType>加上旗標透過<xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A>指示 PLINQ 來平行處理查詢的方法。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-158">In such cases you can use the <xref:System.Linq.ParallelExecutionMode.ForceParallelism?displayProperty=nameWithType> flag via the <xref:System.Linq.ParallelEnumerable.WithExecutionMode%2A> method to instruct PLINQ to parallelize the query.</span></span> <span data-ttu-id="5cb9a-159">如需詳細資訊，請參閱[如何：在 PLINQ 中指定執行模式](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-159">For more information, see [How to: Specify the Execution Mode in PLINQ](../../../docs/standard/parallel-programming/how-to-specify-the-execution-mode-in-plinq.md).</span></span>  
  
 <span data-ttu-id="5cb9a-160">下列清單描述 PLINQ 依預設會在循序模式中執行的查詢圖形：</span><span class="sxs-lookup"><span data-stu-id="5cb9a-160">The following list describes the query shapes that PLINQ by default will execute in sequential mode:</span></span>  
  
-   <span data-ttu-id="5cb9a-161">查詢包含 Select、 編製索引，索引的 SelectMany 或 ElementAt 子句之後已經移除或重新排列原始索引的排序或篩選運算子。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-161">Queries that contain a Select, indexed Where, indexed SelectMany, or ElementAt clause after an ordering or filtering operator that has removed or rearranged original indices.</span></span>  
  
-   <span data-ttu-id="5cb9a-162">查詢中包含 Take、 TakeWhile，略過 SkipWhile 運算子，且來源序列中的索引不在原始的訂單。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-162">Queries that contain a Take, TakeWhile, Skip, SkipWhile operator and where indices in the source sequence are not in the original order.</span></span>  
  
-   <span data-ttu-id="5cb9a-163">包含 Zip 或 SequenceEquals 的查詢，除非其中一個資料來源具有原始排序的索引，而且另一個資料來源也可以索引 (也就是陣列或 IList(T))。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-163">Queries that contain Zip or SequenceEquals, unless one of the data sources has an originally ordered index and the other data source is indexable (i.e. an array or IList(T)).</span></span>  
  
-   <span data-ttu-id="5cb9a-164">包含 Concat，除非它套用到索引的資料來源的查詢。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-164">Queries that contain Concat, unless it is applied to indexable data sources.</span></span>  
  
-   <span data-ttu-id="5cb9a-165">包含相反地，除非套用至索引的資料來源的查詢。</span><span class="sxs-lookup"><span data-stu-id="5cb9a-165">Queries that contain Reverse, unless applied to an indexable data source.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5cb9a-166">另請參閱</span><span class="sxs-lookup"><span data-stu-id="5cb9a-166">See Also</span></span>  
 [<span data-ttu-id="5cb9a-167">平行 LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="5cb9a-167">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
