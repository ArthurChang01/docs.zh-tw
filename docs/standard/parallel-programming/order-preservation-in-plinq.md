---
title: PLINQ 中的順序保留
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- PLINQ queries, order preservation
ms.assetid: 10d202bc-19e1-4b5c-bbf1-9a977322a9ca
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 2b44ff3f460d2f33903f7f083cd1bb59c7bf83e1
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/23/2019
ms.locfileid: "54648691"
---
# <a name="order-preservation-in-plinq"></a><span data-ttu-id="a94e1-102">PLINQ 中的順序保留</span><span class="sxs-lookup"><span data-stu-id="a94e1-102">Order Preservation in PLINQ</span></span>
<span data-ttu-id="a94e1-103">在 PLINQ 中，目標是在達到最佳效能的同時維持正確性。</span><span class="sxs-lookup"><span data-stu-id="a94e1-103">In PLINQ, the goal is to maximize performance while maintaining correctness.</span></span> <span data-ttu-id="a94e1-104">查詢應以最快的速度執行，但仍應產生正確的結果。</span><span class="sxs-lookup"><span data-stu-id="a94e1-104">A query should run as fast as possible but still produce the correct results.</span></span> <span data-ttu-id="a94e1-105">在某些情況下，需要保留來源序列的順序以保持正確性；不過，排序可能需要大量計算。</span><span class="sxs-lookup"><span data-stu-id="a94e1-105">In some cases, correctness requires the order of the source sequence to be preserved; however, ordering can be computationally expensive.</span></span> <span data-ttu-id="a94e1-106">因此，根據預設，PLINQ 不會保留來源序列的順序。</span><span class="sxs-lookup"><span data-stu-id="a94e1-106">Therefore, by default, PLINQ does not preserve the order of the source sequence.</span></span> <span data-ttu-id="a94e1-107">在這方面，PLINQ 類似於 [!INCLUDE[vbtecdlinq](../../../includes/vbtecdlinq-md.md)]，但是有別於會保留順序的 LINQ to Objects。</span><span class="sxs-lookup"><span data-stu-id="a94e1-107">In this regard, PLINQ resembles [!INCLUDE[vbtecdlinq](../../../includes/vbtecdlinq-md.md)], but is unlike LINQ to Objects, which does preserve ordering.</span></span>  
  
 <span data-ttu-id="a94e1-108">若要覆寫預設行為，您可以在來源序列上使用 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 運算子開啟順序保留。</span><span class="sxs-lookup"><span data-stu-id="a94e1-108">To override the default behavior, you can turn on order-preservation by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence.</span></span> <span data-ttu-id="a94e1-109">您之後可以使用 <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> 方法在查詢中關閉順序保留。</span><span class="sxs-lookup"><span data-stu-id="a94e1-109">You can then turn off order preservation later in the query by using the <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> method.</span></span> <span data-ttu-id="a94e1-110">使用這兩種方法，查詢是依據啟發學習法來處理，而啟發學習法會判斷要以平行方式或循序執行查詢。</span><span class="sxs-lookup"><span data-stu-id="a94e1-110">With both methods, the query is processed based on the heuristics that determine whether to execute the query as parallel or as sequential.</span></span> <span data-ttu-id="a94e1-111">如需詳細資訊，請參閱[認識 PLINQ 中的加速](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md)。</span><span class="sxs-lookup"><span data-stu-id="a94e1-111">For more information, see [Understanding Speedup in PLINQ](../../../docs/standard/parallel-programming/understanding-speedup-in-plinq.md).</span></span>  
  
 <span data-ttu-id="a94e1-112">下列範例顯示未排序的平行查詢，其會篩選符合條件的所有元素，但不會嘗試以任何方式排序結果。</span><span class="sxs-lookup"><span data-stu-id="a94e1-112">The following example shows an unordered parallel query that filters for all the elements that match a condition, without trying to order the results in any way.</span></span>  
  
 [!code-csharp[PLINQ#8](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#8)]
 [!code-vb[PLINQ#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#8)]  
  
 <span data-ttu-id="a94e1-113">此查詢不一定會在來源序列中產生符合條件的前 1000 個城市，而是 1000 個城市中符合條件的一些組合。</span><span class="sxs-lookup"><span data-stu-id="a94e1-113">This query does not necessarily produce the first 1000 cities in the source sequence that meet the condition, but rather some set of 1000 cities that meet the condition.</span></span> <span data-ttu-id="a94e1-114">PLINQ 查詢運算子會將來源序列分割為以並行工作處理的多個子序列。</span><span class="sxs-lookup"><span data-stu-id="a94e1-114">PLINQ query operators partition the source sequence into multiple subsequences that are processed as concurrent tasks.</span></span> <span data-ttu-id="a94e1-115">如果未指定保留順序，每個分割區中的結果會以任意順序傳送到查詢的下一個階段。</span><span class="sxs-lookup"><span data-stu-id="a94e1-115">If order preservation is not specified, the results from each partition are handed off to the next stage of the query in an arbitrary order.</span></span> <span data-ttu-id="a94e1-116">此外，分割區可能會先產生其結果的子集，然後再繼續處理其餘的元素。</span><span class="sxs-lookup"><span data-stu-id="a94e1-116">Also, a partition may yield a subset of its results before it continues to process the remaining elements.</span></span> <span data-ttu-id="a94e1-117">每次產生的順序可能會不同。</span><span class="sxs-lookup"><span data-stu-id="a94e1-117">The resulting order may be different every time.</span></span> <span data-ttu-id="a94e1-118">您的應用程式無法控制這點，因為這取決於作業系統排程執行緒的方式。</span><span class="sxs-lookup"><span data-stu-id="a94e1-118">Your application cannot control this because it depends on how the operating system schedules the threads.</span></span>  
  
 <span data-ttu-id="a94e1-119">下列範例會在來源序列上使用 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> 運算子以覆寫預設行為。</span><span class="sxs-lookup"><span data-stu-id="a94e1-119">The following example overrides the default behavior by using the <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> operator on the source sequence.</span></span> <span data-ttu-id="a94e1-120">如此可確保 <xref:System.Linq.ParallelEnumerable.Take%2A> 方法會在來源序列中傳回符合條件的前 1000 個城市。</span><span class="sxs-lookup"><span data-stu-id="a94e1-120">This ensures that the <xref:System.Linq.ParallelEnumerable.Take%2A> method returns the first 1000 cities in the source sequence that meet the condition.</span></span>  
  
 [!code-csharp[PLINQ#9](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#9)]
 [!code-vb[PLINQ#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#9)]  
  
 <span data-ttu-id="a94e1-121">不過，此查詢可能無法和未排序版本的執行速度一樣快，因為它必須記錄分割區內的原始順序，以及在合併時確保順序一致。</span><span class="sxs-lookup"><span data-stu-id="a94e1-121">However, this query probably does not run as fast as the unordered version because it must keep track of the original ordering throughout the partitions and at merge time ensure that the ordering is consistent.</span></span> <span data-ttu-id="a94e1-122">因此，建議您只在必要時使用 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>，並只針對查詢中需要它的組件使用。</span><span class="sxs-lookup"><span data-stu-id="a94e1-122">Therefore, we recommend that you use <xref:System.Linq.ParallelEnumerable.AsOrdered%2A> only when it is required, and only for those parts of the query that require it.</span></span> <span data-ttu-id="a94e1-123">當不再需要保留順序時，請使用 <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> 將它關閉。</span><span class="sxs-lookup"><span data-stu-id="a94e1-123">When order preservation is no longer required, use <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> to turn it off.</span></span> <span data-ttu-id="a94e1-124">下列範例透過撰寫兩個查詢來實現此目標。</span><span class="sxs-lookup"><span data-stu-id="a94e1-124">The following example achieves this by composing two queries.</span></span>  
  
 [!code-csharp[PLINQ#6](../../../samples/snippets/csharp/VS_Snippets_Misc/plinq/cs/plinqsamples.cs#6)]
 [!code-vb[PLINQ#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/plinq/vb/plinq2_vb.vb#6)]  
  
 <span data-ttu-id="a94e1-125">請注意，PLINQ 會為其餘的查詢保留 order-imposing 運算子產生的序列順序。</span><span class="sxs-lookup"><span data-stu-id="a94e1-125">Note that PLINQ preserves the ordering of a sequence produced by order-imposing operators for the rest of the query.</span></span> <span data-ttu-id="a94e1-126">換句話說，<xref:System.Linq.ParallelEnumerable.OrderBy%2A> 和 <xref:System.Linq.ParallelEnumerable.ThenBy%2A> 等運算子的處理方式，如同後續呼叫了 <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>。</span><span class="sxs-lookup"><span data-stu-id="a94e1-126">In other words, operators such as <xref:System.Linq.ParallelEnumerable.OrderBy%2A> and <xref:System.Linq.ParallelEnumerable.ThenBy%2A> are treated as if they were followed by a call to <xref:System.Linq.ParallelEnumerable.AsOrdered%2A>.</span></span>  
  
## <a name="query-operators-and-ordering"></a><span data-ttu-id="a94e1-127">查詢運算子和排序</span><span class="sxs-lookup"><span data-stu-id="a94e1-127">Query Operators and Ordering</span></span>  
 <span data-ttu-id="a94e1-128">下列查詢運算子會將順序保留導入查詢中所有後續的作業，或直到呼叫 <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> 為止：</span><span class="sxs-lookup"><span data-stu-id="a94e1-128">The following query operators introduce order preservation into all subsequent operations in a query, or until <xref:System.Linq.ParallelEnumerable.AsUnordered%2A> is called:</span></span>  
  
-   <xref:System.Linq.ParallelEnumerable.OrderBy%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.OrderByDescending%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.ThenBy%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.ThenByDescending%2A>  
  
 <span data-ttu-id="a94e1-129">下列 PLINQ 查詢運算子在某些情況下可能需要已排序的來源序列產生正確的結果：</span><span class="sxs-lookup"><span data-stu-id="a94e1-129">The following PLINQ query operators may in some cases require ordered source sequences to produce correct results:</span></span>  
  
-   <xref:System.Linq.ParallelEnumerable.Reverse%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.SequenceEqual%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.TakeWhile%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.SkipWhile%2A>  
  
-   <xref:System.Linq.ParallelEnumerable.Zip%2A>  
  
 <span data-ttu-id="a94e1-130">有些 PLINQ 查詢運算子的行為有所不同，這取決於其來源序列是已排序或未排序。</span><span class="sxs-lookup"><span data-stu-id="a94e1-130">Some PLINQ query operators behave differently, depending on whether their source sequence is ordered or unordered.</span></span> <span data-ttu-id="a94e1-131">下表列出這些運算子。</span><span class="sxs-lookup"><span data-stu-id="a94e1-131">The following table lists these operators.</span></span>  
  
|<span data-ttu-id="a94e1-132">運算子</span><span class="sxs-lookup"><span data-stu-id="a94e1-132">Operator</span></span>|<span data-ttu-id="a94e1-133">來源序列排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-133">Result when the source sequence is ordered</span></span>|<span data-ttu-id="a94e1-134">來源序列未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-134">Result when the source sequence is unordered</span></span>|  
|--------------|------------------------------------------------|--------------------------------------------------|  
|<xref:System.Linq.ParallelEnumerable.Aggregate%2A>|<span data-ttu-id="a94e1-135">非關聯或非可交換運算的不具決定性輸出</span><span class="sxs-lookup"><span data-stu-id="a94e1-135">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="a94e1-136">非關聯或非可交換運算的不具決定性輸出</span><span class="sxs-lookup"><span data-stu-id="a94e1-136">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.All%2A>|<span data-ttu-id="a94e1-137">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-137">Not applicable</span></span>|<span data-ttu-id="a94e1-138">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-138">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Any%2A>|<span data-ttu-id="a94e1-139">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-139">Not applicable</span></span>|<span data-ttu-id="a94e1-140">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-140">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.AsEnumerable%2A>|<span data-ttu-id="a94e1-141">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-141">Not applicable</span></span>|<span data-ttu-id="a94e1-142">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-142">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Average%2A>|<span data-ttu-id="a94e1-143">非關聯或非可交換運算的不具決定性輸出</span><span class="sxs-lookup"><span data-stu-id="a94e1-143">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="a94e1-144">非關聯或非可交換運算的不具決定性輸出</span><span class="sxs-lookup"><span data-stu-id="a94e1-144">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Cast%2A>|<span data-ttu-id="a94e1-145">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-145">Ordered results</span></span>|<span data-ttu-id="a94e1-146">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-146">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Concat%2A>|<span data-ttu-id="a94e1-147">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-147">Ordered results</span></span>|<span data-ttu-id="a94e1-148">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-148">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Count%2A>|<span data-ttu-id="a94e1-149">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-149">Not applicable</span></span>|<span data-ttu-id="a94e1-150">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-150">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.DefaultIfEmpty%2A>|<span data-ttu-id="a94e1-151">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-151">Not applicable</span></span>|<span data-ttu-id="a94e1-152">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-152">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Distinct%2A>|<span data-ttu-id="a94e1-153">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-153">Ordered results</span></span>|<span data-ttu-id="a94e1-154">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-154">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ElementAt%2A>|<span data-ttu-id="a94e1-155">傳回指定的元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-155">Return specified element</span></span>|<span data-ttu-id="a94e1-156">任意元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-156">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ElementAtOrDefault%2A>|<span data-ttu-id="a94e1-157">傳回指定的元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-157">Return specified element</span></span>|<span data-ttu-id="a94e1-158">任意元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-158">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Except%2A>|<span data-ttu-id="a94e1-159">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-159">Unordered results</span></span>|<span data-ttu-id="a94e1-160">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-160">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.First%2A>|<span data-ttu-id="a94e1-161">傳回指定的元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-161">Return specified element</span></span>|<span data-ttu-id="a94e1-162">任意元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-162">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.FirstOrDefault%2A>|<span data-ttu-id="a94e1-163">傳回指定的元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-163">Return specified element</span></span>|<span data-ttu-id="a94e1-164">任意元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-164">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ForAll%2A>|<span data-ttu-id="a94e1-165">以平行方式非決定性地執行</span><span class="sxs-lookup"><span data-stu-id="a94e1-165">Executes nondeterministically in parallel</span></span>|<span data-ttu-id="a94e1-166">以平行方式非決定性地執行</span><span class="sxs-lookup"><span data-stu-id="a94e1-166">Executes nondeterministically in parallel</span></span>|  
|<xref:System.Linq.ParallelEnumerable.GroupBy%2A>|<span data-ttu-id="a94e1-167">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-167">Ordered results</span></span>|<span data-ttu-id="a94e1-168">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-168">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.GroupJoin%2A>|<span data-ttu-id="a94e1-169">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-169">Ordered results</span></span>|<span data-ttu-id="a94e1-170">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-170">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Intersect%2A>|<span data-ttu-id="a94e1-171">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-171">Ordered results</span></span>|<span data-ttu-id="a94e1-172">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-172">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Join%2A>|<span data-ttu-id="a94e1-173">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-173">Ordered results</span></span>|<span data-ttu-id="a94e1-174">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-174">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Last%2A>|<span data-ttu-id="a94e1-175">傳回指定的元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-175">Return specified element</span></span>|<span data-ttu-id="a94e1-176">任意元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-176">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.LastOrDefault%2A>|<span data-ttu-id="a94e1-177">傳回指定的元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-177">Return specified element</span></span>|<span data-ttu-id="a94e1-178">任意元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-178">Arbitrary element</span></span>|  
|<xref:System.Linq.ParallelEnumerable.LongCount%2A>|<span data-ttu-id="a94e1-179">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-179">Not applicable</span></span>|<span data-ttu-id="a94e1-180">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-180">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Min%2A>|<span data-ttu-id="a94e1-181">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-181">Not applicable</span></span>|<span data-ttu-id="a94e1-182">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-182">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OrderBy%2A>|<span data-ttu-id="a94e1-183">重新排列順序</span><span class="sxs-lookup"><span data-stu-id="a94e1-183">Reorders the sequence</span></span>|<span data-ttu-id="a94e1-184">啟動新的排序區段</span><span class="sxs-lookup"><span data-stu-id="a94e1-184">Starts new ordered section</span></span>|  
|<xref:System.Linq.ParallelEnumerable.OrderByDescending%2A>|<span data-ttu-id="a94e1-185">重新排列順序</span><span class="sxs-lookup"><span data-stu-id="a94e1-185">Reorders the sequence</span></span>|<span data-ttu-id="a94e1-186">啟動新的排序區段</span><span class="sxs-lookup"><span data-stu-id="a94e1-186">Starts new ordered section</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Range%2A>|<span data-ttu-id="a94e1-187">不適用 (與 <xref:System.Linq.ParallelEnumerable.AsParallel%2A> 的預設值相同)</span><span class="sxs-lookup"><span data-stu-id="a94e1-187">Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A> )</span></span>|<span data-ttu-id="a94e1-188">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-188">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Repeat%2A>|<span data-ttu-id="a94e1-189">不適用 (與 <xref:System.Linq.ParallelEnumerable.AsParallel%2A> 的預設值相同)</span><span class="sxs-lookup"><span data-stu-id="a94e1-189">Not applicable (same default as <xref:System.Linq.ParallelEnumerable.AsParallel%2A>)</span></span>|<span data-ttu-id="a94e1-190">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-190">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Reverse%2A>|<span data-ttu-id="a94e1-191">反轉</span><span class="sxs-lookup"><span data-stu-id="a94e1-191">Reverses</span></span>|<span data-ttu-id="a94e1-192">不執行任何動作</span><span class="sxs-lookup"><span data-stu-id="a94e1-192">Does nothing</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Select%2A>|<span data-ttu-id="a94e1-193">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-193">Ordered results</span></span>|<span data-ttu-id="a94e1-194">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-194">Unordered results</span></span>|  
|<span data-ttu-id="a94e1-195"><xref:System.Linq.ParallelEnumerable.Select%2A> (已編製索引)</span><span class="sxs-lookup"><span data-stu-id="a94e1-195"><xref:System.Linq.ParallelEnumerable.Select%2A> (indexed)</span></span>|<span data-ttu-id="a94e1-196">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-196">Ordered results</span></span>|<span data-ttu-id="a94e1-197">未排序的結果。</span><span class="sxs-lookup"><span data-stu-id="a94e1-197">Unordered results.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SelectMany%2A>|<span data-ttu-id="a94e1-198">排序的結果。</span><span class="sxs-lookup"><span data-stu-id="a94e1-198">Ordered results.</span></span>|<span data-ttu-id="a94e1-199">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-199">Unordered results</span></span>|  
|<span data-ttu-id="a94e1-200"><xref:System.Linq.ParallelEnumerable.SelectMany%2A> (已編製索引)</span><span class="sxs-lookup"><span data-stu-id="a94e1-200"><xref:System.Linq.ParallelEnumerable.SelectMany%2A> (indexed)</span></span>|<span data-ttu-id="a94e1-201">排序的結果。</span><span class="sxs-lookup"><span data-stu-id="a94e1-201">Ordered results.</span></span>|<span data-ttu-id="a94e1-202">未排序的結果。</span><span class="sxs-lookup"><span data-stu-id="a94e1-202">Unordered results.</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SequenceEqual%2A>|<span data-ttu-id="a94e1-203">排序的比較</span><span class="sxs-lookup"><span data-stu-id="a94e1-203">Ordered comparison</span></span>|<span data-ttu-id="a94e1-204">未排序的比較</span><span class="sxs-lookup"><span data-stu-id="a94e1-204">Unordered comparison</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Single%2A>|<span data-ttu-id="a94e1-205">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-205">Not applicable</span></span>|<span data-ttu-id="a94e1-206">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-206">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SingleOrDefault%2A>|<span data-ttu-id="a94e1-207">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-207">Not applicable</span></span>|<span data-ttu-id="a94e1-208">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-208">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Skip%2A>|<span data-ttu-id="a94e1-209">略過前 *n* 個元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-209">Skips first *n* elements</span></span>|<span data-ttu-id="a94e1-210">略過任 *n* 個元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-210">Skips any *n* elements</span></span>|  
|<xref:System.Linq.ParallelEnumerable.SkipWhile%2A>|<span data-ttu-id="a94e1-211">排序的結果。</span><span class="sxs-lookup"><span data-stu-id="a94e1-211">Ordered results.</span></span>|<span data-ttu-id="a94e1-212">非決定性。</span><span class="sxs-lookup"><span data-stu-id="a94e1-212">Nondeterministic.</span></span> <span data-ttu-id="a94e1-213">以目前的任意順序執行 SkipWhile</span><span class="sxs-lookup"><span data-stu-id="a94e1-213">Performs SkipWhile on the current arbitrary order</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Sum%2A>|<span data-ttu-id="a94e1-214">非關聯或非可交換運算的不具決定性輸出</span><span class="sxs-lookup"><span data-stu-id="a94e1-214">Nondeterministic output for nonassociative or noncommutative operations</span></span>|<span data-ttu-id="a94e1-215">非關聯或非可交換運算的不具決定性輸出</span><span class="sxs-lookup"><span data-stu-id="a94e1-215">Nondeterministic output for nonassociative or noncommutative operations</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Take%2A>|<span data-ttu-id="a94e1-216">採用前 `n` 個元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-216">Takes first `n` elements</span></span>|<span data-ttu-id="a94e1-217">採用任 `n` 個元素</span><span class="sxs-lookup"><span data-stu-id="a94e1-217">Takes any `n` elements</span></span>|  
|<xref:System.Linq.ParallelEnumerable.TakeWhile%2A>|<span data-ttu-id="a94e1-218">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-218">Ordered results</span></span>|<span data-ttu-id="a94e1-219">非決定性。</span><span class="sxs-lookup"><span data-stu-id="a94e1-219">Nondeterministic.</span></span> <span data-ttu-id="a94e1-220">以目前的任意順序執行 TakeWhile</span><span class="sxs-lookup"><span data-stu-id="a94e1-220">Performs TakeWhile on the current arbitrary order</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ThenBy%2A>|<span data-ttu-id="a94e1-221">補充 `OrderBy`</span><span class="sxs-lookup"><span data-stu-id="a94e1-221">Supplements `OrderBy`</span></span>|<span data-ttu-id="a94e1-222">補充 `OrderBy`</span><span class="sxs-lookup"><span data-stu-id="a94e1-222">Supplements `OrderBy`</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ThenByDescending%2A>|<span data-ttu-id="a94e1-223">補充 `OrderBy`</span><span class="sxs-lookup"><span data-stu-id="a94e1-223">Supplements `OrderBy`</span></span>|<span data-ttu-id="a94e1-224">補充 `OrderBy`</span><span class="sxs-lookup"><span data-stu-id="a94e1-224">Supplements `OrderBy`</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToArray%2A>|<span data-ttu-id="a94e1-225">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-225">Ordered results</span></span>|<span data-ttu-id="a94e1-226">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-226">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToDictionary%2A>|<span data-ttu-id="a94e1-227">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-227">Not applicable</span></span>|<span data-ttu-id="a94e1-228">不適用</span><span class="sxs-lookup"><span data-stu-id="a94e1-228">Not applicable</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToList%2A>|<span data-ttu-id="a94e1-229">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-229">Ordered results</span></span>|<span data-ttu-id="a94e1-230">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-230">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.ToLookup%2A>|<span data-ttu-id="a94e1-231">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-231">Ordered results</span></span>|<span data-ttu-id="a94e1-232">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-232">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Union%2A>|<span data-ttu-id="a94e1-233">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-233">Ordered results</span></span>|<span data-ttu-id="a94e1-234">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-234">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Where%2A>|<span data-ttu-id="a94e1-235">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-235">Ordered results</span></span>|<span data-ttu-id="a94e1-236">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-236">Unordered results</span></span>|  
|<span data-ttu-id="a94e1-237"><xref:System.Linq.ParallelEnumerable.Where%2A> (已編製索引)</span><span class="sxs-lookup"><span data-stu-id="a94e1-237"><xref:System.Linq.ParallelEnumerable.Where%2A> (indexed)</span></span>|<span data-ttu-id="a94e1-238">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-238">Ordered results</span></span>|<span data-ttu-id="a94e1-239">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-239">Unordered results</span></span>|  
|<xref:System.Linq.ParallelEnumerable.Zip%2A>|<span data-ttu-id="a94e1-240">排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-240">Ordered results</span></span>|<span data-ttu-id="a94e1-241">未排序的結果</span><span class="sxs-lookup"><span data-stu-id="a94e1-241">Unordered results</span></span>|  
  
 <span data-ttu-id="a94e1-242">未排序的結果不會主動打散；它們只是未套用任何特殊的排序邏輯。</span><span class="sxs-lookup"><span data-stu-id="a94e1-242">Unordered results are not actively shuffled; they simply do not have any special ordering logic applied to them.</span></span> <span data-ttu-id="a94e1-243">在某些情況下，未排序的查詢可能會保留來源序列的順序。</span><span class="sxs-lookup"><span data-stu-id="a94e1-243">In some cases, an unordered query may retain the ordering of the source sequence.</span></span> <span data-ttu-id="a94e1-244">對於使用已編制索引之 Select 運算子的查詢，PLINQ 可保證輸出元素將以遞增索引的順序產生，但不保證哪些索引會指派給哪些元素。</span><span class="sxs-lookup"><span data-stu-id="a94e1-244">For queries that use the indexed Select operator, PLINQ guarantees that the output elements will come out in the order of increasing indices, but makes no guarantees about which indices will be assigned to which elements.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a94e1-245">另請參閱</span><span class="sxs-lookup"><span data-stu-id="a94e1-245">See also</span></span>

- [<span data-ttu-id="a94e1-246">平行 LINQ (PLINQ)</span><span class="sxs-lookup"><span data-stu-id="a94e1-246">Parallel LINQ (PLINQ)</span></span>](../../../docs/standard/parallel-programming/parallel-linq-plinq.md)
- [<span data-ttu-id="a94e1-247">平行程式設計</span><span class="sxs-lookup"><span data-stu-id="a94e1-247">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)
