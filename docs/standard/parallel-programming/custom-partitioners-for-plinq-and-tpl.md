---
title: "PLINQ 和 TPL 的自訂 Partitioner"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-standard
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: tasks, partitioners
ms.assetid: 96153688-9a01-47c4-8430-909cee9a2887
caps.latest.revision: "19"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.openlocfilehash: 12d234b86b0067178d54d2fdcb5d37ceaee6109d
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/21/2017
---
# <a name="custom-partitioners-for-plinq-and-tpl"></a><span data-ttu-id="f3cb2-102">PLINQ 和 TPL 的自訂 Partitioner</span><span class="sxs-lookup"><span data-stu-id="f3cb2-102">Custom Partitioners for PLINQ and TPL</span></span>
<span data-ttu-id="f3cb2-103">若要平行處理資料來源上的作業，其中一個重要步驟是*分割*成可由多個執行緒並行存取的多個區段的來源。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-103">To parallelize an operation on a data source, one of the essential steps is to *partition* the source into multiple sections that can be accessed concurrently by multiple threads.</span></span> <span data-ttu-id="f3cb2-104">PLINQ 和工作平行程式庫 (TPL) 提供當您撰寫平行查詢，以透明的方式運作的預設 partitioner 或<xref:System.Threading.Tasks.Parallel.ForEach%2A>迴圈。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-104">PLINQ and the Task Parallel Library (TPL) provide default partitioners that work transparently when you write a parallel query or <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span> <span data-ttu-id="f3cb2-105">更進階的情況下，您可以插入您自己的 partitioner。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-105">For more advanced scenarios, you can plug in your own partitioner.</span></span>  
  
## <a name="kinds-of-partitioning"></a><span data-ttu-id="f3cb2-106">類型的資料分割</span><span class="sxs-lookup"><span data-stu-id="f3cb2-106">Kinds of Partitioning</span></span>  
 <span data-ttu-id="f3cb2-107">有許多方式來分割資料來源。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-107">There are many ways to partition a data source.</span></span> <span data-ttu-id="f3cb2-108">最有效率的方法，在多個執行緒會合作以原始來源序列中，程序，而不是實際將來源分割成多個子。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-108">In the most efficient approaches, multiple threads cooperate to process the original source sequence, rather than physically separating the source into multiple subsequences.</span></span> <span data-ttu-id="f3cb2-109">陣列和其他索引來源例如<xref:System.Collections.IList>集合長度會事先知道*定界資料分割*是簡單類型的資料分割。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-109">For arrays and other indexed sources such as <xref:System.Collections.IList> collections where the length is known in advance, *range partitioning* is the simplest kind of partitioning.</span></span> <span data-ttu-id="f3cb2-110">每個執行緒接收唯一的開始和結束索引，如此可以處理其來源範圍但不覆寫或遭到覆寫其他任何執行緒。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-110">Every thread receives unique beginning and ending indexes, so that it can process its range of the source without overwriting or being overwritten by any other thread.</span></span> <span data-ttu-id="f3cb2-111">參與定界資料分割的的額外負荷會建立範圍; 的初始工作沒有額外的同步處理之後需要的。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-111">The only overhead involved in range partitioning is the initial work of creating the ranges; no additional synchronization is required after that.</span></span> <span data-ttu-id="f3cb2-112">因此，它可以提供良好的效能，只要工作負載會平均分配。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-112">Therefore, it can provide good performance as long as the workload is divided evenly.</span></span> <span data-ttu-id="f3cb2-113">定界資料分割的缺點是，如果一個執行緒提早完成，它無法協助其他執行緒完成其工作。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-113">A disadvantage of range partitioning is that if one thread finishes early, it cannot help the other threads finish their work.</span></span>  
  
 <span data-ttu-id="f3cb2-114">針對連結的清單或其長度不知道其他集合，您可以使用*區塊分割*。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-114">For linked lists or other collections whose length is not known, you can use *chunk partitioning*.</span></span> <span data-ttu-id="f3cb2-115">在資料分割的區塊，每一個執行緒或工作平行迴圈或查詢中的取用一個區塊中的來源項目的某些數目、 處理，然後恢復擷取其他項目。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-115">In chunk partitioning, every thread or task in a parallel loop or query consumes some number of source elements in one chunk, processes them, and then comes back to retrieve additional elements.</span></span> <span data-ttu-id="f3cb2-116">發佈的所有項目，並確認沒有重複項目，可確保 partitioner。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-116">The partitioner ensures that all elements are distributed and that there are no duplicates.</span></span> <span data-ttu-id="f3cb2-117">區塊 (chunk) 可能是任何規模。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-117">A chunk may be any size.</span></span> <span data-ttu-id="f3cb2-118">比方說中, 示範的 partitioner [How to： 實作動態分割](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)建立區塊包含只有一個項目。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-118">For example, the partitioner that is demonstrated in [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md) creates chunks that contain just one element.</span></span> <span data-ttu-id="f3cb2-119">區塊不會太大，因為此類型的資料分割是原本就負載平衡因為不預先決定的項目至執行緒指派。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-119">As long as the chunks are not too large, this kind of partitioning is inherently load-balancing because the assignment of elements to threads is not pre-determined.</span></span> <span data-ttu-id="f3cb2-120">不過，partitioner 沒有執行緒取得另一個區塊會需要每次造成同步處理的負荷。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-120">However, the partitioner does incur the synchronization overhead each time the thread needs to get another chunk.</span></span> <span data-ttu-id="f3cb2-121">在這些情況下所產生的同步處理的數量是區塊的大小成反比。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-121">The amount of synchronization incurred in these cases is inversely proportional to the size of the chunks.</span></span>  
  
 <span data-ttu-id="f3cb2-122">一般情況下，定界資料分割更快時才委派的執行時間很小的仲裁，而且來源具有大量項目，及每個資料分割的總工作大致上相當。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-122">In general, range partitioning is only faster when the execution time of the delegate is small to moderate, and the source has a large number of elements, and the total work of each partition is roughly equivalent.</span></span> <span data-ttu-id="f3cb2-123">區塊資料分割的是，因此通常在大部分情況下會較快。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-123">Chunk partitioning is therefore generally faster in most cases.</span></span> <span data-ttu-id="f3cb2-124">在較少的項目或較長的委派的執行時間來源，然後區塊和 range 資料分割的效能是關於等。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-124">On sources with a small number of elements or longer execution times for the delegate, then the performance of chunk and range partitioning is about equal.</span></span>  
  
 <span data-ttu-id="f3cb2-125">TPL partitioner 也支援動態分割區數目。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-125">The TPL partitioners also support a dynamic number of partitions.</span></span> <span data-ttu-id="f3cb2-126">這表示它們可以建立資料分割上作業，例如，當<xref:System.Threading.Tasks.Parallel.ForEach%2A>迴圈會產生新的工作。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-126">This means they can create partitions on-the-fly, for example, when the <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop spawns a new task.</span></span> <span data-ttu-id="f3cb2-127">此功能可讓您調整以及迴圈本身的 partitioner。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-127">This feature enables the partitioner to scale together with the loop itself.</span></span> <span data-ttu-id="f3cb2-128">動態 partitioner 也是原本就負載平衡。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-128">Dynamic partitioners are also inherently load-balancing.</span></span> <span data-ttu-id="f3cb2-129">當您建立的自訂 partitioner 時，您必須支援動態磁碟分割，可供在使用<xref:System.Threading.Tasks.Parallel.ForEach%2A>迴圈。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-129">When you create a custom partitioner, you must support dynamic partitioning to be consumable from a <xref:System.Threading.Tasks.Parallel.ForEach%2A> loop.</span></span>  
  
### <a name="configuring-load-balancing-partitioners-for-plinq"></a><span data-ttu-id="f3cb2-130">設定負載平衡的 PLINQ Partitioner</span><span class="sxs-lookup"><span data-stu-id="f3cb2-130">Configuring Load Balancing Partitioners for PLINQ</span></span>  
 <span data-ttu-id="f3cb2-131">一些多載<xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType>方法可讓您建立陣列 partitioner 或<xref:System.Collections.IList>來源，並指定是否應嘗試在執行緒之間的工作負載平均分配。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-131">Some overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A?displayProperty=nameWithType> method let you create a partitioner for an array or <xref:System.Collections.IList> source and specify whether it should attempt to balance the workload among the threads.</span></span> <span data-ttu-id="f3cb2-132">當 partitioner 設定負載平衡時，使用區塊資料分割時，與項目會遞交給小區塊中的每個資料分割要求。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-132">When the partitioner is configured to load-balance, chunk partitioning is used, and the elements are handed off to each partition in small chunks as they are requested.</span></span> <span data-ttu-id="f3cb2-133">這種方式有助於確保所有資料分割，直到整個迴圈處理的項目或查詢已完成。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-133">This approach helps ensure that all partitions have elements to process until the entire loop or query is completed.</span></span> <span data-ttu-id="f3cb2-134">其他多載可用來提供負載平衡的任何分割<xref:System.Collections.IEnumerable>來源。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-134">An additional overload can be used to provide load-balancing partitioning of any <xref:System.Collections.IEnumerable> source.</span></span>  
  
 <span data-ttu-id="f3cb2-135">一般情況下，負載平衡所需要的資料分割來要求元素相對經常從 partitioner。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-135">In general, load balancing requires the partitions to request elements relatively frequently from the partitioner.</span></span> <span data-ttu-id="f3cb2-136">相反地，沒有靜態分割 partitioner 可以指派項目給每個 partitioner 一次使用範圍或區塊資料分割。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-136">By contrast, a partitioner that does static partitioning can assign the elements to each partitioner all at once by using either range or chunk partitioning.</span></span> <span data-ttu-id="f3cb2-137">這需要較少的額外負荷比負載平衡，但是可能需要較長的時間執行一個執行緒最後會有比其他更多工作。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-137">This requires less overhead than load balancing, but it might take longer to execute if one thread ends up with significantly more work than the others.</span></span> <span data-ttu-id="f3cb2-138">預設為 IList 或陣列，傳遞時 PLINQ 一律使用 range 資料分割沒有負載平衡。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-138">By default when it is passed an IList or an array, PLINQ always uses range partitioning without load balancing.</span></span> <span data-ttu-id="f3cb2-139">若要啟用 PLINQ 的負載平衡，請使用`Partitioner.Create`方法，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-139">To enable load balancing for PLINQ, use the `Partitioner.Create` method, as shown in the following example.</span></span>  
  
 [!code-csharp[TPL_Partitioners#02](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioners.cs#02)]
 [!code-vb[TPL_Partitioners#02](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionsnippets_vb.vb#02)]  
  
 <span data-ttu-id="f3cb2-140">若要判斷是否要使用負載平衡在任何給定的情況下進行實驗而測量作業下代表性的載入和電腦設定完成所需的時間，最好。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-140">The best way to determine whether to use load balancing in any given scenario is to experiment and measure how long it takes operations to complete under representative loads and computer configurations.</span></span> <span data-ttu-id="f3cb2-141">例如，靜態資料分割可能會有幾個核心、 多核心電腦上提供顯著的加速效果，但可能會導致速度變慢，有相當多核心電腦上。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-141">For example, static partitioning might provide significant speedup on a multi-core computer that has only a few cores, but it might result in slowdowns on computers that have relatively many cores.</span></span>  
  
 <span data-ttu-id="f3cb2-142">下表列出可用的多載的<xref:System.Collections.Concurrent.Partitioner.Create%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-142">The following table lists the available overloads of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> method.</span></span> <span data-ttu-id="f3cb2-143">這些 partitioner 不限於只適用於 PLINQ 或<xref:System.Threading.Tasks.Task>。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-143">These partitioners are not limited to use only with PLINQ or <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="f3cb2-144">它們也可以使用與任何自訂的平行建構。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-144">They can also be used with any custom parallel construct.</span></span>  
  
|<span data-ttu-id="f3cb2-145">多載</span><span class="sxs-lookup"><span data-stu-id="f3cb2-145">Overload</span></span>|<span data-ttu-id="f3cb2-146">使用負載平衡</span><span class="sxs-lookup"><span data-stu-id="f3cb2-146">Uses load balancing</span></span>|  
|--------------|-------------------------|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>|<span data-ttu-id="f3cb2-147">永遠</span><span class="sxs-lookup"><span data-stu-id="f3cb2-147">Always</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28%60%600%5B%5D%2CSystem.Boolean%29>|<span data-ttu-id="f3cb2-148">布林值的引數指定為 true 時</span><span class="sxs-lookup"><span data-stu-id="f3cb2-148">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%60%601%28System.Collections.Generic.IList%7B%60%600%7D%2CSystem.Boolean%29>|<span data-ttu-id="f3cb2-149">布林值的引數指定為 true 時</span><span class="sxs-lookup"><span data-stu-id="f3cb2-149">When the Boolean argument is specified as true</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%29>|<span data-ttu-id="f3cb2-150">永不</span><span class="sxs-lookup"><span data-stu-id="f3cb2-150">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int32%2CSystem.Int32%2CSystem.Int32%29>|<span data-ttu-id="f3cb2-151">永不</span><span class="sxs-lookup"><span data-stu-id="f3cb2-151">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%29>|<span data-ttu-id="f3cb2-152">永不</span><span class="sxs-lookup"><span data-stu-id="f3cb2-152">Never</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner.Create%28System.Int64%2CSystem.Int64%2CSystem.Int64%29>|<span data-ttu-id="f3cb2-153">永不</span><span class="sxs-lookup"><span data-stu-id="f3cb2-153">Never</span></span>|  
  
### <a name="configuring-static-range-partitioners-for-parallelforeach"></a><span data-ttu-id="f3cb2-154">設定 Parallel.ForEach 的靜態範圍的 Partitioner</span><span class="sxs-lookup"><span data-stu-id="f3cb2-154">Configuring Static Range Partitioners for Parallel.ForEach</span></span>  
 <span data-ttu-id="f3cb2-155">在<xref:System.Threading.Tasks.Parallel.For%2A>迴圈，迴圈的主體提供給方法的委派。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-155">In a <xref:System.Threading.Tasks.Parallel.For%2A> loop, the body of the loop is provided to the method as a delegate.</span></span> <span data-ttu-id="f3cb2-156">叫用該委派的成本是關於相同的虛擬方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-156">The cost of invoking that delegate is about the same as a virtual method call.</span></span> <span data-ttu-id="f3cb2-157">在某些情況下，平行迴圈的主體可能小的每個迴圈反覆項目上的委派引動過程成本變得重要。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-157">In some scenarios, the body of a parallel loop might be small enough that the cost of the delegate invocation on each loop iteration becomes significant.</span></span> <span data-ttu-id="f3cb2-158">在這種情況下，您可以使用其中一個<xref:System.Collections.Concurrent.Partitioner.Create%2A>多載來建立<xref:System.Collections.Generic.IEnumerable%601>界定資料分割，在來源項目。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-158">In such situations, you can use one of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads to create an <xref:System.Collections.Generic.IEnumerable%601> of range partitions over the source elements.</span></span> <span data-ttu-id="f3cb2-159">然後，您可以傳遞給此集合的範圍到<xref:System.Threading.Tasks.Parallel.ForEach%2A>其主體包含一般方法`for`迴圈。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-159">Then, you can pass this collection of ranges to a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method whose body consists of a regular `for` loop.</span></span> <span data-ttu-id="f3cb2-160">這個方法的好處是每個範圍，而不是一次每個項目委派引動過程成本一次所造成。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-160">The benefit of this approach is that the delegate invocation cost is incurred only once per range, rather than once per element.</span></span> <span data-ttu-id="f3cb2-161">下列範例示範基本模式。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-161">The following example demonstrates the basic pattern.</span></span>  
  
 [!code-csharp[TPL_Partitioners#01](../../../samples/snippets/csharp/VS_Snippets_Misc/tpl_partitioners/cs/partitioner01.cs#01)]
 [!code-vb[TPL_Partitioners#01](../../../samples/snippets/visualbasic/VS_Snippets_Misc/tpl_partitioners/vb/partitionercreate01.vb#01)]  
  
 <span data-ttu-id="f3cb2-162">在迴圈中的每個執行緒會收到自己<xref:System.Tuple%602>，其中包含的開始和結束的指定子範圍中的索引值。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-162">Every thread in the loop receives its own <xref:System.Tuple%602> that contains the starting and ending index values in the specified sub-range.</span></span> <span data-ttu-id="f3cb2-163">內部`for`迴圈使用`fromInclusive`和`toExclusive`迴圈陣列值或<xref:System.Collections.IList>直接。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-163">The inner `for` loop uses the `fromInclusive` and `toExclusive` values to loop over the array or the <xref:System.Collections.IList> directly.</span></span>  
  
 <span data-ttu-id="f3cb2-164">其中一個<xref:System.Collections.Concurrent.Partitioner.Create%2A>多載可讓您指定的資料分割和資料分割數目的大小。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-164">One of the <xref:System.Collections.Concurrent.Partitioner.Create%2A> overloads lets you specify the size of the partitions, and the number of partitions.</span></span> <span data-ttu-id="f3cb2-165">這個多載可用於案例其中每個項目工作是很低，每個項目甚至一種虛擬方法呼叫對明顯影響效能。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-165">This overload can be used in scenarios where the work per element is so low that even one virtual method call per element has a noticeable impact on performance.</span></span>  
  
## <a name="custom-partitioners"></a><span data-ttu-id="f3cb2-166">自訂 Partitioner</span><span class="sxs-lookup"><span data-stu-id="f3cb2-166">Custom Partitioners</span></span>  
 <span data-ttu-id="f3cb2-167">在某些情況下，它可能是值得或甚至必須實作自己的 partitioner。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-167">In some scenarios, it might be worthwhile or even required to implement your own partitioner.</span></span> <span data-ttu-id="f3cb2-168">例如，您可能比 partitioner 可以以您的內部結構類別的知識為基礎的預設值更有效率，您可以分割的自訂集合類別。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-168">For example, you might have a custom collection class that you can partition more efficiently than the default partitioners can, based on your knowledge of the internal structure of the class.</span></span> <span data-ttu-id="f3cb2-169">或者，您可能想要建立界定資料分割的基礎知識的花多少時間將來源集合中的不同位置的程序項目不同的大小。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-169">Or, you may want to create range partitions of varying sizes based on your knowledge of how long it will take to process elements at different locations in the source collection.</span></span>  
  
 <span data-ttu-id="f3cb2-170">若要建立基本的自訂 partitioner，衍生自<xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType>並覆寫虛擬方法下, 表中所述。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-170">To create a basic custom partitioner, derive a class from <xref:System.Collections.Concurrent.Partitioner%601?displayProperty=nameWithType> and override the virtual methods, as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>|<span data-ttu-id="f3cb2-171">這個方法會由主執行緒呼叫一次，並傳回 IList(IEnumerator(TSource))。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-171">This method is called once by the main thread and returns an IList(IEnumerator(TSource)).</span></span> <span data-ttu-id="f3cb2-172">迴圈或查詢中的每個工作者執行緒可以呼叫`GetEnumerator`上擷取清單<xref:System.Collections.Generic.IEnumerator%601>透過不同的磁碟分割。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-172">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="f3cb2-173">傳回`true`如果您實作<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>，否則`false`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-173">Return `true` if you implement <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, otherwise, `false`.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="f3cb2-174">如果<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>是`true`，而不是可選擇性地呼叫這個方法<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-174">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="f3cb2-175">如果結果必須是可排序，或您為項目需要索引的存取，然後衍生自<xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType>並覆寫其虛擬方法下, 表中所述。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-175">If the results must be sortable or you require indexed access into the elements, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> and override its virtual methods as described in the following table.</span></span>  
  
|||  
|-|-|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetPartitions%2A>|<span data-ttu-id="f3cb2-176">這個方法會由主執行緒呼叫一次，並傳回`IList(IEnumerator(TSource))`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-176">This method is called once by the main thread and returns an `IList(IEnumerator(TSource))`.</span></span> <span data-ttu-id="f3cb2-177">迴圈或查詢中的每個工作者執行緒可以呼叫`GetEnumerator`上擷取清單<xref:System.Collections.Generic.IEnumerator%601>透過不同的磁碟分割。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-177">Each worker thread in the loop or query can call `GetEnumerator` on the list to retrieve a <xref:System.Collections.Generic.IEnumerator%601> over a distinct partition.</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="f3cb2-178">傳回`true`如果您實作<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; 否則為 false。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-178">Return `true` if you implement <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>; otherwise, false.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetDynamicPartitions%2A>|<span data-ttu-id="f3cb2-179">一般而言，這只會呼叫<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-179">Typically, this just calls <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>|<span data-ttu-id="f3cb2-180">如果<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>是`true`，而不是可選擇性地呼叫這個方法<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-180">If <xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A> is `true`, this method can optionally be called instead of <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>.</span></span>|  
  
 <span data-ttu-id="f3cb2-181">下表提供有關的其他詳細資料的三種負載平衡 partitioner 實作<xref:System.Collections.Concurrent.OrderablePartitioner%601>類別。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-181">The following table provides additional details about how the three kinds of load-balancing partitioners implement the <xref:System.Collections.Concurrent.OrderablePartitioner%601> class.</span></span>  
  
|<span data-ttu-id="f3cb2-182">方法/屬性</span><span class="sxs-lookup"><span data-stu-id="f3cb2-182">Method/Property</span></span>|<span data-ttu-id="f3cb2-183">IList / 陣列沒有負載平衡</span><span class="sxs-lookup"><span data-stu-id="f3cb2-183">IList / Array without Load Balancing</span></span>|<span data-ttu-id="f3cb2-184">IList / 陣列負載平衡</span><span class="sxs-lookup"><span data-stu-id="f3cb2-184">IList / Array with Load Balancing</span></span>|<span data-ttu-id="f3cb2-185">IEnumerable</span><span class="sxs-lookup"><span data-stu-id="f3cb2-185">IEnumerable</span></span>|  
|----------------------|-------------------------------------------|----------------------------------------|-----------------|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>|<span data-ttu-id="f3cb2-186">使用 range 資料分割</span><span class="sxs-lookup"><span data-stu-id="f3cb2-186">Uses range partitioning</span></span>|<span data-ttu-id="f3cb2-187">使用最佳化，列出指定 partitionCount 分割區塊</span><span class="sxs-lookup"><span data-stu-id="f3cb2-187">Uses chunk partitioning optimized for Lists for the partitionCount specified</span></span>|<span data-ttu-id="f3cb2-188">會使用區塊資料分割所建立的資料分割的靜態數目。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-188">Uses chunk partitioning by creating a static number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A?displayProperty=nameWithType>|<span data-ttu-id="f3cb2-189">不支援會擲回例外狀況</span><span class="sxs-lookup"><span data-stu-id="f3cb2-189">Throws not-supported exception</span></span>|<span data-ttu-id="f3cb2-190">會使用區塊資料分割最佳化清單和動態的資料分割</span><span class="sxs-lookup"><span data-stu-id="f3cb2-190">Uses chunk partitioning optimized for Lists and dynamic partitions</span></span>|<span data-ttu-id="f3cb2-191">會使用區塊資料分割建立動態的資料分割數目。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-191">Uses chunk partitioning by creating a dynamic number of partitions.</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedInEachPartition%2A>|<span data-ttu-id="f3cb2-192">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-192">Returns `true`</span></span>|<span data-ttu-id="f3cb2-193">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-193">Returns `true`</span></span>|<span data-ttu-id="f3cb2-194">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-194">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysOrderedAcrossPartitions%2A>|<span data-ttu-id="f3cb2-195">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-195">Returns `true`</span></span>|<span data-ttu-id="f3cb2-196">傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-196">Returns `false`</span></span>|<span data-ttu-id="f3cb2-197">傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-197">Returns `false`</span></span>|  
|<xref:System.Collections.Concurrent.OrderablePartitioner%601.KeysNormalized%2A>|<span data-ttu-id="f3cb2-198">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-198">Returns `true`</span></span>|<span data-ttu-id="f3cb2-199">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-199">Returns `true`</span></span>|<span data-ttu-id="f3cb2-200">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-200">Returns `true`</span></span>|  
|<xref:System.Collections.Concurrent.Partitioner%601.SupportsDynamicPartitions%2A>|<span data-ttu-id="f3cb2-201">傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-201">Returns `false`</span></span>|<span data-ttu-id="f3cb2-202">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-202">Returns `true`</span></span>|<span data-ttu-id="f3cb2-203">傳回 `true`。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-203">Returns `true`</span></span>|  
  
### <a name="dynamic-partitions"></a><span data-ttu-id="f3cb2-204">動態分割</span><span class="sxs-lookup"><span data-stu-id="f3cb2-204">Dynamic Partitions</span></span>  
 <span data-ttu-id="f3cb2-205">如果您想要用於 partitioner<xref:System.Threading.Tasks.Parallel.ForEach%2A>方法，您必須能夠傳回的資料分割的動態數目。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-205">If you intend the partitioner to be used in a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method, you must be able to return a dynamic number of partitions.</span></span> <span data-ttu-id="f3cb2-206">這表示，partitioner 迴圈執行期間，隨時可以提供新資料分割指定的列舉值。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-206">This means that the partitioner can supply an enumerator for a new partition on-demand at any time during loop execution.</span></span> <span data-ttu-id="f3cb2-207">基本上，每次迴圈會將新的平行工作，它會要求該工作的新資料分割。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-207">Basically, whenever the loop adds a new parallel task, it requests a new partition for that task.</span></span> <span data-ttu-id="f3cb2-208">如果您需要為可排序資料，然後衍生自<xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType>，讓每個資料分割中的每個項目指派唯一的索引。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-208">If you require the data to be orderable, then derive from <xref:System.Collections.Concurrent.OrderablePartitioner%601?displayProperty=nameWithType> so that each item in each partition is assigned a unique index.</span></span>  
  
 <span data-ttu-id="f3cb2-209">如需詳細資訊和範例，請參閱[How to： 實作動態分割](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-209">For more information, and an example, see [How to: Implement Dynamic Partitions](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
### <a name="contract-for-partitioners"></a><span data-ttu-id="f3cb2-210">Partitioner 合約</span><span class="sxs-lookup"><span data-stu-id="f3cb2-210">Contract for Partitioners</span></span>  
 <span data-ttu-id="f3cb2-211">當您實作的自訂 partitioner 時，請遵循下列指導方針來協助確保正確互動 PLINQ 和<xref:System.Threading.Tasks.Parallel.ForEach%2A>TPL 中：</span><span class="sxs-lookup"><span data-stu-id="f3cb2-211">When you implement a custom partitioner, follow these guidelines to help ensure correct interaction with PLINQ and <xref:System.Threading.Tasks.Parallel.ForEach%2A> in the TPL:</span></span>  
  
-   <span data-ttu-id="f3cb2-212">如果<xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>是呼叫的引數的零或更少的`partitionsCount`，會擲回<xref:System.ArgumentOutOfRangeException>。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-212">If <xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> is called with an argument of zero or less for `partitionsCount`, throw <xref:System.ArgumentOutOfRangeException>.</span></span> <span data-ttu-id="f3cb2-213">雖然 PLINQ 和 TPL 會永遠不會傳入`partitionCount`等於 0，不過建議您防範可能性。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-213">Although PLINQ and TPL will never pass in a `partitionCount` equal to 0, we nevertheless recommend that you guard against the possibility.</span></span>  
  
-   <span data-ttu-id="f3cb2-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>和<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>應該會一律傳回`partitionsCount`數字的資料分割。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-214"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A> and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A> should always return `partitionsCount` number of partitions.</span></span> <span data-ttu-id="f3cb2-215">如果 partitioner 用盡資料，而且無法建立要求最多的資料分割，此方法應傳回其餘的分割區的每個空白的列舉值。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-215">If the partitioner runs out of data and cannot create as many partitions as requested, then the method should return an empty enumerator for each of the remaining partitions.</span></span> <span data-ttu-id="f3cb2-216">PLINQ 和 TPL 否則將會擲回<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-216">Otherwise, both PLINQ and TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="f3cb2-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A><xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>， <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>，和<xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A>永遠不應該傳回`null`(`Nothing`在 Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-217"><xref:System.Collections.Concurrent.Partitioner%601.GetPartitions%2A>, <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderablePartitions%2A>, <xref:System.Collections.Concurrent.Partitioner%601.GetDynamicPartitions%2A>, and <xref:System.Collections.Concurrent.OrderablePartitioner%601.GetOrderableDynamicPartitions%2A> should never return `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="f3cb2-218">如果沒有的話，PLINQ / TPL 會擲回<xref:System.InvalidOperationException>。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-218">If they do, PLINQ / TPL will throw an <xref:System.InvalidOperationException>.</span></span>  
  
-   <span data-ttu-id="f3cb2-219">傳回的資料分割的方法應該一律會傳回可完全且唯一列舉資料來源的資料分割。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-219">Methods that return partitions should always return partitions that can fully and uniquely enumerate the data source.</span></span> <span data-ttu-id="f3cb2-220">除非特別需要的 partitioner 設計時，則應該不是重複的資料來源或略過的項目。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-220">There should be no duplication in the data source or skipped items unless specifically required by the design of the partitioner.</span></span> <span data-ttu-id="f3cb2-221">如果未遵照這項規則，則可能會變碼的輸出順序。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-221">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="f3cb2-222">下列布林 getter，讓不變碼的輸出順序，必須一定可以正確地傳回下列值：</span><span class="sxs-lookup"><span data-stu-id="f3cb2-222">The following Boolean getters must always accurately return the following values so that the output order is not scrambled:</span></span>  
  
    -   <span data-ttu-id="f3cb2-223">`KeysOrderedInEachPartition`： 每個資料分割傳回隨著增加的索引鍵索引的項目。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-223">`KeysOrderedInEachPartition`: Each partition returns elements with increasing key indices.</span></span>  
  
    -   <span data-ttu-id="f3cb2-224">`KeysOrderedAcrossPartitions`： 對於會傳回索引鍵索引資料分割中的所有資料分割*我*高於索引鍵索引資料分割中*我*-1。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-224">`KeysOrderedAcrossPartitions`: For all partitions that are returned, the key indices in partition *i* are higher than the key indices in partition *i*-1.</span></span>  
  
    -   <span data-ttu-id="f3cb2-225">`KeysNormalized`： 沒有間距，從零開始單純增加所有的索引鍵索引。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-225">`KeysNormalized`: All key indices are monotonically increasing without gaps, starting from zero.</span></span>  
  
-   <span data-ttu-id="f3cb2-226">所有索引必須都是唯一的。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-226">All indices must be unique.</span></span> <span data-ttu-id="f3cb2-227">不可能重複的索引。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-227">There may not be duplicate indices.</span></span> <span data-ttu-id="f3cb2-228">如果未遵照這項規則，則可能會變碼的輸出順序。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-228">If this rule is not followed, then the output order may be scrambled.</span></span>  
  
-   <span data-ttu-id="f3cb2-229">所有索引不可都為負值。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-229">All indices must be nonnegative.</span></span> <span data-ttu-id="f3cb2-230">如果未遵照這項規則，則 PLINQ/TPL 可能擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="f3cb2-230">If this rule is not followed, then PLINQ/TPL may throw exceptions.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f3cb2-231">另請參閱</span><span class="sxs-lookup"><span data-stu-id="f3cb2-231">See Also</span></span>  
 [<span data-ttu-id="f3cb2-232">平行程式設計</span><span class="sxs-lookup"><span data-stu-id="f3cb2-232">Parallel Programming</span></span>](../../../docs/standard/parallel-programming/index.md)  
 [<span data-ttu-id="f3cb2-233">操作說明：實作動態磁碟分割</span><span class="sxs-lookup"><span data-stu-id="f3cb2-233">How to: Implement Dynamic Partitions</span></span>](../../../docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md)  
 [<span data-ttu-id="f3cb2-234">操作說明：為靜態分割實作 Partitioner</span><span class="sxs-lookup"><span data-stu-id="f3cb2-234">How to: Implement a Partitioner for Static Partitioning</span></span>](../../../docs/standard/parallel-programming/how-to-implement-a-partitioner-for-static-partitioning.md)
