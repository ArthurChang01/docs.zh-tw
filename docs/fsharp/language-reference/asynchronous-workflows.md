---
title: 非同步工作流程 (F#)
description: '了解支援的 F # 程式語言，以非同步方式執行計算的詳細執行而不封鎖其他工作的執行。'
author: cartermp
ms.author: phcart
ms.date: 05/16/2016
ms.topic: language-reference
ms.prod: dotnet-fsharp
ms.devlang: fsharp
ms.openlocfilehash: 1521ea3719f906a45b11d19a27256e87c5643e28
ms.sourcegitcommit: 03ee570f6f528a7d23a4221dcb26a9498edbdf8c
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/28/2018
---
# <a name="asynchronous-workflows"></a><span data-ttu-id="f95b0-103">非同步工作流程</span><span class="sxs-lookup"><span data-stu-id="f95b0-103">Asynchronous Workflows</span></span>

> [!NOTE]
<span data-ttu-id="f95b0-104">API 參考連結將帶您前往 MSDN。</span><span class="sxs-lookup"><span data-stu-id="f95b0-104">The API reference link will take you to MSDN.</span></span>  <span data-ttu-id="f95b0-105">docs.microsoft.com API 參考不完整。</span><span class="sxs-lookup"><span data-stu-id="f95b0-105">The docs.microsoft.com API reference is not complete.</span></span>

<span data-ttu-id="f95b0-106">本主題描述支援 F # 中的執行的計算以非同步的方式，亦即，而不會封鎖執行其他工作。</span><span class="sxs-lookup"><span data-stu-id="f95b0-106">This topic describes support in F# for performing computations asynchronously, that is, without blocking execution of other work.</span></span> <span data-ttu-id="f95b0-107">例如，非同步計算可用來撰寫為應用程式會執行其他工作能繼續回應使用者的 Ui 的應用程式。</span><span class="sxs-lookup"><span data-stu-id="f95b0-107">For example, asynchronous computations can be used to write applications that have UIs that remain responsive to users as the application performs other work.</span></span>

## <a name="syntax"></a><span data-ttu-id="f95b0-108">語法</span><span class="sxs-lookup"><span data-stu-id="f95b0-108">Syntax</span></span>

```fsharp
async { expression }
```

## <a name="remarks"></a><span data-ttu-id="f95b0-109">備註</span><span class="sxs-lookup"><span data-stu-id="f95b0-109">Remarks</span></span>

<span data-ttu-id="f95b0-110">在上一個語法中，計算由`expression`並將設定為以非同步方式執行，也就是說，而不會封鎖目前的計算執行緒睡眠非同步作業、 I/O 和其他非同步作業執行的時間。</span><span class="sxs-lookup"><span data-stu-id="f95b0-110">In the previous syntax, the computation represented by `expression` is set up to run asynchronously, that is, without blocking the current computation thread when asynchronous sleep operations, I/O, and other asynchronous operations are performed.</span></span> <span data-ttu-id="f95b0-111">同時執行會繼續目前的執行緒上非同步計算通常會啟動背景執行緒上。</span><span class="sxs-lookup"><span data-stu-id="f95b0-111">Asynchronous computations are often started on a background thread while execution continues on the current thread.</span></span> <span data-ttu-id="f95b0-112">運算式的類型是`Async<'T>`，其中`'T`是運算式所傳回的型別時`return`關鍵字使用。</span><span class="sxs-lookup"><span data-stu-id="f95b0-112">The type of the expression is `Async<'T>`, where `'T` is the type returned by the expression when the `return` keyword is used.</span></span> <span data-ttu-id="f95b0-113">這類運算式中的程式碼指*非同步區塊*，或*非同步區塊*。</span><span class="sxs-lookup"><span data-stu-id="f95b0-113">The code in such an expression is referred to as an *asynchronous block*, or *async block*.</span></span>

<span data-ttu-id="f95b0-114">有各種不同的非同步程式設計的方式和[ `Async` ](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7)類別會提供方法，可支援幾個案例。</span><span class="sxs-lookup"><span data-stu-id="f95b0-114">There are a variety of ways of programming asynchronously, and the [`Async`](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7) class provides methods that support several scenarios.</span></span> <span data-ttu-id="f95b0-115">一般方法是建立`Async`物件，代表計算或您想要以非同步方式執行的計算，並使用其中一個觸發的函式，以啟動這些計算。</span><span class="sxs-lookup"><span data-stu-id="f95b0-115">The general approach is to create `Async` objects that represent the computation or computations that you want to run asynchronously, and then start these computations by using one of the triggering functions.</span></span> <span data-ttu-id="f95b0-116">各種觸發函式提供不同的方式執行非同步計算，以及您使用這個資料行依存於您是否想要使用目前的執行緒，背景執行緒或.NET Framework 工作物件，以及是否有接續在計算完成時應該執行的函式。</span><span class="sxs-lookup"><span data-stu-id="f95b0-116">The various triggering functions provide different ways of running asynchronous computations, and which one you use depends on whether you want to use the current thread, a background thread, or a .NET Framework task object, and whether there are continuation functions that should run when the computation finishes.</span></span> <span data-ttu-id="f95b0-117">例如，若要在目前的執行緒上開始非同步的計算，您可以使用[ `Async.StartImmediate` ](https://msdn.microsoft.com/library/2f71d1cc-187f-48cf-ac66-e7fda41c46e3)。</span><span class="sxs-lookup"><span data-stu-id="f95b0-117">For example, to start an asynchronous computation on the current thread, you can use [`Async.StartImmediate`](https://msdn.microsoft.com/library/2f71d1cc-187f-48cf-ac66-e7fda41c46e3).</span></span> <span data-ttu-id="f95b0-118">當您從 UI 執行緒開始非同步的計算時，您不會封鎖主要事件迴圈處理使用者動作，例如按鍵及滑鼠活動，因此您的應用程式仍然能夠保持回應。</span><span class="sxs-lookup"><span data-stu-id="f95b0-118">When you start an asynchronous computation from the UI thread, you do not block the main event loop that processes user actions such as keystrokes and mouse activity, so your application remains responsive.</span></span>

## <a name="asynchronous-binding-by-using-let"></a><span data-ttu-id="f95b0-119">使用可讓非同步繫結 ！</span><span class="sxs-lookup"><span data-stu-id="f95b0-119">Asynchronous Binding by Using let!</span></span>

<span data-ttu-id="f95b0-120">非同步工作流程中，在某些運算式和作業是同步的而有些則用來以非同步方式傳回結果的時間計算。</span><span class="sxs-lookup"><span data-stu-id="f95b0-120">In an asynchronous workflow, some expressions and operations are synchronous, and some are longer computations that are designed to return a result asynchronously.</span></span> <span data-ttu-id="f95b0-121">當您呼叫的方法以非同步的方式，而不是一般`let`繫結，請使用`let!`。</span><span class="sxs-lookup"><span data-stu-id="f95b0-121">When you call a method asynchronously, instead of an ordinary `let` binding, you use `let!`.</span></span> <span data-ttu-id="f95b0-122">效果`let!`是要讓正在執行，以計算為其他運算或在執行緒上繼續執行。</span><span class="sxs-lookup"><span data-stu-id="f95b0-122">The effect of `let!` is to enable execution to continue on other computations or threads as the computation is being performed.</span></span> <span data-ttu-id="f95b0-123">在右邊的 list 之後`let!`繫結傳回時，非同步工作流程的其餘部分會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="f95b0-123">After the right side of the `let!` binding returns, the rest of the asynchronous workflow resumes execution.</span></span>

<span data-ttu-id="f95b0-124">下列程式碼顯示之間的差異`let`和`let!`。</span><span class="sxs-lookup"><span data-stu-id="f95b0-124">The following code shows the difference between `let` and `let!`.</span></span> <span data-ttu-id="f95b0-125">使用的程式碼行`let`則只會建立為物件，您可以稍後再執行所使用，例如，非同步計算`Async.StartImmediate`或[ `Async.RunSynchronously` ](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b)。</span><span class="sxs-lookup"><span data-stu-id="f95b0-125">The line of code that uses `let` just creates an asynchronous computation as an object that you can run later by using, for example, `Async.StartImmediate` or [`Async.RunSynchronously`](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b).</span></span> <span data-ttu-id="f95b0-126">使用的程式碼行`let!`開始計算，並再暫止執行緒的結果，直到可用在哪個點執行會持續。</span><span class="sxs-lookup"><span data-stu-id="f95b0-126">The line of code that uses `let!` starts the computation, and then the thread is suspended until the result is available, at which point execution continues.</span></span>

```fsharp
// let just stores the result as an asynchronous operation.
let (result1 : Async<byte[]>) = stream.AsyncRead(bufferSize)
// let! completes the asynchronous operation and returns the data.
let! (result2 : byte[])  = stream.AsyncRead(bufferSize)
```

<span data-ttu-id="f95b0-127">除了`let!`，您可以使用`use!`執行非同步的繫結。</span><span class="sxs-lookup"><span data-stu-id="f95b0-127">In addition to `let!`, you can use `use!` to perform asynchronous bindings.</span></span> <span data-ttu-id="f95b0-128">之間的差異`let!`和`use!`之間的差異相同`let`和`use`。</span><span class="sxs-lookup"><span data-stu-id="f95b0-128">The difference between `let!` and `use!` is the same as the difference between `let` and `use`.</span></span> <span data-ttu-id="f95b0-129">如`use!`，物件已處置的在目前範圍的結束。</span><span class="sxs-lookup"><span data-stu-id="f95b0-129">For `use!`, the object is disposed of at the close of the current scope.</span></span> <span data-ttu-id="f95b0-130">請注意，在目前版本的 F # 語言，`use!`不允許的值，初始化為 null，即使`use`沒有。</span><span class="sxs-lookup"><span data-stu-id="f95b0-130">Note that in the current release of the F# language, `use!` does not allow a value to be initialized to null, even though `use` does.</span></span>

## <a name="asynchronous-primitives"></a><span data-ttu-id="f95b0-131">非同步基本項目</span><span class="sxs-lookup"><span data-stu-id="f95b0-131">Asynchronous Primitives</span></span>

<span data-ttu-id="f95b0-132">執行單一的非同步工作，並傳回結果的方法會呼叫*非同步基本型別*，以及這些專為搭配`let!`。</span><span class="sxs-lookup"><span data-stu-id="f95b0-132">A method that performs a single asynchronous task and returns the result is called an *asynchronous primitive*, and these are designed specifically for use with `let!`.</span></span> <span data-ttu-id="f95b0-133">數個非同步基本型别都定義在 F # 核心程式庫中。</span><span class="sxs-lookup"><span data-stu-id="f95b0-133">Several asynchronous primitives are defined in the F# core library.</span></span> <span data-ttu-id="f95b0-134">Web 應用程式的兩個這類方法會在模組中定義[ `Microsoft.FSharp.Control.WebExtensions` ](https://msdn.microsoft.com/library/95ef17bc-ee3f-44ba-8a11-c90fcf4cf003): [ `WebRequest.AsyncGetResponse` ](https://msdn.microsoft.com/library/09a60c31-e6e2-4b5c-ad23-92a86e50060c)和[ `WebClient.AsyncDownloadString` ](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a)。</span><span class="sxs-lookup"><span data-stu-id="f95b0-134">Two such methods for Web applications are defined in the module [`Microsoft.FSharp.Control.WebExtensions`](https://msdn.microsoft.com/library/95ef17bc-ee3f-44ba-8a11-c90fcf4cf003): [`WebRequest.AsyncGetResponse`](https://msdn.microsoft.com/library/09a60c31-e6e2-4b5c-ad23-92a86e50060c) and [`WebClient.AsyncDownloadString`](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a).</span></span> <span data-ttu-id="f95b0-135">這兩個基本項目從網頁上，假設有一個 URL 下載資料。</span><span class="sxs-lookup"><span data-stu-id="f95b0-135">Both primitives download data from a Web page, given a URL.</span></span> <span data-ttu-id="f95b0-136">`AsyncGetResponse` 會產生`System.Net.WebResponse`物件，和`AsyncDownloadString`會產生表示網頁的 HTML 字串。</span><span class="sxs-lookup"><span data-stu-id="f95b0-136">`AsyncGetResponse` produces a `System.Net.WebResponse` object, and `AsyncDownloadString` produces a string that represents the HTML for a Web page.</span></span>

<span data-ttu-id="f95b0-137">非同步 I/O 作業數個基本類型中包含[ `Microsoft.FSharp.Control.CommonExtensions` ](https://msdn.microsoft.com/library/2edb67cb-6814-4a30-849f-b6dbdd042396)模組。</span><span class="sxs-lookup"><span data-stu-id="f95b0-137">Several primitives for asynchronous I/O operations are included in the [`Microsoft.FSharp.Control.CommonExtensions`](https://msdn.microsoft.com/library/2edb67cb-6814-4a30-849f-b6dbdd042396) module.</span></span> <span data-ttu-id="f95b0-138">這些擴充方法`System.IO.Stream`類別[ `Stream.AsyncRead` ](https://msdn.microsoft.com/library/85698aaa-bdda-47e6-abed-3730f59fda5e)和[ `Stream.AsyncWrite` ](https://msdn.microsoft.com/library/1b0a2751-e42a-47e1-bd27-020224adc618)。</span><span class="sxs-lookup"><span data-stu-id="f95b0-138">These extension methods of the `System.IO.Stream` class are [`Stream.AsyncRead`](https://msdn.microsoft.com/library/85698aaa-bdda-47e6-abed-3730f59fda5e) and [`Stream.AsyncWrite`](https://msdn.microsoft.com/library/1b0a2751-e42a-47e1-bd27-020224adc618).</span></span>

<span data-ttu-id="f95b0-139">中的其他非同步的基本項目可用[F # PowerTools](https://fsprojects.github.io/VisualFSharpPowerTools/)。</span><span class="sxs-lookup"><span data-stu-id="f95b0-139">Additional asynchronous primitives are available in the [F# PowerTools](https://fsprojects.github.io/VisualFSharpPowerTools/).</span></span> <span data-ttu-id="f95b0-140">您也可以藉由定義其完整的內文被括在非同步區塊中的函式來撰寫您自己的非同步基本項目。</span><span class="sxs-lookup"><span data-stu-id="f95b0-140">You can also write your own asynchronous primitives by defining a function whose complete body is enclosed in an async block.</span></span>

<span data-ttu-id="f95b0-141">若要使用其他非同步模型的 F # 非同步程式設計模型與.NET Framework 中設計的非同步方法，您可以建立傳回 F # 的函式`Async`物件。</span><span class="sxs-lookup"><span data-stu-id="f95b0-141">To use asynchronous methods in the .NET Framework that are designed for other asynchronous models with the F# asynchronous programming model, you create a function that returns an F# `Async` object.</span></span> <span data-ttu-id="f95b0-142">F # 程式庫有方便執行的函式。</span><span class="sxs-lookup"><span data-stu-id="f95b0-142">The F# library has functions that make this easy to do.</span></span>

<span data-ttu-id="f95b0-143">使用非同步工作流程的其中一個範例是包含以下;還有許多其他的方法的文件中[Async 類別](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7)。</span><span class="sxs-lookup"><span data-stu-id="f95b0-143">One example of using asynchronous workflows is included here; there are many others in the documentation for the methods of the [Async class](https://msdn.microsoft.com/library/03eb4d12-a01a-4565-a077-5e83f17cf6f7).</span></span>

<span data-ttu-id="f95b0-144">這個範例示範如何使用非同步工作流程以平行方式執行計算。</span><span class="sxs-lookup"><span data-stu-id="f95b0-144">This example shows how to use asynchronous workflows to perform computations in parallel.</span></span>

<span data-ttu-id="f95b0-145">在下列程式碼範例中，函式`fetchAsync`取得來自 Web 要求傳回 HTML 文字。</span><span class="sxs-lookup"><span data-stu-id="f95b0-145">In the following code example, a function `fetchAsync` gets the HTML text returned from a Web request.</span></span> <span data-ttu-id="f95b0-146">`fetchAsync`函式包含的非同步程式碼區塊。</span><span class="sxs-lookup"><span data-stu-id="f95b0-146">The `fetchAsync` function contains an asynchronous block of code.</span></span> <span data-ttu-id="f95b0-147">繫結進行時結果的非同步的基本型別，在此情況下[ `AsyncDownloadString` ](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a)，讓 ！</span><span class="sxs-lookup"><span data-stu-id="f95b0-147">When a binding is made to the result of an asynchronous primitive, in this case [`AsyncDownloadString`](https://msdn.microsoft.com/library/8a85a9b7-f712-4cac-a0ce-0a797f8ea32a), let!</span></span> <span data-ttu-id="f95b0-148">會用來讓取代。</span><span class="sxs-lookup"><span data-stu-id="f95b0-148">is used instead of let.</span></span>

<span data-ttu-id="f95b0-149">您可以使用函數[ `Async.RunSynchronously` ](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b)來執行非同步作業，並等候其結果。</span><span class="sxs-lookup"><span data-stu-id="f95b0-149">You use the function [`Async.RunSynchronously`](https://msdn.microsoft.com/library/0a6663a9-50f2-4d38-8bf3-cefd1a51fd6b) to execute an asynchronous operation and wait for its result.</span></span> <span data-ttu-id="f95b0-150">例如，您可以執行多個非同步作業以平行方式使用[ `Async.Parallel` ](https://msdn.microsoft.com/library/aa9b0355-2d55-4858-b943-cbe428de9dc4)函數搭配`Async.RunSynchronously`函式。</span><span class="sxs-lookup"><span data-stu-id="f95b0-150">As an example, you can execute multiple asynchronous operations in parallel by using the [`Async.Parallel`](https://msdn.microsoft.com/library/aa9b0355-2d55-4858-b943-cbe428de9dc4) function together with the `Async.RunSynchronously` function.</span></span> <span data-ttu-id="f95b0-151">`Async.Parallel`函式的清單`Async`物件資訊，請針對每個程式碼會設定`Async`task 物件以平行方式，並傳回在執行`Async`物件，表示平行計算。</span><span class="sxs-lookup"><span data-stu-id="f95b0-151">The `Async.Parallel` function takes a list of the `Async` objects, sets up the code for each `Async` task object to run in parallel, and returns an `Async` object that represents the parallel computation.</span></span> <span data-ttu-id="f95b0-152">在您呼叫一樣可以在單一作業`Async.RunSynchronously`即可開始執行。</span><span class="sxs-lookup"><span data-stu-id="f95b0-152">Just as for a single operation, you call `Async.RunSynchronously` to start the execution.</span></span>

<span data-ttu-id="f95b0-153">`runAll`函式會啟動三個平行的非同步工作流程，並等待，直到所有必須完成它們。</span><span class="sxs-lookup"><span data-stu-id="f95b0-153">The `runAll` function launches three asynchronous workflows in parallel and waits until they have all completed.</span></span>

[!code-fsharp[Main](../../../samples/snippets/fsharp/lang-ref-2/snippet8003.fs)]

## <a name="see-also"></a><span data-ttu-id="f95b0-154">另請參閱</span><span class="sxs-lookup"><span data-stu-id="f95b0-154">See Also</span></span>

[<span data-ttu-id="f95b0-155">F# 語言參考</span><span class="sxs-lookup"><span data-stu-id="f95b0-155">F# Language Reference</span></span>](index.md)

[<span data-ttu-id="f95b0-156">計算運算式</span><span class="sxs-lookup"><span data-stu-id="f95b0-156">Computation Expressions</span></span>](computation-expressions.md)

[<span data-ttu-id="f95b0-157">Control.Async 類別</span><span class="sxs-lookup"><span data-stu-id="f95b0-157">Control.Async Class</span></span>](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.async-class-%5bfsharp%5d)
