---
title: 無伺服器體系結構注意事項 - 無伺服器應用
description: 瞭解構建無伺服器應用程式的挑戰，從狀態管理和持久存儲到擴展、日誌記錄、跟蹤和診斷。
author: JEREMYLIKNESS
ms.author: jeliknes
ms.date: 06/26/2018
ms.openlocfilehash: c856683cf6910be98661e634246cd003b93a6d76
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/14/2020
ms.locfileid: "72522434"
---
# <a name="serverless-architecture-considerations"></a><span data-ttu-id="8ebc0-103">無伺服器架構考量</span><span class="sxs-lookup"><span data-stu-id="8ebc0-103">Serverless architecture considerations</span></span>

<span data-ttu-id="8ebc0-104">採用無伺服器體系結構確實帶來了某些挑戰。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-104">Adopting a serverless architecture does come with certain challenges.</span></span> <span data-ttu-id="8ebc0-105">本節將探討需要注意的一些更常見的注意事項。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-105">This section explores some of the more common considerations to be aware of.</span></span> <span data-ttu-id="8ebc0-106">所有這些挑戰都有解決辦法。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-106">All of these challenges have solutions.</span></span> <span data-ttu-id="8ebc0-107">與所有體系結構選擇一樣，只有在仔細考慮利弊後，才能做出無伺服器決策。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-107">As with all architecture choices, the decision to go serverless should be made only after carefully considering the pros and cons.</span></span> <span data-ttu-id="8ebc0-108">根據應用程式的需求，您可能會確定無伺服器實現不是某些元件的正確解決方案。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-108">Depending on the needs of your application, you may decide a serverless implementation isn't the right solution for certain components.</span></span>

## <a name="managing-state"></a><span data-ttu-id="8ebc0-109">管理狀態</span><span class="sxs-lookup"><span data-stu-id="8ebc0-109">Managing state</span></span>

<span data-ttu-id="8ebc0-110">預設情況下，無伺服器函數（與一般微服務一樣）是無狀態的。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-110">Serverless functions, as with microservices in general, are stateless by default.</span></span> <span data-ttu-id="8ebc0-111">避免狀態使無伺服器狀態短暫、橫向擴展和提供彈性，而不會出現核心故障點。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-111">Avoiding state enables serverless to be ephemeral, to scale out, and to provide resiliency without a central point of failure.</span></span> <span data-ttu-id="8ebc0-112">在某些情況下，業務流程需要狀態。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-112">In some circumstances, business processes require state.</span></span> <span data-ttu-id="8ebc0-113">如果進程需要狀態，則有兩個選項。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-113">If your process requires state, you have two options.</span></span> <span data-ttu-id="8ebc0-114">您可以採用非伺服器模型，或與提供狀態的單獨服務進行交互。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-114">You can adopt a model other than serverless, or interact with a separate service that provides state.</span></span> <span data-ttu-id="8ebc0-115">添加狀態會使解決方案複雜化，並加大擴展的難度，並可能創建單個故障點。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-115">Adding state can complicate the solution and make it harder to scale, and potentially create a single point of failure.</span></span> <span data-ttu-id="8ebc0-116">仔細考慮您的功能是否絕對需要狀態。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-116">Carefully consider whether your function absolutely requires state.</span></span> <span data-ttu-id="8ebc0-117">如果答案是"是"，則確定使用無伺服器實現它是否有意義。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-117">If the answer is "yes," determine whether it still makes sense to implement it with serverless.</span></span>

<span data-ttu-id="8ebc0-118">有幾種解決方案可以採用狀態，而不會影響無伺服器的好處。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-118">There are several solutions to adopt state without compromising the benefits of serverless.</span></span> <span data-ttu-id="8ebc0-119">一些較流行的解決方案包括：</span><span class="sxs-lookup"><span data-stu-id="8ebc0-119">Some of the more popular solutions include:</span></span>

- <span data-ttu-id="8ebc0-120">使用臨時資料存儲或分散式緩存，如 Redis</span><span class="sxs-lookup"><span data-stu-id="8ebc0-120">Use a temporary data store or distributed cache, like Redis</span></span>
- <span data-ttu-id="8ebc0-121">將狀態存儲在資料庫中，如 SQL 或 CosmosDB</span><span class="sxs-lookup"><span data-stu-id="8ebc0-121">Store state in a database, like SQL or CosmosDB</span></span>
- <span data-ttu-id="8ebc0-122">通過工作流引擎處理狀態，如持久功能</span><span class="sxs-lookup"><span data-stu-id="8ebc0-122">Handle state through a workflow engine like durable functions</span></span>

<span data-ttu-id="8ebc0-123">底線是，您應該意識到需要考慮在進程內使用無伺服器實現的任何狀態管理的必要性。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-123">The bottom line is that you should be aware of the need for any state management within processes you're considering to implement with serverless.</span></span>

## <a name="long-running-processes"></a><span data-ttu-id="8ebc0-124">長時間運行的進程</span><span class="sxs-lookup"><span data-stu-id="8ebc0-124">Long-running processes</span></span>

<span data-ttu-id="8ebc0-125">無伺服器的許多優點依賴于臨時化進程。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-125">Many benefits of serverless rely on the processes being ephemeral.</span></span> <span data-ttu-id="8ebc0-126">短時間使無伺服器提供程式更容易釋放資源，因為函數在主機之間結束和共用函數。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-126">Short run times make it easier for the serverless provider to free up resources as functions end and share functions across hosts.</span></span> <span data-ttu-id="8ebc0-127">大多數雲供應商將函數運行的總時間限制為 10 分鐘左右。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-127">Most cloud providers limit the total time your function can run to around 10 minutes.</span></span> <span data-ttu-id="8ebc0-128">如果過程可能需要更長的時間，則可以考慮另一種實現。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-128">If your process may take longer, you might consider an alternative implementation.</span></span>

<span data-ttu-id="8ebc0-129">有幾個例外和解決方案。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-129">There are a few exceptions and solutions.</span></span> <span data-ttu-id="8ebc0-130">一種解決方案可能是將流程分解為更小的元件，而這些元件的執行時間卻更少。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-130">One solution may be to break your process into smaller components that individually take less time to run.</span></span> <span data-ttu-id="8ebc0-131">如果進程由於依賴關係而運行很長時間，還可以考慮使用持久函數等解決方案的非同步工作流。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-131">If your process runs long because of dependencies, you can also consider an asynchronous workflow using a solution like durable functions.</span></span> <span data-ttu-id="8ebc0-132">持久功能在等待外部進程完成時暫停並維護進程的狀態。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-132">Durable functions pause and maintain the state of your process while it's waiting on an external process to finish.</span></span> <span data-ttu-id="8ebc0-133">非同步處理減少了實際進程運行的時間。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-133">Asynchronous handling reduces the time the actual process runs.</span></span>

## <a name="startup-time"></a><span data-ttu-id="8ebc0-134">啟動時間</span><span class="sxs-lookup"><span data-stu-id="8ebc0-134">Startup time</span></span>

<span data-ttu-id="8ebc0-135">無伺服器實現的潛在問題之一是啟動時間。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-135">One potential concern with serverless implementations is startup time.</span></span> <span data-ttu-id="8ebc0-136">為了節約資源，許多無伺服器供應商"按需"創建基礎結構。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-136">To conserve resources, many serverless providers create infrastructure "on demand."</span></span> <span data-ttu-id="8ebc0-137">在一段時間後觸發無伺服器函數時，可能需要創建或重新開機承載該函數的資源。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-137">When a serverless function is triggered after a period of time, the resources to host the function may need to be created or restarted.</span></span> <span data-ttu-id="8ebc0-138">在某些情況下，冷起動可能導致幾秒鐘的延遲。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-138">In some situations, cold starts may result in delays of several seconds.</span></span> <span data-ttu-id="8ebc0-139">啟動時間因供應商和服務等級而異。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-139">Startup time varies across providers and service levels.</span></span> <span data-ttu-id="8ebc0-140">如果為應用的成功最小化很重要，則有幾種方法可以解決啟動時間。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-140">There are a few approaches to address startup time if it's important to minimize for the success of the app.</span></span>

- <span data-ttu-id="8ebc0-141">某些供應商允許使用者為保證基礎結構"始終處於"的服務等級付費。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-141">Some providers allow users to pay for service levels that guarantee infrastructure is "always on".</span></span>
- <span data-ttu-id="8ebc0-142">實現保持活動機制（ping終結點以保持其"喚醒"）。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-142">Implement a keep-alive mechanism (ping the endpoint to keep it "awake").</span></span>
- <span data-ttu-id="8ebc0-143">使用業務流程，如 Kubernetes 與容器化函數方法（主機已在運行，因此旋轉新實例非常快）。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-143">Use orchestration like Kubernetes with a containerized function approach (the host is already running so spinning up new instances is extremely fast).</span></span>

## <a name="database-updates-and-migrations"></a><span data-ttu-id="8ebc0-144">資料庫更新和遷移</span><span class="sxs-lookup"><span data-stu-id="8ebc0-144">Database updates and migrations</span></span>

<span data-ttu-id="8ebc0-145">無伺服器代碼的一個優點是，您可以發佈新功能，而無需重新部署整個應用程式。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-145">An advantage of serverless code is that you can release new functions without having to redeploy the entire application.</span></span> <span data-ttu-id="8ebc0-146">當涉及關係資料庫時，這種優勢可能會成為劣勢。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-146">This advantage can become a disadvantage when there's a relational database involved.</span></span> <span data-ttu-id="8ebc0-147">對資料庫架構的更改很難與無伺服器更新同步。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-147">Changes to database schemas are difficult to synchronize with serverless updates.</span></span> <span data-ttu-id="8ebc0-148">當出現問題，並且必須回滾更改時，將構成其他挑戰。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-148">Additional challenges are posed when things go wrong and the changes must be rolled back.</span></span> <span data-ttu-id="8ebc0-149">資料完整性是微服務和無伺服器函數的最佳做法之一，即它們擁有自己的資料。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-149">Data integrity is one reason that a best practice for microservices and serverless functions is that they own their own data.</span></span> <span data-ttu-id="8ebc0-150">可以將更改部署為單個計算和資料單元。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-150">It is possible to deploy changes as a single unit of compute and data.</span></span> <span data-ttu-id="8ebc0-151">現實情況是，許多遺留系統具有大型後端資料庫，必須與無伺服器體系結構協調。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-151">The reality is that many legacy systems feature a large back-end database that must be reconciled with the serverless architecture.</span></span>

<span data-ttu-id="8ebc0-152">解決架構版本控制的流行方法是從不修改現有屬性和列，而是添加新資訊。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-152">A popular approach to solve schema versioning is to never modify existing properties and columns, but instead add new information.</span></span> <span data-ttu-id="8ebc0-153">例如，請考慮將更改從待辦事項清單的布林"已完成"標誌移動到"已完成日期"。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-153">For example, consider a change to move from a Boolean "completed" flag for a todo list to a "completed date."</span></span> <span data-ttu-id="8ebc0-154">資料庫更改將：：</span><span class="sxs-lookup"><span data-stu-id="8ebc0-154">Instead of removing the old field, the database change will:</span></span>

1. <span data-ttu-id="8ebc0-155">添加新的"完成日期"欄位。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-155">Add a new "completed date" field.</span></span>
1. <span data-ttu-id="8ebc0-156">將"已完成"布林欄位轉換為計算函數，該函數評估完成日期是否在當前日期之後。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-156">Transform the "completed" Boolean field to a computed function that evaluates whether the completed date is after the current date.</span></span>
1. <span data-ttu-id="8ebc0-157">添加觸發器，將已完成日期設置為已完成的布林設置為 true 時的當前日期。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-157">Add a trigger to set the completed date to the current date when the completed Boolean is set to true.</span></span>

<span data-ttu-id="8ebc0-158">更改序列可確保舊代碼繼續"按現在"運行，而較新的無伺服器函數可以利用新欄位。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-158">The sequence of changes ensures that legacy code continues to run "as is" while newer serverless functions can take advantage of the new field.</span></span>

<span data-ttu-id="8ebc0-159">有關無伺服器體系結構中資料的詳細資訊，請參閱[分散式資料管理的挑戰和解決方案](../microservices/architect-microservice-container-applications/distributed-data-management.md)。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-159">For more information about data in serverless architectures, see [Challenges and solutions for distributed data management](../microservices/architect-microservice-container-applications/distributed-data-management.md).</span></span>

## <a name="scaling"></a><span data-ttu-id="8ebc0-160">調整大小</span><span class="sxs-lookup"><span data-stu-id="8ebc0-160">Scaling</span></span>

<span data-ttu-id="8ebc0-161">一種常見的誤解是，無伺服器意味著"無伺服器"。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-161">It's a common misconception that serverless means "no server."</span></span> <span data-ttu-id="8ebc0-162">事實上，它是"更少的伺服器"。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-162">It's in fact "less server."</span></span> <span data-ttu-id="8ebc0-163">在擴展方面，存在支援基礎結構非常重要。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-163">The fact there is a backing infrastructure is important to understand when it comes to scaling.</span></span> <span data-ttu-id="8ebc0-164">大多數無伺服器平臺提供一組控制項，用於處理當事件密度增加時基礎結構應如何擴展。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-164">Most serverless platforms provide a set of controls to handle how the infrastructure should scale when event density increases.</span></span> <span data-ttu-id="8ebc0-165">您可以從各種選項中進行選擇，但策略可能因功能而異。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-165">You can choose from a variety of options, but your strategy may vary depending on the function.</span></span> <span data-ttu-id="8ebc0-166">此外，函數通常在相關主機下運行，以便同一主機上的函數具有相同的比例選項。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-166">Furthermore, functions are typically run under a related host, so that functions on the same host have the same scale options.</span></span> <span data-ttu-id="8ebc0-167">因此，有必要根據規模要求組織並制定哪些函數一起託管。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-167">Therefore it is necessary to organize and strategize which functions are hosted together based on scale requirements.</span></span>

<span data-ttu-id="8ebc0-168">規則通常指定如何根據不同的參數進行擴展（增加主機資源）和橫向擴展（增加主機實例數）。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-168">Rules often specify how to scale-up (increase the host resources) and scale-out (increase the number of host instances) based on varying parameters.</span></span> <span data-ttu-id="8ebc0-169">比例的觸發器可能包括計畫、請求速率、CPU 利用率和記憶體使用方式。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-169">Triggers for scales may include schedule, request rates, CPU utilization, and memory usage.</span></span> <span data-ttu-id="8ebc0-170">更高的性能通常要花費更大的成本。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-170">Higher performance often comes at a greater cost.</span></span> <span data-ttu-id="8ebc0-171">當請求率突然增加時，成本較低的基於消費的方法可能不會迅速擴展。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-171">The less expensive, consumption-based approaches may not scale as quickly when the request rate suddenly increases.</span></span> <span data-ttu-id="8ebc0-172">在提前支付"保險成本"與嚴格"隨走"和因需求突然增加而面臨反應遲緩的風險之間，有一個權衡。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-172">There is a trade-off between paying up front "insurance cost" versus paying strictly "as you go" and risking slower responses due to sudden increases in demand.</span></span>

## <a name="monitoring-tracing-and-logging"></a><span data-ttu-id="8ebc0-173">監視、跟蹤和日誌記錄</span><span class="sxs-lookup"><span data-stu-id="8ebc0-173">Monitoring, tracing, and logging</span></span>

<span data-ttu-id="8ebc0-174">DevOps 的一個經常被忽視的方面是監視部署後的應用程式。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-174">An often overlooked aspect of DevOps is monitoring applications once deployed.</span></span> <span data-ttu-id="8ebc0-175">制定監視無伺服器功能的策略非常重要。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-175">It's important to have a strategy for monitoring serverless functions.</span></span> <span data-ttu-id="8ebc0-176">最大的挑戰通常是相關性，或者識別當使用者調用多個函數作為同一交互的一部分時。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-176">The biggest challenge is often correlation, or recognizing when a user calls multiple functions as part of the same interaction.</span></span> <span data-ttu-id="8ebc0-177">大多數無伺服器平臺允許主控台日誌記錄，可以導入到協力廠商工具中。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-177">Most serverless platforms allow console logging that can be imported into third-party tools.</span></span> <span data-ttu-id="8ebc0-178">還有一些選項可以自動收集遙測資料、生成和跟蹤相關 I 並監視特定操作以提供詳細的見解。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-178">There are also options to automate collection of telemetry, generate and track correlation IDs, and monitor specific actions to provide detailed insights.</span></span> <span data-ttu-id="8ebc0-179">Azure 提供了用於監視和分析的高級[應用程式見解平臺](https://docs.microsoft.com/azure/azure-functions/functions-monitoring)。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-179">Azure provides the advanced [Application Insights platform](https://docs.microsoft.com/azure/azure-functions/functions-monitoring) for monitoring and analytics.</span></span>

## <a name="inter-service-dependencies"></a><span data-ttu-id="8ebc0-180">服務間依賴項</span><span class="sxs-lookup"><span data-stu-id="8ebc0-180">Inter-service dependencies</span></span>

<span data-ttu-id="8ebc0-181">無伺服器體系結構可能包括依賴于其他函數的功能。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-181">A serverless architecture may include functions that rely on other functions.</span></span> <span data-ttu-id="8ebc0-182">事實上，在無伺服器體系結構中，將多個服務作為交互或分散式交易的一部分相互調用的情況並不少見。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-182">In fact, it isn't uncommon in a serverless architecture to have multiple services call each other as part of an interaction or distributed transaction.</span></span> <span data-ttu-id="8ebc0-183">為了避免強耦合，建議服務不要直接引用對方。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-183">To avoid strong coupling, it's recommended that services don't reference each other directly.</span></span> <span data-ttu-id="8ebc0-184">當服務的終結點需要更改時，直接引用可能會導致重大重構。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-184">When the endpoint for a service needs to change, direct references could result in major refactoring.</span></span> <span data-ttu-id="8ebc0-185">建議的解決方案是提供服務發現機制（如註冊表），該機制為請求類型提供適當的終結點。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-185">A suggested solution is to provide a service discovery mechanism, such as a registry, that provides the appropriate end point for a request type.</span></span> <span data-ttu-id="8ebc0-186">另一個解決方案是利用消息傳遞服務（如佇列或主題）來在服務之間進行通信。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-186">Another solution is to leverage messaging services like queues or topics for communication between services.</span></span>

## <a name="managing-failure-and-providing-resiliency"></a><span data-ttu-id="8ebc0-187">管理故障並提供彈性</span><span class="sxs-lookup"><span data-stu-id="8ebc0-187">Managing failure and providing resiliency</span></span>

<span data-ttu-id="8ebc0-188">考慮*斷路器模式*也很重要：如果由於某種原因，服務繼續出現故障，則不建議重複調用該服務。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-188">It's also important to consider the *circuit-breaker pattern*: If, for some reason, a service continues to fail, it isn't advisable to call that service repeatedly.</span></span> <span data-ttu-id="8ebc0-189">相反，調用替代服務或返回消息，直到重新建立從屬服務的運行狀況。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-189">Instead, an alternative service is called or a message returned until the health of the dependent service is re-established.</span></span> <span data-ttu-id="8ebc0-190">無伺服器體系結構需要考慮解決和管理服務間依賴關係的策略。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-190">The serverless architecture needs to take into account the strategy for resolving and managing inter-service dependencies.</span></span>

<span data-ttu-id="8ebc0-191">要繼續斷路器模式，服務需要容錯和彈性。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-191">To continue the circuit-breaker pattern, services need to be fault tolerant and resilient.</span></span> <span data-ttu-id="8ebc0-192">容錯是指應用程式即使在遇到意外異常或無效狀態後仍繼續運行的能力。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-192">Fault tolerance refers to the ability of your application to continue running even after unexpected exceptions or invalid states are encountered.</span></span> <span data-ttu-id="8ebc0-193">容錯通常是代碼本身的函數，以及編寫如何處理異常的方式。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-193">Fault tolerance is typically a function of the code itself and how it's written to handle exceptions.</span></span> <span data-ttu-id="8ebc0-194">恢復能力是指應用從故障中恢復的能力。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-194">Resiliency refers to how capable the app is at recovering from failures.</span></span> <span data-ttu-id="8ebc0-195">恢復能力通常由無伺服器平臺管理。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-195">Resiliency is often managed by the serverless platform.</span></span> <span data-ttu-id="8ebc0-196">當現有無伺服器函數實例發生故障時，平臺應該能夠啟動新的無伺服器函數實例。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-196">The platform should be able to spin up a new serverless function instance when the existing one fails.</span></span> <span data-ttu-id="8ebc0-197">平臺還應足夠智慧，在每個新實例失敗時停止旋轉新實例。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-197">The platform should also be intelligent enough to stop spinning up new instances when every new instance fails.</span></span>

<span data-ttu-id="8ebc0-198">有關詳細資訊，請參閱[實現斷路器模式](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-198">For more information, see [Implementing the Circuit Breaker pattern](../microservices/implement-resilient-applications/implement-circuit-breaker-pattern.md).</span></span>

## <a name="versioning-and-greenblue-deployments"></a><span data-ttu-id="8ebc0-199">版本和綠色/藍色部署</span><span class="sxs-lookup"><span data-stu-id="8ebc0-199">Versioning and green/blue deployments</span></span>

<span data-ttu-id="8ebc0-200">無伺服器的一個主要好處是能夠升級特定功能，而無需重新部署整個應用程式。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-200">A major benefit of serverless is the ability to upgrade a specific function without having to redeploy the entire application.</span></span> <span data-ttu-id="8ebc0-201">要成功升級，必須對函數進行版本控制，以便調用它們的服務路由到正確的代碼版本。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-201">For upgrades to be successful, functions must be versioned so that services calling them are routed to the correct version of code.</span></span> <span data-ttu-id="8ebc0-202">部署新版本的策略也很重要。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-202">A strategy for deploying new versions is also important.</span></span> <span data-ttu-id="8ebc0-203">常用方法是使用"綠色/藍色部署"。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-203">A common approach is to use "green/blue deployments."</span></span> <span data-ttu-id="8ebc0-204">綠色部署是當前功能。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-204">The green deployment is the current function.</span></span> <span data-ttu-id="8ebc0-205">新的"藍色"版本部署到生產和測試。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-205">A new "blue" version is deployed to production and tested.</span></span> <span data-ttu-id="8ebc0-206">測試通過後，將交換綠色和藍色版本，以便新版本上線。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-206">When testing passes, the green and blue versions are swapped so the new version comes live.</span></span> <span data-ttu-id="8ebc0-207">如果遇到任何問題，可以重新交換它們。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-207">If any issues are encountered, they can be swapped back.</span></span> <span data-ttu-id="8ebc0-208">支援版本控制和綠色/藍色部署需要組合創作函數以適應版本更改，以及使用無伺服器平臺來處理部署。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-208">Supporting versioning and green/blue deployments requires a combination of authoring the functions to accommodate version changes and working with the serverless platform to handle deployments.</span></span> <span data-ttu-id="8ebc0-209">一種可能的方法是使用代理，這在[Azure 無伺服器平臺](azure-functions.md#proxies)章節仲介紹。</span><span class="sxs-lookup"><span data-stu-id="8ebc0-209">One possible approach is to use proxies, which are described in the [Azure serverless platform](azure-functions.md#proxies) chapter.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="8ebc0-210">[上一個](serverless-architecture.md)
>[下一個](serverless-design-examples.md)</span><span class="sxs-lookup"><span data-stu-id="8ebc0-210">[Previous](serverless-architecture.md)
[Next](serverless-design-examples.md)</span></span>
