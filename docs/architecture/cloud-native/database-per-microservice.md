---
title: 具各微服務特性的資料庫
description: 對比單片和雲原生應用程式中的資料存儲。
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: c0c5611fa866d70f155e4bdad2eee1181b13c065
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141441"
---
# <a name="database-per-microservice"></a><span data-ttu-id="52258-103">具各微服務特性的資料庫</span><span class="sxs-lookup"><span data-stu-id="52258-103">Database-per-microservice</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="52258-104">正如我們在本書中所看到的，雲原生方法改變了設計、部署和管理應用程式的方式。</span><span class="sxs-lookup"><span data-stu-id="52258-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="52258-105">它還會更改管理和存儲資料的方式。</span><span class="sxs-lookup"><span data-stu-id="52258-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="52258-106">圖 5-1 對比了差異。</span><span class="sxs-lookup"><span data-stu-id="52258-106">Figure 5-1 contrasts the differences.</span></span>

![雲原生應用程式中的資料存儲](./media/distributed-data.png)

<span data-ttu-id="52258-108">**圖5-1**.</span><span class="sxs-lookup"><span data-stu-id="52258-108">**Figure 5-1**.</span></span> <span data-ttu-id="52258-109">雲原生應用程式中的資料管理</span><span class="sxs-lookup"><span data-stu-id="52258-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="52258-110">有經驗的開發人員將很容易識別圖 5-1 左側的體系結構。</span><span class="sxs-lookup"><span data-stu-id="52258-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="52258-111">在此*單片應用程式中*，業務服務元件在共用服務層中組合在一起，共用來自單個關係資料庫的資料。</span><span class="sxs-lookup"><span data-stu-id="52258-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="52258-112">在許多方面，單個資料庫使資料管理變得簡單。</span><span class="sxs-lookup"><span data-stu-id="52258-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="52258-113">跨多個表查詢資料非常簡單。</span><span class="sxs-lookup"><span data-stu-id="52258-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="52258-114">對資料所做的更改一起更新，或者它們全部回滾。</span><span class="sxs-lookup"><span data-stu-id="52258-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="52258-115">[ACID 交易](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties)保證強和即時的一致性。</span><span class="sxs-lookup"><span data-stu-id="52258-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="52258-116">為雲原生設計，我們採取了不同的方法。</span><span class="sxs-lookup"><span data-stu-id="52258-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="52258-117">在圖 5-1 的右側，請注意業務功能如何隔離到小型的獨立微服務中。</span><span class="sxs-lookup"><span data-stu-id="52258-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="52258-118">每個微服務封裝特定的業務功能及其自己的資料。</span><span class="sxs-lookup"><span data-stu-id="52258-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="52258-119">單片資料庫分解為具有許多較小資料庫的分散式資料模型，每個資料庫都與微服務對齊。</span><span class="sxs-lookup"><span data-stu-id="52258-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="52258-120">當煙霧清除時，我們出現了一個設計，它公開*了每個微服務的資料庫*。</span><span class="sxs-lookup"><span data-stu-id="52258-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="why"></a><span data-ttu-id="52258-121">原因為何？</span><span class="sxs-lookup"><span data-stu-id="52258-121">Why?</span></span>

<span data-ttu-id="52258-122">每個微服務的此資料庫提供了許多好處，尤其是對於必須快速發展並支援大規模擴展的系統。</span><span class="sxs-lookup"><span data-stu-id="52258-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="52258-123">使用此模型...</span><span class="sxs-lookup"><span data-stu-id="52258-123">With this model...</span></span>

- <span data-ttu-id="52258-124">域資料封裝在服務中</span><span class="sxs-lookup"><span data-stu-id="52258-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="52258-125">資料架構可以在不影響其他服務的情況下發展</span><span class="sxs-lookup"><span data-stu-id="52258-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="52258-126">每個資料存儲可以獨立擴展</span><span class="sxs-lookup"><span data-stu-id="52258-126">Each data store can independently scale</span></span>
- <span data-ttu-id="52258-127">一個服務中的資料存儲故障不會直接影響其他服務</span><span class="sxs-lookup"><span data-stu-id="52258-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="52258-128">隔離資料還使每個微服務能夠實現最適合其工作負載、存儲需求和讀/寫模式的資料存儲類型。</span><span class="sxs-lookup"><span data-stu-id="52258-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="52258-129">選項包括關係、文檔、鍵值，甚至基於圖形的資料存儲。</span><span class="sxs-lookup"><span data-stu-id="52258-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="52258-130">圖 5-2 介紹了雲本機系統中多面體持久性的原則。</span><span class="sxs-lookup"><span data-stu-id="52258-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![多格洛特資料持久性](./media/polyglot-data-persistence.png)

<span data-ttu-id="52258-132">**圖5-2**.</span><span class="sxs-lookup"><span data-stu-id="52258-132">**Figure 5-2**.</span></span> <span data-ttu-id="52258-133">多格洛特資料持久性</span><span class="sxs-lookup"><span data-stu-id="52258-133">Polyglot data persistence</span></span>

<span data-ttu-id="52258-134">請注意，在上圖中，每個微服務如何支援不同類型的資料存儲。</span><span class="sxs-lookup"><span data-stu-id="52258-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="52258-135">產品目錄微服務使用關係資料庫來容納其基礎資料的豐富關聯式結構。</span><span class="sxs-lookup"><span data-stu-id="52258-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="52258-136">購物車微服務使用支援其簡單、鍵值資料存儲的分散式緩存。</span><span class="sxs-lookup"><span data-stu-id="52258-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="52258-137">訂購微服務既使用 NoSql 文檔資料庫進行寫入操作，也使用高度非正常化的金鑰/值存儲，以適應大量讀取操作。</span><span class="sxs-lookup"><span data-stu-id="52258-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="52258-138">雖然關係資料庫與具有複雜資料的微服務仍然相關，但 NoSQL 資料庫已獲得相當普及。</span><span class="sxs-lookup"><span data-stu-id="52258-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="52258-139">它們提供大規模和高可用性。</span><span class="sxs-lookup"><span data-stu-id="52258-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="52258-140">其無架構特性允許開發人員擺脫類型化資料類和 ORM 的體系結構，使更改變得昂貴且耗時。</span><span class="sxs-lookup"><span data-stu-id="52258-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="52258-141">本章後面我們將介紹 NoSQL 資料庫。</span><span class="sxs-lookup"><span data-stu-id="52258-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="52258-142">雖然將資料封裝到單獨的微服務中可以提高敏捷性、性能和可擴充性，但它也帶來了許多挑戰。</span><span class="sxs-lookup"><span data-stu-id="52258-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="52258-143">在下一節中，我們將討論這些挑戰以及説明克服這些挑戰的模式和實踐。</span><span class="sxs-lookup"><span data-stu-id="52258-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="52258-144">跨服務查詢</span><span class="sxs-lookup"><span data-stu-id="52258-144">Cross-service queries</span></span>

<span data-ttu-id="52258-145">雖然微服務是獨立的，並且側重于特定的功能功能，如庫存、發貨或訂購，但它們通常需要與其他微服務集成。</span><span class="sxs-lookup"><span data-stu-id="52258-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="52258-146">通常，集成涉及一個微服務*查詢*另一個微服務的資料。</span><span class="sxs-lookup"><span data-stu-id="52258-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="52258-147">圖 5-3 顯示了方案。</span><span class="sxs-lookup"><span data-stu-id="52258-147">Figure 5-3 shows the scenario.</span></span>

![跨微服務查詢](./media/cross-service-query.png)

<span data-ttu-id="52258-149">**圖5-3**.</span><span class="sxs-lookup"><span data-stu-id="52258-149">**Figure 5-3**.</span></span> <span data-ttu-id="52258-150">跨微服務查詢</span><span class="sxs-lookup"><span data-stu-id="52258-150">Querying across microservices</span></span>

<span data-ttu-id="52258-151">在上圖中，我們看到一個購物籃微服務，將商品添加到使用者的購物籃中。</span><span class="sxs-lookup"><span data-stu-id="52258-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="52258-152">雖然此微服務的資料存儲包含購物籃和行專案資料，但它不維護產品或定價資料。</span><span class="sxs-lookup"><span data-stu-id="52258-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="52258-153">相反，這些資料項目歸目錄所有，並定價微服務。</span><span class="sxs-lookup"><span data-stu-id="52258-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="52258-154">這帶來了一個問題。</span><span class="sxs-lookup"><span data-stu-id="52258-154">This presents a problem.</span></span> <span data-ttu-id="52258-155">購物籃微服務如何在使用者沒有產品或定價資料的情況下將產品添加到使用者的購物籃中？</span><span class="sxs-lookup"><span data-stu-id="52258-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="52258-156">第 4 章中討論的一個選項是從購物籃[直接調用目錄](service-to-service-communication.md#queries)和定價微服務。</span><span class="sxs-lookup"><span data-stu-id="52258-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="52258-157">但是，在第 4 章中，我們說過同步 HTTP 將*微服務調用在*一起，從而降低了它們的自主性並降低了它們的體系結構優勢。</span><span class="sxs-lookup"><span data-stu-id="52258-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="52258-158">我們還可以實現請求-答覆模式，為每個服務分別提供入站和出站佇列。</span><span class="sxs-lookup"><span data-stu-id="52258-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="52258-159">但是，此模式很複雜，需要管道來關聯請求和回應訊息。</span><span class="sxs-lookup"><span data-stu-id="52258-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="52258-160">雖然它確實分離後端微服務呼叫，但呼叫服務仍必須同步等待來電完成。</span><span class="sxs-lookup"><span data-stu-id="52258-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="52258-161">網路擁塞、瞬態故障或超載微服務，可能導致長時間運行甚至失敗的操作。</span><span class="sxs-lookup"><span data-stu-id="52258-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="52258-162">相反，一個被廣泛接受的刪除跨服務依賴項的模式是[具體化視圖模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)，如圖 5-4 所示。</span><span class="sxs-lookup"><span data-stu-id="52258-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![具體化視圖模式](./media/materialized-view-pattern.png)

<span data-ttu-id="52258-164">**圖5-4**。</span><span class="sxs-lookup"><span data-stu-id="52258-164">**Figure 5-4**.</span></span> <span data-ttu-id="52258-165">具體化視圖模式</span><span class="sxs-lookup"><span data-stu-id="52258-165">Materialized View Pattern</span></span>

<span data-ttu-id="52258-166">使用此模式，您將本地資料表（稱為*讀取模型*）放在購物籃服務中。</span><span class="sxs-lookup"><span data-stu-id="52258-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="52258-167">此表包含產品和定價微服務所需的資料的非正常化副本。</span><span class="sxs-lookup"><span data-stu-id="52258-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="52258-168">將資料直接複製到購物籃微服務中，無需昂貴的跨服務呼叫。</span><span class="sxs-lookup"><span data-stu-id="52258-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="52258-169">使用服務本地資料，可以提高服務的回應時間和可靠性。</span><span class="sxs-lookup"><span data-stu-id="52258-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="52258-170">此外，擁有自己的資料副本使購物籃服務更具彈性。</span><span class="sxs-lookup"><span data-stu-id="52258-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="52258-171">如果目錄服務不可用，它不會直接影響購物籃服務。</span><span class="sxs-lookup"><span data-stu-id="52258-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="52258-172">購物籃可以繼續使用自己商店的資料進行操作。</span><span class="sxs-lookup"><span data-stu-id="52258-172">The shopping basket can continue operating with the data from its own store.</span></span>

<span data-ttu-id="52258-173">這種方法的問題在於，您現在系統中有重複的資料。</span><span class="sxs-lookup"><span data-stu-id="52258-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="52258-174">但是，*在*雲本機系統中戰略性地複製資料是一種既定做法，不被視為反模式或不良做法。</span><span class="sxs-lookup"><span data-stu-id="52258-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="52258-175">請記住，*只有一個服務*可以擁有資料集並有權擁有資料集。</span><span class="sxs-lookup"><span data-stu-id="52258-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="52258-176">更新記錄系統時，您需要同步讀取模型。</span><span class="sxs-lookup"><span data-stu-id="52258-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="52258-177">同步通常通過具有[發佈/訂閱模式](service-to-service-communication.md#events)的非同步消息實現，如圖 5.4 所示。</span><span class="sxs-lookup"><span data-stu-id="52258-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="52258-178">分散式交易</span><span class="sxs-lookup"><span data-stu-id="52258-178">Distributed transactions</span></span>

<span data-ttu-id="52258-179">雖然跨微服務查詢資料很困難，但跨多個微服務實現事務甚至更為複雜。</span><span class="sxs-lookup"><span data-stu-id="52258-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="52258-180">在不同微服務中保持獨立資料來源的資料一致性的內在挑戰怎麼強調也不為過。</span><span class="sxs-lookup"><span data-stu-id="52258-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="52258-181">雲原生應用程式中缺少分散式交易意味著您必須以程式設計方式管理分散式交易。</span><span class="sxs-lookup"><span data-stu-id="52258-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="52258-182">你從一個*即時一致性*的世界走向最終一*致性*的世界。</span><span class="sxs-lookup"><span data-stu-id="52258-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="52258-183">圖 5-5 顯示了問題。</span><span class="sxs-lookup"><span data-stu-id="52258-183">Figure 5-5 shows the problem.</span></span>

![saga 模式中的事務](./media/saga-transaction-operation.png)

<span data-ttu-id="52258-185">**圖5-5**.</span><span class="sxs-lookup"><span data-stu-id="52258-185">**Figure 5-5**.</span></span> <span data-ttu-id="52258-186">跨微服務實現事務</span><span class="sxs-lookup"><span data-stu-id="52258-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="52258-187">在上圖中，五個獨立的微服務參與創建訂單的分散式交易。</span><span class="sxs-lookup"><span data-stu-id="52258-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="52258-188">每個微服務維護自己的資料存儲，並為其存儲實現本地事務。</span><span class="sxs-lookup"><span data-stu-id="52258-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="52258-189">要創建訂單，*每個*微服務的本地事務必須成功，或者*所有*事務都必須中止和回滾該操作。</span><span class="sxs-lookup"><span data-stu-id="52258-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="52258-190">雖然每個微服務都提供內置事務支援，但不支援跨所有五個服務的分散式交易來保持資料一致性。</span><span class="sxs-lookup"><span data-stu-id="52258-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="52258-191">相反，您必須*以程式設計方式*構造此分散式交易。</span><span class="sxs-lookup"><span data-stu-id="52258-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="52258-192">添加分散式交易支援的流行模式是 Saga 模式。</span><span class="sxs-lookup"><span data-stu-id="52258-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="52258-193">它通過將本地事務分組到一起以程式設計和按順序調用每個事務來實現。</span><span class="sxs-lookup"><span data-stu-id="52258-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="52258-194">如果任何本地事務失敗，Saga 將中止該操作並調用一組[補償事務](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)。</span><span class="sxs-lookup"><span data-stu-id="52258-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="52258-195">補償事務撤銷了上述本地事務所做的更改，並還原了資料一致性。</span><span class="sxs-lookup"><span data-stu-id="52258-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="52258-196">圖 5-6 顯示了 Saga 模式的失敗事務。</span><span class="sxs-lookup"><span data-stu-id="52258-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![回滾在傳奇模式](./media/saga-rollback-operation.png)

<span data-ttu-id="52258-198">**圖5-6**.</span><span class="sxs-lookup"><span data-stu-id="52258-198">**Figure 5-6**.</span></span> <span data-ttu-id="52258-199">復原交易</span><span class="sxs-lookup"><span data-stu-id="52258-199">Rolling back a transaction</span></span>

<span data-ttu-id="52258-200">在上圖中，"*更新清單"* 操作在"清單"微服務中失敗。</span><span class="sxs-lookup"><span data-stu-id="52258-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="52258-201">Saga 調用一組補償事務（紅色）來調整庫存計數、取消付款和訂單，並將每個微服務的資料返回到一致狀態。</span><span class="sxs-lookup"><span data-stu-id="52258-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="52258-202">Saga 模式通常編排為一系列相關事件，或作為一組相關命令編排。</span><span class="sxs-lookup"><span data-stu-id="52258-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="52258-203">在第 4 章中，我們討論了作為協調的 saga 實現基礎的服務聚合器模式。</span><span class="sxs-lookup"><span data-stu-id="52258-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="52258-204">我們還討論了與 Azure 服務匯流排和 Azure 事件網格主題一起發生的事件，這些主題將成為精心編排的 saga 實現的基礎。</span><span class="sxs-lookup"><span data-stu-id="52258-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="52258-205">大容量資料</span><span class="sxs-lookup"><span data-stu-id="52258-205">High volume data</span></span>

<span data-ttu-id="52258-206">大型雲原生應用程式通常支援大容量資料要求。</span><span class="sxs-lookup"><span data-stu-id="52258-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="52258-207">在這些情況下，傳統的資料存儲技術可能會導致瓶頸。</span><span class="sxs-lookup"><span data-stu-id="52258-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="52258-208">對於大規模部署的複雜系統，命令和查詢責任分離 （CQRS） 和事件源都可能提高應用程式性能。</span><span class="sxs-lookup"><span data-stu-id="52258-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="52258-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="52258-209">CQRS</span></span>

<span data-ttu-id="52258-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs)是一種體系結構模式，可説明最大限度地提高性能、可擴充性和安全性。</span><span class="sxs-lookup"><span data-stu-id="52258-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="52258-211">該模式將讀取資料的操作與寫入資料的工序分開。</span><span class="sxs-lookup"><span data-stu-id="52258-211">The pattern separates operations that read data from those operations that write data.</span></span>

<span data-ttu-id="52258-212">對於正常方案，相同的實體模型和資料存儲庫*物件用於讀取*和寫入操作。</span><span class="sxs-lookup"><span data-stu-id="52258-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="52258-213">但是，高容量資料方案可以從用於讀取和寫入的單獨模型和資料表中獲益。</span><span class="sxs-lookup"><span data-stu-id="52258-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="52258-214">為了提高性能，讀取操作可以查詢資料的高度非正常化表示形式，以避免昂貴的重複表聯接和表鎖。</span><span class="sxs-lookup"><span data-stu-id="52258-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="52258-215">*寫入*操作（稱為*命令*）將針對資料完全正常化表示形式進行更新，以確保一致性。</span><span class="sxs-lookup"><span data-stu-id="52258-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="52258-216">然後，您需要實現一個機制，使兩個表示保持同步。通常，每當修改寫入表時，它都會發佈一個事件，將修改複製到讀取表。</span><span class="sxs-lookup"><span data-stu-id="52258-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="52258-217">圖 5-7 顯示了 CQRS 模式的實現。</span><span class="sxs-lookup"><span data-stu-id="52258-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![命令和查詢責任分離](./media/cqrs-implementation.png)

<span data-ttu-id="52258-219">**圖5-7**.</span><span class="sxs-lookup"><span data-stu-id="52258-219">**Figure 5-7**.</span></span> <span data-ttu-id="52258-220">CQRS 實現</span><span class="sxs-lookup"><span data-stu-id="52258-220">CQRS implementation</span></span>

<span data-ttu-id="52258-221">在上圖中，實現了單獨的命令和查詢模型。</span><span class="sxs-lookup"><span data-stu-id="52258-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="52258-222">每個資料寫入操作都保存到寫入存儲，然後傳播到讀取存儲。</span><span class="sxs-lookup"><span data-stu-id="52258-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="52258-223">密切關注資料傳播過程在[最終一致性](http://www.cloudcomputingpatterns.org/eventual_consistency/)原則下如何運作。</span><span class="sxs-lookup"><span data-stu-id="52258-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="52258-224">讀取模型最終與寫入模型同步，但過程可能有一些延遲。</span><span class="sxs-lookup"><span data-stu-id="52258-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="52258-225">我們將在下一節中討論最終的一致性。</span><span class="sxs-lookup"><span data-stu-id="52258-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="52258-226">這種分離使讀取和寫入能夠獨立縮放。</span><span class="sxs-lookup"><span data-stu-id="52258-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="52258-227">讀取操作使用針對查詢優化的架構，而寫入使用針對更新優化的架構。</span><span class="sxs-lookup"><span data-stu-id="52258-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="52258-228">讀取查詢與非正常化資料有關，而複雜的業務邏輯可以應用於寫入模型。</span><span class="sxs-lookup"><span data-stu-id="52258-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="52258-229">同樣，與公開讀取操作相比，您可能對寫入操作施加更嚴格的安全性。</span><span class="sxs-lookup"><span data-stu-id="52258-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="52258-230">實現 CQRS 可以提高雲原生服務的應用程式性能。</span><span class="sxs-lookup"><span data-stu-id="52258-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="52258-231">但是，它確實會導致更複雜的設計。</span><span class="sxs-lookup"><span data-stu-id="52258-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="52258-232">謹慎和戰略性地將此原則應用於雲原生應用程式中將從中獲益的部分。</span><span class="sxs-lookup"><span data-stu-id="52258-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="52258-233">有關 CQRS 的更多資訊，請參閱 Microsoft 書[.NET 微服務：容器化 .NET 應用程式的體系結構](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns)。</span><span class="sxs-lookup"><span data-stu-id="52258-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="52258-234">活動採購</span><span class="sxs-lookup"><span data-stu-id="52258-234">Event sourcing</span></span>

<span data-ttu-id="52258-235">優化大容量資料場景的另一種方法涉及[事件源](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)。</span><span class="sxs-lookup"><span data-stu-id="52258-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="52258-236">系統通常存儲資料實體的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="52258-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="52258-237">例如，如果使用者更改了電話號碼，則客戶記錄將更新為新號碼。</span><span class="sxs-lookup"><span data-stu-id="52258-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="52258-238">我們始終知道資料實體的目前狀態，但每個更新都覆蓋以前的狀態。</span><span class="sxs-lookup"><span data-stu-id="52258-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span>

<span data-ttu-id="52258-239">在大多數情況下，此模型工作正常。</span><span class="sxs-lookup"><span data-stu-id="52258-239">In most cases, this model works fine.</span></span> <span data-ttu-id="52258-240">但是，在高容量系統中，事務鎖定和頻繁更新操作造成的開銷可能會影響資料庫性能、回應能力和限制可伸縮性。</span><span class="sxs-lookup"><span data-stu-id="52258-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="52258-241">事件源採用不同的方法來捕獲資料。</span><span class="sxs-lookup"><span data-stu-id="52258-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="52258-242">影響資料的每個操作都會保存到事件存儲。</span><span class="sxs-lookup"><span data-stu-id="52258-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="52258-243">我們不是更新資料記錄的狀態，而是將每個更改追加到過去事件的順序清單 - 類似于會計的分類帳。</span><span class="sxs-lookup"><span data-stu-id="52258-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="52258-244">事件存儲成為資料的記錄系統。</span><span class="sxs-lookup"><span data-stu-id="52258-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="52258-245">它用於在微服務的邊界上下文中傳播各種具體化視圖。</span><span class="sxs-lookup"><span data-stu-id="52258-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="52258-246">圖 5.8 顯示了圖案。</span><span class="sxs-lookup"><span data-stu-id="52258-246">Figure 5.8 shows the pattern.</span></span>

![事件來源](./media/event-sourcing.png)

<span data-ttu-id="52258-248">**圖5-8**。</span><span class="sxs-lookup"><span data-stu-id="52258-248">**Figure 5-8**.</span></span> <span data-ttu-id="52258-249">事件來源</span><span class="sxs-lookup"><span data-stu-id="52258-249">Event Sourcing</span></span>

<span data-ttu-id="52258-250">在上圖中，請注意如何將使用者購物車的每個條目（藍色）追加到基礎事件存儲中。</span><span class="sxs-lookup"><span data-stu-id="52258-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="52258-251">在連續的具體化視圖中，系統通過重播與每個購物車關聯的所有事件來預測目前狀態。</span><span class="sxs-lookup"><span data-stu-id="52258-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="52258-252">然後，此視圖或讀取模型將暴露回 UI。</span><span class="sxs-lookup"><span data-stu-id="52258-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="52258-253">事件也可以與外部系統和應用程式集成，也可以查詢以確定實體的目前狀態。</span><span class="sxs-lookup"><span data-stu-id="52258-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="52258-254">使用此方法，您可以維護歷史記錄。</span><span class="sxs-lookup"><span data-stu-id="52258-254">With this approach, you maintain history.</span></span> <span data-ttu-id="52258-255">您不僅瞭解實體的目前狀態，還瞭解如何達到此狀態。</span><span class="sxs-lookup"><span data-stu-id="52258-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="52258-256">機械上講，事件源簡化了寫入模型。</span><span class="sxs-lookup"><span data-stu-id="52258-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="52258-257">沒有更新或刪除。</span><span class="sxs-lookup"><span data-stu-id="52258-257">There are no updates or deletes.</span></span> <span data-ttu-id="52258-258">將每個資料條目追加為不可變事件可最大限度地減少與關係資料庫關聯的爭用、鎖定和併發衝突。</span><span class="sxs-lookup"><span data-stu-id="52258-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="52258-259">使用具體化視圖模式構建讀取模型使您能夠將視圖與寫入模型分離，並選擇最佳資料存儲以優化應用程式 UI 的需求。</span><span class="sxs-lookup"><span data-stu-id="52258-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="52258-260">對於此模式，請考慮直接支援事件源的資料存儲。</span><span class="sxs-lookup"><span data-stu-id="52258-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="52258-261">Azure 宇宙 DB、蒙戈 DB、卡珊多拉、庫 DB 和 RavenDB 都是不錯的候選者。</span><span class="sxs-lookup"><span data-stu-id="52258-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="52258-262">與所有模式和技術一樣，在需要時戰略性地實施。</span><span class="sxs-lookup"><span data-stu-id="52258-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="52258-263">雖然事件源可以提供更高的性能和可擴充性，但它以犧牲複雜性和學習曲線為代價。</span><span class="sxs-lookup"><span data-stu-id="52258-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="52258-264">[上一個](service-mesh-communication-infrastructure.md)
>[下一個](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="52258-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
