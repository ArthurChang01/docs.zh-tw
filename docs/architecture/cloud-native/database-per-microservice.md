---
title: 具各微服務特性的資料庫
description: 對比單片和雲原生應用程式中的資料存儲。
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: c0c5611fa866d70f155e4bdad2eee1181b13c065
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141441"
---
# <a name="database-per-microservice"></a>具各微服務特性的資料庫

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

正如我們在本書中所看到的，雲原生方法改變了設計、部署和管理應用程式的方式。 它還會更改管理和存儲資料的方式。

圖 5-1 對比了差異。

![雲原生應用程式中的資料存儲](./media/distributed-data.png)

**圖5-1**. 雲原生應用程式中的資料管理

有經驗的開發人員將很容易識別圖 5-1 左側的體系結構。 在此*單片應用程式中*，業務服務元件在共用服務層中組合在一起，共用來自單個關係資料庫的資料。

在許多方面，單個資料庫使資料管理變得簡單。 跨多個表查詢資料非常簡單。 對資料所做的更改一起更新，或者它們全部回滾。 [ACID 交易](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties)保證強和即時的一致性。

為雲原生設計，我們採取了不同的方法。 在圖 5-1 的右側，請注意業務功能如何隔離到小型的獨立微服務中。 每個微服務封裝特定的業務功能及其自己的資料。 單片資料庫分解為具有許多較小資料庫的分散式資料模型，每個資料庫都與微服務對齊。 當煙霧清除時，我們出現了一個設計，它公開*了每個微服務的資料庫*。

## <a name="why"></a>原因為何？

每個微服務的此資料庫提供了許多好處，尤其是對於必須快速發展並支援大規模擴展的系統。 使用此模型...

- 域資料封裝在服務中
- 資料架構可以在不影響其他服務的情況下發展
- 每個資料存儲可以獨立擴展
- 一個服務中的資料存儲故障不會直接影響其他服務

隔離資料還使每個微服務能夠實現最適合其工作負載、存儲需求和讀/寫模式的資料存儲類型。 選項包括關係、文檔、鍵值，甚至基於圖形的資料存儲。

圖 5-2 介紹了雲本機系統中多面體持久性的原則。

![多格洛特資料持久性](./media/polyglot-data-persistence.png)

**圖5-2**. 多格洛特資料持久性

請注意，在上圖中，每個微服務如何支援不同類型的資料存儲。

- 產品目錄微服務使用關係資料庫來容納其基礎資料的豐富關聯式結構。
- 購物車微服務使用支援其簡單、鍵值資料存儲的分散式緩存。
- 訂購微服務既使用 NoSql 文檔資料庫進行寫入操作，也使用高度非正常化的金鑰/值存儲，以適應大量讀取操作。
  
雖然關係資料庫與具有複雜資料的微服務仍然相關，但 NoSQL 資料庫已獲得相當普及。 它們提供大規模和高可用性。 其無架構特性允許開發人員擺脫類型化資料類和 ORM 的體系結構，使更改變得昂貴且耗時。 本章後面我們將介紹 NoSQL 資料庫。

 雖然將資料封裝到單獨的微服務中可以提高敏捷性、性能和可擴充性，但它也帶來了許多挑戰。 在下一節中，我們將討論這些挑戰以及説明克服這些挑戰的模式和實踐。  

## <a name="cross-service-queries"></a>跨服務查詢

雖然微服務是獨立的，並且側重于特定的功能功能，如庫存、發貨或訂購，但它們通常需要與其他微服務集成。 通常，集成涉及一個微服務*查詢*另一個微服務的資料。 圖 5-3 顯示了方案。

![跨微服務查詢](./media/cross-service-query.png)

**圖5-3**. 跨微服務查詢

在上圖中，我們看到一個購物籃微服務，將商品添加到使用者的購物籃中。 雖然此微服務的資料存儲包含購物籃和行專案資料，但它不維護產品或定價資料。 相反，這些資料項目歸目錄所有，並定價微服務。 這帶來了一個問題。 購物籃微服務如何在使用者沒有產品或定價資料的情況下將產品添加到使用者的購物籃中？

第 4 章中討論的一個選項是從購物籃[直接調用目錄](service-to-service-communication.md#queries)和定價微服務。 但是，在第 4 章中，我們說過同步 HTTP 將*微服務調用在*一起，從而降低了它們的自主性並降低了它們的體系結構優勢。

我們還可以實現請求-答覆模式，為每個服務分別提供入站和出站佇列。 但是，此模式很複雜，需要管道來關聯請求和回應訊息。
雖然它確實分離後端微服務呼叫，但呼叫服務仍必須同步等待來電完成。 網路擁塞、瞬態故障或超載微服務，可能導致長時間運行甚至失敗的操作。

相反，一個被廣泛接受的刪除跨服務依賴項的模式是[具體化視圖模式](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)，如圖 5-4 所示。

![具體化視圖模式](./media/materialized-view-pattern.png)

**圖5-4**。 具體化視圖模式

使用此模式，您將本地資料表（稱為*讀取模型*）放在購物籃服務中。 此表包含產品和定價微服務所需的資料的非正常化副本。 將資料直接複製到購物籃微服務中，無需昂貴的跨服務呼叫。 使用服務本地資料，可以提高服務的回應時間和可靠性。 此外，擁有自己的資料副本使購物籃服務更具彈性。 如果目錄服務不可用，它不會直接影響購物籃服務。 購物籃可以繼續使用自己商店的資料進行操作。

這種方法的問題在於，您現在系統中有重複的資料。 但是，*在*雲本機系統中戰略性地複製資料是一種既定做法，不被視為反模式或不良做法。 請記住，*只有一個服務*可以擁有資料集並有權擁有資料集。 更新記錄系統時，您需要同步讀取模型。 同步通常通過具有[發佈/訂閱模式](service-to-service-communication.md#events)的非同步消息實現，如圖 5.4 所示。

## <a name="distributed-transactions"></a>分散式交易

雖然跨微服務查詢資料很困難，但跨多個微服務實現事務甚至更為複雜。 在不同微服務中保持獨立資料來源的資料一致性的內在挑戰怎麼強調也不為過。 雲原生應用程式中缺少分散式交易意味著您必須以程式設計方式管理分散式交易。 你從一個*即時一致性*的世界走向最終一*致性*的世界。

圖 5-5 顯示了問題。

![saga 模式中的事務](./media/saga-transaction-operation.png)

**圖5-5**. 跨微服務實現事務

在上圖中，五個獨立的微服務參與創建訂單的分散式交易。 每個微服務維護自己的資料存儲，並為其存儲實現本地事務。 要創建訂單，*每個*微服務的本地事務必須成功，或者*所有*事務都必須中止和回滾該操作。 雖然每個微服務都提供內置事務支援，但不支援跨所有五個服務的分散式交易來保持資料一致性。

相反，您必須*以程式設計方式*構造此分散式交易。

添加分散式交易支援的流行模式是 Saga 模式。 它通過將本地事務分組到一起以程式設計和按順序調用每個事務來實現。 如果任何本地事務失敗，Saga 將中止該操作並調用一組[補償事務](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)。 補償事務撤銷了上述本地事務所做的更改，並還原了資料一致性。 圖 5-6 顯示了 Saga 模式的失敗事務。

![回滾在傳奇模式](./media/saga-rollback-operation.png)

**圖5-6**. 復原交易

在上圖中，"*更新清單"* 操作在"清單"微服務中失敗。 Saga 調用一組補償事務（紅色）來調整庫存計數、取消付款和訂單，並將每個微服務的資料返回到一致狀態。

Saga 模式通常編排為一系列相關事件，或作為一組相關命令編排。 在第 4 章中，我們討論了作為協調的 saga 實現基礎的服務聚合器模式。 我們還討論了與 Azure 服務匯流排和 Azure 事件網格主題一起發生的事件，這些主題將成為精心編排的 saga 實現的基礎。

## <a name="high-volume-data"></a>大容量資料

大型雲原生應用程式通常支援大容量資料要求。 在這些情況下，傳統的資料存儲技術可能會導致瓶頸。 對於大規模部署的複雜系統，命令和查詢責任分離 （CQRS） 和事件源都可能提高應用程式性能。  

### <a name="cqrs"></a>CQRS

[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs)是一種體系結構模式，可説明最大限度地提高性能、可擴充性和安全性。 該模式將讀取資料的操作與寫入資料的工序分開。

對於正常方案，相同的實體模型和資料存儲庫*物件用於讀取*和寫入操作。

但是，高容量資料方案可以從用於讀取和寫入的單獨模型和資料表中獲益。 為了提高性能，讀取操作可以查詢資料的高度非正常化表示形式，以避免昂貴的重複表聯接和表鎖。 *寫入*操作（稱為*命令*）將針對資料完全正常化表示形式進行更新，以確保一致性。 然後，您需要實現一個機制，使兩個表示保持同步。通常，每當修改寫入表時，它都會發佈一個事件，將修改複製到讀取表。

圖 5-7 顯示了 CQRS 模式的實現。

![命令和查詢責任分離](./media/cqrs-implementation.png)

**圖5-7**. CQRS 實現

在上圖中，實現了單獨的命令和查詢模型。 每個資料寫入操作都保存到寫入存儲，然後傳播到讀取存儲。 密切關注資料傳播過程在[最終一致性](http://www.cloudcomputingpatterns.org/eventual_consistency/)原則下如何運作。 讀取模型最終與寫入模型同步，但過程可能有一些延遲。 我們將在下一節中討論最終的一致性。

這種分離使讀取和寫入能夠獨立縮放。 讀取操作使用針對查詢優化的架構，而寫入使用針對更新優化的架構。 讀取查詢與非正常化資料有關，而複雜的業務邏輯可以應用於寫入模型。 同樣，與公開讀取操作相比，您可能對寫入操作施加更嚴格的安全性。

實現 CQRS 可以提高雲原生服務的應用程式性能。 但是，它確實會導致更複雜的設計。 謹慎和戰略性地將此原則應用於雲原生應用程式中將從中獲益的部分。 有關 CQRS 的更多資訊，請參閱 Microsoft 書[.NET 微服務：容器化 .NET 應用程式的體系結構](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns)。

### <a name="event-sourcing"></a>活動採購

優化大容量資料場景的另一種方法涉及[事件源](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing)。

系統通常存儲資料實體的目前狀態。 例如，如果使用者更改了電話號碼，則客戶記錄將更新為新號碼。 我們始終知道資料實體的目前狀態，但每個更新都覆蓋以前的狀態。

在大多數情況下，此模型工作正常。 但是，在高容量系統中，事務鎖定和頻繁更新操作造成的開銷可能會影響資料庫性能、回應能力和限制可伸縮性。

事件源採用不同的方法來捕獲資料。 影響資料的每個操作都會保存到事件存儲。 我們不是更新資料記錄的狀態，而是將每個更改追加到過去事件的順序清單 - 類似于會計的分類帳。 事件存儲成為資料的記錄系統。 它用於在微服務的邊界上下文中傳播各種具體化視圖。 圖 5.8 顯示了圖案。

![事件來源](./media/event-sourcing.png)

**圖5-8**。 事件來源

在上圖中，請注意如何將使用者購物車的每個條目（藍色）追加到基礎事件存儲中。 在連續的具體化視圖中，系統通過重播與每個購物車關聯的所有事件來預測目前狀態。 然後，此視圖或讀取模型將暴露回 UI。 事件也可以與外部系統和應用程式集成，也可以查詢以確定實體的目前狀態。 使用此方法，您可以維護歷史記錄。 您不僅瞭解實體的目前狀態，還瞭解如何達到此狀態。

機械上講，事件源簡化了寫入模型。 沒有更新或刪除。 將每個資料條目追加為不可變事件可最大限度地減少與關係資料庫關聯的爭用、鎖定和併發衝突。 使用具體化視圖模式構建讀取模型使您能夠將視圖與寫入模型分離，並選擇最佳資料存儲以優化應用程式 UI 的需求。

對於此模式，請考慮直接支援事件源的資料存儲。 Azure 宇宙 DB、蒙戈 DB、卡珊多拉、庫 DB 和 RavenDB 都是不錯的候選者。

與所有模式和技術一樣，在需要時戰略性地實施。 雖然事件源可以提供更高的性能和可擴充性，但它以犧牲複雜性和學習曲線為代價。

>[!div class="step-by-step"]
>[上一個](service-mesh-communication-infrastructure.md)
>[下一個](relational-vs-nosql-data.md)
