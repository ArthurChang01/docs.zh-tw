---
title: 前端用戶端通訊
description: 瞭解前端用戶端如何與雲端本機系統通訊
author: robvet
ms.date: 09/08/2019
ms.openlocfilehash: af26873381509df7807db6ecb37a7d73669adb37
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/09/2020
ms.locfileid: "80989073"
---
# <a name="front-end-client-communication"></a><span data-ttu-id="af452-103">前端用戶端通訊</span><span class="sxs-lookup"><span data-stu-id="af452-103">Front-end client communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="af452-104">在雲端本機系統中,前端用戶端(行動、Web和桌面應用程式)需要通訊通道才能與獨立的後端微服務進行互動。</span><span class="sxs-lookup"><span data-stu-id="af452-104">In a cloud-native system, front-end clients (mobile, web, and desktop applications) require a communication channel to interact with independent back-end microservices.</span></span>  

<span data-ttu-id="af452-105">有哪些選擇?</span><span class="sxs-lookup"><span data-stu-id="af452-105">What are the options?</span></span>

<span data-ttu-id="af452-106">為了簡單化,前端用戶端可以直接與後端微服務*通信*,如圖 4-2 所示。</span><span class="sxs-lookup"><span data-stu-id="af452-106">To keep things simple, a front-end client could *directly communicate* with the back-end microservices, shown in Figure 4-2.</span></span>

![將用戶端直接連線到服務通訊](./media/direct-client-to-service-communication.png)

<span data-ttu-id="af452-108">**圖 4-2。**</span><span class="sxs-lookup"><span data-stu-id="af452-108">**Figure 4-2.**</span></span> <span data-ttu-id="af452-109">將用戶端直接連線到服務通訊</span><span class="sxs-lookup"><span data-stu-id="af452-109">Direct client to service communication</span></span>

<span data-ttu-id="af452-110">使用此方法,每個微服務都有一個公共終結點,前端用戶端可以訪問該終結點。</span><span class="sxs-lookup"><span data-stu-id="af452-110">With this approach, each microservice has a public endpoint that is accessible by front-end clients.</span></span> <span data-ttu-id="af452-111">在生產環境中,您將負載均衡器放在微服務前面,按比例路由流量。</span><span class="sxs-lookup"><span data-stu-id="af452-111">In a production environment, you'd place a load balancer in front of the microservices, routing traffic proportionately.</span></span>

<span data-ttu-id="af452-112">雖然易於實現,但直接用戶端通信僅對簡單的微服務應用程式是可以接受的。</span><span class="sxs-lookup"><span data-stu-id="af452-112">While simple to implement, direct client communication would be acceptable only for simple microservice applications.</span></span> <span data-ttu-id="af452-113">這種模式緊密耦合前端客戶的核心後端服務,為許多問題打開了大門,包括:</span><span class="sxs-lookup"><span data-stu-id="af452-113">This pattern tightly couples front-end clients to core back-end services, opening the door for a number of problems, including:</span></span>

- <span data-ttu-id="af452-114">用戶端對後端服務重構的易感性。</span><span class="sxs-lookup"><span data-stu-id="af452-114">Client susceptibility to back-end service refactoring.</span></span>
- <span data-ttu-id="af452-115">核心後端服務會直接暴露出更大的攻擊面。</span><span class="sxs-lookup"><span data-stu-id="af452-115">A wider attack surface as core back-end services are directly exposed.</span></span>
- <span data-ttu-id="af452-116">重複每個微服務之間的交叉問題。</span><span class="sxs-lookup"><span data-stu-id="af452-116">Duplication of cross-cutting concerns across each microservice.</span></span>
- <span data-ttu-id="af452-117">過於複雜的客戶端代碼 - 客戶端必須跟蹤多個終結點,並以彈性方式處理故障。</span><span class="sxs-lookup"><span data-stu-id="af452-117">Overly complex client code - clients must keep track of multiple endpoints and handle failures in a resilient way.</span></span>

<span data-ttu-id="af452-118">相反,一個被廣泛接受的雲端設計模式是在前端應用程式和後端服務之間實現[API 閘道服務](../microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md)。</span><span class="sxs-lookup"><span data-stu-id="af452-118">Instead, a widely accepted cloud design pattern is to implement an [API Gateway Service](../microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern.md) between the front-end applications and back-end services.</span></span> <span data-ttu-id="af452-119">圖案如圖 4-3 所示。</span><span class="sxs-lookup"><span data-stu-id="af452-119">The pattern is shown in Figure 4-3.</span></span>

![API 閘道模式](./media/api-gateway-pattern.png)

<span data-ttu-id="af452-121">**圖 4-3。**</span><span class="sxs-lookup"><span data-stu-id="af452-121">**Figure 4-3.**</span></span> <span data-ttu-id="af452-122">API 閘道模式</span><span class="sxs-lookup"><span data-stu-id="af452-122">API gateway pattern</span></span>

<span data-ttu-id="af452-123">在上圖中,請注意 API 閘道服務如何抽象後端核心微服務。</span><span class="sxs-lookup"><span data-stu-id="af452-123">In the previous figure, note how the API Gateway service abstracts the back-end core microservices.</span></span> <span data-ttu-id="af452-124">作為 Web API 實現,它充當*反向代理*,將傳入的流量路由到內部微服務。</span><span class="sxs-lookup"><span data-stu-id="af452-124">Implemented as a web API, it acts as a *reverse proxy*, routing incoming traffic to the internal microservices.</span></span>

<span data-ttu-id="af452-125">閘道將客戶端與內部服務分區和重構隔離。</span><span class="sxs-lookup"><span data-stu-id="af452-125">The gateway insulates the client from internal service partitioning and refactoring.</span></span> <span data-ttu-id="af452-126">如果更改後端服務,則可以在不中斷客戶端的情況下將其用於閘道。</span><span class="sxs-lookup"><span data-stu-id="af452-126">If you change a back-end service, you accommodate for it in the gateway without breaking the client.</span></span> <span data-ttu-id="af452-127">這也是您處理交叉問題(如身份、緩存、彈性、計量和限制)的第一道防線。</span><span class="sxs-lookup"><span data-stu-id="af452-127">It's also your first line of defense for cross-cutting concerns, such as identity, caching, resiliency, metering, and throttling.</span></span> <span data-ttu-id="af452-128">其中許多交叉問題可以從後端核心服務卸載到網關,從而簡化了後端服務。</span><span class="sxs-lookup"><span data-stu-id="af452-128">Many of these cross-cutting concerns can be off-loaded from the back-end core services to the gateway, simplifying the back-end services.</span></span>

<span data-ttu-id="af452-129">必須注意保持 API 閘道簡單快捷。</span><span class="sxs-lookup"><span data-stu-id="af452-129">Care must be taken to keep the API Gateway simple and fast.</span></span> <span data-ttu-id="af452-130">通常,業務邏輯會遠離閘道。</span><span class="sxs-lookup"><span data-stu-id="af452-130">Typically, business logic is kept out of the gateway.</span></span> <span data-ttu-id="af452-131">複雜的閘道有可能成為瓶頸,最終成為一個整體。</span><span class="sxs-lookup"><span data-stu-id="af452-131">A complex gateway risks becoming a bottleneck and eventually a monolith itself.</span></span> <span data-ttu-id="af452-132">較大的系統通常公開按用戶端類型(移動、Web、桌面)或後端功能劃分的多個 API 閘道。</span><span class="sxs-lookup"><span data-stu-id="af452-132">Larger systems often expose multiple API Gateways segmented by client type (mobile, web, desktop) or back-end functionality.</span></span> <span data-ttu-id="af452-133">[前端後端](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends)模式為實現多個閘道提供了方向。</span><span class="sxs-lookup"><span data-stu-id="af452-133">The [Backend for Frontends](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) pattern provides direction for implementing multiple gateways.</span></span> <span data-ttu-id="af452-134">圖案如圖 4-4 所示。</span><span class="sxs-lookup"><span data-stu-id="af452-134">The pattern is shown in Figure 4-4.</span></span>

![API 閘道模式](./media/backend-for-frontend-pattern.png)

<span data-ttu-id="af452-136">**圖 4-4。**</span><span class="sxs-lookup"><span data-stu-id="af452-136">**Figure 4-4.**</span></span> <span data-ttu-id="af452-137">前端圖案的後端介面</span><span class="sxs-lookup"><span data-stu-id="af452-137">Backend for frontend pattern</span></span>

<span data-ttu-id="af452-138">請注意,在上圖中,如何根據用戶端類型(Web、移動或桌面應用)將傳入流量發送到特定 API 閘道。</span><span class="sxs-lookup"><span data-stu-id="af452-138">Note in the previous figure how incoming traffic is sent to a specific API gateway - based upon client type: web, mobile, or desktop app.</span></span> <span data-ttu-id="af452-139">此方法有意義,因為每個設備的功能因外形、性能和顯示限制而異。</span><span class="sxs-lookup"><span data-stu-id="af452-139">This approach makes sense as the capabilities of each device differ significantly across form factor, performance, and display limitations.</span></span> <span data-ttu-id="af452-140">通常,與瀏覽器或桌面應用程式相比,移動應用程式公開的功能較少。</span><span class="sxs-lookup"><span data-stu-id="af452-140">Typically mobile applications expose less functionality than a browser or desktop applications.</span></span> <span data-ttu-id="af452-141">每個閘道都可以進行優化,以匹配相應設備的功能和功能。</span><span class="sxs-lookup"><span data-stu-id="af452-141">Each gateway can be optimized to match the capabilities and functionality of the corresponding device.</span></span>

<span data-ttu-id="af452-142">首先,您可以構建自己的 API 閘道服務。</span><span class="sxs-lookup"><span data-stu-id="af452-142">To start, you could build your own API Gateway service.</span></span> <span data-ttu-id="af452-143">快速搜索 GitHub 將提供許多範例。</span><span class="sxs-lookup"><span data-stu-id="af452-143">A quick search of GitHub will provide many examples.</span></span> <span data-ttu-id="af452-144">但是,有幾個框架和商業閘道產品可用。</span><span class="sxs-lookup"><span data-stu-id="af452-144">However, there are several frameworks and commercial gateway products available.</span></span>

## <a name="ocelot-gateway"></a><span data-ttu-id="af452-145">Ocelot 閘道</span><span class="sxs-lookup"><span data-stu-id="af452-145">Ocelot Gateway</span></span>

<span data-ttu-id="af452-146">對於簡單的 .NET 雲本機應用程式,您可以考慮[Ocelot 閘道](https://github.com/ThreeMammals/Ocelot)。</span><span class="sxs-lookup"><span data-stu-id="af452-146">For simple .NET cloud-native applications, you might consider the [Ocelot Gateway](https://github.com/ThreeMammals/Ocelot).</span></span> <span data-ttu-id="af452-147">Ocelot 是為 .NET 微服務創建的開源 API 閘道,需要統一的入口點才能進入其系統。</span><span class="sxs-lookup"><span data-stu-id="af452-147">Ocelot is an Open Source API Gateway created for .NET microservices that require a unified point of entry into their system.</span></span> <span data-ttu-id="af452-148">它重量輕、速度快、可擴展。</span><span class="sxs-lookup"><span data-stu-id="af452-148">It's lightweight, fast, scalable.</span></span>

<span data-ttu-id="af452-149">與任何 API 閘道一樣,其主要功能是將傳入的 HTTP 請求轉發到下游服務。</span><span class="sxs-lookup"><span data-stu-id="af452-149">Like any API Gateway, its primary functionality is to forward incoming HTTP requests to downstream services.</span></span> <span data-ttu-id="af452-150">此外,它還支援可在 .NET Core 中間件管道中配置的各種功能。</span><span class="sxs-lookup"><span data-stu-id="af452-150">Additionally, it supports a wide variety of capabilities that are configurable in a .NET Core middleware pipeline.</span></span> <span data-ttu-id="af452-151">其功能集顯示在下表中。</span><span class="sxs-lookup"><span data-stu-id="af452-151">Its feature set is presented in following table.</span></span>

|<span data-ttu-id="af452-152">Ocelot 功能</span><span class="sxs-lookup"><span data-stu-id="af452-152">Ocelot Features</span></span>  | |
| :-------- | :-------- |
| <span data-ttu-id="af452-153">路由</span><span class="sxs-lookup"><span data-stu-id="af452-153">Routing</span></span> | <span data-ttu-id="af452-154">驗證</span><span class="sxs-lookup"><span data-stu-id="af452-154">Authentication</span></span> |
| <span data-ttu-id="af452-155">要求集合模式</span><span class="sxs-lookup"><span data-stu-id="af452-155">Request Aggregation</span></span> | <span data-ttu-id="af452-156">授權</span><span class="sxs-lookup"><span data-stu-id="af452-156">Authorization</span></span> |
| <span data-ttu-id="af452-157">服務發現(與領事和尤里卡)</span><span class="sxs-lookup"><span data-stu-id="af452-157">Service Discovery (with Consul and Eureka)</span></span> | <span data-ttu-id="af452-158">節流</span><span class="sxs-lookup"><span data-stu-id="af452-158">Throttling</span></span> |
| <span data-ttu-id="af452-159">負載平衡</span><span class="sxs-lookup"><span data-stu-id="af452-159">Load Balancing</span></span> | <span data-ttu-id="af452-160">記錄記錄、追蹤</span><span class="sxs-lookup"><span data-stu-id="af452-160">Logging, Tracing</span></span> |
| <span data-ttu-id="af452-161">Caching</span><span class="sxs-lookup"><span data-stu-id="af452-161">Caching</span></span> | <span data-ttu-id="af452-162">標題/查詢字串轉換</span><span class="sxs-lookup"><span data-stu-id="af452-162">Headers/Query String Transformation</span></span> |
| <span data-ttu-id="af452-163">關聯傳遞</span><span class="sxs-lookup"><span data-stu-id="af452-163">Correlation Pass-Through</span></span> | <span data-ttu-id="af452-164">自訂中間件</span><span class="sxs-lookup"><span data-stu-id="af452-164">Custom Middleware</span></span> |
| <span data-ttu-id="af452-165">服務品質</span><span class="sxs-lookup"><span data-stu-id="af452-165">Quality of Service</span></span> | <span data-ttu-id="af452-166">重試原則</span><span class="sxs-lookup"><span data-stu-id="af452-166">Retry Policies</span></span> |

<span data-ttu-id="af452-167">每個 Ocelot 閘道指定 JSON 設定檔中的上游和下游位址和可配置功能。</span><span class="sxs-lookup"><span data-stu-id="af452-167">Each Ocelot gateway specifies the upstream and downstream addresses and configurable features in a JSON configuration file.</span></span> <span data-ttu-id="af452-168">用戶端向 Ocelot 閘道發送 HTTP 請求。</span><span class="sxs-lookup"><span data-stu-id="af452-168">The client sends an HTTP request to the Ocelot gateway.</span></span> <span data-ttu-id="af452-169">收到后,Ocelot 會通過其管道將 HttpRequest 物件傳遞到其配置指定的狀態。</span><span class="sxs-lookup"><span data-stu-id="af452-169">Once received, Ocelot passes the HttpRequest object through its pipeline manipulating it into the state specified by its configuration.</span></span> <span data-ttu-id="af452-170">在導管結束時,Ocelot會創建一個新的 HTTPResponseObject 並將其傳遞到下游服務。</span><span class="sxs-lookup"><span data-stu-id="af452-170">At the end of pipeline, Ocelot creates a new HTTPResponseObject and passes it to the downstream service.</span></span> <span data-ttu-id="af452-171">對於回應,Ocelot將反轉管道,將回應發送回用戶端。</span><span class="sxs-lookup"><span data-stu-id="af452-171">For the response, Ocelot reverses the pipeline, sending the response back to client.</span></span>

<span data-ttu-id="af452-172">Ocelot 可作為 NuGet 套件提供。</span><span class="sxs-lookup"><span data-stu-id="af452-172">Ocelot is available as a NuGet package.</span></span> <span data-ttu-id="af452-173">它針對 NET 標準 2.0,使其與 .NET Core 2.0+ 和 .NET 框架 4.6.1+ 執行時相容。</span><span class="sxs-lookup"><span data-stu-id="af452-173">It targets the NET Standard 2.0, making it compatible with both .NET Core 2.0+ and .NET Framework 4.6.1+ runtimes.</span></span> <span data-ttu-id="af452-174">Ocelot 與任何講 HTTP 並在 .NET Core 支援的平台上運行的函數集成:Linux、macOS 和 Windows。</span><span class="sxs-lookup"><span data-stu-id="af452-174">Ocelot integrates with anything that speaks HTTP and runs on the platforms which .NET Core supports: Linux, macOS, and Windows.</span></span> <span data-ttu-id="af452-175">Ocelot 是可擴展的,支援許多現代平臺,包括 Docker 容器、Azure 庫伯奈斯服務或其他公共雲。</span><span class="sxs-lookup"><span data-stu-id="af452-175">Ocelot is extensible and supports many modern platforms, including Docker containers, Azure Kubernetes Services, or other public clouds.</span></span>  <span data-ttu-id="af452-176">Ocelot 與開源套餐集成,如[領事](https://www.consul.io)[、GraphQL](https://graphql.org)和 Netflix 的[Eureka。](https://github.com/Netflix/eureka)</span><span class="sxs-lookup"><span data-stu-id="af452-176">Ocelot integrates with open-source packages like [Consul](https://www.consul.io), [GraphQL](https://graphql.org), and Netflix's [Eureka](https://github.com/Netflix/eureka).</span></span>

<span data-ttu-id="af452-177">請考慮 Ocelot 的簡單雲原生應用程式,這些應用程式不需要商業 API 閘道的豐富功能集。</span><span class="sxs-lookup"><span data-stu-id="af452-177">Consider Ocelot for simple cloud-native applications that don't require the rich feature-set of a commercial API gateway.</span></span>

## <a name="azure-application-gateway"></a><span data-ttu-id="af452-178">Azure 應用程式閘道</span><span class="sxs-lookup"><span data-stu-id="af452-178">Azure Application Gateway</span></span>

<span data-ttu-id="af452-179">對於簡單的閘道要求,可以考慮[Azure 應用程式閘道](https://docs.microsoft.com/azure/application-gateway/overview)。</span><span class="sxs-lookup"><span data-stu-id="af452-179">For simple gateway requirements, you may consider [Azure Application Gateway](https://docs.microsoft.com/azure/application-gateway/overview).</span></span> <span data-ttu-id="af452-180">它作為 Azure [PaaS 服務](https://azure.microsoft.com/overview/what-is-paas/)提供,它包括基本的閘道功能,如 URL 路由、SSL 終止和 Web 應用程式防火牆。</span><span class="sxs-lookup"><span data-stu-id="af452-180">Available as an Azure [PaaS service](https://azure.microsoft.com/overview/what-is-paas/), it includes basic gateway features such as URL routing, SSL termination, and a Web Application Firewall.</span></span> <span data-ttu-id="af452-181">該服務支援[第 7 層負載平衡](https://www.nginx.com/resources/glossary/layer-7-load-balancing/)功能。</span><span class="sxs-lookup"><span data-stu-id="af452-181">The service supports [Layer-7 load balancing](https://www.nginx.com/resources/glossary/layer-7-load-balancing/) capabilities.</span></span> <span data-ttu-id="af452-182">使用第 7 層,您可以基於 HTTP 消息的實際內容路由請求,而不僅僅是低級 TCP 網路數據包。</span><span class="sxs-lookup"><span data-stu-id="af452-182">With Layer 7, you can route requests based on the actual content of an HTTP message, not just low-level TCP network packets.</span></span>

<span data-ttu-id="af452-183">在這本書中,我們宣傳在[庫伯內斯](https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html)託管雲原生系統。</span><span class="sxs-lookup"><span data-stu-id="af452-183">Throughout this book, we evangelize hosting cloud-native systems in [Kubernetes](https://www.infoworld.com/article/3268073/what-is-kubernetes-your-next-application-platform.html).</span></span> <span data-ttu-id="af452-184">Kubernetes 是容器協調器,可自動處理容器化工作負載的部署、擴展和操作問題。</span><span class="sxs-lookup"><span data-stu-id="af452-184">A container orchestrator, Kubernetes automates the deployment, scaling, and operational concerns of containerized workloads.</span></span> <span data-ttu-id="af452-185">Azure 應用程式閘道可以配置為[Azure 庫伯奈斯服務群集的](https://azure.microsoft.com/services/kubernetes-service/)API 閘道。</span><span class="sxs-lookup"><span data-stu-id="af452-185">Azure Application Gateway can be configured as an API gateway for [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/) cluster.</span></span>

<span data-ttu-id="af452-186">應用程式[閘道閘道控制器](https://azure.github.io/application-gateway-kubernetes-ingress/)使 Azure 應用程式閘道能夠直接與[Azure 庫伯奈斯服務](https://azure.microsoft.com/services/kubernetes-service/)配合使用。</span><span class="sxs-lookup"><span data-stu-id="af452-186">The [Application Gateway Ingress Controller](https://azure.github.io/application-gateway-kubernetes-ingress/) enables Azure Application Gateway to work directly with [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="af452-187">圖 4.5 顯示了體系結構。</span><span class="sxs-lookup"><span data-stu-id="af452-187">Figure 4.5 shows the architecture.</span></span>

![應用程式閘道輸入控制器](./media/application-gateway-ingress-controller.png)

<span data-ttu-id="af452-189">**圖 4-5。**</span><span class="sxs-lookup"><span data-stu-id="af452-189">**Figure 4-5.**</span></span> <span data-ttu-id="af452-190">應用程式閘道輸入控制器</span><span class="sxs-lookup"><span data-stu-id="af452-190">Application Gateway Ingress Controller</span></span>

<span data-ttu-id="af452-191">Kubernets 包括一個內建功能,支援 HTTP (7 級) 負載平衡,稱為[入口](https://kubernetes.io/docs/concepts/services-networking/ingress/)。</span><span class="sxs-lookup"><span data-stu-id="af452-191">Kubernetes includes a built-in feature that supports HTTP (Level 7) load balancing, called [Ingress](https://kubernetes.io/docs/concepts/services-networking/ingress/).</span></span> <span data-ttu-id="af452-192">入口定義了一組規則,用於如何將 AKS 內的微服務實例暴露給外部世界。</span><span class="sxs-lookup"><span data-stu-id="af452-192">Ingress defines a set of rules for how microservice instances inside AKS can be exposed to the outside world.</span></span> <span data-ttu-id="af452-193">在上一個映射中,入口控制器解釋為群集配置的入口規則,並自動配置 Azure 應用程式閘道。</span><span class="sxs-lookup"><span data-stu-id="af452-193">In the previous image, the ingress controller interprets the ingress rules configured for the cluster and automatically configures the Azure Application Gateway.</span></span> <span data-ttu-id="af452-194">根據這些規則,應用程式閘道將流量路由到在 AKS 內運行的微服務。</span><span class="sxs-lookup"><span data-stu-id="af452-194">Based on those rules, the Application Gateway routes traffic to microservices running inside AKS.</span></span> <span data-ttu-id="af452-195">入口控制器偵聽入口規則的更改,並相應更改 Azure 應用程式閘道。</span><span class="sxs-lookup"><span data-stu-id="af452-195">The ingress controller listens for changes to ingress rules and makes the appropriate changes to the Azure Application Gateway.</span></span>

## <a name="azure-api-management"></a><span data-ttu-id="af452-196">Azure API 管理</span><span class="sxs-lookup"><span data-stu-id="af452-196">Azure API Management</span></span>

<span data-ttu-id="af452-197">對於中度到大規模雲本機系統,可以考慮 Azure [API 管理](https://azure.microsoft.com/services/api-management/)。</span><span class="sxs-lookup"><span data-stu-id="af452-197">For moderate to large-scale cloud-native systems, you may consider [Azure API Management](https://azure.microsoft.com/services/api-management/).</span></span> <span data-ttu-id="af452-198">它是一種基於雲的服務,不僅可滿足您的 API 閘道需求,而且還提供功能齊全的開發人員和管理體驗。</span><span class="sxs-lookup"><span data-stu-id="af452-198">It's a cloud-based service that not only solves your API Gateway needs, but provides a full-featured developer and administrative experience.</span></span> <span data-ttu-id="af452-199">API 管理如圖 4-6 所示。</span><span class="sxs-lookup"><span data-stu-id="af452-199">API Management is shown in Figure 4-6.</span></span>

![Azure API 管理](./media/azure-api-management.png)

<span data-ttu-id="af452-201">**圖 4-6。**</span><span class="sxs-lookup"><span data-stu-id="af452-201">**Figure 4-6.**</span></span> <span data-ttu-id="af452-202">Azure API 管理</span><span class="sxs-lookup"><span data-stu-id="af452-202">Azure API Management</span></span>

<span data-ttu-id="af452-203">首先,API 管理公開了允許基於可配置規則和策略對後端服務的受控訪問的閘道伺服器。</span><span class="sxs-lookup"><span data-stu-id="af452-203">To start, API Management exposes a gateway server that allows controlled access to back-end services based upon configurable rules and policies.</span></span> <span data-ttu-id="af452-204">這些服務可以位於 Azure 雲、上置數據中心或其他公共雲中。</span><span class="sxs-lookup"><span data-stu-id="af452-204">These services can be in the Azure cloud, your on-prem data center, or other public clouds.</span></span> <span data-ttu-id="af452-205">API 金鑰和 JWT 權杖確定誰可以執行哪些操作。</span><span class="sxs-lookup"><span data-stu-id="af452-205">API keys and JWT tokens determine who can do what.</span></span> <span data-ttu-id="af452-206">出於分析目的,記錄所有流量。</span><span class="sxs-lookup"><span data-stu-id="af452-206">All traffic is logged for analytical purposes.</span></span>

<span data-ttu-id="af452-207">對於開發人員,API 管理提供了一個開發人員門戶,提供對用於調用服務、文檔和示例代碼的訪問。</span><span class="sxs-lookup"><span data-stu-id="af452-207">For developers, API Management offers a developer portal that provides access to services, documentation, and sample code for invoking them.</span></span> <span data-ttu-id="af452-208">開發人員可以使用 Swagger/Open API 來檢查服務終結點並分析它們的使用方式。</span><span class="sxs-lookup"><span data-stu-id="af452-208">Developers can use Swagger/Open API to inspect service endpoints and analyze their usage.</span></span> <span data-ttu-id="af452-209">該服務適用於主要開發平臺:.NET、JAVA、Golang 等。</span><span class="sxs-lookup"><span data-stu-id="af452-209">The service works across the major development platforms: .NET, Java, Golang, and more.</span></span>

<span data-ttu-id="af452-210">發佈者門戶公開管理儀錶板,管理員在儀錶板中公開 API 並管理其行為。</span><span class="sxs-lookup"><span data-stu-id="af452-210">The publisher portal exposes a management dashboard where administrators expose APIs and manage their behavior.</span></span> <span data-ttu-id="af452-211">可以授予服務訪問許可權、監視服務運行狀況以及收集服務遙測。</span><span class="sxs-lookup"><span data-stu-id="af452-211">Service access can be granted, service health monitored, and service telemetry gathered.</span></span> <span data-ttu-id="af452-212">管理員將*策略*應用於每個終結點以影響行為。</span><span class="sxs-lookup"><span data-stu-id="af452-212">Administrators apply *policies* to each endpoint to affect behavior.</span></span> <span data-ttu-id="af452-213">[策略](https://docs.microsoft.com/azure/api-management/api-management-howto-policies)是預先構建的語句,每個服務調用按順序執行。</span><span class="sxs-lookup"><span data-stu-id="af452-213">[Policies](https://docs.microsoft.com/azure/api-management/api-management-howto-policies) are pre-built statements that execute sequentially for each service call.</span></span>  <span data-ttu-id="af452-214">策略配置為入站呼叫、出站呼叫或在錯誤時調用。</span><span class="sxs-lookup"><span data-stu-id="af452-214">Policies are configured for an inbound call, outbound call, or invoked upon an error.</span></span> <span data-ttu-id="af452-215">策略可以應用於不同的服務範圍,以便在組合策略時啟用確定性排序。</span><span class="sxs-lookup"><span data-stu-id="af452-215">Policies can be applied at different service scopes as to enable deterministic ordering when combining policies.</span></span> <span data-ttu-id="af452-216">該產品附帶了大量預先建[構的策略](https://docs.microsoft.com/azure/api-management/api-management-policies)。</span><span class="sxs-lookup"><span data-stu-id="af452-216">The product ships with a large number of prebuilt [policies](https://docs.microsoft.com/azure/api-management/api-management-policies).</span></span>

<span data-ttu-id="af452-217">以下是策略如何影響雲原生服務的行為的範例:</span><span class="sxs-lookup"><span data-stu-id="af452-217">Here are examples of how policies can affect the behavior of your cloud-native services:</span></span>  

- <span data-ttu-id="af452-218">限制服務訪問。</span><span class="sxs-lookup"><span data-stu-id="af452-218">Restrict service access.</span></span>
- <span data-ttu-id="af452-219">強制實施身份驗證。</span><span class="sxs-lookup"><span data-stu-id="af452-219">Enforce authentication.</span></span>  
- <span data-ttu-id="af452-220">如有必要,從單個源進行節流呼叫。</span><span class="sxs-lookup"><span data-stu-id="af452-220">Throttle calls from a single source, if necessary.</span></span>
- <span data-ttu-id="af452-221">啟用快取。</span><span class="sxs-lookup"><span data-stu-id="af452-221">Enable caching.</span></span>
- <span data-ttu-id="af452-222">阻止來自特定 IP 位址的呼叫。</span><span class="sxs-lookup"><span data-stu-id="af452-222">Block calls from specific IP addresses.</span></span>
- <span data-ttu-id="af452-223">控制服務流。</span><span class="sxs-lookup"><span data-stu-id="af452-223">Control the flow of the service.</span></span>
- <span data-ttu-id="af452-224">將請求從 SOAP 轉換為 REST 或在不同的資料格式(如從 XML 轉換為 JSON)之間。</span><span class="sxs-lookup"><span data-stu-id="af452-224">Convert requests from SOAP to REST or between different data formats, such as from XML to JSON.</span></span>

<span data-ttu-id="af452-225">Azure API 管理可以公開託管在雲或資料中心的任何地方的後端服務。</span><span class="sxs-lookup"><span data-stu-id="af452-225">Azure API Management can expose back-end services that are hosted anywhere – in the cloud or your data center.</span></span> <span data-ttu-id="af452-226">對於可能在雲端本機系統中公開的舊式服務,它同時支援 REST 和 SOAP API。</span><span class="sxs-lookup"><span data-stu-id="af452-226">For legacy services that you may expose in your cloud-native systems, it supports both REST and SOAP APIs.</span></span> <span data-ttu-id="af452-227">甚至其他 Azure 服務也可透過 API 管理公開。</span><span class="sxs-lookup"><span data-stu-id="af452-227">Even other Azure services can be exposed through API Management.</span></span> <span data-ttu-id="af452-228">您可以將託管 API 放在 Azure 支援服務(如[Azure 服務總線](https://azure.microsoft.com/services/service-bus/)或[Azure 邏輯應用](https://azure.microsoft.com/services/logic-apps/))之上。</span><span class="sxs-lookup"><span data-stu-id="af452-228">You could place a managed API on top of an Azure backing service like [Azure Service Bus](https://azure.microsoft.com/services/service-bus/) or [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/).</span></span> <span data-ttu-id="af452-229">Azure API 管理不包括內置負載平衡支援,應與負載平衡服務結合使用。</span><span class="sxs-lookup"><span data-stu-id="af452-229">Azure API Management doesn't include built-in load-balancing support and should be used in conjunction with a load-balancing service.</span></span>

<span data-ttu-id="af452-230">Azure API 管理會在[不同的層中](https://azure.microsoft.com/pricing/details/api-management/):</span><span class="sxs-lookup"><span data-stu-id="af452-230">Azure API Management is available across [four different tiers](https://azure.microsoft.com/pricing/details/api-management/):</span></span>

- <span data-ttu-id="af452-231">開發人員</span><span class="sxs-lookup"><span data-stu-id="af452-231">Developer</span></span>
- <span data-ttu-id="af452-232">基本</span><span class="sxs-lookup"><span data-stu-id="af452-232">Basic</span></span>
- <span data-ttu-id="af452-233">標準</span><span class="sxs-lookup"><span data-stu-id="af452-233">Standard</span></span>
- <span data-ttu-id="af452-234">Premium</span><span class="sxs-lookup"><span data-stu-id="af452-234">Premium</span></span>

<span data-ttu-id="af452-235">開發人員層用於非生產工作負載和評估。</span><span class="sxs-lookup"><span data-stu-id="af452-235">The Developer tier is meant for non-production workloads and evaluation.</span></span> <span data-ttu-id="af452-236">其他層提供更高的功率、功能和更高的服務級別協定 (SL)。</span><span class="sxs-lookup"><span data-stu-id="af452-236">The other tiers offer progressively more power, features, and higher service level agreements (SLAs).</span></span> <span data-ttu-id="af452-237">進階層提供[Azure 虛擬網路和](https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview)[多區域支援](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region)。</span><span class="sxs-lookup"><span data-stu-id="af452-237">The Premium tier provides [Azure Virtual Network](https://docs.microsoft.com/azure/virtual-network/virtual-networks-overview) and [multi-region support](https://docs.microsoft.com/azure/api-management/api-management-howto-deploy-multi-region).</span></span> <span data-ttu-id="af452-238">所有層每小時都有固定價格。</span><span class="sxs-lookup"><span data-stu-id="af452-238">All tiers have a fixed price per hour.</span></span>

<span data-ttu-id="af452-239">最近,Microsoft 發佈了 Azure [API 管理的 API 管理無伺服器層](https://azure.microsoft.com/blog/announcing-azure-api-management-for-serverless-architectures/)。</span><span class="sxs-lookup"><span data-stu-id="af452-239">Recently, Microsoft announced a [API Management serverless tier](https://azure.microsoft.com/blog/announcing-azure-api-management-for-serverless-architectures/) for Azure API Management.</span></span> <span data-ttu-id="af452-240">該服務稱為*消耗定價層*,是圍繞無伺服器計算模型設計的 API 管理的變體。</span><span class="sxs-lookup"><span data-stu-id="af452-240">Referred to as the *consumption pricing tier*, the service is a variant of API Management designed around the serverless computing model.</span></span> <span data-ttu-id="af452-241">與之前顯示的「預分配」定價層不同,消費層提供即時預配和按行動付費定價。</span><span class="sxs-lookup"><span data-stu-id="af452-241">Unlike the "pre-allocated" pricing tiers previously shown, the consumption tier provides  instant provisioning and pay-per-action pricing.</span></span>

<span data-ttu-id="af452-242">它為以下用例開啟 API 閘道功能:</span><span class="sxs-lookup"><span data-stu-id="af452-242">It enables API Gateway features for the following use cases:</span></span>

- <span data-ttu-id="af452-243">使用無伺服器技術(如 Azure[函數](https://docs.microsoft.com/azure/azure-functions/functions-overview)和[Azure 邏輯應用](https://azure.microsoft.com/services/logic-apps/))實現的微服務。</span><span class="sxs-lookup"><span data-stu-id="af452-243">Microservices implemented using serverless technologies such as [Azure Functions](https://docs.microsoft.com/azure/azure-functions/functions-overview) and [Azure Logic Apps](https://azure.microsoft.com/services/logic-apps/).</span></span>
- <span data-ttu-id="af452-244">Azure 支援服務資源,如服務總線佇列和主題、Azure 存儲等。</span><span class="sxs-lookup"><span data-stu-id="af452-244">Azure backing service resources such as Service Bus queues and topics, Azure storage, and others.</span></span>
- <span data-ttu-id="af452-245">微服務,其中流量偶爾有大峰值,但大部分時間仍然很低。</span><span class="sxs-lookup"><span data-stu-id="af452-245">Microservices where traffic has occasional large spikes but remains low the majority of the time.</span></span>

<span data-ttu-id="af452-246">消耗層使用相同的基礎服務 API 管理元件,但使用基於動態分配的資源的完全不同的體系結構。</span><span class="sxs-lookup"><span data-stu-id="af452-246">The consumption tier uses the same underlying service API Management components, but employs an entirely different architecture based on dynamically allocated resources.</span></span> <span data-ttu-id="af452-247">它與無伺服器計算模型完美一致:</span><span class="sxs-lookup"><span data-stu-id="af452-247">It aligns perfectly with the serverless computing model:</span></span>

- <span data-ttu-id="af452-248">沒有要管理的基礎結構。</span><span class="sxs-lookup"><span data-stu-id="af452-248">No infrastructure to manage.</span></span>
- <span data-ttu-id="af452-249">無空閒容量。</span><span class="sxs-lookup"><span data-stu-id="af452-249">No idle capacity.</span></span>
- <span data-ttu-id="af452-250">高可用性。</span><span class="sxs-lookup"><span data-stu-id="af452-250">High-availability.</span></span>
- <span data-ttu-id="af452-251">自動縮放。</span><span class="sxs-lookup"><span data-stu-id="af452-251">Automatic scaling.</span></span>
- <span data-ttu-id="af452-252">成本基於實際使用方式。</span><span class="sxs-lookup"><span data-stu-id="af452-252">Cost is based on actual usage.</span></span>
  
<span data-ttu-id="af452-253">對於將無伺服器資源公開為 API 的雲原生系統而言,新的消費層是一個很好的選擇。</span><span class="sxs-lookup"><span data-stu-id="af452-253">The new consumption tier is a great choice for cloud-native systems that expose serverless resources as APIs.</span></span>

> <span data-ttu-id="af452-254">在編寫本文時,消費層處於 Azure 雲中的預覽狀態。</span><span class="sxs-lookup"><span data-stu-id="af452-254">At the time of writing, the consumption tier is in preview in the Azure cloud.</span></span>

## <a name="real-time-communication"></a><span data-ttu-id="af452-255">即時通訊</span><span class="sxs-lookup"><span data-stu-id="af452-255">Real-time communication</span></span>

<span data-ttu-id="af452-256">即時通訊或推送通訊是前端應用程式通過 HTTP 與後端雲端雲端雲端原生系統通訊的另一個選項。</span><span class="sxs-lookup"><span data-stu-id="af452-256">Real-time, or push, communication is another option for front-end applications that communicate with back-end cloud-native systems over HTTP.</span></span> <span data-ttu-id="af452-257">應用程式(如財務代碼、在線教育、遊戲和工作進度更新)需要後端的即時實時回應。</span><span class="sxs-lookup"><span data-stu-id="af452-257">Applications, such as financial-tickers, online education, gaming, and job-progress updates, require instantaneous, real-time responses from the back-end.</span></span> <span data-ttu-id="af452-258">使用正常的 HTTP 通信,客戶端無法知道何時有新數據可用。</span><span class="sxs-lookup"><span data-stu-id="af452-258">With normal HTTP communication, there's no way for the client to know when new data is available.</span></span> <span data-ttu-id="af452-259">客戶端必須持續*輪詢*或向伺服器發送請求。</span><span class="sxs-lookup"><span data-stu-id="af452-259">The client must continually *poll* or send requests to the server.</span></span> <span data-ttu-id="af452-260">通過*即時*通訊,伺服器可以隨時將新數據推送到用戶端。</span><span class="sxs-lookup"><span data-stu-id="af452-260">With *real-time* communication, the server can push new data to the client at any time.</span></span>

<span data-ttu-id="af452-261">即時系統通常以高頻數據流和大量併發用戶端連接為特徵。</span><span class="sxs-lookup"><span data-stu-id="af452-261">Real-time systems are often characterized by high-frequency data flows and large numbers of concurrent client connections.</span></span> <span data-ttu-id="af452-262">手動實現即時連接可能會很快變得複雜,需要非普通基礎架構來確保可伸縮性和向連接的用戶端發送可靠的消息。</span><span class="sxs-lookup"><span data-stu-id="af452-262">Manually implementing real-time connectivity can quickly become complex, requiring non-trivial infrastructure to ensure scalability and reliable messaging to connected clients.</span></span> <span data-ttu-id="af452-263">您可以發現自己管理 Azure Redis Cache 的實例和一組負載均衡器,這些平衡器配置了用於用戶端相關性的粘性作業階段。</span><span class="sxs-lookup"><span data-stu-id="af452-263">You could find yourself managing an  instance of Azure Redis Cache and a set of load balancers configured with sticky sessions for client affinity.</span></span>

<span data-ttu-id="af452-264">[Azure SignalR 服務](https://azure.microsoft.com/services/signalr-service/)是一種完全託管的 Azure 服務,可簡化雲原生應用程式的即時通信。</span><span class="sxs-lookup"><span data-stu-id="af452-264">[Azure SignalR Service](https://azure.microsoft.com/services/signalr-service/) is a fully managed Azure service that simplifies real-time communication for your cloud-native applications.</span></span> <span data-ttu-id="af452-265">技術實現詳細資訊(如容量配置、擴展和持久連接)被抽象化。</span><span class="sxs-lookup"><span data-stu-id="af452-265">Technical implementation details like capacity provisioning, scaling, and persistent connections are abstracted away.</span></span> <span data-ttu-id="af452-266">他們處理你與99.9%的服務級別協定。</span><span class="sxs-lookup"><span data-stu-id="af452-266">They're handled for you with a 99.9% service-level agreement.</span></span> <span data-ttu-id="af452-267">您專注於應用程式功能,而不是基礎結構管道。</span><span class="sxs-lookup"><span data-stu-id="af452-267">You focus on application features, not infrastructure plumbing.</span></span>

<span data-ttu-id="af452-268">啟用後,基於雲的 HTTP 服務可以直接將內容更新推送到連接的用戶端,包括瀏覽器、行動和桌面應用程式。</span><span class="sxs-lookup"><span data-stu-id="af452-268">Once enabled, a cloud-based HTTP service can push content updates directly to connected clients, including browser, mobile and desktop applications.</span></span> <span data-ttu-id="af452-269">用戶端將更新,而無需輪詢伺服器。</span><span class="sxs-lookup"><span data-stu-id="af452-269">Clients are updated without the need to poll the server.</span></span> <span data-ttu-id="af452-270">Azure SignalR 抽象了創建即時連接的傳輸技術,包括 WebSocket、伺服器端事件和長期輪詢。</span><span class="sxs-lookup"><span data-stu-id="af452-270">Azure SignalR abstracts the transport technologies that create real-time connectivity, including WebSockets, Server-Side Events, and Long Polling.</span></span> <span data-ttu-id="af452-271">開發人員專注於向連接用戶端的所有或特定子集發送消息。</span><span class="sxs-lookup"><span data-stu-id="af452-271">Developers focus on sending messages to all or specific subsets of connected clients.</span></span>

<span data-ttu-id="af452-272">圖 4-7 顯示了一組 HTTP 客戶端,這些用戶端連接到啟用了 Azure SignalR 的雲端本機應用程式。</span><span class="sxs-lookup"><span data-stu-id="af452-272">Figure 4-7 shows a set of HTTP Clients connecting to a Cloud-native application with Azure SignalR enabled.</span></span>

![Azure SignalR](./media/azure-signalr-service.png)

<span data-ttu-id="af452-274">**圖 4-7。**</span><span class="sxs-lookup"><span data-stu-id="af452-274">**Figure 4-7.**</span></span> <span data-ttu-id="af452-275">Azure SignalR</span><span class="sxs-lookup"><span data-stu-id="af452-275">Azure SignalR</span></span>

<span data-ttu-id="af452-276">Azure SignalR 服務的另一個優勢是實現無伺服器雲本機服務。</span><span class="sxs-lookup"><span data-stu-id="af452-276">Another advantage of Azure SignalR Service comes with implementing Serverless cloud-native services.</span></span> <span data-ttu-id="af452-277">也許您的代碼是按需使用 Azure 函數觸發器執行的。</span><span class="sxs-lookup"><span data-stu-id="af452-277">Perhaps your code is executed on demand with Azure Functions triggers.</span></span> <span data-ttu-id="af452-278">這種情況可能比較棘手,因為代碼不會與用戶端保持長連接。</span><span class="sxs-lookup"><span data-stu-id="af452-278">This scenario can be tricky because your code doesn't maintain long connections with clients.</span></span> <span data-ttu-id="af452-279">Azure SignalR 服務可以處理這種情況，因為該服務已經為您管理連線。</span><span class="sxs-lookup"><span data-stu-id="af452-279">Azure SignalR Service can handle this situation since the service already manages connections for you.</span></span>

<span data-ttu-id="af452-280">Azure SignalR 服務與其他 Azure 服務(如 Azure SQL 資料庫、服務總線或 Redis Cache)緊密整合,為雲端本機應用程式開闢了許多可能性。</span><span class="sxs-lookup"><span data-stu-id="af452-280">Azure SignalR Service closely integrates with other Azure services, such as Azure SQL Database, Service Bus, or Redis Cache, opening up many possibilities for your cloud-native applications.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="af452-281">[前一個](communication-patterns.md)
>[下一個](service-to-service-communication.md)</span><span class="sxs-lookup"><span data-stu-id="af452-281">[Previous](communication-patterns.md)
[Next](service-to-service-communication.md)</span></span>
