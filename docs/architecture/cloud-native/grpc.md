---
title: gRPC
description: 瞭解 gRPC 及其在雲原生應用程式中的角色,以及它與 HTTP RESTful 通信有何不同。
author: robvet
ms.date: 03/31/2020
ms.openlocfilehash: 28a07ad5ec105d3fc5b65e4cf0ac0cd85eb16627
ms.sourcegitcommit: 79b0dd8bfc63f33a02137121dd23475887ecefda
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/01/2020
ms.locfileid: "80524170"
---
# <a name="grpc"></a><span data-ttu-id="031f2-103">gRPC</span><span class="sxs-lookup"><span data-stu-id="031f2-103">gRPC</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="031f2-104">到目前為止,在這本書中,我們專注於[基於REST](https://docs.microsoft.com/azure/architecture/best-practices/api-design)的溝通。</span><span class="sxs-lookup"><span data-stu-id="031f2-104">So far in this book, we've focused on [REST-based](https://docs.microsoft.com/azure/architecture/best-practices/api-design) communication.</span></span> <span data-ttu-id="031f2-105">我們已經看到 REST 是一種靈活的體系結構風格,它根據實體資源定義基於 CRUD 的操作。</span><span class="sxs-lookup"><span data-stu-id="031f2-105">We've seen that REST is a flexible architectural style that defines CRUD-based operations against entity resources.</span></span> <span data-ttu-id="031f2-106">用戶端使用請求/回應通信模型跨 HTTP 與資源進行交互。</span><span class="sxs-lookup"><span data-stu-id="031f2-106">Clients interact with resources across HTTP with a request/response communication model.</span></span> <span data-ttu-id="031f2-107">雖然 REST 得到了廣泛實施,但一種較新的通信技術 gRPC 在整個雲原生社區中獲得了巨大的發展勢頭。</span><span class="sxs-lookup"><span data-stu-id="031f2-107">While REST is widely implemented, a newer communication technology, gRPC, has gained tremendous momentum across the cloud-native community.</span></span>

## <a name="what-is-grpc"></a><span data-ttu-id="031f2-108">什麼是 gRPC?</span><span class="sxs-lookup"><span data-stu-id="031f2-108">What is gRPC?</span></span>

<span data-ttu-id="031f2-109">gRPC 是一個現代的高性能框架,它發展古老的[遠端過程調用 (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call)協定。</span><span class="sxs-lookup"><span data-stu-id="031f2-109">gRPC is a modern, high-performance framework that evolves the age-old [remote procedure call (RPC)](https://en.wikipedia.org/wiki/Remote_procedure_call) protocol.</span></span> <span data-ttu-id="031f2-110">在應用程式級別,gRPC 簡化了用戶端和後端服務之間的消息傳遞。</span><span class="sxs-lookup"><span data-stu-id="031f2-110">At the application level, gRPC streamlines messaging between clients and back-end services.</span></span> <span data-ttu-id="031f2-111">gRPC 源自 Google,是雲[原生產品雲原生計算基礎 (CNCF)](https://www.cncf.io/)生態系統的一部分。</span><span class="sxs-lookup"><span data-stu-id="031f2-111">Originating from Google, gRPC is open source and part of the  [Cloud Native Computing Foundation (CNCF)](https://www.cncf.io/) ecosystem of cloud-native offerings.</span></span> <span data-ttu-id="031f2-112">CNCF認為gRPC是一個[孵化專案](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc)。</span><span class="sxs-lookup"><span data-stu-id="031f2-112">CNCF considers gRPC an [incubating project](https://github.com/cncf/toc/blob/master/process/graduation_criteria.adoc).</span></span> <span data-ttu-id="031f2-113">孵化意味著最終使用者在生產應用程式中使用該技術,並且專案具有大量貢獻者。</span><span class="sxs-lookup"><span data-stu-id="031f2-113">Incubating means end users are using the technology in production applications, and the project has a healthy number of contributors.</span></span>

<span data-ttu-id="031f2-114">典型的 gRPC 用戶端應用將公開實現業務操作的本地進程內函數。</span><span class="sxs-lookup"><span data-stu-id="031f2-114">A typical gRPC client app will expose a local, in-process function that implements a business operation.</span></span> <span data-ttu-id="031f2-115">在封面下,該本地函數調用遠程電腦上的另一個函數。</span><span class="sxs-lookup"><span data-stu-id="031f2-115">Under the covers, that local function invokes another function on a remote machine.</span></span> <span data-ttu-id="031f2-116">看似本地呼叫的內容實質上變成了對遠端服務的透明進程外調用。</span><span class="sxs-lookup"><span data-stu-id="031f2-116">What appears to be a local call essentially becomes a transparent out-of-process call to a remote service.</span></span> <span data-ttu-id="031f2-117">RPC 管道抽象了計算機之間的點對點網路通信、序列化和執行。</span><span class="sxs-lookup"><span data-stu-id="031f2-117">The RPC plumbing abstracts the point-to-point networking communication, serialization, and execution between computers.</span></span>

<span data-ttu-id="031f2-118">在雲原生應用程式中,開發人員通常跨程式設計語言、框架和技術工作。</span><span class="sxs-lookup"><span data-stu-id="031f2-118">In cloud-native applications, developers often work across programming languages, frameworks, and technologies.</span></span> <span data-ttu-id="031f2-119">這種*互操作性*使消息協定和跨平臺通信所需的管道複雜化。</span><span class="sxs-lookup"><span data-stu-id="031f2-119">This *interoperability* complicates message contracts and the plumbing required for cross-platform communication.</span></span>  <span data-ttu-id="031f2-120">gRPC 提供了一個"統一的水準層",用於抽象這些關注點。</span><span class="sxs-lookup"><span data-stu-id="031f2-120">gRPC provides a "uniform horizontal layer" that abstracts these concerns.</span></span> <span data-ttu-id="031f2-121">開發人員在其本機平臺中的代碼側重於業務功能,而 gRPC 處理通信管道。</span><span class="sxs-lookup"><span data-stu-id="031f2-121">Developers code in their native platform focused on business functionality, while gRPC handles communication plumbing.</span></span>

<span data-ttu-id="031f2-122">gRPC 在最流行的開發堆疊中提供全面支援,包括 JAVA、JAvaScript、C#、Go、Swift 和 NodeJS。</span><span class="sxs-lookup"><span data-stu-id="031f2-122">gRPC offers comprehensive support across most popular development stacks, including Java, JavaScript, C#, Go, Swift, and NodeJS.</span></span>

## <a name="grpc-benefits"></a><span data-ttu-id="031f2-123">gRPC 優勢</span><span class="sxs-lookup"><span data-stu-id="031f2-123">gRPC Benefits</span></span>

<span data-ttu-id="031f2-124">gRPC 使用 HTTP/2 進行傳輸協定。</span><span class="sxs-lookup"><span data-stu-id="031f2-124">gRPC uses HTTP/2 for its transport protocol.</span></span> <span data-ttu-id="031f2-125">雖然 HTTP/2 與 HTTP 1.1 相容,但具有許多高級功能:</span><span class="sxs-lookup"><span data-stu-id="031f2-125">While compatible with HTTP 1.1, HTTP/2 features many advanced capabilities:</span></span>

- <span data-ttu-id="031f2-126">用於資料傳輸的二進位協定 - 與 HTTP 1.1 不同,HTTP 1.1 以明文形式發送數據。</span><span class="sxs-lookup"><span data-stu-id="031f2-126">A binary protocol for data transport - unlike HTTP 1.1, which sends data as clear text.</span></span>
- <span data-ttu-id="031f2-127">跨行支援通過同一連接發送多個並行請求 - HTTP 1.1 將處理限制為一次一個請求/回應消息。</span><span class="sxs-lookup"><span data-stu-id="031f2-127">Multiplexing support for sending multiple parallel requests over the same connection - HTTP 1.1 limits processing to one request/response message at a time.</span></span>
- <span data-ttu-id="031f2-128">雙向全雙工通信,用於同時發送用戶端請求和伺服器回應。</span><span class="sxs-lookup"><span data-stu-id="031f2-128">Bidirectional full-duplex communication for sending both client requests and server responses simultaneously.</span></span>
- <span data-ttu-id="031f2-129">內置流式處理,支援對非同步串流大型資料集的請求和回應。</span><span class="sxs-lookup"><span data-stu-id="031f2-129">Built-in streaming enabling requests and responses to asynchronously stream large data sets.</span></span>

<span data-ttu-id="031f2-130">gRPC 重量輕,性能高。</span><span class="sxs-lookup"><span data-stu-id="031f2-130">gRPC is lightweight and highly performant.</span></span> <span data-ttu-id="031f2-131">與 JSON 序列化相比,其速度可能高達 8 倍,消息小 60-80%。</span><span class="sxs-lookup"><span data-stu-id="031f2-131">It can be up to 8x faster than JSON serialization with messages 60-80% smaller.</span></span> <span data-ttu-id="031f2-132">用微軟[視窗通訊基金會(WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf)的話說,gRPC性能超過了高度優化的[NetTCP 綁定](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8)的速度和效率。</span><span class="sxs-lookup"><span data-stu-id="031f2-132">In Microsoft [Windows Communication Foundation (WCF)](https://docs.microsoft.com/dotnet/framework/wcf/whats-wcf) parlance, gRPC performance exceeds the speed and efficiency of the highly optimized [NetTCP bindings](https://docs.microsoft.com/dotnet/api/system.servicemodel.nettcpbinding?view=netframework-4.8).</span></span> <span data-ttu-id="031f2-133">與支援微軟堆疊的 NetTCP 不同,gRPC 是跨平臺的。</span><span class="sxs-lookup"><span data-stu-id="031f2-133">Unlike NetTCP, which favors the Microsoft stack, gRPC is cross-platform.</span></span>

## <a name="protocol-buffers"></a><span data-ttu-id="031f2-134">通訊協定緩衝區</span><span class="sxs-lookup"><span data-stu-id="031f2-134">Protocol Buffers</span></span>

<span data-ttu-id="031f2-135">gRPC 採用一種稱為[協定緩衝區的](https://developers.google.com/protocol-buffers/docs/overview)開源技術。</span><span class="sxs-lookup"><span data-stu-id="031f2-135">gRPC embraces an open-source technology called [Protocol Buffers](https://developers.google.com/protocol-buffers/docs/overview).</span></span> <span data-ttu-id="031f2-136">它們為序列化服務相互發送的結構化消息提供了高效且平臺中立的序列化格式。</span><span class="sxs-lookup"><span data-stu-id="031f2-136">They provide a highly efficient and platform-neutral serialization format for serializing structured messages that services send to each other.</span></span> <span data-ttu-id="031f2-137">使用跨平臺介面定義語言 (IDL),開發人員為每個微服務定義服務協定。</span><span class="sxs-lookup"><span data-stu-id="031f2-137">Using a cross-platform Interface Definition Language (IDL), developers define a service contract for each microservice.</span></span> <span data-ttu-id="031f2-138">協定作為基於`.proto`文本的文件實現,描述每個服務的方法、輸入和輸出。</span><span class="sxs-lookup"><span data-stu-id="031f2-138">The contract, implemented as a text-based `.proto` file, describes the methods, inputs, and outputs for each service.</span></span> <span data-ttu-id="031f2-139">相同的合同檔可用於在不同開發平臺上構建的 gRPC 客戶端和服務。</span><span class="sxs-lookup"><span data-stu-id="031f2-139">The same contract file can be used for gRPC clients and services built on different development platforms.</span></span>

<span data-ttu-id="031f2-140">使用 proto 檔案 Protobuf`protoc`編譯器 ,為您的目標平臺生成用戶端和服務代碼。</span><span class="sxs-lookup"><span data-stu-id="031f2-140">Using the proto file, the Protobuf compiler, `protoc`, generates both client and service code for your target platform.</span></span> <span data-ttu-id="031f2-141">該代碼包括以下元件:</span><span class="sxs-lookup"><span data-stu-id="031f2-141">The code includes the following components:</span></span>

- <span data-ttu-id="031f2-142">由用戶端和服務共用的強類型物件,表示消息的服務操作和數據元素。</span><span class="sxs-lookup"><span data-stu-id="031f2-142">Strongly-typed objects, shared by the client and service, that represent the service operations and data elements for a message.</span></span>
- <span data-ttu-id="031f2-143">具有遠端 gRPC 服務可以繼承和擴展所需的網路管道的強類型基類。</span><span class="sxs-lookup"><span data-stu-id="031f2-143">A strongly-typed base class with the required network plumbing that the remote gRPC service can inherit and extend.</span></span>
- <span data-ttu-id="031f2-144">包含調用遠端 gRPC 服務所需的管道的用戶端存根。</span><span class="sxs-lookup"><span data-stu-id="031f2-144">A client stub that contains the required plumbing to invoke the remote gRPC service.</span></span>

<span data-ttu-id="031f2-145">在運行時,每條消息都序列化為標準 Protobuf 表示形式,並在用戶端和遠端服務之間交換。</span><span class="sxs-lookup"><span data-stu-id="031f2-145">At runtime, each message is serialized as a standard Protobuf representation and exchanged between the client and remote service.</span></span> <span data-ttu-id="031f2-146">與 JSON 或 XML 不同,Protobuf 消息被序列化為編譯的二進位元組。</span><span class="sxs-lookup"><span data-stu-id="031f2-146">Unlike JSON or XML, Protobuf messages are serialized as compiled binary bytes.</span></span>

<span data-ttu-id="031f2-147">該書名為[gRPC,適用於 WCF 開發人員](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/),可從 Microsoft 體系結構網站獲得,提供 gRPC 和協定緩衝區的深入覆蓋。</span><span class="sxs-lookup"><span data-stu-id="031f2-147">The book, [gRPC for WCF Developers](https://docs.microsoft.com/dotnet/architecture/grpc-for-wcf-developers/), available from the Microsoft Architecture site, provides in-depth coverage of gRPC and Protocol Buffers.</span></span>

## <a name="grpc-support-in-net"></a><span data-ttu-id="031f2-148">gRPC 支援 .NET</span><span class="sxs-lookup"><span data-stu-id="031f2-148">gRPC support in .NET</span></span>

<span data-ttu-id="031f2-149">gRPC 整合到 .NET 核心 3.0 SDK 或更高版本中。</span><span class="sxs-lookup"><span data-stu-id="031f2-149">gRPC is integrated into .NET Core 3.0 SDK or later.</span></span> <span data-ttu-id="031f2-150">以下工具支援它:</span><span class="sxs-lookup"><span data-stu-id="031f2-150">The following tools support it:</span></span>

- <span data-ttu-id="031f2-151">Visual Studio 2019,版本 16.3 或更高版本,安裝了 Web 開發工作負載。</span><span class="sxs-lookup"><span data-stu-id="031f2-151">Visual Studio 2019, version 16.3 or later, with the web development workload installed.</span></span>
- <span data-ttu-id="031f2-152">Visual Studio Code</span><span class="sxs-lookup"><span data-stu-id="031f2-152">Visual Studio Code</span></span>
- <span data-ttu-id="031f2-153">點網 CLI</span><span class="sxs-lookup"><span data-stu-id="031f2-153">the dotnet CLI</span></span>

<span data-ttu-id="031f2-154">SDK 包括用於端點路由、內建 IoC 和日誌記錄的工具。</span><span class="sxs-lookup"><span data-stu-id="031f2-154">The SDK includes tooling for endpoint routing, built-in IoC, and logging.</span></span> <span data-ttu-id="031f2-155">開源 Kestrel Web 伺服器支援 HTTP/2 連接。</span><span class="sxs-lookup"><span data-stu-id="031f2-155">The open-source Kestrel web server supports HTTP/2 connections.</span></span> <span data-ttu-id="031f2-156">圖 4-20 顯示了 Visual Studio 2019 範本,該範本為 gRPC 服務的腳架式骨架專案提供了支架。</span><span class="sxs-lookup"><span data-stu-id="031f2-156">Figure 4-20 shows a Visual Studio 2019 template that scaffolds a skeleton project for a gRPC service.</span></span> <span data-ttu-id="031f2-157">請注意 .NET Core 如何完全支援 Windows、Linux 和 macOS。</span><span class="sxs-lookup"><span data-stu-id="031f2-157">Note how .NET Core fully supports Windows, Linux, and macOS.</span></span>

![gRPC 支援視覺工作室 2019](./media/visual-studio-2019-grpc-template.png)

<span data-ttu-id="031f2-159">**圖 4-20**：</span><span class="sxs-lookup"><span data-stu-id="031f2-159">**Figure 4-20**.</span></span> <span data-ttu-id="031f2-160">gRPC 支援視覺工作室 2019</span><span class="sxs-lookup"><span data-stu-id="031f2-160">gRPC support in Visual Studio 2019</span></span>
  
<span data-ttu-id="031f2-161">圖 4-21 顯示了從 Visual Studio 2019 中包含的內建基架生成的骨架 gRPC 服務。</span><span class="sxs-lookup"><span data-stu-id="031f2-161">Figure 4-21 shows the skeleton gRPC service generated from the built-in scaffolding included in Visual Studio 2019.</span></span>  

![gRPC 專案在視覺工作室 2019](./media/grpc-project.png  )

<span data-ttu-id="031f2-163">**圖 4-21**：</span><span class="sxs-lookup"><span data-stu-id="031f2-163">**Figure 4-21**.</span></span> <span data-ttu-id="031f2-164">gRPC 專案在視覺工作室 2019</span><span class="sxs-lookup"><span data-stu-id="031f2-164">gRPC project in Visual Studio 2019</span></span>

<span data-ttu-id="031f2-165">在上圖中,請注意原型描述檔和服務代碼。</span><span class="sxs-lookup"><span data-stu-id="031f2-165">In the previous figure, note the proto description file and service code.</span></span> <span data-ttu-id="031f2-166">正如您稍後看到的,Visual Studio 會在啟動類和基礎專案檔中生成其他配置。</span><span class="sxs-lookup"><span data-stu-id="031f2-166">As you'll see shortly, Visual Studio generates additional configuration in both the Startup class and underlying project file.</span></span>

## <a name="grpc-usage"></a><span data-ttu-id="031f2-167">gRPC 使用方式</span><span class="sxs-lookup"><span data-stu-id="031f2-167">gRPC usage</span></span>

<span data-ttu-id="031f2-168">以下方案有利於 gRPC:</span><span class="sxs-lookup"><span data-stu-id="031f2-168">Favor gRPC for the following scenarios:</span></span>

- <span data-ttu-id="031f2-169">同步後端微服務到微服務通信,需要立即回應才能繼續處理。</span><span class="sxs-lookup"><span data-stu-id="031f2-169">Synchronous backend microservice-to-microservice communication where an immediate response is required to continue processing.</span></span>
- <span data-ttu-id="031f2-170">需要支援混合程式設計平臺的多面體環境。</span><span class="sxs-lookup"><span data-stu-id="031f2-170">Polyglot environments that need to support mixed programming platforms.</span></span>
- <span data-ttu-id="031f2-171">低延遲和高吞吐量通信,其中性能至關重要。</span><span class="sxs-lookup"><span data-stu-id="031f2-171">Low latency and high throughput communication where performance is critical.</span></span>
- <span data-ttu-id="031f2-172">點對點即時通信 - gRPC 無需輪詢即可即時推送消息,並且對雙向流流具有出色的支援。</span><span class="sxs-lookup"><span data-stu-id="031f2-172">Point-to-point real-time communication - gRPC can push messages in real time without polling and has excellent support for bi-directional streaming.</span></span>
- <span data-ttu-id="031f2-173">網路受限環境 – 二進位 gRPC 消息始終小於等效的基於文本的 JSON 消息。</span><span class="sxs-lookup"><span data-stu-id="031f2-173">Network constrained environments – binary gRPC messages are always smaller than an equivalent text-based JSON message.</span></span>

<span data-ttu-id="031f2-174">在撰寫本文時,gRPC 主要用於後端服務。</span><span class="sxs-lookup"><span data-stu-id="031f2-174">At the time, of this writing, gRPC is primarily used with backend services.</span></span> <span data-ttu-id="031f2-175">大多數現代瀏覽器無法提供支援前端 gRPC 用戶端所需的 HTTP/2 控制級別。</span><span class="sxs-lookup"><span data-stu-id="031f2-175">Most modern browsers can't provide the level of HTTP/2 control required to support a front-end gRPC client.</span></span> <span data-ttu-id="031f2-176">也就是說,有一[個早期計劃](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/),支援 gRPC 通信從基於瀏覽器的應用程式構建與 JavaScript 或 Blazor WebAssembly 技術。</span><span class="sxs-lookup"><span data-stu-id="031f2-176">That said, there's an [early initiative](https://devblogs.microsoft.com/aspnet/grpc-web-experiment/) that enables gRPC communication from browser-based apps built with JavaScript or Blazor WebAssembly technologies.</span></span> <span data-ttu-id="031f2-177">[gRPC-Web 表示 .NET,](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md)支援ASP.NET核心 gRPC 應用,以支援瀏覽器應用中的 gRPC 功能:</span><span class="sxs-lookup"><span data-stu-id="031f2-177">The  [gRPC-Web for .NET](https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md) enables an ASP.NET Core gRPC app to support gRPC features in browser apps:</span></span>

- <span data-ttu-id="031f2-178">強類型代碼產生的用戶端</span><span class="sxs-lookup"><span data-stu-id="031f2-178">Strongly-typed code-generated clients</span></span>
- <span data-ttu-id="031f2-179">緊湊型 Protobuf 訊息</span><span class="sxs-lookup"><span data-stu-id="031f2-179">Compact Protobuf messages</span></span>
- <span data-ttu-id="031f2-180">伺服器流程處理</span><span class="sxs-lookup"><span data-stu-id="031f2-180">Server streaming</span></span>

## <a name="grpc-implementation"></a><span data-ttu-id="031f2-181">gRPC 實現</span><span class="sxs-lookup"><span data-stu-id="031f2-181">gRPC implementation</span></span>

<span data-ttu-id="031f2-182">微軟的微服務參考體系結構[,即容器上的eShop,](https://github.com/dotnet-architecture/eShopOnContainers)展示了如何在 .NET Core 應用程式中實現 gRPC 服務。</span><span class="sxs-lookup"><span data-stu-id="031f2-182">The microservice reference architecture, [eShop on Containers](https://github.com/dotnet-architecture/eShopOnContainers), from Microsoft, shows how to implement gRPC services in .NET Core applications.</span></span> <span data-ttu-id="031f2-183">圖 4-22 顯示了後端體系結構。</span><span class="sxs-lookup"><span data-stu-id="031f2-183">Figure 4-22 presents the back-end architecture.</span></span>

![容器上 eShop 的後端結構](./media/eshop-with-aggregators.png)

<span data-ttu-id="031f2-185">**圖 4-22**。</span><span class="sxs-lookup"><span data-stu-id="031f2-185">**Figure 4-22**.</span></span> <span data-ttu-id="031f2-186">容器上 eShop 的後端結構</span><span class="sxs-lookup"><span data-stu-id="031f2-186">Backend architecture for eShop on Containers</span></span>

<span data-ttu-id="031f2-187">在上圖中,請注意 eShop 如何通過公開多個 API 閘道來擁抱[前端模式](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends)(BFF) 的後端。</span><span class="sxs-lookup"><span data-stu-id="031f2-187">In the previous figure, note how eShop embraces the [Backend for Frontends pattern](https://docs.microsoft.com/azure/architecture/patterns/backends-for-frontends) (BFF) by exposing multiple API gateways.</span></span> <span data-ttu-id="031f2-188">本章前面討論了 BFF 模式。</span><span class="sxs-lookup"><span data-stu-id="031f2-188">We discussed the BFF pattern earlier in this chapter.</span></span> <span data-ttu-id="031f2-189">密切關注位於 Web 購物 API 閘道和後端購物微服務之間的聚合器微服務(灰色)。</span><span class="sxs-lookup"><span data-stu-id="031f2-189">Pay close attention to the Aggregator microservice (in gray) that sits between the Web-Shopping API Gateway and backend Shopping microservices.</span></span> <span data-ttu-id="031f2-190">聚合器接收來自用戶端的單個請求,將其調度到各種微服務,聚合結果,並將它們發送回請求用戶端。</span><span class="sxs-lookup"><span data-stu-id="031f2-190">The Aggregator receives a single request from a client, dispatches it to various microservices, aggregates the results, and sends them back to the requesting client.</span></span> <span data-ttu-id="031f2-191">此類操作通常需要同步通信才能立即產生回應。</span><span class="sxs-lookup"><span data-stu-id="031f2-191">Such operations typically require synchronous communication as to produce an immediate response.</span></span> <span data-ttu-id="031f2-192">在 eShop 中,聚合器的後端調用使用 gRPC 執行,如圖 4-23 所示。</span><span class="sxs-lookup"><span data-stu-id="031f2-192">In eShop, backend calls from the Aggregator are performed using gRPC as shown in Figure 4-23.</span></span>

![gRPC 在容器上的 eShop 中](./media/grpc-implementation.png)

<span data-ttu-id="031f2-194">**圖 4-23**：</span><span class="sxs-lookup"><span data-stu-id="031f2-194">**Figure 4-23**.</span></span> <span data-ttu-id="031f2-195">gRPC 在容器上的 eShop 中</span><span class="sxs-lookup"><span data-stu-id="031f2-195">gRPC in eShop on Containers</span></span>

<span data-ttu-id="031f2-196">gRPC 通訊需要用戶端和伺服器元件。</span><span class="sxs-lookup"><span data-stu-id="031f2-196">gRPC communication requires both client and server components.</span></span> <span data-ttu-id="031f2-197">在上圖中,請注意購物聚合器如何實現 gRPC 用戶端。</span><span class="sxs-lookup"><span data-stu-id="031f2-197">In the previous figure, note how the Shopping Aggregator implements a gRPC client.</span></span> <span data-ttu-id="031f2-198">用戶端對後端微服務進行同步 gRPC 調用(紅色),每個微服務都實現 gRPC 伺服器。</span><span class="sxs-lookup"><span data-stu-id="031f2-198">The client makes synchronous gRPC calls (in red) to backend microservices, each of which implement a gRPC server.</span></span> <span data-ttu-id="031f2-199">用戶端和伺服器都利用了 .NET Core 3.0 SDK 的內建 gRPC 管道。</span><span class="sxs-lookup"><span data-stu-id="031f2-199">Both the client and server take advantage of the built-in gRPC plumbing from the .NET Core 3.0 SDK.</span></span> <span data-ttu-id="031f2-200">用戶端*存根*提供調用遠端 gRPC 調用的管道。</span><span class="sxs-lookup"><span data-stu-id="031f2-200">Client-side *stubs* provide the plumbing to invoke remote gRPC calls.</span></span> <span data-ttu-id="031f2-201">伺服器端元件提供自定義服務類可以繼承和使用 gRPC 管道。</span><span class="sxs-lookup"><span data-stu-id="031f2-201">Server-side components provide gRPC plumbing that custom service classes can inherit and consume.</span></span>

<span data-ttu-id="031f2-202">公開 RESTful API 和 gRPC 通訊的微服務需要多個終結點來管理流量。</span><span class="sxs-lookup"><span data-stu-id="031f2-202">Microservices that expose both a RESTful API and gRPC communication require multiple endpoints to manage traffic.</span></span> <span data-ttu-id="031f2-203">您將打開一個終結點,用於偵聽呼叫的 HTTP 流量,為 gRPC 呼叫打開另一個終結點。</span><span class="sxs-lookup"><span data-stu-id="031f2-203">You would open an endpoint that listens for HTTP traffic for the RESTful calls and another for gRPC calls.</span></span> <span data-ttu-id="031f2-204">gRPC 終結點必須配置為 gRPC 通訊所需的 HTTP/2 協定。</span><span class="sxs-lookup"><span data-stu-id="031f2-204">The gRPC endpoint must be configured for the HTTP/2 protocol that is required for gRPC communication.</span></span>

<span data-ttu-id="031f2-205">儘管我們努力使微服務與非同步通信模式分離,但某些操作需要直接調用。</span><span class="sxs-lookup"><span data-stu-id="031f2-205">While we strive to decouple microservices with asynchronous communication patterns, some operations require direct calls.</span></span> <span data-ttu-id="031f2-206">gRPC 應該是微服務之間直接同步通信的主要選擇。</span><span class="sxs-lookup"><span data-stu-id="031f2-206">gRPC should be the primary choice for direct synchronous communication between microservices.</span></span> <span data-ttu-id="031f2-207">基於 HTTP/2 和協定緩衝區的高性能通訊協定使其成為一個完美的選擇。</span><span class="sxs-lookup"><span data-stu-id="031f2-207">Its high-performance communication protocol, based on HTTP/2 and protocol buffers, make it a perfect choice.</span></span>

## <a name="looking-ahead"></a><span data-ttu-id="031f2-208">展望未來</span><span class="sxs-lookup"><span data-stu-id="031f2-208">Looking ahead</span></span>

<span data-ttu-id="031f2-209">展望未來,gRPC將繼續為雲本機系統贏得牽引力。</span><span class="sxs-lookup"><span data-stu-id="031f2-209">Looking ahead, gRPC will continue to gain traction for cloud-native systems.</span></span> <span data-ttu-id="031f2-210">性能優勢和易於開發是引人注目的。</span><span class="sxs-lookup"><span data-stu-id="031f2-210">The performance benefits and ease of development are compelling.</span></span> <span data-ttu-id="031f2-211">但是,REST 可能會出現很長時間。</span><span class="sxs-lookup"><span data-stu-id="031f2-211">However, REST will likely be around for a long time.</span></span> <span data-ttu-id="031f2-212">它擅長公開公開的 API 和向後相容性原因。</span><span class="sxs-lookup"><span data-stu-id="031f2-212">It excels for publicly exposed APIs and for backward compatibility reasons.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="031f2-213">[前一個](service-to-service-communication.md)
>[下一個](service-mesh-communication-infrastructure.md)</span><span class="sxs-lookup"><span data-stu-id="031f2-213">[Previous](service-to-service-communication.md)
[Next](service-mesh-communication-infrastructure.md)</span></span>
