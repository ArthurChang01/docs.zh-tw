---
title: 服務到服務通訊
description: 瞭解後端雲端雲端微服務如何與其他後端微服務進行通信。
author: robvet
ms.date: 09/09/2019
ms.openlocfilehash: 926be3c2eb4513c89ebcd1f31dceb7d58639dc6f
ms.sourcegitcommit: 79b0dd8bfc63f33a02137121dd23475887ecefda
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/01/2020
ms.locfileid: "80523554"
---
# <a name="service-to-service-communication"></a><span data-ttu-id="bf0c0-103">服務到服務通訊</span><span class="sxs-lookup"><span data-stu-id="bf0c0-103">Service-to-service communication</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="bf0c0-104">從前端用戶端,我們現在處理後端微服務相互通信。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-104">Moving from the front-end client, we now address back-end microservices communicate with each other.</span></span>

<span data-ttu-id="bf0c0-105">構建雲本機應用程式時,您需要對後端服務如何相互通信敏感。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-105">When constructing a cloud-native application, you'll want to be sensitive to how back-end services communicate with each other.</span></span> <span data-ttu-id="bf0c0-106">理想情況下,服務間通信越少越好。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-106">Ideally, the less inter-service communication, the better.</span></span> <span data-ttu-id="bf0c0-107">但是,由於後端服務通常相互依賴來完成操作,因此並非始終能夠避免。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-107">However, avoidance isn't always possible as back-end services often rely on one another to complete an operation.</span></span>

<span data-ttu-id="bf0c0-108">實施跨服務通信的方法被廣泛接受。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-108">There are several widely accepted approaches to implementing cross-service communication.</span></span> <span data-ttu-id="bf0c0-109">*通信交互的類型*通常將決定最佳方法。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-109">The *type of communication interaction* will often determine the best approach.</span></span>

<span data-ttu-id="bf0c0-110">請考慮以下互動型態:</span><span class="sxs-lookup"><span data-stu-id="bf0c0-110">Consider the following interaction types:</span></span>

- <span data-ttu-id="bf0c0-111">*查詢*– 當呼叫微服務需要來自被呼叫的微服務的回應時,例如「嘿,給我給定客戶 ID 的買方資訊。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-111">*Query* – when a calling microservice requires a response from a called microservice, such as, "Hey, give me the buyer information for a given customer Id."</span></span>

- <span data-ttu-id="bf0c0-112">*命令*– 當呼叫微服務需要另一個微服務來執行操作,但不需要回應時,例如「嘿,只需發出此訂單」。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-112">*Command* – when the calling microservice needs another microservice to execute an action but doesn't require a response, such as, "Hey, just ship this order."</span></span>

- <span data-ttu-id="bf0c0-113">*事件*— 當稱為發佈伺服器的微服務引發狀態已更改或已發生操作的事件時。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-113">*Event* – when a microservice, called the publisher, raises an event that state has changed or an action has occurred.</span></span> <span data-ttu-id="bf0c0-114">其他微服務(稱為訂閱者)有興趣,可以對事件做出適當的反應。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-114">Other microservices, called subscribers, who are interested, can react to the event appropriately.</span></span> <span data-ttu-id="bf0c0-115">發行者和訂閱者彼此不知道。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-115">The publisher and the subscribers aren't aware of each other.</span></span>

<span data-ttu-id="bf0c0-116">在執行需要跨服務交互的操作時,微服務系統通常使用這些交互類型的組合。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-116">Microservice systems typically use a combination of these interaction types when executing operations that require cross-service interaction.</span></span> <span data-ttu-id="bf0c0-117">讓我們仔細看看每個以及如何實現它們。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-117">Let's take a close look at each and how you might implement them.</span></span>

## <a name="queries"></a><span data-ttu-id="bf0c0-118">查詢</span><span class="sxs-lookup"><span data-stu-id="bf0c0-118">Queries</span></span>

<span data-ttu-id="bf0c0-119">很多時候,一個微服務可能需要*查詢*另一個微服務,需要立即回應才能完成操作。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-119">Many times, one microservice might need to *query* another, requiring an immediate response to complete an operation.</span></span> <span data-ttu-id="bf0c0-120">購物籃微服務可能需要產品資訊和價格才能將商品添加到其購物籃中。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-120">A shopping basket microservice may need product information and a price to add an item to its basket.</span></span> <span data-ttu-id="bf0c0-121">實現查詢操作的方法有很多種。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-121">There are a number of approaches for implementing query operations.</span></span>

### <a name="requestresponse-messaging"></a><span data-ttu-id="bf0c0-122">要求/回應傳訊</span><span class="sxs-lookup"><span data-stu-id="bf0c0-122">Request/Response Messaging</span></span>

<span data-ttu-id="bf0c0-123">實現此方案的一個選項是調用後端微服務,以便直接向需要查詢的微服務發出 HTTP 請求,如圖 4-8 所示。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-123">One option for implementing this scenario is for the calling back-end microservice to make direct HTTP requests to the microservices it needs to query, shown in Figure 4-8.</span></span>

![直接 HTTP 通訊](./media/direct-http-communication.png)

<span data-ttu-id="bf0c0-125">**圖4-8**。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-125">**Figure 4-8**.</span></span> <span data-ttu-id="bf0c0-126">直接 HTTP 通訊</span><span class="sxs-lookup"><span data-stu-id="bf0c0-126">Direct HTTP communication</span></span>

<span data-ttu-id="bf0c0-127">雖然微服務之間的直接 HTTP 調用執行起來相對簡單,但應注意將這種做法降至最低。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-127">While direct HTTP calls between microservices are relatively simple to implement, care should be taken to minimize this practice.</span></span> <span data-ttu-id="bf0c0-128">要啟動,這些調用始終是*同步*的,並將阻止操作,直到返回結果或請求超時。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-128">To start, these calls are always *synchronous* and will block the operation until a result is returned or the request times outs.</span></span> <span data-ttu-id="bf0c0-129">曾經自成一體的獨立服務能夠獨立發展並頻繁部署,現在卻相互耦合。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-129">What were once self-contained, independent services, able to evolve independently and deploy frequently, now become coupled to each other.</span></span> <span data-ttu-id="bf0c0-130">隨著微服務之間的耦合增加,其體系結構優勢逐漸降低。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-130">As coupling among microservices increase, their architectural benefits diminish.</span></span>

<span data-ttu-id="bf0c0-131">執行對另一個微服務進行單個直接 HTTP 調用的不常見請求對於某些系統可能是可以接受的。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-131">Executing an infrequent request that makes a single direct HTTP call to another microservice might be acceptable for some systems.</span></span> <span data-ttu-id="bf0c0-132">但是,不建議調用對多個微服務直接 HTTP 調用的高容量調用。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-132">However, high-volume calls that invoke direct HTTP calls to multiple microservices aren't advisable.</span></span> <span data-ttu-id="bf0c0-133">它們會增加延遲,並產生負面影響系統的性能、可擴充性和可用性。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-133">They can increase latency and negatively impact the performance, scalability, and availability of your system.</span></span> <span data-ttu-id="bf0c0-134">更糟糕的是,一系列直接 HTTP 通信可能導致同步微服務調用的深層和複雜鏈,如圖 4-9 所示:</span><span class="sxs-lookup"><span data-stu-id="bf0c0-134">Even worse, a long series of direct HTTP communication can lead to deep and complex chains of synchronous microservices calls, shown in Figure 4-9:</span></span>

![連結 HTTP 查詢](./media/chaining-http-queries.png)

<span data-ttu-id="bf0c0-136">**圖4-9**。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-136">**Figure 4-9**.</span></span> <span data-ttu-id="bf0c0-137">連結 HTTP 查詢</span><span class="sxs-lookup"><span data-stu-id="bf0c0-137">Chaining HTTP queries</span></span>

<span data-ttu-id="bf0c0-138">您當然可以想像前一張圖片中顯示的設計中的風險。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-138">You can certainly imagine the risk in the design shown in the previous image.</span></span> <span data-ttu-id="bf0c0-139">如果步驟\#3 失敗,會發生什麼情況?</span><span class="sxs-lookup"><span data-stu-id="bf0c0-139">What happens if Step \#3 fails?</span></span> <span data-ttu-id="bf0c0-140">還是步驟\#8 失敗?</span><span class="sxs-lookup"><span data-stu-id="bf0c0-140">Or Step \#8 fails?</span></span> <span data-ttu-id="bf0c0-141">你如何恢復?</span><span class="sxs-lookup"><span data-stu-id="bf0c0-141">How do you recover?</span></span> <span data-ttu-id="bf0c0-142">如果步驟\#6 由於基礎服務繁忙而速度較慢,該怎麼辦?</span><span class="sxs-lookup"><span data-stu-id="bf0c0-142">What if Step \#6 is slow because the underlying service is busy?</span></span> <span data-ttu-id="bf0c0-143">你如何繼續?</span><span class="sxs-lookup"><span data-stu-id="bf0c0-143">How do you continue?</span></span> <span data-ttu-id="bf0c0-144">即使所有操作都正常工作,也想想此調用產生的延遲,即每個步驟的延遲總和。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-144">Even if all works correctly, think of the latency this call would incur, which is the sum of the latency of each step.</span></span>

<span data-ttu-id="bf0c0-145">上圖中大量耦合表明,服務沒有進行最佳建模。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-145">The large degree of coupling in the previous image suggests the services weren't optimally modeled.</span></span> <span data-ttu-id="bf0c0-146">團隊應該重新審視他們的設計。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-146">It would behoove the team to revisit their design.</span></span>

### <a name="materialized-view-pattern"></a><span data-ttu-id="bf0c0-147">具體化檢視模式</span><span class="sxs-lookup"><span data-stu-id="bf0c0-147">Materialized View pattern</span></span>

<span data-ttu-id="bf0c0-148">刪除微服務耦合的一個常用選項是[一個影像](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)的檢視模式 。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-148">A popular option for removing microservice coupling is the [Materialized View pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view).</span></span> <span data-ttu-id="bf0c0-149">使用此模式,微服務存儲其自己的本地、非規範化數據副本,這些副本由其他服務擁有。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-149">With this pattern, a microservice stores its own local, denormalized copy of data that's owned by other services.</span></span> <span data-ttu-id="bf0c0-150">它維護自己的本地數據副本,而不是查詢產品目錄和定價微服務的購物籃微服務。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-150">Instead of the Shopping Basket microservice querying the Product Catalog and Pricing microservices, it maintains its own local copy of that data.</span></span> <span data-ttu-id="bf0c0-151">此模式消除了不必要的耦合,提高了可靠性和響應時間。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-151">This pattern eliminates unnecessary coupling and improves reliability and response time.</span></span> <span data-ttu-id="bf0c0-152">整個操作在單個進程內執行。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-152">The entire operation executes inside a single process.</span></span> <span data-ttu-id="bf0c0-153">我們在第 5 章中探討此模式和其他數據問題。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-153">We explore this pattern and other data concerns in Chapter 5.</span></span>

### <a name="service-aggregator-pattern"></a><span data-ttu-id="bf0c0-154">服務集合模式模式</span><span class="sxs-lookup"><span data-stu-id="bf0c0-154">Service Aggregator Pattern</span></span>

<span data-ttu-id="bf0c0-155">消除微服務到微服務耦合的另一個選項是[聚合器微服務](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/),如圖 4-10 中紫色所示。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-155">Another option for eliminating microservice-to-microservice coupling is an [Aggregator microservice](https://devblogs.microsoft.com/cesardelatorre/designing-and-implementing-api-gateways-with-ocelot-in-a-microservices-and-container-based-architecture/), shown in purple in Figure 4-10.</span></span>

![彙總器服務](./media/aggregator-service.png)

<span data-ttu-id="bf0c0-157">**圖 4-10**：</span><span class="sxs-lookup"><span data-stu-id="bf0c0-157">**Figure 4-10**.</span></span> <span data-ttu-id="bf0c0-158">聚合器微服務</span><span class="sxs-lookup"><span data-stu-id="bf0c0-158">Aggregator microservice</span></span>

<span data-ttu-id="bf0c0-159">該模式隔離了對多個後端微服務進行調用的操作,將其邏輯集中到專用微服務中。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-159">The pattern isolates an operation that makes calls to multiple back-end microservices, centralizing its logic into a specialized microservice.</span></span>  <span data-ttu-id="bf0c0-160">上圖中的紫色簽出聚合器微服務協調簽出操作的工作流。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-160">The purple checkout aggregator microservice in the previous figure orchestrates the workflow for the Checkout operation.</span></span> <span data-ttu-id="bf0c0-161">它包括按順序順序對多個後端微服務的調用。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-161">It includes calls to several back-end microservices in a sequenced order.</span></span> <span data-ttu-id="bf0c0-162">來自工作流的數據將聚合併返回到調用方。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-162">Data from the workflow is aggregated and returned to the caller.</span></span> <span data-ttu-id="bf0c0-163">雖然它仍然實現直接 HTTP 調用,但聚合器微服務減少了後端微服務之間的直接依賴關係。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-163">While it still implements direct HTTP calls, the aggregator microservice reduces direct dependencies among back-end microservices.</span></span>

### <a name="requestreply-pattern"></a><span data-ttu-id="bf0c0-164">請求/回覆模式</span><span class="sxs-lookup"><span data-stu-id="bf0c0-164">Request/Reply Pattern</span></span>

<span data-ttu-id="bf0c0-165">分離同步 HTTP 訊息的另一種方法是[請求回覆模式](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html),它使用佇列通信。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-165">Another approach for decoupling synchronous HTTP messages is a [Request-Reply Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReply.html), which uses queuing communication.</span></span> <span data-ttu-id="bf0c0-166">使用佇列的通信始終是單向通道,生產者發送消息並接收消費者。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-166">Communication using a queue is always a one-way channel, with a producer sending the message and consumer receiving it.</span></span> <span data-ttu-id="bf0c0-167">使用此模式,將實現請求佇列和響應佇列,如圖 4-11 所示。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-167">With this pattern, both a request queue and response queue are implemented, shown in Figure 4-11.</span></span>

![要求-回覆模式](./media/request-reply-pattern.png)

<span data-ttu-id="bf0c0-169">**圖 4-11**：</span><span class="sxs-lookup"><span data-stu-id="bf0c0-169">**Figure 4-11**.</span></span> <span data-ttu-id="bf0c0-170">要求-回覆模式</span><span class="sxs-lookup"><span data-stu-id="bf0c0-170">Request-reply pattern</span></span>

<span data-ttu-id="bf0c0-171">在這裡,消息生成器創建一個基於查詢的消息,其中包含唯一的相關性 ID 並將其放入請求佇列中。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-171">Here, the message producer creates a query-based message that contains a unique correlation ID and places it into a request queue.</span></span> <span data-ttu-id="bf0c0-172">使用服務取消消息排隊,處理消息,並將回應放在具有相同關聯 ID 的回應佇列中。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-172">The consuming service dequeues the messages, processes it and places the response into the response queue with the same correlation ID.</span></span> <span data-ttu-id="bf0c0-173">生產者服務取消消息的排隊,將其與相關 ID 匹配並繼續處理。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-173">The producer service dequeues the message, matches it with the correlation ID and continues processing.</span></span> <span data-ttu-id="bf0c0-174">我們將在下一節中詳細介紹佇列。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-174">We cover queues in detail in the next section.</span></span>

## <a name="commands"></a><span data-ttu-id="bf0c0-175">命令</span><span class="sxs-lookup"><span data-stu-id="bf0c0-175">Commands</span></span>

<span data-ttu-id="bf0c0-176">另一種類型的通訊互動是*指令*。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-176">Another type of communication interaction is a *command*.</span></span> <span data-ttu-id="bf0c0-177">微服務可能需要另一個微服務來執行操作。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-177">A microservice may need another microservice to perform an action.</span></span> <span data-ttu-id="bf0c0-178">訂購微服務可能需要運輸微服務為已批准的訂單創建貨件。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-178">The Ordering microservice may need the Shipping microservice to create a shipment for an approved order.</span></span> <span data-ttu-id="bf0c0-179">在圖 4-12 中,一個稱為"生產者"的微服務向另一個微服務"消費者"發送消息,命令它執行某些操作。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-179">In Figure 4-12, one microservice, called a Producer, sends a message to another microservice, the Consumer, commanding it to do something.</span></span>

![命令與佇列的互動](./media/command-interaction-with-queue.png)

<span data-ttu-id="bf0c0-181">**圖 4-12**.</span><span class="sxs-lookup"><span data-stu-id="bf0c0-181">**Figure 4-12**.</span></span> <span data-ttu-id="bf0c0-182">命令與佇列的互動</span><span class="sxs-lookup"><span data-stu-id="bf0c0-182">Command interaction with a queue</span></span>

<span data-ttu-id="bf0c0-183">通常,生產者不需要回應,可能會*觸發和忘記*消息。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-183">Most often, the Producer doesn't require a response and can *fire-and-forget* the message.</span></span> <span data-ttu-id="bf0c0-184">如果需要回復,使用者將發送單獨的消息回另一個通道上的生產者。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-184">If a reply is needed, the Consumer sends a separate message back to Producer on another channel.</span></span> <span data-ttu-id="bf0c0-185">命令消息最好使用消息佇列非同步發送。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-185">A command message is best sent asynchronously with a message queue.</span></span> <span data-ttu-id="bf0c0-186">由輕量級消息代理支援。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-186">supported by a lightweight message broker.</span></span> <span data-ttu-id="bf0c0-187">在上圖中,請注意佇列如何分離和分離兩個服務。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-187">In the previous diagram, note how a queue separates and decouples both services.</span></span>

<span data-ttu-id="bf0c0-188">消息佇列是一種中間構造,生產者和使用者通過它傳遞消息。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-188">A message queue is an intermediary construct through which a producer and consumer pass a message.</span></span> <span data-ttu-id="bf0c0-189">佇列實現非同步點對點訊息傳遞模式。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-189">Queues implement an asynchronous, point-to-point messaging pattern.</span></span> <span data-ttu-id="bf0c0-190">生產者知道需要發送命令的位置並相應地路由。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-190">The Producer knows where a command needs to be sent and routes appropriately.</span></span> <span data-ttu-id="bf0c0-191">佇列保證消息由從通道讀取的消費者實例之一處理。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-191">The queue guarantees that a message is processed by exactly one of the consumer instances that are reading from the channel.</span></span> <span data-ttu-id="bf0c0-192">在這種情況下,生產者或消費者服務可以橫向擴展,而不會影響其他服務。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-192">In this scenario, either the producer or consumer service can scale out without affecting the other.</span></span> <span data-ttu-id="bf0c0-193">同樣,技術在兩側可能各不相同,這意味著我們可能有一個 JAVA 微服務,稱為[Golang](https://golang.org)微服務。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-193">As well, technologies can be disparate on each side, meaning that we might have a Java microservice calling a [Golang](https://golang.org) microservice.</span></span>

<span data-ttu-id="bf0c0-194">在第 1 章中,我們討論了*支援服務*。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-194">In chapter 1, we talked about *backing services*.</span></span> <span data-ttu-id="bf0c0-195">支援服務是雲原生系統所依賴的輔助資源。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-195">Backing services are ancillary resources upon which cloud-native systems depend.</span></span> <span data-ttu-id="bf0c0-196">消息佇列是支援服務。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-196">Message queues are backing services.</span></span> <span data-ttu-id="bf0c0-197">Azure 雲支援兩種類型的消息佇列,雲原生系統可用於實現命令消息傳遞:Azure 儲存佇列和 Azure 服務總線佇列。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-197">The Azure cloud supports two types of message queues that your cloud-native systems can consume to implement command messaging: Azure Storage Queues and Azure Service Bus Queues.</span></span>

### <a name="azure-storage-queues"></a><span data-ttu-id="bf0c0-198">Azure 儲存體佇列</span><span class="sxs-lookup"><span data-stu-id="bf0c0-198">Azure Storage Queues</span></span>

<span data-ttu-id="bf0c0-199">Azure 儲存佇列提供快速、經濟實惠並由 Azure 存儲帳戶提供支援的簡單佇列基礎結構。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-199">Azure storage queues offer a simple queueing infrastructure that is fast, affordable, and backed by Azure storage accounts.</span></span>

<span data-ttu-id="bf0c0-200">[Azure 儲存佇列](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction)具有基於 REST 的排隊機制,具有可靠且持久的消息傳遞。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-200">[Azure Storage Queues](https://docs.microsoft.com/azure/storage/queues/storage-queues-introduction) feature a REST-based queuing mechanism with reliable and persistent messaging.</span></span> <span data-ttu-id="bf0c0-201">它們提供最少的功能集,但價格低廉,並存儲數百萬條消息。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-201">They provide a minimal feature set, but are inexpensive and store millions of messages.</span></span> <span data-ttu-id="bf0c0-202">其容量範圍可達 500 TB。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-202">Their capacity ranges up to 500 TB.</span></span> <span data-ttu-id="bf0c0-203">一條消息的大小可達 64 KB。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-203">A single message can be up to 64 KB in size.</span></span>

<span data-ttu-id="bf0c0-204">您可以使用 HTTP 或 HTTPS 透過經過身份驗證的通話從世界任何地方存取訊息。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-204">You can access messages from anywhere in the world via authenticated calls using HTTP or HTTPS.</span></span> <span data-ttu-id="bf0c0-205">存儲佇列可以擴展到大量併發用戶端,以處理流量峰值。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-205">Storage queues can scale out to large numbers of concurrent clients to handle traffic spikes.</span></span>

<span data-ttu-id="bf0c0-206">也就是說,服務存在限制:</span><span class="sxs-lookup"><span data-stu-id="bf0c0-206">That said, there are limitations with the service:</span></span>

- <span data-ttu-id="bf0c0-207">消息順序不保證。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-207">Message order isn't guaranteed.</span></span>

- <span data-ttu-id="bf0c0-208">消息只能保留七天,然後才能自動刪除。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-208">A message can only persist for seven days before it's automatically removed.</span></span>

- <span data-ttu-id="bf0c0-209">不支持狀態管理、重複檢測或事務不可用。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-209">Support for state management, duplicate detection, or transactions isn't available.</span></span>

<span data-ttu-id="bf0c0-210">圖 4-13 顯示了 Azure 儲存佇列的層次結構。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-210">Figure 4-13 shows the hierarchy of an Azure Storage Queue.</span></span>

![儲存佇列層次結構](./media/storage-queue-hierarchy.png)

<span data-ttu-id="bf0c0-212">**圖 4-13**.</span><span class="sxs-lookup"><span data-stu-id="bf0c0-212">**Figure 4-13**.</span></span> <span data-ttu-id="bf0c0-213">儲存佇列層次結構</span><span class="sxs-lookup"><span data-stu-id="bf0c0-213">Storage queue hierarchy</span></span>

<span data-ttu-id="bf0c0-214">在上圖中,請注意儲存佇列如何將其消息存儲在基礎 Azure 存儲帳戶中。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-214">In the previous figure, note how storage queues store their messages in the underlying Azure Storage account.</span></span>

<span data-ttu-id="bf0c0-215">對於開發人員,Microsoft 提供了多個用戶端和伺服器端庫,用於存儲佇列處理。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-215">For developers, Microsoft provides several client and server-side libraries for Storage queue processing.</span></span> <span data-ttu-id="bf0c0-216">大多數主要平臺都受支援,包括 .NET、JAVA、JAVAScript、Ruby、Python 和 Go。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-216">Most major platforms are supported including .NET, Java, JavaScript, Ruby, Python, and Go.</span></span> <span data-ttu-id="bf0c0-217">開發人員絕不應直接與這些庫通信。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-217">Developers should never communicate directly with these libraries.</span></span> <span data-ttu-id="bf0c0-218">這樣做會將微服務代碼與 Azure 儲存佇列服務緊密耦合。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-218">Doing so will tightly couple your microservice code to the Azure Storage Queue service.</span></span> <span data-ttu-id="bf0c0-219">最好隔離 API 的實現詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-219">It's a better practice to insulate the implementation details of the API.</span></span> <span data-ttu-id="bf0c0-220">引入中介層或中間 API,該層公開泛型操作並封裝具體庫。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-220">Introduce an intermediation layer, or intermediate API, that exposes generic operations and encapsulates the concrete library.</span></span> <span data-ttu-id="bf0c0-221">這種鬆散的耦合使您能夠將一個佇列服務交換到另一個佇列服務,而無需更改主線服務代碼。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-221">This loose coupling enables you to swap out one queuing service for another without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="bf0c0-222">Azure 儲存佇列是在雲本機應用程式中實現命令消息傳遞的經濟選擇。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-222">Azure Storage queues are an economical option to implement command messaging in your cloud-native applications.</span></span> <span data-ttu-id="bf0c0-223">特別是當佇列大小超過 80 GB 時,或者一個簡單的功能集是可以接受的。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-223">Especially when a queue size will exceed 80 GB, or a simple feature set is acceptable.</span></span> <span data-ttu-id="bf0c0-224">您只為郵件的存儲付費;沒有固定的小時費用。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-224">You only pay for the storage of the messages; there are no fixed hourly charges.</span></span>

### <a name="azure-service-bus-queues"></a><span data-ttu-id="bf0c0-225">Azure 服務匯流排佇列</span><span class="sxs-lookup"><span data-stu-id="bf0c0-225">Azure Service Bus Queues</span></span>

<span data-ttu-id="bf0c0-226">對於更複雜的消息傳遞要求,請考慮 Azure 服務總線佇列。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-226">For more complex messaging requirements, consider Azure Service Bus queues.</span></span>

<span data-ttu-id="bf0c0-227">[Azure 服務匯流線](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview)位於強大的訊息基礎結構之上,支援*中轉訊息傳遞模型*。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-227">Sitting atop a robust message infrastructure, [Azure Service Bus](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview) supports a *brokered messaging model*.</span></span> <span data-ttu-id="bf0c0-228">消息可靠地存儲在代理(佇列)中,直到消費者收到消息。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-228">Messages are reliably stored in a broker (the queue) until received by the consumer.</span></span> <span data-ttu-id="bf0c0-229">佇列保證先到/先出 (FIFO) 消息傳遞,遵守消息添加到佇列的順序。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-229">The queue guarantees First-In/First-Out (FIFO) message delivery, respecting the order in which messages were added to the queue.</span></span>

<span data-ttu-id="bf0c0-230">消息的大小可以大得多,高達 256 KB。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-230">The size of a message can be much larger, up to 256 KB.</span></span> <span data-ttu-id="bf0c0-231">消息在佇列中保留無限時間。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-231">Messages are persisted in the queue for an unlimited period of time.</span></span> <span data-ttu-id="bf0c0-232">服務總線不僅支援基於 HTTP 的調用,而且還提供對[AMPQ 協定的](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview)完全支援。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-232">Service Bus supports not only HTTP-based calls, but also provides full support for the [AMPQ protocol](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-amqp-overview).</span></span> <span data-ttu-id="bf0c0-233">AMPQ 是跨供應商的開放標準,支援二進位協定和更高可靠性度。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-233">AMPQ is an open-standard across vendors that supports a binary protocol and higher degrees of reliability.</span></span>

<span data-ttu-id="bf0c0-234">服務匯流排提供豐富的功能,包括[事務支援](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)與[重覆偵測功能](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-234">Service Bus provides a rich set of features, including [transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions) and a [duplicate detection feature](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection).</span></span> <span data-ttu-id="bf0c0-235">佇列保證每條消息"最多傳遞一次」。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-235">The queue guarantees "at most once delivery" per message.</span></span> <span data-ttu-id="bf0c0-236">它會自動丟棄已發送的消息。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-236">It automatically discards a message that has already been sent.</span></span> <span data-ttu-id="bf0c0-237">如果生產者有疑問,它可以重新發送相同的消息,並且服務總線保證只處理一個副本。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-237">If a producer is in doubt, it can resend the same message, and Service Bus guarantees that only one copy will be processed.</span></span> <span data-ttu-id="bf0c0-238">重複檢測使您不必構建其他基礎結構管道。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-238">Duplicate detection frees you from  having to build additional infrastructure plumbing.</span></span>

<span data-ttu-id="bf0c0-239">另外兩個企業功能是分區和會話。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-239">Two more enterprise features are partitioning and sessions.</span></span> <span data-ttu-id="bf0c0-240">傳統的服務總線佇列由單一消息代理處理並存儲在單一消息儲存中。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-240">A conventional Service Bus queue is handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="bf0c0-241">但是,[服務總線分區](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)將佇列分散到多個消息代理和消息存儲中。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-241">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) spreads the queue across multiple message brokers and message stores.</span></span> <span data-ttu-id="bf0c0-242">總體輸送量不再受單個消息代理或消息存儲的性能的限制。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-242">The overall throughput is no longer limited by the performance of a single message broker or messaging store.</span></span> <span data-ttu-id="bf0c0-243">消息存儲的臨時中斷不會使分區佇列不可用。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-243">A temporary outage of a messaging store doesn't render a partitioned queue unavailable.</span></span>

<span data-ttu-id="bf0c0-244">[服務總線會話](https://codingcanvas.com/azure-service-bus-sessions/)提供了一種組相關消息的方法。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-244">[Service Bus Sessions](https://codingcanvas.com/azure-service-bus-sessions/) provide a way to group-related messages.</span></span> <span data-ttu-id="bf0c0-245">想像一下工作流方案,其中消息必須一起處理,操作在結束時完成。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-245">Imagine a workflow scenario where messages must be processed together and the operation completed at the end.</span></span> <span data-ttu-id="bf0c0-246">要利用此優勢,必須為佇列顯式啟用會話,並且每個相關消息必須包含相同的會話 ID。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-246">To take advantage, sessions must be explicitly enabled for the queue and each related messaged must contain the same session ID.</span></span>

<span data-ttu-id="bf0c0-247">但是,有一些重要的警告:服務總線佇列大小限制為 80 GB,這比商店佇列中可用的小得多。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-247">However, there are some important caveats: Service Bus queues size is limited to 80 GB, which is much smaller than what's available from store queues.</span></span> <span data-ttu-id="bf0c0-248">此外,服務總線佇列會產生基本成本和每次操作的費用。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-248">Additionally, Service Bus queues incur a base cost and charge per operation.</span></span>

<span data-ttu-id="bf0c0-249">圖 4-14 概述了服務總線佇列的高級體系結構。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-249">Figure 4-14 outlines the high-level architecture of a Service Bus queue.</span></span>

![服務匯流排佇列](./media/service-bus-queue.png)

<span data-ttu-id="bf0c0-251">**圖 4-14**.</span><span class="sxs-lookup"><span data-stu-id="bf0c0-251">**Figure 4-14**.</span></span> <span data-ttu-id="bf0c0-252">服務匯流排佇列</span><span class="sxs-lookup"><span data-stu-id="bf0c0-252">Service Bus queue</span></span>

<span data-ttu-id="bf0c0-253">在上圖中,請注意點對點關係。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-253">In the previous figure, note the point-to-point relationship.</span></span> <span data-ttu-id="bf0c0-254">同一提供程式的兩個實例正在將消息排入單個服務總線佇列中。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-254">Two instances of the same provider are enqueuing messages into a single Service Bus queue.</span></span> <span data-ttu-id="bf0c0-255">每條消息僅由右側三個使用者實例中的一個使用。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-255">Each message is consumed by only one of three consumer instances on the right.</span></span> <span data-ttu-id="bf0c0-256">接下來,我們將討論如何在不同消費者都對同一消息感興趣的地方實現消息傳遞。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-256">Next, we discuss how to implement messaging where different consumers may all be interested the same message.</span></span>

## <a name="events"></a><span data-ttu-id="bf0c0-257">事件</span><span class="sxs-lookup"><span data-stu-id="bf0c0-257">Events</span></span>

<span data-ttu-id="bf0c0-258">消息佇列是實現通信的有效方法,其中生產者可以異步向消費者發送消息。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-258">Message queuing is an effective way to implement communication where a producer can asynchronously send a consumer a message.</span></span> <span data-ttu-id="bf0c0-259">但是,當*許多不同的消費者對*同一消息感興趣時,會發生什麼情況?</span><span class="sxs-lookup"><span data-stu-id="bf0c0-259">However, what happens when *many different consumers* are interested in the same message?</span></span> <span data-ttu-id="bf0c0-260">每個消費者的專用消息佇列不會很好地擴展,並且將變得難以管理。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-260">A dedicated message queue for each consumer wouldn't scale well and would become difficult to manage.</span></span>

<span data-ttu-id="bf0c0-261">為了解決這個問題,我們轉到第三種類型的消息交互,*事件*。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-261">To address this scenario, we move to the third type of message interaction, the *event*.</span></span> <span data-ttu-id="bf0c0-262">一個微服務宣佈已發生操作。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-262">One microservice announces that an action had occurred.</span></span> <span data-ttu-id="bf0c0-263">其他微服務(如果有興趣)對操作或事件做出反應。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-263">Other microservices, if interested, react to the action, or event.</span></span>

<span data-ttu-id="bf0c0-264">事件是一個兩步過程。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-264">Eventing is a two-step process.</span></span> <span data-ttu-id="bf0c0-265">對於給定的狀態更改,微服務將事件發佈到消息代理,使其可用於任何其他感興趣的微服務。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-265">For a given state change, a microservice publishes an event to a message broker, making it available to any other interested microservice.</span></span> <span data-ttu-id="bf0c0-266">通過訂閱消息代理中的事件來通知感興趣的微服務。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-266">The interested microservice is notified by subscribing to the event in the message broker.</span></span> <span data-ttu-id="bf0c0-267">您可以使用[「 發布/訂閱](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber)模式」 來實現[此事件的通訊](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications)。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-267">You use the [Publish/Subscribe](https://docs.microsoft.com/azure/architecture/patterns/publisher-subscriber) pattern to implement [event-based communication](https://docs.microsoft.com/dotnet/standard/microservices-architecture/multi-container-microservice-net-applications/integration-event-based-microservice-communications).</span></span>

<span data-ttu-id="bf0c0-268">圖 4-15 顯示了購物籃微服務發佈事件,其中另外兩個微服務訂閱了它。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-268">Figure 4-15 shows a shopping basket microservice publishing an event with two other microservices subscribing to it.</span></span>

![事件驅動訊息](./media/event-driven-messaging.png)

<span data-ttu-id="bf0c0-270">**圖 4-15**：</span><span class="sxs-lookup"><span data-stu-id="bf0c0-270">**Figure 4-15**.</span></span> <span data-ttu-id="bf0c0-271">事件驅動訊息</span><span class="sxs-lookup"><span data-stu-id="bf0c0-271">Event-Driven messaging</span></span>

<span data-ttu-id="bf0c0-272">請注意位於通信通道中間*的事件總線*元件。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-272">Note the *event bus* component that sits in the middle of the communication channel.</span></span> <span data-ttu-id="bf0c0-273">它是一個自定義類,它封裝消息代理並將其與基礎應用程式分離。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-273">It's a custom class that encapsulates the message broker and decouples it from the underlying application.</span></span> <span data-ttu-id="bf0c0-274">訂購和庫存微服務在彼此不知情的情況下獨立操作事件,也無需購物籃微服務。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-274">The ordering and inventory microservices independently operate the event with no knowledge of each other, nor the shopping basket microservice.</span></span> <span data-ttu-id="bf0c0-275">當註冊事件發佈到事件總線時,它們會對它執行操作。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-275">When the registered event is published to the event bus, they act upon it.</span></span>

<span data-ttu-id="bf0c0-276">通過事件,我們從排隊技術轉向*主題*。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-276">With eventing, we move from queuing technology to *topics*.</span></span> <span data-ttu-id="bf0c0-277">[主題](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)類似於佇列,但支援一對多消息傳遞模式。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-277">A [topic](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions) is similar to a queue, but supports a one-to-many messaging pattern.</span></span> <span data-ttu-id="bf0c0-278">一個微服務發佈消息。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-278">One microservice publishes a message.</span></span> <span data-ttu-id="bf0c0-279">多個訂閱微服務可以選擇接收該消息並採取行動。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-279">Multiple subscribing microservices can choose to receive and act upon that message.</span></span> <span data-ttu-id="bf0c0-280">圖 4-16 顯示了主題體系結構。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-280">Figure 4-16 shows a topic architecture.</span></span>

![主題架構結構](./media/topic-architecture.png)

<span data-ttu-id="bf0c0-282">**圖 4-16**：</span><span class="sxs-lookup"><span data-stu-id="bf0c0-282">**Figure 4-16**.</span></span> <span data-ttu-id="bf0c0-283">主題架構結構</span><span class="sxs-lookup"><span data-stu-id="bf0c0-283">Topic architecture</span></span>

<span data-ttu-id="bf0c0-284">在上圖中,發佈者向主題發送消息。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-284">In the previous figure, publishers send messages to the topic.</span></span> <span data-ttu-id="bf0c0-285">最後,訂閱者會從訂閱接收消息。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-285">At the end, subscribers receive messages from subscriptions.</span></span> <span data-ttu-id="bf0c0-286">在中間,主題根據一組*規則*將消息轉發到訂閱,這些規則顯示在深藍色框中。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-286">In the middle, the topic forwards messages to subscriptions based on a set of *rules*, shown in dark blue boxes.</span></span> <span data-ttu-id="bf0c0-287">規則充當將特定消息轉發到訂閱的篩選器。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-287">Rules act as a filter that forward specific messages to a subscription.</span></span> <span data-ttu-id="bf0c0-288">此處,將"創建訂單"事件發送到訂閱\#1\#和訂閱 3,但不會\#發送到訂閱 2。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-288">Here, a "CreateOrder" event would be sent to Subscription \#1 and Subscription \#3, but not to Subscription \#2.</span></span> <span data-ttu-id="bf0c0-289">群組訂單完成"事件將發送到訂閱\#2\#和訂閱 3。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-289">An "OrderCompleted" event would be sent to Subscription \#2 and Subscription \#3.</span></span>

<span data-ttu-id="bf0c0-290">Azure 雲支援兩種不同的主題服務:Azure 服務總線主題和 Azure 事件網格。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-290">The Azure cloud supports two different topic services: Azure Service Bus Topics and Azure EventGrid.</span></span>

### <a name="azure-service-bus-topics"></a><span data-ttu-id="bf0c0-291">Azure 服務匯流排主題</span><span class="sxs-lookup"><span data-stu-id="bf0c0-291">Azure Service Bus Topics</span></span>

<span data-ttu-id="bf0c0-292">坐在 Azure 服務總線佇列的相同強大代理訊息模型的頂部是 Azure[服務總線主題](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions)。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-292">Sitting on top of the same robust brokered message model of Azure Service Bus queues are [Azure Service Bus Topics](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-how-to-use-topics-subscriptions).</span></span> <span data-ttu-id="bf0c0-293">主題可以接收來自多個獨立發佈者的消息,並向多達 2,000 個訂閱者發送消息。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-293">A topic can receive messages from multiple independent publishers and send messages to up to 2,000 subscribers.</span></span> <span data-ttu-id="bf0c0-294">訂閱可以在運行時動態添加或刪除,而無需停止系統或重新建立主題。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-294">Subscriptions can be dynamically added or removed at runtime without stopping the system or recreating the topic.</span></span>

<span data-ttu-id="bf0c0-295">Azure 服務匯流排排列中的許多進階功能也可用於主題,包括[重複偵測](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection)與[事務支援](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions)。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-295">Many advanced features from Azure Service Bus queues are also available for topics, including [Duplicate Detection](https://docs.microsoft.com/azure/service-bus-messaging/duplicate-detection) and [Transaction support](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-transactions).</span></span> <span data-ttu-id="bf0c0-296">默認情況下,服務總線主題由單個消息代理處理並存儲在單個消息存儲中。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-296">By default, Service Bus topics are handled by a single message broker and stored in a single message store.</span></span> <span data-ttu-id="bf0c0-297">但是,[服務總線分區](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning)通過將主題傳播到許多消息代理和消息存儲中來擴展主題。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-297">But, [Service Bus Partitioning](https://docs.microsoft.com/azure/service-bus-messaging/service-bus-partitioning) scales a topic by spreading it across many message brokers and message stores.</span></span>

<span data-ttu-id="bf0c0-298">[計劃郵件傳遞](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing)標記具有特定時間處理的郵件。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-298">[Scheduled Message Delivery](https://docs.microsoft.com/azure/service-bus-messaging/message-sequencing) tags a message with a specific time for processing.</span></span> <span data-ttu-id="bf0c0-299">在此之前,該消息不會顯示在主題中。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-299">The message won't appear in the topic before that time.</span></span> <span data-ttu-id="bf0c0-300">[消息延遲](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral)使您能夠將郵件的檢索推遲到以後。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-300">[Message Deferral](https://docs.microsoft.com/azure/service-bus-messaging/message-deferral) enables you to defer a retrieval of a message to a later time.</span></span> <span data-ttu-id="bf0c0-301">這兩種情況通常用於工作流處理方案,其中操作按特定順序處理。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-301">Both are commonly used in workflow processing scenarios where operations are processed in a particular order.</span></span> <span data-ttu-id="bf0c0-302">您可以推遲處理已接收的消息,直到完成之前的工作。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-302">You can postpone processing of received messages until prior work has been completed.</span></span>

<span data-ttu-id="bf0c0-303">服務總線主題是一種強大且經過驗證的技術,可在雲本機系統中啟用發佈/訂閱通信。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-303">Service Bus topics are a robust and proven technology for enabling publish/subscribe communication in your cloud-native systems.</span></span>

### <a name="azure-event-grid"></a><span data-ttu-id="bf0c0-304">Azure Event Grid</span><span class="sxs-lookup"><span data-stu-id="bf0c0-304">Azure Event Grid</span></span>

<span data-ttu-id="bf0c0-305">雖然 Azure 服務總線是經過戰鬥測試的消息代理,具有一整套企業功能,但[Azure 事件網格](https://docs.microsoft.com/azure/event-grid/overview)是塊上的新孩子。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-305">While Azure Service Bus is a battle-tested messaging broker with a full set of enterprise features, [Azure Event Grid](https://docs.microsoft.com/azure/event-grid/overview) is the new kid on the block.</span></span>

<span data-ttu-id="bf0c0-306">乍一看,事件網格可能只是另一個基於主題的郵件系統。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-306">At first glance, Event Grid may look like just another topic-based messaging system.</span></span> <span data-ttu-id="bf0c0-307">然而,它在許多方面是不同的。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-307">However, it's different in many ways.</span></span> <span data-ttu-id="bf0c0-308">它專注於事件驅動的工作負載,支援即時事件處理、深度 Azure 整合和開放平臺 - 所有這些都位於無伺服器基礎架構上。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-308">Focused on event-driven workloads, it enables real-time event processing, deep Azure integration, and an open-platform - all on serverless infrastructure.</span></span> <span data-ttu-id="bf0c0-309">它專為現代雲原生和無伺服器應用程式而設計</span><span class="sxs-lookup"><span data-stu-id="bf0c0-309">It's designed for contemporary cloud-native and serverless applications</span></span>

<span data-ttu-id="bf0c0-310">作為集中*式事件背板*或管道,事件網格對 Azure 資源內的事件和您自己的服務做出反應。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-310">As a centralized *eventing backplane*, or pipe, Event Grid reacts to events inside Azure resources and from your own services.</span></span>

<span data-ttu-id="bf0c0-311">事件通知發佈到事件網格主題,而事件網格主題又將每個事件路由到訂閱。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-311">Event notifications are published to an Event Grid Topic, which, in turn, routes each event to a subscription.</span></span> <span data-ttu-id="bf0c0-312">訂閱伺服器對應到訂閱並使用事件。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-312">Subscribers map to subscriptions and consume the events.</span></span> <span data-ttu-id="bf0c0-313">與服務總線一樣,事件網格支援*篩選的訂閱者模型*,其中訂閱集其希望接收的事件的規則。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-313">Like Service Bus, Event Grid supports a *filtered subscriber model* where a subscription sets rule for the events it wishes to receive.</span></span> <span data-ttu-id="bf0c0-314">事件網格提供快速輸送量,保證每秒 1000 萬個事件,實現近乎即時的傳遞 -遠遠超過 Azure 服務總線所能生成的。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-314">Event Grid provides fast throughput with a guarantee of 10 million events per second enabling near real-time delivery - far more than what Azure Service Bus can generate.</span></span>

<span data-ttu-id="bf0c0-315">事件網格的一個最佳亮點是它深入集成到 Azure 基礎結構的結構中。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-315">A sweet spot for Event Grid is its deep integration into the fabric of Azure infrastructure.</span></span> <span data-ttu-id="bf0c0-316">Azure 資源(如Cosmos DB)可以直接將內建事件發佈到其他感興趣的Azure資源,而無需自定義代碼。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-316">An Azure resource, such as Cosmos DB, can publish built-in events directly to other interested Azure resources - without the need for custom code.</span></span> <span data-ttu-id="bf0c0-317">事件網格可以從 Azure 訂閱、資源組或服務發佈事件,使開發人員能夠細粒度地控制雲資源的生命週期。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-317">Event Grid can publish events from an Azure Subscription, Resource Group, or Service, giving developers fine-grained control over the lifecycle of cloud resources.</span></span> <span data-ttu-id="bf0c0-318">但是,事件網格並不僅限於 Azure。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-318">However, Event Grid isn't limited to Azure.</span></span> <span data-ttu-id="bf0c0-319">它是一個開放的平臺,可以使用從應用程式或第三方服務發佈的自定義 HTTP 事件,並將事件路由到外部訂閱者。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-319">It's an open platform that can consume custom HTTP events published from applications or third-party services and route events to external subscribers.</span></span>

<span data-ttu-id="bf0c0-320">從 Azure 資源發佈和訂閱本機事件時,不需要編碼。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-320">When publishing and subscribing to native events from Azure resources, no coding is required.</span></span> <span data-ttu-id="bf0c0-321">通過簡單的配置,您可以利用主題和訂閱的內建管道將事件從一個 Azure 資源整合到另一個 Azure 資源。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-321">With simple configuration, you can integrate events from one Azure resource to another leveraging built-in plumbing for Topics and Subscriptions.</span></span> <span data-ttu-id="bf0c0-322">圖 4-17 顯示了事件網格的剖析。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-322">Figure 4-17 shows the anatomy of Event Grid.</span></span>

![事件網格解剖](./media/event-grid-anatomy.png)

<span data-ttu-id="bf0c0-324">**圖 4-17**：</span><span class="sxs-lookup"><span data-stu-id="bf0c0-324">**Figure 4-17**.</span></span> <span data-ttu-id="bf0c0-325">事件網格解剖</span><span class="sxs-lookup"><span data-stu-id="bf0c0-325">Event Grid anatomy</span></span>

<span data-ttu-id="bf0c0-326">事件格線與服務匯流線之間的主要區別是基礎*訊息交換模式*。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-326">A major difference between EventGrid and Service Bus is the underlying *message exchange pattern*.</span></span>

<span data-ttu-id="bf0c0-327">服務總線實現了較舊的樣式*拉取模型*,其中下游訂閱者主動輪詢主題訂閱的新消息。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-327">Service Bus implements an older style *pull model* in which the downstream subscriber actively polls the topic subscription for new messages.</span></span> <span data-ttu-id="bf0c0-328">有利的一面是,此方法使訂閱者能夠完全控制其處理消息的速度。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-328">On the upside, this approach gives the subscriber full control of the pace at which it processes messages.</span></span> <span data-ttu-id="bf0c0-329">它控制在任意給定時間處理的時間和消息數。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-329">It controls when and how many messages to process at any given time.</span></span> <span data-ttu-id="bf0c0-330">未讀郵件將保留在訂閱中,直到處理。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-330">Unread messages remain in the subscription until processed.</span></span> <span data-ttu-id="bf0c0-331">一個重大缺點是生成事件的時間與將該消息拉至訂閱者進行處理的輪詢操作之間的延遲。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-331">A significant shortcoming is the latency between the time the event is generated and the polling operation that pulls that message to the subscriber for processing.</span></span> <span data-ttu-id="bf0c0-332">此外,下一個事件的恆定輪詢開銷會消耗資源和資金。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-332">Also, the overhead of constant polling for the next event consumes resources and money.</span></span>

<span data-ttu-id="bf0c0-333">但是,事件網格是不同的。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-333">EventGrid, however, is different.</span></span> <span data-ttu-id="bf0c0-334">它實現了一個*推送模型*,其中事件在接收時發送到事件處理程式,提供近乎即時的事件傳遞。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-334">It implements a *push model* in which events are sent to the EventHandlers as received, giving near real-time event delivery.</span></span> <span data-ttu-id="bf0c0-335">它還降低了成本,因為服務僅在需要使用事件時觸發 –而不是與輪詢那樣持續。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-335">It also reduces cost as the service is triggered only when it's needed to consume an event – not continually as with polling.</span></span> <span data-ttu-id="bf0c0-336">也就是說,事件處理程序必須處理傳入負載並提供限制機制,以防止自身不堪重負。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-336">That said, an event handler must handle the incoming load and provide throttling mechanisms to protect itself from becoming overwhelmed.</span></span> <span data-ttu-id="bf0c0-337">許多使用這些事件的 Azure 服務(如 Azure 函數和邏輯應用)提供自動自動縮放功能來處理增加的負載。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-337">Many Azure services that consume these events, such as Azure Functions and Logic Apps provide automatic autoscaling capabilities to handle increased loads.</span></span>  

<span data-ttu-id="bf0c0-338">事件網格是一個完全託管的無伺服器雲服務。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-338">Event Grid is a fully managed serverless cloud service.</span></span> <span data-ttu-id="bf0c0-339">它根據您的流量動態擴展,僅針對實際使用方式收費,而不是預購買容量。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-339">It dynamically scales based on your traffic and charges you only for your actual usage, not pre-purchased capacity.</span></span> <span data-ttu-id="bf0c0-340">每月的前 100,000 個操作是免費的 - 操作定義為事件入口(傳入事件通知)、訂閱傳遞嘗試、管理調用和按主題篩選。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-340">The first 100,000 operations per month are free – operations being defined as event ingress (incoming event notifications), subscription delivery attempts, management calls, and filtering by subject.</span></span> <span data-ttu-id="bf0c0-341">憑藉 99.99% 的可用性,EventGrid 保證在 24 小時內交付事件,並內置重試功能,以不成功交付。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-341">With 99.99% availability, EventGrid guarantees the delivery of an event within a 24-hour period, with built-in retry functionality for unsuccessful delivery.</span></span> <span data-ttu-id="bf0c0-342">未傳遞的消息可以移動到"死信"佇列以進行解析。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-342">Undelivered messages can be moved to a "dead-letter" queue for resolution.</span></span>  <span data-ttu-id="bf0c0-343">與 Azure 服務總線不同,事件網格經過最佳化以獲得快速性能,不支援有序訊息傳遞、事務和會話等功能。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-343">Unlike Azure Service Bus, Event Grid is tuned for fast performance and doesn't support features like ordered messaging, transactions, and sessions.</span></span>

### <a name="streaming-messages-in-the-azure-cloud"></a><span data-ttu-id="bf0c0-344">在 Azure 雲中流式傳輸訊息</span><span class="sxs-lookup"><span data-stu-id="bf0c0-344">Streaming messages in the Azure cloud</span></span>

<span data-ttu-id="bf0c0-345">Azure 服務總線和事件網格為公開單個離散事件(如新文檔)的應用程式提供了極大的支援,這些事件已插入到Cosmos DB中。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-345">Azure Service Bus and Event Grid provide great support for applications that expose single, discrete events like a new document has been inserted into a Cosmos DB.</span></span> <span data-ttu-id="bf0c0-346">但是,如果您的雲原生系統需要處理*一系列相關事件*,該怎麼辦?</span><span class="sxs-lookup"><span data-stu-id="bf0c0-346">But, what if your cloud-native system needs to process a *stream of related events*?</span></span> <span data-ttu-id="bf0c0-347">[事件流](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems)更為複雜。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-347">[Event streams](https://docs.microsoft.com/archive/msdn-magazine/2015/february/microsoft-azure-the-rise-of-event-stream-oriented-systems) are more complex.</span></span> <span data-ttu-id="bf0c0-348">它們通常是按時間順序排列的,是相互關聯的,必須作為一個組進行處理。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-348">They're typically time-ordered, interrelated, and must be processed as a group.</span></span>

<span data-ttu-id="bf0c0-349">[Azure 事件中心](https://azure.microsoft.com/services/event-hubs/)是一個數據流平臺和事件引入服務,用於收集、轉換和存儲事件。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-349">[Azure Event Hub](https://azure.microsoft.com/services/event-hubs/) is a data streaming platform and event ingestion service that collects, transforms, and stores events.</span></span> <span data-ttu-id="bf0c0-350">它經過微調以捕獲流數據,例如從遙測上下文中發出的連續事件通知。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-350">It's fine-tuned to capture streaming data, such as continuous event notifications emitted from a telemetry context.</span></span> <span data-ttu-id="bf0c0-351">該服務具有高度可擴充性,每秒可以儲存[和處理數百萬個事件](https://docs.microsoft.com/azure/event-hubs/event-hubs-about)。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-351">The service is highly scalable and can store and [process millions of events per second](https://docs.microsoft.com/azure/event-hubs/event-hubs-about).</span></span> <span data-ttu-id="bf0c0-352">如圖 4-18 所示,它通常是事件管道的前門,將引入流與事件消耗分離。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-352">Shown in Figure 4-18, it's often a front door for an event pipeline, decoupling ingest stream from event consumption.</span></span>

![Azure 事件中樞](./media/azure-event-hub.png)

<span data-ttu-id="bf0c0-354">**圖 4-18**.</span><span class="sxs-lookup"><span data-stu-id="bf0c0-354">**Figure 4-18**.</span></span> <span data-ttu-id="bf0c0-355">Azure 事件中樞</span><span class="sxs-lookup"><span data-stu-id="bf0c0-355">Azure Event Hub</span></span>

<span data-ttu-id="bf0c0-356">事件中心支援低延遲和可配置的時間保留。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-356">Event Hub supports low latency and configurable time retention.</span></span> <span data-ttu-id="bf0c0-357">與佇列和主題不同,事件中心在使用者讀取事件數據後保留事件數據。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-357">Unlike queues and topics, Event Hubs keep event data after it's been read by a consumer.</span></span> <span data-ttu-id="bf0c0-358">此功能使內部和外部的其他數據分析服務能夠重播數據以進行進一步分析。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-358">This feature enables other data analytic services, both internal and external, to replay the data for further analysis.</span></span> <span data-ttu-id="bf0c0-359">存儲在事件中心的事件僅在保留期到期時刪除,默認情況下為一天,但可配置。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-359">Events stored in event hub are only deleted upon expiration of the retention period, which is one day by default, but configurable.</span></span>

<span data-ttu-id="bf0c0-360">事件中心支援常見的事件發佈協定,包括 HTTPS 和 AMQP。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-360">Event Hub supports common event publishing protocols including HTTPS and AMQP.</span></span> <span data-ttu-id="bf0c0-361">它還支援卡夫卡1.0。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-361">It also supports Kafka 1.0.</span></span> <span data-ttu-id="bf0c0-362">[現有的 Kafka 應用程式可以使用](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview)Kafka 協定與事件中心通信,為管理大型 Kafka 群集提供了替代方案。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-362">[Existing Kafka applications can communicate with Event Hub](https://docs.microsoft.com/azure/event-hubs/event-hubs-for-kafka-ecosystem-overview) using the Kafka protocol providing an alternative to managing large Kafka clusters.</span></span> <span data-ttu-id="bf0c0-363">許多開源雲原生系統都擁抱卡夫卡。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-363">Many open-source cloud-native systems embrace Kafka.</span></span>

<span data-ttu-id="bf0c0-364">事件中心通過[分區消費者模型](https://docs.microsoft.com/azure/event-hubs/event-hubs-features)實現消息流,其中每個消費者唯讀取消息流的特定子集或分區。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-364">Event Hubs implements message streaming through a [partitioned consumer model](https://docs.microsoft.com/azure/event-hubs/event-hubs-features) in which each consumer only reads a specific subset, or partition, of the message stream.</span></span> <span data-ttu-id="bf0c0-365">此模式支援大幅的水平擴充來處理事件，並提供佇列和主題所沒有的其他串流功能。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-365">This pattern enables tremendous horizontal scale for event processing and provides other stream-focused features that are unavailable in queues and topics.</span></span> <span data-ttu-id="bf0c0-366">資料分割是經過排序且保存在事件中樞內的事件序列。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-366">A partition is an ordered sequence of events that is held in an event hub.</span></span> <span data-ttu-id="bf0c0-367">當較新的事件到達時,它們將添加到此序列的末尾。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-367">As newer events arrive, they're added to the end of this sequence.</span></span><span data-ttu-id="bf0c0-368">圖 4-19 顯示了事件中心中的分區。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-368"> Figure 4-19 shows partitioning in an Event Hub.</span></span>

![事件中心分割區](./media/event-hub-partitioning.png)

<span data-ttu-id="bf0c0-370">**圖 4-19**.</span><span class="sxs-lookup"><span data-stu-id="bf0c0-370">**Figure 4-19**.</span></span> <span data-ttu-id="bf0c0-371">事件中心分割區</span><span class="sxs-lookup"><span data-stu-id="bf0c0-371">Event Hub partitioning</span></span>

<span data-ttu-id="bf0c0-372">每個使用者組讀取消息流的子集或分區不是從同一資源讀取。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-372">Instead of reading from the same resource, each consumer group reads across a subset, or partition, of the message stream.</span></span>

<span data-ttu-id="bf0c0-373">對於必須流式傳輸大量事件的雲原生應用程式,Azure 事件中心可以是一個強大且經濟實惠的解決方案。</span><span class="sxs-lookup"><span data-stu-id="bf0c0-373">For cloud-native applications that must stream large numbers of events, Azure Event Hub can be a robust and affordable solution.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="bf0c0-374">[前一個](front-end-communication.md)
>[下一個](grpc.md)</span><span class="sxs-lookup"><span data-stu-id="bf0c0-374">[Previous](front-end-communication.md)
[Next](grpc.md)</span></span>
