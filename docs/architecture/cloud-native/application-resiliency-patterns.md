---
title: 應用程式復原模式
description: 架構適用于 Azure 的雲端原生 .NET 應用程式 |應用程式復原模式
ms.date: 06/30/2019
ms.openlocfilehash: 8455584fe1d5b02f6d9543c3bad32cca7369c158
ms.sourcegitcommit: 55f438d4d00a34b9aca9eedaac3f85590bb11565
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/23/2019
ms.locfileid: "71183718"
---
# <a name="application-resiliency-patterns"></a><span data-ttu-id="68276-103">應用程式復原模式</span><span class="sxs-lookup"><span data-stu-id="68276-103">Application resiliency patterns</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="68276-104">第一道防線是具備軟體功能的應用程式恢復功能。</span><span class="sxs-lookup"><span data-stu-id="68276-104">The first line of defense is software-enabled application resiliency.</span></span> 

<span data-ttu-id="68276-105">雖然您可以投入相當長的時間來撰寫自己的復原架構，但這類產品已經存在。</span><span class="sxs-lookup"><span data-stu-id="68276-105">While you could invest considerable time writing your own resiliency framework, such products already exist.</span></span> <span data-ttu-id="68276-106">例如， [Polly](http://www.thepollyproject.org/)是完整的 .net 復原和暫時性錯誤處理程式庫，可讓開發人員以流暢且安全線程的方式來表示復原原則。</span><span class="sxs-lookup"><span data-stu-id="68276-106">For example, [Polly](http://www.thepollyproject.org/) is a comprehensive .NET resilience and transient-fault-handling library that allows developers to express resiliency policies in a fluent and thread-safe manner.</span></span> <span data-ttu-id="68276-107">Polly 是以完整 .NET Framework 或 .NET Core 所建立的應用程式為目標。</span><span class="sxs-lookup"><span data-stu-id="68276-107">Polly targets applications built with either the full .NET Framework or .NET Core.</span></span> <span data-ttu-id="68276-108">圖6-2 顯示可從 Polly 程式庫取得的復原原則（也就是功能）。</span><span class="sxs-lookup"><span data-stu-id="68276-108">Figure 6-2 shows the resiliency policies (that is, functionality) available from the Polly Library.</span></span> <span data-ttu-id="68276-109">這些原則可以個別套用或結合在一起。</span><span class="sxs-lookup"><span data-stu-id="68276-109">These policies can be applied individually or combined together.</span></span>

![Polly 架構](./media/polly-resiliency-framework.png)

<span data-ttu-id="68276-111">**圖 6-2**.</span><span class="sxs-lookup"><span data-stu-id="68276-111">**Figure 6-2**.</span></span> <span data-ttu-id="68276-112">Polly 復原架構功能</span><span class="sxs-lookup"><span data-stu-id="68276-112">Polly resiliency framework features</span></span>

<span data-ttu-id="68276-113">請注意，在上圖中，復原原則會套用至要求訊息，不論是來自外部用戶端還是其他後端服務。</span><span class="sxs-lookup"><span data-stu-id="68276-113">Note how in the previous figure the resiliency policies apply to request messages, whether coming from an external client or another back-end service.</span></span> <span data-ttu-id="68276-114">其目標是要補償可能暫時無法使用之服務的要求。</span><span class="sxs-lookup"><span data-stu-id="68276-114">The goal is to compensate the request for a service that might be momentarily unavailable.</span></span> <span data-ttu-id="68276-115">這些短暫的中斷通常會以 [圖 6-3] 所示的 HTTP 狀態碼來進行資訊清單。</span><span class="sxs-lookup"><span data-stu-id="68276-115">These short interruptions typically manifest themselves with the HTTP status codes shown in Figure 6-3.</span></span>

![要重試的 HTTP 狀態碼](./media/http-status-codes.png)

<span data-ttu-id="68276-117">**圖 6-3**.</span><span class="sxs-lookup"><span data-stu-id="68276-117">**Figure 6-3**.</span></span> <span data-ttu-id="68276-118">要重試的 HTTP 狀態碼</span><span class="sxs-lookup"><span data-stu-id="68276-118">HTTP status codes to retry</span></span>

<span data-ttu-id="68276-119">問題：是否要重試 HTTP 狀態碼 403-禁止？</span><span class="sxs-lookup"><span data-stu-id="68276-119">Question: Would you retry an HTTP Status Code of 403 - Forbidden?</span></span> <span data-ttu-id="68276-120">否。</span><span class="sxs-lookup"><span data-stu-id="68276-120">No.</span></span> <span data-ttu-id="68276-121">在這裡，系統會正常運作，但會通知呼叫者未獲授權執行要求的作業。</span><span class="sxs-lookup"><span data-stu-id="68276-121">Here, the system is functioning properly, but informing the caller that they aren't authorized to perform the requested operation.</span></span> <span data-ttu-id="68276-122">請務必小心，只重試失敗所造成的作業。</span><span class="sxs-lookup"><span data-stu-id="68276-122">Care must be taken to retry only those operations caused by failures.</span></span>

<span data-ttu-id="68276-123">如第1章所建議，建立雲端原生應用程式的 Microsoft 開發人員應該以 .NET Core 為目標。</span><span class="sxs-lookup"><span data-stu-id="68276-123">As recommended in Chapter 1, Microsoft developers constructing cloud-native applications should target .NET Core.</span></span> <span data-ttu-id="68276-124">2\.1 版引進了[HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore)程式庫，可用於建立與 URL 型資源互動的 HTTP 用戶端實例。</span><span class="sxs-lookup"><span data-stu-id="68276-124">Version 2.1 introduced the [HTTPClientFactory](https://www.stevejgordon.co.uk/introduction-to-httpclientfactory-aspnetcore) library for creating HTTP Client instances for interacting with URL-based resources.</span></span> <span data-ttu-id="68276-125">取代原始的 HTTPClient 類別，factory 類別支援許多增強功能，其中一個與 Polly 復原程式庫[緊密整合](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md)。</span><span class="sxs-lookup"><span data-stu-id="68276-125">Superseding the original HTTPClient class, the factory class supports many enhanced features, one of which is [tight integration](../microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly.md) with the Polly resiliency library.</span></span> <span data-ttu-id="68276-126">有了這項功能，您就可以在應用程式啟動類別中輕鬆定義復原原則，以處理部分失敗和連接問題。</span><span class="sxs-lookup"><span data-stu-id="68276-126">With it, you can easily define resiliency policies in the application Startup class to handle partial failures and connectivity issues.</span></span>

<span data-ttu-id="68276-127">接下來，讓我們展開重試和斷路器模式。</span><span class="sxs-lookup"><span data-stu-id="68276-127">Next, let's expand on retry and circuit breaker patterns.</span></span>

### <a name="retry-pattern"></a><span data-ttu-id="68276-128">重試模式</span><span class="sxs-lookup"><span data-stu-id="68276-128">Retry pattern</span></span>

<span data-ttu-id="68276-129">在分散式雲端原生環境中，服務和雲端資源的呼叫可能會因為暫時性（短期）失敗而失敗，這通常會在短時間後自行修正。</span><span class="sxs-lookup"><span data-stu-id="68276-129">In a distributed cloud-native environment, calls to services and cloud resources can fail because of transient (short-lived) failures, which typically correct themselves after a brief period of time.</span></span> <span data-ttu-id="68276-130">執行重試策略可協助雲端原生服務處理這些案例。</span><span class="sxs-lookup"><span data-stu-id="68276-130">Implementing a retry strategy helps a cloud-native service handle these scenarios.</span></span>

<span data-ttu-id="68276-131">[重試模式](https://docs.microsoft.com/azure/architecture/patterns/retry)可讓服務以指數方式增加等候時間，重試失敗的要求作業 a （可設定）的次數。</span><span class="sxs-lookup"><span data-stu-id="68276-131">The [Retry pattern](https://docs.microsoft.com/azure/architecture/patterns/retry) enables a service to retry a failed request operation a (configurable) number of times with an exponentially increasing wait time.</span></span> <span data-ttu-id="68276-132">圖6-4 顯示重試動作。</span><span class="sxs-lookup"><span data-stu-id="68276-132">Figure 6-4 shows a retry in action.</span></span>

![動作中的重試模式](./media/retry-pattern.png)

<span data-ttu-id="68276-134">**圖 6-4**。</span><span class="sxs-lookup"><span data-stu-id="68276-134">**Figure 6-4**.</span></span> <span data-ttu-id="68276-135">動作中的重試模式</span><span class="sxs-lookup"><span data-stu-id="68276-135">Retry pattern in action</span></span>

<span data-ttu-id="68276-136">在上圖中，已針對要求作業實作為重試模式。</span><span class="sxs-lookup"><span data-stu-id="68276-136">In the previous figure, a retry pattern has been implemented for a request operation.</span></span> <span data-ttu-id="68276-137">它會設定為在失敗後的輪詢間隔（等待時間）後最多允許四次重試，每次後續嘗試會以指數方式加倍。</span><span class="sxs-lookup"><span data-stu-id="68276-137">It's configured to allow up to four retries before failing with a backoff interval (wait time) starting at two seconds, which exponentially doubles for each subsequent attempt.</span></span>

- <span data-ttu-id="68276-138">第一個調用失敗，並傳回 HTTP 狀態碼500。</span><span class="sxs-lookup"><span data-stu-id="68276-138">The first invocation fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="68276-139">應用程式會等待兩秒，並 reties 呼叫。</span><span class="sxs-lookup"><span data-stu-id="68276-139">The application waits for two seconds and reties the call.</span></span>
- <span data-ttu-id="68276-140">第二個調用也會失敗，並傳回 HTTP 狀態碼500。</span><span class="sxs-lookup"><span data-stu-id="68276-140">The second invocation also fails and returns an HTTP status code of 500.</span></span> <span data-ttu-id="68276-141">應用程式現在會將輪詢間隔加倍到四秒，然後重試呼叫。</span><span class="sxs-lookup"><span data-stu-id="68276-141">The application now doubles the backoff interval to four seconds and retries the call.</span></span>
- <span data-ttu-id="68276-142">最後，第三個呼叫會成功。</span><span class="sxs-lookup"><span data-stu-id="68276-142">Finally, the third call succeeds.</span></span>
- <span data-ttu-id="68276-143">在此案例中，重試作業最多會嘗試四次重試，同時將輪詢持續時間加倍，再使呼叫失敗。</span><span class="sxs-lookup"><span data-stu-id="68276-143">In this scenario, the retry operation would have attempted up to four retries while doubling the backoff duration before failing the call.</span></span>

<span data-ttu-id="68276-144">請務必增加輪詢期間，再重試呼叫以允許服務時間自行修正。</span><span class="sxs-lookup"><span data-stu-id="68276-144">It's important to increase the backoff period before retrying the call to allow the service time to self-correct.</span></span> <span data-ttu-id="68276-145">最佳做法是實施以指數方式增加的輪詢（每次重試的間隔加倍），以允許適當的更正時間。</span><span class="sxs-lookup"><span data-stu-id="68276-145">It's a best practice to implement an exponentially increasing backoff (doubling the period on each retry) to allow adequate correction time.</span></span>

## <a name="circuit-breaker-pattern"></a><span data-ttu-id="68276-146">斷路器模式</span><span class="sxs-lookup"><span data-stu-id="68276-146">Circuit breaker pattern</span></span>

<span data-ttu-id="68276-147">雖然重試模式可以協助搶救在部分失敗中光子的要求，但在某些情況下，失敗可能是因為無法預期的事件而需要較長的時間來解決。</span><span class="sxs-lookup"><span data-stu-id="68276-147">While the retry pattern can help salvage a request entangled in a partial failure, there are situations where failures can be caused by unanticipated events that will require longer periods of time to resolve.</span></span> <span data-ttu-id="68276-148">這些錯誤的嚴重性可能從失去部分連線到服務完全失敗。</span><span class="sxs-lookup"><span data-stu-id="68276-148">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="68276-149">在這些情況下，應用程式會持續重試不太可能成功的作業，這是無意義的。</span><span class="sxs-lookup"><span data-stu-id="68276-149">In these situations, it's pointless for an application to continually retry an operation that is unlikely to succeed.</span></span>

<span data-ttu-id="68276-150">為了讓事情更糟，在無回應的服務上執行連續的重試作業，可以將您移至自我加諸的阻絕服務案例，其中會持續呼叫耗盡資源（例如記憶體、執行緒和資料庫）來淹沒服務連接，導致系統中使用相同資源的不相關部分發生失敗。</span><span class="sxs-lookup"><span data-stu-id="68276-150">To make things worse, executing continual retry operations on a non-responsive service can move you into a self-imposed denial of service scenario where you flood your service with continual calls exhausting resources such as memory, threads and database connections, causing failure in unrelated parts of the system that use the same resources.</span></span>

<span data-ttu-id="68276-151">在這些情況下，最好是讓作業立即失敗，而且只有在可能成功時才嘗試叫用服務。</span><span class="sxs-lookup"><span data-stu-id="68276-151">In these situations, it would be preferable for the operation to fail immediately and only attempt to invoke the service if it's likely to succeed.</span></span>

<span data-ttu-id="68276-152">[斷路器模式](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker)可防止應用程式重複嘗試執行可能失敗的作業。</span><span class="sxs-lookup"><span data-stu-id="68276-152">The [Circuit Breaker pattern](https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker) can prevent an application from repeatedly trying to execute an operation that's likely to fail.</span></span> <span data-ttu-id="68276-153">它也會透過定期試用呼叫來監視應用程式，以判斷錯誤是否已解決。</span><span class="sxs-lookup"><span data-stu-id="68276-153">It also monitors the application with a periodic trial call to determine whether the fault has resolved.</span></span> <span data-ttu-id="68276-154">圖6-5 顯示作用中的斷路器模式。</span><span class="sxs-lookup"><span data-stu-id="68276-154">Figure 6-5 shows the Circuit Breaker pattern in action.</span></span>

![動作中的斷路器模式](./media/circuit-breaker-pattern.png)

<span data-ttu-id="68276-156">**圖 6-5**。</span><span class="sxs-lookup"><span data-stu-id="68276-156">**Figure 6-5**.</span></span> <span data-ttu-id="68276-157">動作中的斷路器模式</span><span class="sxs-lookup"><span data-stu-id="68276-157">Circuit breaker pattern in action</span></span>

<span data-ttu-id="68276-158">在上圖中，已將斷路器模式新增至原始的重試模式。</span><span class="sxs-lookup"><span data-stu-id="68276-158">In the previous figure, a Circuit Breaker pattern has been added to the original retry pattern.</span></span> <span data-ttu-id="68276-159">請注意，在10次失敗的要求之後，斷路器會開啟，不再允許服務的呼叫。</span><span class="sxs-lookup"><span data-stu-id="68276-159">Note how after 10 failed requests, the circuit breakers opens and no longer allows calls to the service.</span></span> <span data-ttu-id="68276-160">設定為30秒的 CheckCircuit 值會指定程式庫允許一個要求繼續至服務的頻率。</span><span class="sxs-lookup"><span data-stu-id="68276-160">The CheckCircuit value, set at 30 seconds, specifies how often the library allows one request to proceed to the service.</span></span> <span data-ttu-id="68276-161">如果該呼叫成功，則電路會關閉，且服務會再次提供給流量。</span><span class="sxs-lookup"><span data-stu-id="68276-161">If that call succeeds, the circuit closes and the service is once again available to traffic.</span></span>

<span data-ttu-id="68276-162">請記住，斷路器模式的目的與重試模式*不同*。</span><span class="sxs-lookup"><span data-stu-id="68276-162">Keep in mind that the intent of the Circuit Breaker pattern is *different* than that of the Retry pattern.</span></span> <span data-ttu-id="68276-163">重試模式可讓應用程式在預期會成功的情況下重試操作。</span><span class="sxs-lookup"><span data-stu-id="68276-163">The Retry pattern enables an application to retry an operation in the expectation that it will succeed.</span></span> <span data-ttu-id="68276-164">斷路器模式可防止應用程式執行可能失敗的作業。</span><span class="sxs-lookup"><span data-stu-id="68276-164">The Circuit Breaker pattern prevents an application from doing an operation that is likely to fail.</span></span> <span data-ttu-id="68276-165">應用程式通常會使用重試模式*結合*這兩種模式，透過斷路器叫用操作。</span><span class="sxs-lookup"><span data-stu-id="68276-165">Often, an application will *combine* these two patterns by using the Retry pattern to invoke an operation through a circuit breaker.</span></span> <span data-ttu-id="68276-166">不過，重試邏輯應該會受到斷路器所傳回之任何例外狀況的影響，而且如果斷路器指出錯誤不是暫時性的，就會放棄重試嘗試。</span><span class="sxs-lookup"><span data-stu-id="68276-166">However, the retry logic should be sensitive to any exceptions returned by the circuit breaker and abandon retry attempts if the circuit breaker indicates that a fault isn't transient.</span></span>

<span data-ttu-id="68276-167">應用程式復原是處理有問題的要求作業時必須具備的。</span><span class="sxs-lookup"><span data-stu-id="68276-167">Application resiliency is a must for handling problematic requested operations.</span></span> <span data-ttu-id="68276-168">但是，這只是故事的一半而已。</span><span class="sxs-lookup"><span data-stu-id="68276-168">But, it's only half of the story.</span></span> <span data-ttu-id="68276-169">接下來，我們將討論 Azure 雲端中可用的復原功能。</span><span class="sxs-lookup"><span data-stu-id="68276-169">Next, we cover resiliency features available in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="68276-170">[上一頁](resiliency.md)
>[下一頁](infrastructure-resiliency-azure.md)</span><span class="sxs-lookup"><span data-stu-id="68276-170">[Previous](resiliency.md)
[Next](infrastructure-resiliency-azure.md)</span></span>
