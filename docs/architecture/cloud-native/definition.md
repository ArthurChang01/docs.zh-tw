---
title: 雲端原生的定義
description: 瞭解為雲原生系統提供基岩的基礎支柱
author: robvet
ms.date: 08/20/2019
ms.openlocfilehash: 27191a67b2964ac2e1636a4d7dc55d5314b78439
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401568"
---
# <a name="defining-cloud-native"></a>定義雲本機

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

停止你正在做的事情，給10位同事發短信。 請他們定義術語"雲原生"。 很有可能你會得到八個不同的答案。 有趣的是，六個月後，隨著雲原生技術和實踐的發展，它們的定義也會隨之發展。

雲原生就是改變我們構建關鍵業務系統的方式。

雲原生系統旨在適應快速變化、大規模和彈性。

雲原生計算基金會提供了一[個官方的定義](https://github.com/cncf/foundation/blob/master/charter.md)：

> *雲原生技術使組織能夠在公共、私有和混合雲等現代動態環境中構建和運行可擴展的應用程式。容器、服務同理、微服務、不可變基礎結構和聲明性 API 就是此方法的例證。*

> *這些技術支援具有彈性、可管理和可觀測的鬆散耦合系統。結合強大的自動化，它們使工程師能夠以最少的辛勞頻繁、可預見地進行高影響更改。*

隨著使用者要求越來越高，應用程式變得越來越複雜。 使用者期望快速回應、創新功能和零停機時間。 性能問題、反復出現的錯誤和無法快速移動不再為所接受。 他們很容易轉移到你的競爭對手。

雲原生是很多關於*速度和**敏捷*性。 業務系統正在從支援業務能力演變為戰略轉型、加快業務速度和增長的武器。 立即將創意推向市場勢在必行。

以下是一些已經實施了這些技術的公司。 考慮他們實現的速度、敏捷性和可擴充性。

| 公司 | 體驗 |
| :-------- | :-------- |
| [Netflix](https://www.infoq.com/news/2013/06/netflix/) | 有 600 多種生產服務。 每天部署一百次。 |
| [超級](https://eng.uber.com/micro-deploy/) | 生產中存儲了 1，000 多個服務。 每週部署幾千個生成。 |
| [微信](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | 有 300 多種生產服務。 每天進行近 1，000 次更改。 |

正如您所看到的，Netflix、優步和微信公開了由數百個獨立的微服務組成的系統。 這種建築風格使他們能夠快速回應市場條件。 他們可以即時更新即時複雜應用程式的社區域，並根據需要單獨縮放這些區域。

雲原生的速度和敏捷性來自許多因素。 首先是雲基礎架構。 圖 1-3 所示的另外五個基柱也為雲原生系統提供了基岩。

![雲原生基礎支柱](./media/cloud-native-foundational-pillars.png)

**圖1-3**。 雲原生基礎支柱

讓我們花一些時間來更好地瞭解每個支柱的重要性。

## <a name="the-cloud"></a>雲...

雲原生系統充分利用了雲服務模型。

這些系統旨在在動態虛擬化的雲環境中蓬勃發展，廣泛使用[平臺即服務 （PaaS）](https://azure.microsoft.com/overview/what-is-paas/)計算基礎架構和託管服務。 他們將底層基礎架構視為*一次性*基礎結構 - 在幾分鐘內預配，並通過自動化按需調整規模、縮放、移動或銷毀。

考慮廣泛接受的DevOps概念[寵物與牛](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)。 在傳統的資料中心中，伺服器被視為*寵物*：物理機器，被賦予一個有意義的名稱，並受到關注。 通過向同一電腦添加更多資源（向上擴展）進行擴展。 如果伺服器生病，您將將其護理回運行狀況。 如果伺服器不可用，每個人都會注意到。

*牛*服務模式不同。 將每個實例預配為虛擬機器或容器。 它們相同，並分配了系統識別碼，如服務-01、服務-02等。 您可以通過創建更多（向外擴展）進行擴展。 當一個人變得無法接通，沒有人會注意到。

牛模式擁抱*了不變的基礎設施*。 伺服器未修復或修改。 如果一個失敗或需要更新，它將被銷毀，並預配了新的更新 - 所有這些都通過自動化完成。

雲原生系統採用牛服務模式。 它們繼續隨著基礎結構的擴展或運行而運行，而不考慮運行的機器。

Azure 雲平臺支援這種類型的高彈性基礎架構，具有自動縮放、自我修復和監視功能。

## <a name="modern-design"></a>現代設計

您將如何設計雲原生應用？ 您的體系結構是什麼樣子的？ 您會遵循哪些原則、模式和最佳實踐？ 哪些基礎設施和運營問題很重要？

### <a name="the-twelve-factor-application"></a>十二因數應用

構建基於雲的應用程式是一種被廣泛接受的方法是[十二因數應用程式](https://12factor.net/)。 它描述了開發人員遵循的一組原則和實踐，以構建針對現代雲環境優化的應用程式。 特別注意跨環境的可攜性和聲明性自動化。

雖然適用于任何基於 Web 的應用程式，但許多從業者認為它是構建雲原生應用的堅實基礎。 基於這些原則構建的系統可以快速部署和擴展，並添加功能以快速回應市場變化。

下表重點介紹了十二因數方法：

|    |  因數 | 說明  |
| :-------- | :-------- | :-------- |
| 1 | 代碼庫 | 每個微服務的單一代碼庫，存儲在其自己的存儲庫中。 通過版本控制進行跟蹤，它可以部署到多個環境（QA、暫存、生產）。 |
| 2 | 相依性 | 每個微服務隔離和打包自己的依賴項，在不影響整個系統的情況下接受更改。 |
| 3 | 組態  | 配置資訊從微服務中移出，並通過代碼外部的建構管理工具進行外部化。 相同的部署可以在應用正確配置的環境中傳播。  |
| 4 | 支援服務 | 輔助資源（資料存儲、緩存、消息代理）應通過可定址 URL 公開。 這樣做會將資源與應用程式分離，使其可互換。  |
| 5 | 生成、發佈、運行 | 每個版本都必須在生成、發佈和運行階段強制實施嚴格的分離。 每個應標記一個唯一的 ID，並支援回滾的能力。 現代 CI/CD 系統有助於實現這一原則。 |
| 6 | 處理序 | 每個微服務都應在自己的進程中執行，與其他正在運行的服務隔離。 將所需狀態外部化到備份服務（如分散式緩存或資料存儲）。 |
| 7 | 連接埠繫結 | 每個微服務都應自包含其介面和功能，並在其自己的埠上公開。 這樣做會與其他微服務隔離。 |
| 8 | 並行 | 服務將擴展在大量小型相同進程（副本）上，而不是在最強大的電腦上擴展單個大型實例。 |
| 9 | 可處置性 | 服務實例應該是一次性的，有利於快速啟動來增加可伸縮性機會和正常關機，使系統處於正確的狀態。 Docker 容器以及協調器本身就滿足了此要求。 |
| 10 | 開發/昇冪同位 | 使整個應用程式生命週期中的環境盡可能相似，避免昂貴的快捷方式。 在這裡，採用容器可以極大地促進相同的執行環境。 |
| 11 | 記錄 | 將微服務生成的日誌視為事件流。 使用事件聚合器處理它們，並將資料傳播到資料採礦/日誌管理工具（如 Azure 監視器或 Splunk），並最終進行長期存檔。 |
| 12 | 管理流程 | 將管理/管理工作作為一次性流程運行。 任務可以包括報表的資料清理和拉取分析。 執行這些任務的工具應從生產環境調用，但與應用程式分開調用。 |

在《 [十二因素應用》](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)一書中，作者凱文·霍夫曼詳細介紹了最初的12個因素（寫于2011年）。 此外，本書還提供了反映當今現代雲應用程式設計的三個附加因素。

|    |  新因素 | 說明  |
| :-------- | :-------- | :-------- |
| 13 | API 優先 | 使一切成為服務。 假設您的代碼將被前端用戶端、閘道或其他服務使用。 |
| 14 | 遙測 | 在工作站上，您可以深入瞭解應用程式及其行為。 在雲中，你沒有。 確保您的設計包括監視、特定于域和運行狀況/系統資料的集合。 |
| 15 | 身份驗證/授權  | 從一開始就實現標識。 考慮公共雲中可用的[RBAC（基於角色的存取控制）](https://docs.microsoft.com/azure/role-based-access-control/overview)功能。  |

我們將參考本章和整個書中的 12 個以上因素中的許多。

### <a name="critical-design-considerations"></a>關鍵設計注意事項

除了由十二因素方法提供的指導外，在構建分散式系統時，還必須做出一些關鍵的設計決策。

*通信*

前端用戶端應用程式將如何與後端核心服務通信？ 你會允許直接溝通嗎？ 或者，您是否使用提供靈活性、控制和安全性的閘道外觀抽象後端服務？

後端核心服務將如何相互通信？ 您是否允許直接 HTTP 調用導致耦合並影響性能和敏捷性？ 或者，您可以考慮將消息傳送與佇列和主題技術分離？

通信內容詳包括第 4 章，*雲-原生通訊模式*。

*復原*

微服務體系結構將系統從進程內移動到網路通信。 在分散式環境中，當服務 B 未回應服務 A 的呼叫時，您將執行什麼操作？ 當服務 C 暫時不可用，其他調用它的服務將其堆疊並降低系統性能時，會發生什麼情況？

復原能力詳包括第6章，*雲原生彈性*。

*分散式資料*

根據設計，每個微服務封裝自己的資料，通過其公共介面公開操作。 如果是，您如何查詢資料或跨多個服務實現事務？

分散式資料詳包括第 5 章，*雲原生資料模式*。

*身份*

您的服務將如何識別訪問它的人員以及他們擁有哪些許可權？

身份詳包括第8章 *，《身份*》。

## <a name="microservices"></a>微服務

雲原生系統採用微服務，這是構建現代應用程式的常用體系結構風格。

微服務是一組分散式獨立服務，通過共用結構進行交互，具有以下特徵：

- 每個在更大的網域內容中實現特定的業務功能。

- 每個都是自主開發的，可以獨立部署。

- 每個都是自包含封裝自己的資料存儲技術（SQL、NoSQL）和程式設計平臺。

- 每個程式都運行在自己的進程中，並使用標準通訊協定（如 HTTP/HTTPS、WebSocket 或[AMQP）](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)與他人通信。

- 它們組合在一起以形成一個應用程式。

圖 1-4 將整體應用程式方法與微服務方法進行對比。 請注意單體如何由分層體系結構組成，該體系結構在單個進程中執行。 它通常使用關係資料庫。 但是，微服務方法將功能隔離到包含邏輯和資料的獨立服務中。 每個微服務都託管自己的資料存儲。

![單片部署與微服務](./media/monolithic-vs-microservices.png)

**圖 1-4。** 單片部署與微服務

請注意，微服務如何從本章前面討論的[十二因數應用程式中](https://12factor.net/)推廣"一個代碼庫，一個應用程式"原則。

> *因數\#1 指定"每個微服務的單一代碼庫，存儲在其自己的存儲庫中。通過版本控制進行跟蹤，它可以部署到多個環境。*

### <a name="why-microservices"></a>使用微服務的理由？

微服務提供敏捷性。

在本章前面，我們將構建為單一的電子商務應用程式與微服務進行了比較。 在此示例中，我們看到了一些明顯的好處：

- 每個微服務都有自主生命週期，可以獨立發展並頻繁部署。 您不必等待季度版本來部署新功能或更新。 您可以更新複雜應用程式的一小塊區域，從而降低破壞整個系統的風險。

- 每個微服務都可以獨立擴展。 您只擴展那些需要更多處理能力或網路頻寬的服務，而不是將整個應用程式擴展為單個單元。 這種細細微性的擴充方法可更好地控制系統，並有助於在擴展系統部分（而不是所有內容）時降低總體成本。

理解微服務的優秀參考指南是[.NET 微服務：容器化 .NET 應用程式的體系結構](https://docs.microsoft.com/dotnet/standard/microservices-architecture/)。 這本書深入探討了微服務設計和建築。 它是從 Microsoft 免費下載的[全棧微服務參考體系結構](https://github.com/dotnet-architecture/eShopOnContainers)的配套。

### <a name="developing-microservices"></a>開發微服務

微服務可以使用任何現代開發平臺創建。

微軟 .NET 核心平臺是一個絕佳的選擇。 它具有許多內置功能，可簡化微服務開發， 具有免費和開源功能。 .NET 核心是跨平臺的。 可以在 Windows、macOS 和大多數 Linux 風格上構建和運行應用程式。

.NET Core 性能極高，與 Node.js 和其他競爭平臺相比得分很高。 有趣的是[，TechEmpower](https://www.techempower.com/)在許多 Web 應用程式平臺和框架中進行了一套廣泛的[性能基準](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext)測試。 .NET Core 得分在前 10 名 - 遠高於 Node.js 和其他競爭平臺。

.NET 核心由 Microsoft 和 GitHub 上的 .NET 社區維護。

## <a name="containers"></a>容器

如今，在任何有關*雲原生*的對話中，都自然而然地聽到術語*容器*。 在《[雲原生模式](https://www.manning.com/books/cloud-native-patterns)》一書中，作者科妮莉亞·大衛斯指出，"容器是雲原生軟體的一大推動因素。 雲原生計算基金會將微服務容器化作為[雲原生跟蹤地圖](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)的第一步 - 為企業開始雲原生之旅的指導。

將微服務容器化簡單明瞭。 代碼、其依賴項和運行時打包到稱為[容器映射](https://docs.docker.com/glossary/?term=image)的二進位檔案中。 圖像存儲在[容器註冊表](https://caylent.com/container-registries/)中，它充當圖像的存儲庫或庫。 註冊表可以位於開發電腦、資料中心或公共雲中。 Docker 本身通過 Docker [Hub](https://hub.docker.com/)維護公共註冊表。 Azure 雲具有[容器註冊表](https://azure.microsoft.com/services/container-registry/)，用於存儲靠近將運行它們的雲應用程式的容器映射。

如果需要，可以將映射轉換為正在運行的容器實例。 實例在安裝了[容器運行時](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)引擎的任何電腦上運行。 可以根據需要擁有盡可能多的容器化服務的實例。

圖 1-5 顯示了三個不同的微服務，每個微服務都位於其自己的容器中，在單個主機上運行。

![在容器主機上執行的多個容器](./media/hosting-mulitple-containers.png)

**圖 1-5**. 在容器主機上執行的多個容器

請注意每個容器如何維護其自己的依賴項和運行時集，這些依賴項和運行時可能不同。 在這裡，我們看到產品微服務的不同版本在同一主機上運行。 每個容器共用基礎主機作業系統、記憶體和處理器的一個切片，但彼此隔離。

請注意容器模型如何很好地接受[來自十二因數應用程式的](https://12factor.net/)"依賴"原則。

> *因數\#2 指定"每個微服務隔離和打包其自己的依賴項，在不影響整個系統的情況下接受更改。*

容器同時支援 Linux 和 Windows 工作負載。 Azure 雲公開包含這兩者。 有趣的是，Linux，而不是Windows伺服器，已經成為Azure中最流行的作業系統。

雖然存在幾個集裝箱供應商，但 Docker 已經佔據了市場的大部分份額。 該公司一直在推動軟體容器的移動。 它已成為打包、部署和運行雲原生應用程式的實際標準。

### <a name="why-containers"></a>為什麼選擇容器？

容器提供可攜性，並保證跨環境的一致性。 通過將所有內容封裝到單個包中，您將微服務及其依賴項與基礎基礎結構*隔離*開來。

您可以在具有 Docker 運行時引擎的任何環境中部署同一容器。 容器化工作負載還消除了使用框架、軟體庫和運行時引擎預先配置每個環境的費用。

通過共用底層作業系統和主機資源，容器的佔用空間比整個虛擬機器小得多。 較小的大小會增加給定主機可以同時運行的*密度*或微服務的數量。

### <a name="container-orchestration"></a>容器協調流程

雖然 Docker 等工具創建映射並運行容器，但您還需要工具來管理它們。 容器管理使用稱為容器協調器的特殊軟體程式來完成。 大規模運行時，容器編排至關重要。

圖 1-6 顯示了容器協調器提供的管理工作。

![容器協調器執行哪些操作](./media/what-container-orchestrators-do.png)

**圖1-6**. 容器協調器執行哪些操作

下表描述了常見的業務流程任務。

|  工作 | 說明  |
| :-------- | :-------- |
| 排程 | 自動預配容器實例。|
| 親和力/反親和力 | 在附近或相距甚遠的地方預配容器，説明提供可用性和性能。 |
| 健康狀況監視 | 自動檢測並糾正故障。|
| 容錯移轉 | 自動將失敗的實例重新調配到正常運行的電腦。|
| 調整大小 | 自動添加或刪除容器實例以滿足需求。|
| 網路功能 | 管理容器通信的網路覆蓋。|
| 服務探索 | 使容器能夠彼此定位。|
| 輪流升級 | 通過零停機時間部署協調增量升級。 自動回滾有問題的更改。|

請注意，協調器如何接受本章前面討論的[十二因數應用程式中](https://12factor.net/)的可處置性和併發性原則。

> *因數\#9 指定"服務實例應該是一次性的，有利於快速啟動來增加可伸縮性機會和正常關機，使系統處於正確的狀態。Docker 容器以及協調器本身就滿足了這一要求。*

> *因數\#8 指定"服務跨大量小型相同進程（副本）進行橫向擴展，而不是在最強大的電腦上擴展單個大型實例。*

雖然存在多個容器協調器，[但庫伯奈斯](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)已成為雲原生世界的實際標準。 它是一個可移植的、可擴展的開源平臺，用於管理容器化工作負載。

您可以託管自己的 Kubernetes 實例，但隨後您將負責預配和管理其資源-這可能很複雜。 Azure 雲將庫伯奈斯作為託管服務[，Azure 庫伯奈斯服務 （AKS） 。](https://azure.microsoft.com/services/kubernetes-service/) 託管服務允許您充分利用其功能，而無需安裝和維護它。

Azure 庫伯奈斯服務詳細介紹了第 2 章"*擴展雲原生應用程式*"。

## <a name="backing-services"></a>支援服務

雲本機系統依賴于許多不同的輔助資源，如資料存儲、消息代理、監視和標識服務。 這些服務被稱為[支援服務](https://12factor.net/backing-services)。

 圖 1-7 顯示了雲本機系統使用的許多常見支援服務。

![常見的支援服務](./media/common-backing-services.png)

**圖 1-7**. 常見的支援服務

支援服務從本章前面討論的[十二因數應用](https://12factor.net/)中推廣"無國籍"原則。

>*因數\#6*指定，"每個微服務都應在其自己的進程中執行，與其他正在運行的服務隔離。 將所需狀態外部化到備份服務（如分散式緩存或資料存儲）。

您可以託管自己的支援服務，但隨後您將負責許可、預配和管理這些資源。

雲供應商提供種類繁多的*託管支援服務。* 您只需使用該服務，而不是擁有該服務。 供應商大規模運營資源，並負責性能、安全性和維護。 服務中內置了監視、冗余和可用性。 供應商完全支援其託管服務 - 打開票證，他們修復您的問題。

雲原生系統青睞雲供應商的託管支援服務。 時間和工作力的節省很大。 託管您自己的操作風險和遇到麻煩可能會很快變得昂貴。

最佳做法是將備份服務視為*附加資源*，動態繫結到微服務，其中資訊（URL 和憑據）存儲在外部配置中。 本指南在本章前面討論的[十二因數應用程式中](https://12factor.net/)進行了詳細說明。

>*因數\#4*指定支援服務"應通過可定址 URL 公開。 這樣做會將資源與應用程式分離，使其易於互換。

>*因數\#3*指定"配置資訊從微服務中移出，並通過代碼外部的建構管理工具進行外部化。

使用此模式，無需更改代碼即可連接和分離支援服務。 您可以將微服務從 QA 提升為暫存環境。 更新微服務配置以指向暫存中的備份服務，並通過環境變數將設置注入容器。

雲供應商提供 API，以便您與其專有的支援服務進行通信。 這些庫封裝了管道和複雜性。 直接與這些 API 通信會將代碼與備份服務緊密耦合。 最好隔離供應商 API 的實現詳細資訊。 引入仲介層或中間 API，將泛型操作公開給服務代碼。 這種鬆散的耦合使您能夠將一個備份服務交換到另一個備份服務，或者將代碼移動到其他公共雲，而無需更改主線服務代碼。

支援服務將詳細討論第 5 章，*雲原生資料模式*，和第 4 章，*雲-本機通訊模式*。

## <a name="automation"></a>自動化

正如您所看到的，雲原生系統採用微服務、容器和現代系統設計，以實現速度和敏捷性。 但是，這只是故事的一部分。 如何預配這些系統運行的雲環境？ 如何快速部署應用功能和更新？ 你如何全面瞭解情況？

輸入廣泛接受的[基礎結構作為代碼](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)，或 IaC 的實踐。

使用 IaC，您可以自動執行平台佈建和應用程式部署。 您基本上將軟體工程實踐（如測試和版本控制）應用於 DevOps 實踐。 您的基礎架構和部署是自動化、一致且可重複的。

### <a name="automating-infrastructure"></a>自動化基礎架構

Azure[資源管理器](https://azure.microsoft.com/documentation/articles/resource-group-overview/)、Terraform 和 Azure [CLI](https://docs.microsoft.com/cli/azure/)等工具使您能夠以聲明方式編寫所需的雲基礎結構的腳本。 資源名稱、位置、容量和機密是參數化的和動態的。 腳本作為專案的專案版本控制和簽入原始程式碼管理。 調用腳本可跨系統內容（如 QA、暫存和生產）預配一致且可重複的基礎結構。

在引擎蓋下，IaC是冪等的，這意味著你可以運行相同的腳本一遍又一遍沒有副作用。 如果團隊需要進行更改，他們將編輯並重新運行腳本。 只有更新的資源受到影響。

在《[什麼是基礎設施是代碼》](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)一文中，作者 Sam Guckenheimer 描述了"實施 IaC 的團隊如何快速、大規模地提供穩定的環境。 團隊通過代碼表示其環境的所需狀態，避免手動設定環境並增強一致性。 具有 IaC 的基礎結構部署是可重複的，可防止由於配置漂移或缺少依賴項而導致的運行時問題。 DevOps 團隊可以協同使用一套統一的實踐和工具，快速、可靠、大規模地交付應用程式及其支援基礎架構。

### <a name="automating-deployments"></a>自動化部署

前面討論的[十二因數應用程式](https://12factor.net/)要求在將已完成的代碼轉換為正在運行的應用程式時採取單獨的步驟。

> *因數\#5*指定"每個版本必須跨生成、發佈和運行階段強制實施嚴格的分離。 每個都應使用唯一的 ID 標記，並支援回滾的能力。

現代 CI/CD 系統有助於實現這一原則。 它們提供了單獨的部署步驟，有助於確保使用者隨時可用的一致且高品質的代碼。

圖 1-8 顯示了整個部署過程的分離。

![CI/CD 管道中的部署步驟](./media/build-release-run-pipeline.png)

**圖 1-8**. CI/CD 管道中的部署步驟

在上圖中，特別注意任務分離。

開發人員在其開發環境中構造一個功能，通過代碼、運行和調試的所謂"內部迴圈"進行反覆運算。 完成後，該代碼將*推送*到代碼存儲庫中，如 GitHub、Azure DevOps 或 BitBucket。

推送將觸發生成階段，將代碼轉換為二進位專案。 工作使用[持續集成 （CI）](https://martinfowler.com/articles/continuousIntegration.html)管道實現。 它會自動生成、測試和打包應用程式。

發佈階段拾取二進位專案，應用外部應用程式和環境配置資訊，並生成不可變版本。 該版本部署到指定的環境。 工作使用[連續交付 （CD）](https://martinfowler.com/bliki/ContinuousDelivery.html)管道實現。 每個版本都應可識別。 您可以說，"此部署正在運行應用程式的第 2.1.1 版。

最後，在目標執行環境中運行釋放的功能。 版本是不可變的，這意味著任何更改都必須創建新版本。

應用這些實踐，組織已經從根本上改變了它們運送軟體的方式。 許多產品已經從季度發佈遷移到按需更新。 目標是在開發週期的早期發現問題，而問題修復成本較低。 集成之間的持續時間越長，解決問題的成本就越高。  通過集成過程的一致性，團隊可以更頻繁地提交代碼更改，從而提供更好的協作和軟體品質。

### <a name="azure-pipelines"></a>Azure Pipelines

Azure 雲包括名為[Azure 管道](https://azure.microsoft.com/services/devops/pipelines/)的新 CI/CD 服務，該服務是圖 1-9 所示的[Azure DevOps](https://azure.microsoft.com/services/devops/)服務的一部分。

![開發人員中的 Azure 管道](./media/devops-components.png)

**圖 1-9**. Azure 開發人員計畫產品

Azure 管道是一種雲服務，結合了持續集成 （CI） 和持續交付 （CD）。 您可以自動測試、生成代碼並將代碼運送到任何目標。

在 YAML 檔中的代碼中定義管道，以及應用的其他代碼。

- 管道使用代碼進行版本控制，並遵循相同的分支結構。
- 通過在拉取請求和分支生成策略中的代碼評審來驗證更改。
- 使用的每個分支都可以通過修改 azure 管道.yml 檔來自訂生成策略。
- 管道檔將簽入版本控制，如果存在問題，可以進行調查。

Azure 管道服務支援大多數 Git 提供程式，並可以為在 Linux、macOS 或 Windows 平臺上編寫的應用程式生成部署管道。 它包括對JAVA、.NET、JavaScript、Python、PHP、Go、XCode和C++的支援。

>[!div class="step-by-step"]
>[上一個](introduction.md)
>[下一個](candidate-apps.md)
