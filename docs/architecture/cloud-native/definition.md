---
title: 雲端原生的定義
description: 瞭解為雲端原生系統提供探源的基本要素
author: robvet
ms.date: 08/20/2019
ms.openlocfilehash: c99a99ec2cd7a8c4263ae3321d5a836bc40da087
ms.sourcegitcommit: 628e8147ca10187488e6407dab4c4e6ebe0cac47
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/15/2019
ms.locfileid: "72315940"
---
# <a name="defining-cloud-native"></a><span data-ttu-id="b7fc2-103">定義雲端原生</span><span class="sxs-lookup"><span data-stu-id="b7fc2-103">Defining cloud native</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="b7fc2-104">停止您正在進行的工作，以及您的同事的文字10。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-104">Stop what you’re doing and text 10 of your colleagues.</span></span> <span data-ttu-id="b7fc2-105">要求他們定義「雲端原生」一詞。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-105">Ask them to define the term “Cloud Native.”</span></span> <span data-ttu-id="b7fc2-106">好的，您可能會收到八種不同的答案。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-106">Good chance you’ll get eight different answers.</span></span> <span data-ttu-id="b7fc2-107">有趣的是，從現在起算的六個月，隨著雲端原生技術和實務的發展，其定義也會跟著演變。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-107">Interestingly, six months from now, as cloud-native technologies and practices evolve, so will their definition.</span></span>

<span data-ttu-id="b7fc2-108">雲端原生的重點在於改變我們對建立重要商務系統的想法。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-108">Cloud native is all about changing the way we think about constructing critical business systems.</span></span>

<span data-ttu-id="b7fc2-109">雲端原生系統的設計目的是要採用快速的變更、大規模和復原能力。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-109">Cloud-native systems are designed to embrace rapid change, large scale, and resilience.</span></span> 

<span data-ttu-id="b7fc2-110">雲端原生運算基礎提供[官方定義](https://github.com/cncf/foundation/blob/master/charter.md)：</span><span class="sxs-lookup"><span data-stu-id="b7fc2-110">The Cloud Native Computing Foundation provides an [official definition](https://github.com/cncf/foundation/blob/master/charter.md):</span></span>

> <span data-ttu-id="b7fc2-111">*雲端原生技術讓組織能夠在現代化的動態環境（例如公用、私人和混合式雲端）中建立並執行可擴充的應用程式。容器、服務網格、微服務、不可變的基礎結構和宣告式 Api 會範例說明點此方法。*</span><span class="sxs-lookup"><span data-stu-id="b7fc2-111">*Cloud-native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.*</span></span>

> <span data-ttu-id="b7fc2-112">*這些技術可讓您以具有彈性、容易管理和觀察的鬆散耦合系統。結合強大的自動化功能，讓工程師能夠以最少的辛勞，經常且可預測的方式進行高影響力的變更。*</span><span class="sxs-lookup"><span data-stu-id="b7fc2-112">*These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.*</span></span>

<span data-ttu-id="b7fc2-113">隨著使用者的需求越來越多，應用程式也變得越來越複雜。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-113">Applications have become increasingly complex with users demanding more and more.</span></span> <span data-ttu-id="b7fc2-114">使用者預期快速回應能力、創新功能和零停機時間。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-114">Users expect rapid responsiveness, innovative features, and zero downtime.</span></span> <span data-ttu-id="b7fc2-115">效能問題、週期性錯誤和無法移動的速度已不再接受。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-115">Performance problems, recurring errors, and the inability to move fast are no longer acceptable.</span></span> <span data-ttu-id="b7fc2-116">他們可以輕鬆地移到您的競爭對手。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-116">They'll easily move to your competitor.</span></span>

<span data-ttu-id="b7fc2-117">雲端原生的*速度*與*靈活性*很多。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-117">Cloud native is much about *speed* and *agility*.</span></span> <span data-ttu-id="b7fc2-118">商務系統的發展，是讓商業功能能夠在策略轉型的武器，加速業務速度和成長。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-118">Business systems are evolving from enabling business capabilities to weapons of strategic transformation, accelerating business velocity and growth.</span></span> <span data-ttu-id="b7fc2-119">請務必立即將想法推向市場。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-119">It’s imperative to get ideas to market immediately.</span></span> 

<span data-ttu-id="b7fc2-120">以下是一些已實行這些技術的公司。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-120">Here are some companies who have implemented these techniques.</span></span> <span data-ttu-id="b7fc2-121">思考他們所達成的速度、靈活性和擴充性。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-121">Think about the speed, agility, and scalability they've achieved.</span></span>

| <span data-ttu-id="b7fc2-122">公司</span><span class="sxs-lookup"><span data-stu-id="b7fc2-122">Company</span></span> | <span data-ttu-id="b7fc2-123">遇到</span><span class="sxs-lookup"><span data-stu-id="b7fc2-123">Experience</span></span> | 
| :-------- | :-------- |
| [<span data-ttu-id="b7fc2-124">Netflix</span><span class="sxs-lookup"><span data-stu-id="b7fc2-124">Netflix</span></span>](https://www.infoq.com/news/2013/06/netflix/) | <span data-ttu-id="b7fc2-125">在生產環境中有600個以上的服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-125">Has 600+ services in production.</span></span> <span data-ttu-id="b7fc2-126">每天部署一百次。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-126">Deploys a hundred times per day.</span></span> |
| [<span data-ttu-id="b7fc2-127">Uber</span><span class="sxs-lookup"><span data-stu-id="b7fc2-127">Uber</span></span>](https://eng.uber.com/micro-deploy/) | <span data-ttu-id="b7fc2-128">在生產環境中儲存了1000項以上的服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-128">Has 1,000+ services stored in production.</span></span> <span data-ttu-id="b7fc2-129">每週部署數千個組建。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-129">Deploys several thousand builds each week.</span></span> | 
| [<span data-ttu-id="b7fc2-130">WeChat</span><span class="sxs-lookup"><span data-stu-id="b7fc2-130">WeChat</span></span>](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | <span data-ttu-id="b7fc2-131">在生產環境中有300個以上的服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-131">Has 300+ services in production.</span></span> <span data-ttu-id="b7fc2-132">每天會進行大約1000的變更。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-132">Makes almost 1,000 changes per day.</span></span> |

<span data-ttu-id="b7fc2-133">如您所見，Netflix、Uber 和 WeChat 會公開由數百個獨立微服務所組成的系統。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-133">As you can see, Netflix, Uber, and WeChat expose systems that consist of hundreds of independent microservices.</span></span> <span data-ttu-id="b7fc2-134">此架構樣式可讓他們快速回應市場狀況。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-134">This architectural style enables them to rapidly respond to market conditions.</span></span> <span data-ttu-id="b7fc2-135">他們可以立即更新即時、複雜應用程式的小型區域，並視需要個別調整這些區域。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-135">They can instantaneously update small areas of a live, complex application, and individually scale those areas as needed.</span></span>

<span data-ttu-id="b7fc2-136">雲端原生的速度與靈活性來自數個因素。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-136">The speed and agility of cloud native come about from a number of factors.</span></span> <span data-ttu-id="b7fc2-137">最重要的是雲端基礎結構。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-137">Foremost is cloud infrastructure.</span></span> <span data-ttu-id="b7fc2-138">圖1-3 中所示的五個額外基礎要素也會提供雲端原生系統的探源。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-138">Five additional foundational pillars shown in Figure 1-3 also provide the bedrock for cloud-native systems.</span></span>

![雲端原生基本要素](./media/cloud-native-foundational-pillars.png)

<span data-ttu-id="b7fc2-140">**圖 1-3**。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-140">**Figure 1-3**.</span></span> <span data-ttu-id="b7fc2-141">雲端原生基本要素</span><span class="sxs-lookup"><span data-stu-id="b7fc2-141">Cloud-native foundational pillars</span></span>

<span data-ttu-id="b7fc2-142">讓我們花一些時間進一步瞭解每個要件的重要性。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-142">Let’s take some time to better understand the significance of each pillar.</span></span>

## <a name="the-cloud"></a><span data-ttu-id="b7fc2-143">雲端 。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-143">The cloud…</span></span>

<span data-ttu-id="b7fc2-144">雲端原生系統會充分利用雲端服務模型。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-144">Cloud-native systems take full advantage of the cloud service model.</span></span>

<span data-ttu-id="b7fc2-145">這些系統是設計成在動態、虛擬化的雲端環境中，可廣泛使用[平臺即服務（PaaS）](https://azure.microsoft.com/overview/what-is-paas/)計算基礎結構和受控服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-145">Designed to thrive in a dynamic, virtualized cloud environment, these systems make extensive use of [Platform as a Service (PaaS)](https://azure.microsoft.com/overview/what-is-paas/) compute infrastructure and managed services.</span></span> <span data-ttu-id="b7fc2-146">它們會在幾分鐘內將基礎結構視為可*處置*布建，並在需要時調整大小、縮放、移動或損毀–透過自動化。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-146">They treat the underlying infrastructure as *disposable* - provisioned in minutes and resized, scaled, moved, or destroyed on demand – via automation.</span></span>

<span data-ttu-id="b7fc2-147">請考慮已廣泛接受的[寵物與牛群完全轉換](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)DevOps 概念。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-147">Consider the widely accepted DevOps concept of [Pets vs. Cattle](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313).</span></span> <span data-ttu-id="b7fc2-148">在傳統的資料中心，伺服器會被視為*寵物*：實體機器、指定有意義的名稱，以及的關心。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-148">In a traditional data center, servers are treated as *Pets*: a physical machine, given a meaningful name, and cared for.</span></span> <span data-ttu-id="b7fc2-149">您可以將更多資源新增至同一部電腦（相應增加）來調整規模。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-149">You scale by adding more resources to the same machine (scaling up).</span></span> <span data-ttu-id="b7fc2-150">如果伺服器變成病假，您會將它返回健康狀態。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-150">If the server becomes sick, you nurse it back to health.</span></span> <span data-ttu-id="b7fc2-151">萬一伺服器變得無法使用，每個人都會注意到。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-151">Should the server become unavailable, everyone notices.</span></span>

<span data-ttu-id="b7fc2-152">*牛群完全轉換*服務模型不同。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-152">The *Cattle* service model is different.</span></span> <span data-ttu-id="b7fc2-153">您會將每個實例布建為虛擬機器或容器。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-153">You provision each instance as a virtual machine or container.</span></span> <span data-ttu-id="b7fc2-154">它們是相同的，而且指派了系統識別碼，例如，服務-01、Service-02 等等。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-154">They're identical and assigned a system identifier such as Service-01, Service-02, and so on.</span></span> <span data-ttu-id="b7fc2-155">您可以藉由建立更多專案來進行調整（向外延展）。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-155">You scale by creating more of them (scaling out).</span></span> <span data-ttu-id="b7fc2-156">當其中一個變成無法使用時，沒有人會注意到。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-156">When one becomes unavailable, nobody notices.</span></span>

<span data-ttu-id="b7fc2-157">牛群完全轉換模型會涵蓋固定的*基礎結構*。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-157">The cattle model embraces *immutable infrastructure*.</span></span> <span data-ttu-id="b7fc2-158">伺服器不會進行修復或修改。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-158">Servers aren't repaired or modified.</span></span> <span data-ttu-id="b7fc2-159">如果其中一個失敗或需要更新，它會被終結並布建一個新的–全都透過自動化完成。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-159">If one fails or requires updating, it's destroyed and a new one is provisioned – all done via automation.</span></span>

<span data-ttu-id="b7fc2-160">雲端原生系統採用牛群完全轉換服務模型。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-160">Cloud-native systems embrace the Cattle service model.</span></span> <span data-ttu-id="b7fc2-161">它們會繼續執行，因為基礎結構會相應縮小或相應放大，而不考慮其執行所在的電腦。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-161">They continue to run as the infrastructure scales in or out with no regard to the machines upon which they're running.</span></span>

<span data-ttu-id="b7fc2-162">Azure 雲端平臺支援這種高度彈性的基礎結構，其中包含自動調整、自我修復和監視功能。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-162">The Azure cloud platform supports this type of highly elastic infrastructure with automatic scaling, self-healing, and monitoring capabilities.</span></span>

## <a name="modern-design"></a><span data-ttu-id="b7fc2-163">現代化設計</span><span class="sxs-lookup"><span data-stu-id="b7fc2-163">Modern design</span></span>

<span data-ttu-id="b7fc2-164">您要如何設計雲端原生應用程式？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-164">How would you design a cloud-native app?</span></span> <span data-ttu-id="b7fc2-165">您的架構看起來是什麼樣子？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-165">What would your architecture look like?</span></span> <span data-ttu-id="b7fc2-166">您會遵守哪些原則、模式和最佳作法？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-166">To what principles, patterns, and best practices would you adhere?</span></span> <span data-ttu-id="b7fc2-167">什麼是基礎結構和操作考慮很重要？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-167">What infrastructure and operational concerns would be important?</span></span>

### <a name="the-twelve-factor-application"></a><span data-ttu-id="b7fc2-168">十二因素應用程式</span><span class="sxs-lookup"><span data-stu-id="b7fc2-168">The Twelve-Factor Application</span></span>

<span data-ttu-id="b7fc2-169">可廣泛接受用來建立雲端式應用程式的方法是[十二因素應用程式](https://12factor.net/)。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-169">A widely accepted methodology for constructing cloud-based applications is the [Twelve-Factor Application](https://12factor.net/).</span></span> <span data-ttu-id="b7fc2-170">其中說明開發人員遵循的一組原則和作法，來建造針對現代化雲端環境優化的應用程式。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-170">It describes a set of principles and practices that developers follow to construct applications optimized for modern cloud environments.</span></span> <span data-ttu-id="b7fc2-171">在環境和宣告式自動化之間提供可攜性的特別注意。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-171">Special attention is given to portability across environments and declarative automation.</span></span>

<span data-ttu-id="b7fc2-172">在適用于任何 web 應用程式的情況下，許多開發人員會將其視為建立雲端原生應用程式的穩固基礎。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-172">While applicable to any web-based application, many practitioners consider it as a solid foundation for building cloud-native apps.</span></span> <span data-ttu-id="b7fc2-173">根據這些原則建立的系統可以快速部署和調整規模，並新增功能，以快速回應市場變化。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-173">Systems built upon these principles can deploy and scale rapidly and add features to react quickly to market changes.</span></span>

<span data-ttu-id="b7fc2-174">下表將重點放在十二個要素的方法：</span><span class="sxs-lookup"><span data-stu-id="b7fc2-174">The following table highlights the Twelve-Factor methodology:</span></span>

|    |  <span data-ttu-id="b7fc2-175">因素</span><span class="sxs-lookup"><span data-stu-id="b7fc2-175">Factor</span></span> | <span data-ttu-id="b7fc2-176">說明</span><span class="sxs-lookup"><span data-stu-id="b7fc2-176">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="b7fc2-177">1</span><span class="sxs-lookup"><span data-stu-id="b7fc2-177">1</span></span> | <span data-ttu-id="b7fc2-178">程式碼基底</span><span class="sxs-lookup"><span data-stu-id="b7fc2-178">Code Base</span></span> | <span data-ttu-id="b7fc2-179">每個微服務的單一程式碼基底，儲存在自己的存放庫中。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-179">A single code base for each microservice, stored in its own repository.</span></span> <span data-ttu-id="b7fc2-180">透過版本控制進行追蹤，它可以部署到多個環境（QA、預備、生產）。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-180">Tracked with version control, it can deploy to multiple environments (QA, Staging, Production).</span></span> |
| <span data-ttu-id="b7fc2-181">2</span><span class="sxs-lookup"><span data-stu-id="b7fc2-181">2</span></span> | <span data-ttu-id="b7fc2-182">相依性</span><span class="sxs-lookup"><span data-stu-id="b7fc2-182">Dependencies</span></span> | <span data-ttu-id="b7fc2-183">每個微服務都會隔離並封裝自己的相依性，並在不影響整個系統的情況下進行變更。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-183">Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system.</span></span> |
| <span data-ttu-id="b7fc2-184">3</span><span class="sxs-lookup"><span data-stu-id="b7fc2-184">3</span></span> | <span data-ttu-id="b7fc2-185">組態</span><span class="sxs-lookup"><span data-stu-id="b7fc2-185">Configurations</span></span>  | <span data-ttu-id="b7fc2-186">設定資訊會從微服務和外部化移出，並透過程式碼之外的設定管理工具。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-186">Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code.</span></span> <span data-ttu-id="b7fc2-187">相同的部署可以跨已套用正確設定的環境進行傳播。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-187">The same deployment can propagate across environments with the correct configuration applied.</span></span>  |
| <span data-ttu-id="b7fc2-188">4</span><span class="sxs-lookup"><span data-stu-id="b7fc2-188">4</span></span> | <span data-ttu-id="b7fc2-189">支援服務</span><span class="sxs-lookup"><span data-stu-id="b7fc2-189">Backing Services</span></span> | <span data-ttu-id="b7fc2-190">輔助資源（資料存放區、快取、訊息代理程式）應透過可定址的 URL 公開。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-190">Ancillary resources (data stores, caches, message brokers) should be exposed via an addressable URL.</span></span> <span data-ttu-id="b7fc2-191">這麼做會將資源與應用程式分離，使其可互換。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-191">Doing so decouples the resource from the application, enabling it to be interchangeable.</span></span>  |
| <span data-ttu-id="b7fc2-192">5</span><span class="sxs-lookup"><span data-stu-id="b7fc2-192">5</span></span> | <span data-ttu-id="b7fc2-193">組建、發行、執行</span><span class="sxs-lookup"><span data-stu-id="b7fc2-193">Build, Release, Run</span></span> | <span data-ttu-id="b7fc2-194">每個版本都必須在組建、發行和執行階段強制執行嚴格的分隔。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-194">Each release must enforce a strict separation across the build, release, and run stages.</span></span> <span data-ttu-id="b7fc2-195">每個都應該以唯一識別碼標記，並支援復原的能力。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-195">Each should be tagged with a unique ID and support the ability to roll back.</span></span> <span data-ttu-id="b7fc2-196">新式 CI/CD 系統有助於滿足此原則。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-196">Modern CI/CD systems help fulfill this principle.</span></span> |
| <span data-ttu-id="b7fc2-197">6</span><span class="sxs-lookup"><span data-stu-id="b7fc2-197">6</span></span> | <span data-ttu-id="b7fc2-198">處理序</span><span class="sxs-lookup"><span data-stu-id="b7fc2-198">Processes</span></span> | <span data-ttu-id="b7fc2-199">每個微服務都應該在它自己的進程中執行，與其他正在執行的服務隔離。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-199">Each microservice should execute in its own process,  isolated from other running services.</span></span> <span data-ttu-id="b7fc2-200">將需要的狀態外部化至支援服務，例如分散式快取或資料存放區。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-200">Externalize required state to a backing service such as a distributed cache or data store.</span></span> |
| <span data-ttu-id="b7fc2-201">7</span><span class="sxs-lookup"><span data-stu-id="b7fc2-201">7</span></span> | <span data-ttu-id="b7fc2-202">埠系結</span><span class="sxs-lookup"><span data-stu-id="b7fc2-202">Port Binding</span></span> | <span data-ttu-id="b7fc2-203">每個微服務都應該各自獨立于其本身的埠上公開的介面和功能。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-203">Each microservice should be self-contained with its interfaces and functionality exposed on its own port.</span></span> <span data-ttu-id="b7fc2-204">這麼做會提供與其他微服務的隔離。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-204">Doing so provides isolation from other microservices.</span></span> |
| <span data-ttu-id="b7fc2-205">8</span><span class="sxs-lookup"><span data-stu-id="b7fc2-205">8</span></span> | <span data-ttu-id="b7fc2-206">並行</span><span class="sxs-lookup"><span data-stu-id="b7fc2-206">Concurrency</span></span> | <span data-ttu-id="b7fc2-207">服務會在大量的小型相同進程（複本）上相應放大，而不是在最強大的電腦上相應增加單一大型實例。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-207">Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available.</span></span> |
| <span data-ttu-id="b7fc2-208">9</span><span class="sxs-lookup"><span data-stu-id="b7fc2-208">9</span></span> | <span data-ttu-id="b7fc2-209">Disposability</span><span class="sxs-lookup"><span data-stu-id="b7fc2-209">Disposability</span></span> | <span data-ttu-id="b7fc2-210">服務實例應可處置，優先列出快速新創公司，以增加擴充性機會和正常關機，讓系統處於正確的狀態。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-210">Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state.</span></span> <span data-ttu-id="b7fc2-211">Docker 容器和協調器原本就能滿足這項需求。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-211">Docker containers along with an orchestrator inherently satisfy this requirement.</span></span> |
| <span data-ttu-id="b7fc2-212">10</span><span class="sxs-lookup"><span data-stu-id="b7fc2-212">10</span></span> | <span data-ttu-id="b7fc2-213">開發/生產同位</span><span class="sxs-lookup"><span data-stu-id="b7fc2-213">Dev/Prod Parity</span></span> | <span data-ttu-id="b7fc2-214">盡可能讓應用程式生命週期中的環境保持相似，以避免昂貴的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-214">Keep environments across the application lifecycle as similar as possible, avoiding costly shortcuts.</span></span> <span data-ttu-id="b7fc2-215">在這裡，您可以藉由升級相同的執行環境，大幅提升容器的採用。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-215">Here, the adoption of containers can greatly contribute by promoting the same execution environment.</span></span> |
| <span data-ttu-id="b7fc2-216">11</span><span class="sxs-lookup"><span data-stu-id="b7fc2-216">11</span></span> | <span data-ttu-id="b7fc2-217">記錄</span><span class="sxs-lookup"><span data-stu-id="b7fc2-217">Logging</span></span> | <span data-ttu-id="b7fc2-218">將微服務產生的記錄視為事件資料流程。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-218">Treat logs generated by microservices as event streams.</span></span> <span data-ttu-id="b7fc2-219">使用事件匯總工具處理它們，並將資料傳播至資料採礦/記錄管理工具，例如 Azure 監視器或 Splunk，以及最終長期保存。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-219">Process them with an event aggregator and propagate the data to data-mining/log management tools like Azure Monitor or Splunk and eventually long-term archival.</span></span> |
| <span data-ttu-id="b7fc2-220">12</span><span class="sxs-lookup"><span data-stu-id="b7fc2-220">12</span></span> | <span data-ttu-id="b7fc2-221">管理進程</span><span class="sxs-lookup"><span data-stu-id="b7fc2-221">Admin Processes</span></span> | <span data-ttu-id="b7fc2-222">以一次性程式的形式執行系統管理/管理工作。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-222">Run administrative/management tasks as one-off processes.</span></span> <span data-ttu-id="b7fc2-223">工作可以包含資料清除和提取報表的分析。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-223">Tasks can include data cleanup and pulling analytics for a report.</span></span> <span data-ttu-id="b7fc2-224">執行這些工作的工具應從生產環境叫用，但與應用程式分開。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-224">Tools executing these tasks should be  invoked from the production environment, but separately from the application.</span></span> |

<span data-ttu-id="b7fc2-225">除了 [12 個要素的應用程式之外](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)，作者古柯 Hoffman 會詳細說明每一個原始12因素（以2011撰寫）。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-225">In the book, [Beyond the Twelve-Factor App](https://content.pivotal.io/blog/beyond-the-twelve-factor-app), author Kevin Hoffman details each of the original 12 factors (written in 2011).</span></span> <span data-ttu-id="b7fc2-226">此外，本書還提供其他三個因素來反映現今現代化的雲端應用程式設計。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-226">Additionally, the book provides three additional factors that reflect today's modern cloud application design.</span></span>

|    |  <span data-ttu-id="b7fc2-227">新因素</span><span class="sxs-lookup"><span data-stu-id="b7fc2-227">New Factor</span></span> | <span data-ttu-id="b7fc2-228">說明</span><span class="sxs-lookup"><span data-stu-id="b7fc2-228">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="b7fc2-229">13</span><span class="sxs-lookup"><span data-stu-id="b7fc2-229">13</span></span> | <span data-ttu-id="b7fc2-230">API 第一個</span><span class="sxs-lookup"><span data-stu-id="b7fc2-230">API First</span></span> | <span data-ttu-id="b7fc2-231">將所有專案變成一項服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-231">Make everything a service.</span></span> <span data-ttu-id="b7fc2-232">假設您的程式碼將由前端用戶端使用。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-232">Assume your code will be consumed by a front-end client.</span></span> <span data-ttu-id="b7fc2-233">閘道或其他服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-233">gateway or another service.</span></span> |
| <span data-ttu-id="b7fc2-234">14</span><span class="sxs-lookup"><span data-stu-id="b7fc2-234">14</span></span> | <span data-ttu-id="b7fc2-235">遙測</span><span class="sxs-lookup"><span data-stu-id="b7fc2-235">Telemetry</span></span> | <span data-ttu-id="b7fc2-236">在工作站上，您可以深入瞭解您的應用程式及其行為。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-236">On a workstation, you have deep visibility into your application and its behavior.</span></span> <span data-ttu-id="b7fc2-237">在雲端中，您不會這麼做。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-237">In the cloud, you don't.</span></span> <span data-ttu-id="b7fc2-238">請確定您的設計包含「監視」、「網域特定」和「健康情況/系統」資料的集合。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-238">Make sure your design includes the collection of monitoring, domain-specific, and health/system data.</span></span> |
| <span data-ttu-id="b7fc2-239">15</span><span class="sxs-lookup"><span data-stu-id="b7fc2-239">15</span></span> | <span data-ttu-id="b7fc2-240">驗證/授權</span><span class="sxs-lookup"><span data-stu-id="b7fc2-240">Authentication/ Authorization</span></span>  | <span data-ttu-id="b7fc2-241">從起始處執行身分識別。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-241">Implement identity from the start.</span></span> <span data-ttu-id="b7fc2-242">請考慮公用雲端中可用的[RBAC （角色型存取控制）](https://docs.microsoft.com/azure/role-based-access-control/overview)功能。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-242">Consider [RBAC (role-based access control)](https://docs.microsoft.com/azure/role-based-access-control/overview) features available in public clouds.</span></span>  |

<span data-ttu-id="b7fc2-243">我們將在這一章和整本書中參考許多12個以上的因素。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-243">We'll refer to many of the 12+ factors in this chapter and throughout the book.</span></span>

### <a name="critical-design-considerations"></a><span data-ttu-id="b7fc2-244">重大設計考慮</span><span class="sxs-lookup"><span data-stu-id="b7fc2-244">Critical Design Considerations</span></span>

<span data-ttu-id="b7fc2-245">除了12因素方法所提供的指引之外，在您建立分散式系統時，您必須進行幾項重要的設計決策。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-245">Beyond the guidance provided from the twelve-factor methodology, there are several critical design decisions you must make when constructing distributed systems.</span></span>

<span data-ttu-id="b7fc2-246">*交流*</span><span class="sxs-lookup"><span data-stu-id="b7fc2-246">*Communication*</span></span>

<span data-ttu-id="b7fc2-247">前端用戶端應用程式會如何與支援的端核心服務通訊？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-247">How will front-end client applications communicate with backed-end core services?</span></span> <span data-ttu-id="b7fc2-248">您是否允許直接通訊？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-248">Will you allow direct communication?</span></span> <span data-ttu-id="b7fc2-249">或者，您可以使用提供彈性、控制和安全性的閘道外觀來抽象化後端服務嗎？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-249">Or, might you abstract the back-end services with a gateway façade that provides  flexibility, control, and security?</span></span>

<span data-ttu-id="b7fc2-250">後端核心服務會如何彼此通訊？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-250">How will back-end core services communicate with each other?</span></span> <span data-ttu-id="b7fc2-251">您是否允許直接 HTTP 呼叫導致結合性和影響效能和靈活性？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-251">Will you allow direct HTTP calls that lead to coupling and impact performance and agility?</span></span> <span data-ttu-id="b7fc2-252">或者，您可以考慮使用佇列和主題技術來分離訊息嗎？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-252">Or might you consider decoupled messaging with queue and topic technologies?</span></span>

<span data-ttu-id="b7fc2-253">通訊詳述于第4章，也就是*雲端原生通訊模式*。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-253">Communication is covered in detail Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

<span data-ttu-id="b7fc2-254">*恢復*</span><span class="sxs-lookup"><span data-stu-id="b7fc2-254">*Resiliency*</span></span>

<span data-ttu-id="b7fc2-255">微服務架構會將您的系統從同進程移動到網路通訊。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-255">A microservices architecture moves your system from in-process to network communication.</span></span> <span data-ttu-id="b7fc2-256">在分散式環境中，當服務 B 未回應來自服務 A 的呼叫時，您會怎麼做？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-256">In a distributed environment, what will you do when Service B isn't responding to a call from Service A?</span></span> <span data-ttu-id="b7fc2-257">當服務 C 暫時無法使用，且其他服務呼叫它堆疊並降低系統效能時，會發生什麼事？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-257">What happens when Service C becomes up temporarily unavailable and other services calling it stack and degrade system performance?</span></span>

<span data-ttu-id="b7fc2-258">復原功能詳述于第6章，也就是*雲端原生復原*。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-258">Resiliency is covered in detail Chapter 6, *Cloud-Native Resiliency*.</span></span>

<span data-ttu-id="b7fc2-259">*分散式資料*</span><span class="sxs-lookup"><span data-stu-id="b7fc2-259">*Distributed Data*</span></span>

<span data-ttu-id="b7fc2-260">根據設計，每個微服務都會封裝自己的資料，透過其公用介面公開作業。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-260">By design, each microservice encapsulates its own data, exposing operations via its public interface.</span></span> <span data-ttu-id="b7fc2-261">若是如此，您要如何查詢資料或跨多個服務執行交易？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-261">If so, how do you query data or implement a transaction across multiple services?</span></span>

<span data-ttu-id="b7fc2-262">分散式資料詳述于第5章，也就是*雲端原生資料模式*。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-262">Distributed data is covered in detail Chapter 5, *Cloud-Native Data Patterns*.</span></span>

<span data-ttu-id="b7fc2-263">*識別*</span><span class="sxs-lookup"><span data-stu-id="b7fc2-263">*Identity*</span></span>

<span data-ttu-id="b7fc2-264">您的服務如何識別誰正在存取它，以及他們有哪些許可權？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-264">How will your service identify who is accessing it and what permissions they have?</span></span>

<span data-ttu-id="b7fc2-265">身分識別詳述于第8章，身分*識別*。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-265">Identity is covered in detail Chapter 8, *Identity*.</span></span>

## <a name="microservices"></a><span data-ttu-id="b7fc2-266">微服務</span><span class="sxs-lookup"><span data-stu-id="b7fc2-266">Microservices</span></span>
<span data-ttu-id="b7fc2-267">雲端原生系統採用微服務，這是用來建立現代化應用程式的熱門架構樣式。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-267">Cloud-native systems embrace microservices, a popular architectural style for constructing modern applications.</span></span>

<span data-ttu-id="b7fc2-268">建立為一組分散式的小型獨立服務，透過共用網狀架構進行互動，微服務會共用下列特性：</span><span class="sxs-lookup"><span data-stu-id="b7fc2-268">Built as a distributed set of small, independent services that interact through a shared fabric, microservices share the following characteristics:</span></span>

- <span data-ttu-id="b7fc2-269">每個都會在較大的網域內容中執行特定的商務功能。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-269">Each implements a specific business capability within a larger domain context.</span></span>

- <span data-ttu-id="b7fc2-270">每個都是自主開發，而且可以獨立部署。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-270">Each is developed autonomously and can be deployed independently.</span></span>

- <span data-ttu-id="b7fc2-271">各自獨立封裝自己的資料儲存技術（SQL、NoSQL）和程式設計平臺。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-271">Each is self-contained encapsulating its own data storage technology (SQL, NoSQL) and programming platform.</span></span>

- <span data-ttu-id="b7fc2-272">每個都會在自己的進程中執行，並使用標準通訊協定（例如 HTTP/HTTPS、Websocket 或[AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)）與其他人進行通訊。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-272">Each runs in its own process and communicates with others using standard communication protocols such as HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span>

- <span data-ttu-id="b7fc2-273">它們組合在一起，以形成應用程式。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-273">They compose together to form an application.</span></span>

<span data-ttu-id="b7fc2-274">圖1-4 將整合型應用程式方法與微服務方法做對比。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-274">Figure 1-4 contrasts a monolithic application approach with a microservices approach.</span></span> <span data-ttu-id="b7fc2-275">請注意單體如何由多層式架構組成，這會在單一進程中執行。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-275">Note how the monolith is composed of a layered architecture, which executes in a single process.</span></span> <span data-ttu-id="b7fc2-276">它通常會使用關係資料庫。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-276">It typically consumes a relational database.</span></span> <span data-ttu-id="b7fc2-277">不過，微服務方法會將功能都會隔離到包含邏輯和資料的獨立服務中。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-277">The microservice approach, however, segregates functionality into independent services that include logic and data.</span></span> <span data-ttu-id="b7fc2-278">每個微服務都會裝載自己的資料存放區。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-278">Each microservice hosts its own datastore.</span></span>

![整合型部署與微服務](./media/monolithic-vs-microservices.png)

<span data-ttu-id="b7fc2-280">**圖1-4。**</span><span class="sxs-lookup"><span data-stu-id="b7fc2-280">**Figure 1-4.**</span></span> <span data-ttu-id="b7fc2-281">整合型部署與微服務</span><span class="sxs-lookup"><span data-stu-id="b7fc2-281">Monolithic deployment versus microservices</span></span>

<span data-ttu-id="b7fc2-282">請注意，微服務如何從[十二個要素的應用程式](https://12factor.net/)升級「一個程式碼基底，一個應用程式」原則，這章節稍早所討論。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-282">Note how microservices promote the "One Codebase, One Application" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="b7fc2-283">*因素 \#1 指定每個微服務的單一程式碼基底，並儲存在其本身的存放庫中。以版本控制進行追蹤，它可以部署到多個環境。」*</span><span class="sxs-lookup"><span data-stu-id="b7fc2-283">*Factor \#1  specifies "A single codebase for each microservice, stored in its own repository. Tracked with version control, it can deploy to multiple environments."*</span></span>

### <a name="why-microservices"></a><span data-ttu-id="b7fc2-284">為什麼要微服務？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-284">Why microservices?</span></span>

<span data-ttu-id="b7fc2-285">微服務提供靈活性。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-285">Microservices provide agility.</span></span>

<span data-ttu-id="b7fc2-286">稍早在章節中，我們比較了以單體建立的電子商務應用程式與微服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-286">Earlier in the chapter, we compared an eCommerce application built as a monolith to that with microservices.</span></span> <span data-ttu-id="b7fc2-287">在此範例中，我們看到一些清楚的好處：</span><span class="sxs-lookup"><span data-stu-id="b7fc2-287">In the example, we saw some clear benefits:</span></span> 

- <span data-ttu-id="b7fc2-288">每個微服務都有自發的生命週期，而且可以獨立且經常地進行部署。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-288">Each microservice has an autonomous lifecycle and can evolve independently and deploy frequently.</span></span> <span data-ttu-id="b7fc2-289">您不需要等候每季版本來部署新功能或更新。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-289">You don’t have to wait for a quarterly release to deploy a new features or update.</span></span> <span data-ttu-id="b7fc2-290">您可以更新複雜應用程式的小型區域，降低中斷整個系統的風險。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-290">You can update a small area of a complex application with less risk of disrupting the entire system.</span></span>

- <span data-ttu-id="b7fc2-291">每個微服務都可以獨立調整。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-291">Each microservice can scale independently.</span></span> <span data-ttu-id="b7fc2-292">您不會將整個應用程式調整為單一單位，而是只向外延展那些需要更多處理能力或網路頻寬的服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-292">Instead of scaling the entire application as a single unit, you scale out only those services that require more processing power or network bandwidth.</span></span> <span data-ttu-id="b7fc2-293">這個更細緻的調整方法可提供更好的系統控制，並在您調整系統的部分（而非所有專案）時，協助降低整體成本。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-293">This  fine-grained approach to scaling provides for greater control of your system and helps to reduce overall costs as you scale portions of your system, not everything.</span></span>

<span data-ttu-id="b7fc2-294">瞭解微服務的絕佳參考指南是[.Net 微服務：容器化 .Net 應用程式的架構](https://docs.microsoft.com/dotnet/standard/microservices-architecture/)。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-294">An excellent reference guide for understanding microservices is [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/standard/microservices-architecture/).</span></span> <span data-ttu-id="b7fc2-295">本書深入探討微服務的設計與架構。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-295">The book deep dives into microservices design and architecture.</span></span> <span data-ttu-id="b7fc2-296">這是隨附于 Microsoft 免費下載的[完整堆疊微服務參考架構](https://github.com/dotnet-architecture/eShopOnContainers)。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-296">It's a companion for a [full-stack microservice reference architecture](https://github.com/dotnet-architecture/eShopOnContainers) available as a free download from Microsoft.</span></span>

### <a name="developing-microservices"></a><span data-ttu-id="b7fc2-297">開發微服務</span><span class="sxs-lookup"><span data-stu-id="b7fc2-297">Developing microservices</span></span>

<span data-ttu-id="b7fc2-298">您可以使用任何現代化開發平臺來建立微服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-298">Microservices can be created with any modern development platform.</span></span>

<span data-ttu-id="b7fc2-299">Microsoft .NET Core 平臺是絕佳的選擇。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-299">The Microsoft .NET Core platform is an excellent choice.</span></span> <span data-ttu-id="b7fc2-300">免費且開放的原始碼提供許多內建功能，可簡化微服務的開發。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-300">Free and open source, it has many built-in features to simplify microservice development.</span></span> <span data-ttu-id="b7fc2-301">.NET Core 是跨平臺。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-301">.NET Core is cross-platform.</span></span> <span data-ttu-id="b7fc2-302">應用程式可以在 Windows、macOS 及大部分的 Linux 類別上建立和執行。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-302">Applications can be built and run on Windows, macOS, and most flavors of Linux.</span></span>

<span data-ttu-id="b7fc2-303">.NET Core 的效能非常高效，相較于 node.js 和其他競爭平臺，其計分程度相當良好。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-303">.NET Core is highly performant and has scored well in comparison to Node.js and other competing platforms.</span></span> <span data-ttu-id="b7fc2-304">有趣的是， [TechEmpower](https://www.techempower.com/)在許多 web 應用程式平臺和架構上執行了一組廣泛的[效能基準](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext)檢驗。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-304">Interestingly, [TechEmpower](https://www.techempower.com/) conducted an extensive set of [performance benchmarks](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) across many web application platforms and frameworks.</span></span> <span data-ttu-id="b7fc2-305">.NET Core 在前10大-良好的 node.js 和其他競爭平臺上評分。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-305">.NET Core scored in the top 10 - well above Node.js and other competing platforms.</span></span> 

<span data-ttu-id="b7fc2-306">.NET Core 是由 Microsoft 和 GitHub 上的 .NET 社區維護。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-306">.NET Core is maintained by Microsoft and the .NET community on GitHub.</span></span> 

## <a name="containers"></a><span data-ttu-id="b7fc2-307">容器</span><span class="sxs-lookup"><span data-stu-id="b7fc2-307">Containers</span></span>

<span data-ttu-id="b7fc2-308">現今，很自然地聽到任何關於*雲端原生*的交談中所提到的「*容器*」一詞。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-308">Nowadays, it's natural to hear the term *container* mentioned in any conversation concerning *cloud native*.</span></span> <span data-ttu-id="b7fc2-309">在本書中，[雲端原生模式](https://www.manning.com/books/cloud-native-patterns)，作者 Cornelia Davis 會觀察到「容器是雲端原生軟體的絕佳促成者」。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-309">In the book, [Cloud Native Patterns](https://www.manning.com/books/cloud-native-patterns), author Cornelia Davis observes that, "Containers are a great enabler of cloud-native software."</span></span> <span data-ttu-id="b7fc2-310">雲端原生運算基礎將微服務容器化作為其[雲端原生線索對應](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)的第一個步驟-開始進行雲端原生旅程的企業指導方針。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-310">The Cloud Native Computing Foundation places microservice containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span>

<span data-ttu-id="b7fc2-311">容器化微服務簡單明瞭。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-311">Containerizing a microservice is simple and straightforward.</span></span> <span data-ttu-id="b7fc2-312">程式碼、其相依性和執行時間會封裝成稱為[容器映射](https://docs.docker.com/glossary/?term=image)的二進位檔。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-312">The code, its dependencies, and runtime are packaged into a binary called a [container image](https://docs.docker.com/glossary/?term=image).</span></span> <span data-ttu-id="b7fc2-313">映射會儲存在[容器](https://caylent.com/container-registries/)登錄中，作為映射的存放庫或程式庫。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-313">Images are stored in a [container registry](https://caylent.com/container-registries/), which acts as a repository or library for images.</span></span> <span data-ttu-id="b7fc2-314">登錄可以位於您的開發電腦、資料中心或公用雲端中。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-314">A registry can be located on your development computer, in your data center, or in a public cloud.</span></span> <span data-ttu-id="b7fc2-315">Docker 本身會透過[Docker Hub](https://hub.docker.com/)維護公用登錄。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-315">Docker itself maintains a public registry via [Docker Hub](https://hub.docker.com/).</span></span> <span data-ttu-id="b7fc2-316">Azure 雲端具有[容器](https://azure.microsoft.com/services/container-registry/)登錄，可將容器映射儲存在即將執行它們的雲端應用程式附近。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-316">The Azure cloud features a [container registry](https://azure.microsoft.com/services/container-registry/) to store container images close to the cloud applications that will run them.</span></span>

<span data-ttu-id="b7fc2-317">如有需要，您可以將映射轉換成執行中的容器實例。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-317">When needed, you transform the image into a running container instance.</span></span> <span data-ttu-id="b7fc2-318">此實例會在已安裝[容器運行](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)時間引擎的任何電腦上執行。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-318">The instance runs on any computer that has a [container runtime](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) engine installed.</span></span> <span data-ttu-id="b7fc2-319">您可以視需要擁有容器化服務的多個實例。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-319">You can have as many instances of the containerized service as needed.</span></span>

<span data-ttu-id="b7fc2-320">圖1-5 顯示三個不同的微服務，每個都在自己的容器中，在單一主機上執行。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-320">Figure 1-5 shows three different microservices, each in its own container, running on a single host.</span></span>

![在容器主機上執行的多個容器](./media/hosting-mulitple-containers.png)  

<span data-ttu-id="b7fc2-322">**圖 1-5**。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-322">**Figure 1-5**.</span></span> <span data-ttu-id="b7fc2-323">在容器主機上執行的多個容器</span><span class="sxs-lookup"><span data-stu-id="b7fc2-323">Multiple containers running on a container host</span></span>

<span data-ttu-id="b7fc2-324">請注意，每個容器如何維護自己的相依性和執行時間集合，這可能會有所不同。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-324">Note how each container maintains its own set of dependencies and runtime, which can be different.</span></span> <span data-ttu-id="b7fc2-325">在這裡，我們會看到在相同主機上執行的不同版本的產品微服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-325">Here, we see different versions of the Product microservice running on the same host.</span></span> <span data-ttu-id="b7fc2-326">每個容器會共用基礎主機作業系統、記憶體和處理器的配量，但會彼此隔離。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-326">Each container shares a slice of the underlying host operating system, memory, and processor, but is isolated from one another.</span></span> 

<span data-ttu-id="b7fc2-327">請注意，容器模型從[十二個要素應用程式](https://12factor.net/)中納入「相依性」原則的效果。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-327">Note how well the container model embraces the "Dependencies" principle from the [Twelve-Factor Application](https://12factor.net/).</span></span>

> <span data-ttu-id="b7fc2-328">*因素 \#2 指定「每個微服務會隔離和封裝自己的相依性，並在不影響整個系統的情況下進行變更。」*</span><span class="sxs-lookup"><span data-stu-id="b7fc2-328">*Factor \#2  specifies that "Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system."*</span></span>

<span data-ttu-id="b7fc2-329">容器同時支援 Linux 和 Windows 工作負載。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-329">Containers support both Linux and Windows workloads.</span></span> <span data-ttu-id="b7fc2-330">Azure 雲端公開同時採用這兩種。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-330">The Azure cloud openly embraces both.</span></span> <span data-ttu-id="b7fc2-331">有趣的是，它是 Linux，而不是 Windows Server，已成為 Azure 中最受歡迎的作業系統。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-331">Interestingly, it's Linux, not Windows Server, that has become the most popular operating system in Azure.</span></span>

<span data-ttu-id="b7fc2-332">雖然有數個容器廠商存在，但 Docker 已捕捉到 lion 的市場份額。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-332">While several container vendors exist, Docker has captured the lion's share of the market.</span></span> <span data-ttu-id="b7fc2-333">公司已推動軟體容器的移動。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-333">The company has been driving the software container movement.</span></span> <span data-ttu-id="b7fc2-334">它已成為封裝、部署和執行雲端原生應用程式的事實上標準。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-334">It has become the de facto standard for packaging, deploying, and running cloud-native applications.</span></span>

### <a name="why-containers"></a><span data-ttu-id="b7fc2-335">為何選擇容器？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-335">Why containers?</span></span>

<span data-ttu-id="b7fc2-336">容器提供可攜性，並確保環境之間的一致性。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-336">Containers provide portability and guarantee consistency across environments.</span></span> <span data-ttu-id="b7fc2-337">藉由將所有專案封裝成單一套件，您可以*隔離*微服務及其相依性與基礎結構。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-337">By encapsulating everything into a single package, you *isolate* the microservice and its dependencies from the underlying infrastructure.</span></span> 

<span data-ttu-id="b7fc2-338">您可以在任何具有 Docker 執行時間引擎的環境中部署該相同容器。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-338">You can deploy that same container in any environment that has the Docker runtime engine.</span></span> <span data-ttu-id="b7fc2-339">容器化工作負載也可消除使用架構、軟體程式庫和執行時間引擎預先設定各個環境的費用。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-339">Containerized workloads also eliminate the expense of pre-configuring each environment with frameworks, software libraries, and runtime engines.</span></span>

<span data-ttu-id="b7fc2-340">藉由共用基礎作業系統和主機資源，容器的使用量會比完整虛擬機器更小。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-340">By sharing the underlying operating system and host resources, containers have a much smaller footprint than a full virtual machine.</span></span> <span data-ttu-id="b7fc2-341">較小的大小會增加指定的主機一次可以執行的*密度*，或微服務的數目。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-341">The smaller size increases the *density*, or number of microservices, that a given host can run at one time.</span></span>

### <a name="container-orchestration"></a><span data-ttu-id="b7fc2-342">容器協調流程</span><span class="sxs-lookup"><span data-stu-id="b7fc2-342">Container orchestration</span></span>

<span data-ttu-id="b7fc2-343">雖然 Docker 之類的工具會建立映射和執行容器，但您也需要工具來管理它們。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-343">While tools such as Docker create images and run containers, you also need tools to manage them.</span></span> <span data-ttu-id="b7fc2-344">容器管理是以稱為容器協調器的特殊軟體程式來完成。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-344">Container management is done with a special software program called a container orchestrator.</span></span> <span data-ttu-id="b7fc2-345">在大規模運作時，容器協調流程是不可或缺的。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-345">When operating at scale, container orchestration is essential.</span></span> 

<span data-ttu-id="b7fc2-346">圖1-6 顯示 container 協調器所提供的管理工作。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-346">Figure 1-6 shows management tasks that container orchestrators provide.</span></span>

![容器協調器的用途](./media/what-container-orchestrators-do.png)

<span data-ttu-id="b7fc2-348">**圖 1-6**。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-348">**Figure 1-6**.</span></span> <span data-ttu-id="b7fc2-349">容器協調器的用途</span><span class="sxs-lookup"><span data-stu-id="b7fc2-349">What container orchestrators do</span></span>

<span data-ttu-id="b7fc2-350">下表說明常見的協調流程工作。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-350">The following table describes common orchestration tasks.</span></span>

|  <span data-ttu-id="b7fc2-351">工作</span><span class="sxs-lookup"><span data-stu-id="b7fc2-351">Tasks</span></span> | <span data-ttu-id="b7fc2-352">說明</span><span class="sxs-lookup"><span data-stu-id="b7fc2-352">Explanation</span></span>  |
| :-------- | :-------- |
| <span data-ttu-id="b7fc2-353">功能</span><span class="sxs-lookup"><span data-stu-id="b7fc2-353">Scheduling</span></span> | <span data-ttu-id="b7fc2-354">自動布建容器實例。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-354">Automatically provision container instances.</span></span>|
| <span data-ttu-id="b7fc2-355">親和性/反親和性</span><span class="sxs-lookup"><span data-stu-id="b7fc2-355">Affinity/anti-affinity</span></span> | <span data-ttu-id="b7fc2-356">布建附近或遠離彼此的容器，以協助提供可用性和效能。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-356">Provision containers nearby or far apart from each other, helping  availability and performance.</span></span> |
| <span data-ttu-id="b7fc2-357">健康狀態監視</span><span class="sxs-lookup"><span data-stu-id="b7fc2-357">Health monitoring</span></span> | <span data-ttu-id="b7fc2-358">自動偵測並更正失敗。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-358">Automatically detect and correct failures.</span></span>|
| <span data-ttu-id="b7fc2-359">容錯移轉</span><span class="sxs-lookup"><span data-stu-id="b7fc2-359">Failover</span></span> | <span data-ttu-id="b7fc2-360">自動將失敗的實例重新布建至狀況良好的機器。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-360">Automatically reprovision failed instance to healthy machines.</span></span>|
| <span data-ttu-id="b7fc2-361">縮放</span><span class="sxs-lookup"><span data-stu-id="b7fc2-361">Scaling</span></span> | <span data-ttu-id="b7fc2-362">自動新增或移除容器實例以符合需求。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-362">Automatically add or remove container instance to meet demand.</span></span>|
| <span data-ttu-id="b7fc2-363">網路功能</span><span class="sxs-lookup"><span data-stu-id="b7fc2-363">Networking</span></span> | <span data-ttu-id="b7fc2-364">管理容器通訊的網路重迭。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-364">Manage a networking overlay for container communication.</span></span>|
| <span data-ttu-id="b7fc2-365">服務探索</span><span class="sxs-lookup"><span data-stu-id="b7fc2-365">Service Discovery</span></span> | <span data-ttu-id="b7fc2-366">讓容器彼此尋找。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-366">Enable containers to locate each other.</span></span>|
| <span data-ttu-id="b7fc2-367">輪流升級</span><span class="sxs-lookup"><span data-stu-id="b7fc2-367">Rolling Upgrades</span></span> | <span data-ttu-id="b7fc2-368">協調增量升級，而不需要停機部署。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-368">Coordinate incremental upgrades with zero downtime deployment.</span></span> <span data-ttu-id="b7fc2-369">自動復原有問題的變更。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-369">Automatically roll back problematic changes.</span></span>|

<span data-ttu-id="b7fc2-370">請注意，協調器如何從[十二個要素的應用程式](https://12factor.net/)中採用 disposability 和並行原則，這章節稍早討論過。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-370">Note how orchestrators embrace the disposability and concurrency principles from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="b7fc2-371">*因素 \#9 指定「服務實例應可處置，優先列出快速新創公司」，以增加擴充性機會和正常關機，讓系統處於正確的狀態。Docker 容器和協調器原本就能滿足這項需求。」*</span><span class="sxs-lookup"><span data-stu-id="b7fc2-371">*Factor \#9  specifies that "Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state. Docker containers along with an orchestrator inherently satisfy this requirement."*</span></span>

> <span data-ttu-id="b7fc2-372">*因素 \#8 指定「服務向外延展到大量的小型相同進程（複本），而不是相應增加最強大電腦上的單一大型實例。」*</span><span class="sxs-lookup"><span data-stu-id="b7fc2-372">*Factor \#8  specifies that "Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available."*</span></span>

<span data-ttu-id="b7fc2-373">雖然有數個容器協調器存在，但[Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)已經成為雲端原生世界的既定標準。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-373">While several container orchestrators exist, [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) has become the de facto standard for the cloud-native world.</span></span> <span data-ttu-id="b7fc2-374">它是一種可移植、可擴充的開放原始碼平臺，用於管理容器化的工作負載。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-374">It's a portable, extensible, open-source platform for managing containerized workloads.</span></span> 

<span data-ttu-id="b7fc2-375">您可以裝載自己的 Kubernetes 實例，但是您會負責布建和管理其資源，這可能很複雜。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-375">You could host your own instance of Kubernetes, but then you'd be responsible for provisioning and managing its resources - which can be complex.</span></span> <span data-ttu-id="b7fc2-376">Azure 雲端功能 Kubernetes 為受控服務， [Azure Kubernetes Service （AKS）](https://azure.microsoft.com/services/kubernetes-service/)。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-376">The Azure cloud features Kubernetes as a managed service, [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="b7fc2-377">受控服務可讓您充分利用其功能，而不需要安裝及維護它。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-377">A managed service allows you to fully leverage its features, without having to install and maintain it.</span></span>

<span data-ttu-id="b7fc2-378">Azure Kubernetes Services 的詳細資訊請在第2章（*調整雲端原生應用程式*）中討論。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-378">Azure Kubernetes Services is covered in detail Chapter 2, *Scaling Cloud-Native Applications*.</span></span>

## <a name="backing-services"></a><span data-ttu-id="b7fc2-379">支援服務</span><span class="sxs-lookup"><span data-stu-id="b7fc2-379">Backing services</span></span>

<span data-ttu-id="b7fc2-380">雲端原生系統取決於許多不同的輔助資源，例如資料存放區、訊息代理程式、監視和身分識別服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-380">Cloud-native systems depend upon many different ancillary resources, such as data stores, message brokers, monitoring, and identity services.</span></span> <span data-ttu-id="b7fc2-381">這些服務稱為「[支援服務](https://12factor.net/backing-services)」。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-381">These services are known as [backing services](https://12factor.net/backing-services).</span></span>

 <span data-ttu-id="b7fc2-382">圖1-7 顯示雲端原生系統使用的許多常見的支援服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-382">Figure 1-7 shows many common backing services that cloud-native systems consume.</span></span>

![一般支援服務](./media/common-backing-services.png)

<span data-ttu-id="b7fc2-384">**圖 1-7**。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-384">**Figure 1-7**.</span></span> <span data-ttu-id="b7fc2-385">一般支援服務</span><span class="sxs-lookup"><span data-stu-id="b7fc2-385">Common backing services</span></span>

<span data-ttu-id="b7fc2-386">備份服務會從[12 個要素的應用程式](https://12factor.net/)升級「Statelessness」原則，本章稍早所討論。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-386">Backing services promote the "Statelessness" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="b7fc2-387">*因素 \#6*指定，「每個微服務都應該在自己的進程中執行，並與其他執行中的服務隔離。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-387">*Factor \#6* specifies that, "Each microservice should execute in its own process, isolated from other running services.</span></span> <span data-ttu-id="b7fc2-388">將必要狀態外部化到支援服務，例如分散式快取或資料存放區。」</span><span class="sxs-lookup"><span data-stu-id="b7fc2-388">Externalize required state to a backing service such as a distributed cache or data store."</span></span>

<span data-ttu-id="b7fc2-389">您可以裝載自己的支援服務，但您會負責授權、布建及管理這些資源。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-389">You could host your own backing services, but then you'd be responsible for licensing, provisioning, and managing those resources.</span></span>

<span data-ttu-id="b7fc2-390">雲端提供者提供各式各樣的*受控支援服務。*</span><span class="sxs-lookup"><span data-stu-id="b7fc2-390">Cloud providers offer a rich assortment of *managed backing services.*</span></span> <span data-ttu-id="b7fc2-391">而不是擁有服務，而是只使用它。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-391">Instead of owning the service, you simply consume it.</span></span> <span data-ttu-id="b7fc2-392">提供者會大規模地操作資源，並擁有效能、安全性和維護的責任。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-392">The provider operates the resource at scale and bears the responsibility for performance, security, and maintenance.</span></span> <span data-ttu-id="b7fc2-393">服務內建監視、冗余和可用性。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-393">Monitoring, redundancy, and availability are built into the service.</span></span> <span data-ttu-id="b7fc2-394">提供者完全支援其受控服務-開啟票證，並修正您的問題。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-394">Providers fully support their managed services - open a ticket and they fix your issue.</span></span>

<span data-ttu-id="b7fc2-395">雲端原生系統優先于雲端廠商提供的受控支援服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-395">Cloud-native systems favor managed backing services from cloud vendors.</span></span> <span data-ttu-id="b7fc2-396">節省時間和人力很棒。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-396">The savings in time and labor are great.</span></span> <span data-ttu-id="b7fc2-397">裝載您自己和遇到問題的作業風險，可能很快就會變得昂貴。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-397">The operational risk of hosting your own and experiencing trouble can get expensive fast.</span></span>

<span data-ttu-id="b7fc2-398">最佳做法是將支援服務視為連結的*資源*，並以動態方式系結至微服務，並將資訊（URL 和認證）儲存在外部設定中。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-398">A best practice is to treat a backing service as an *attached resource*, dynamically bound to a microservice with information (a URL and credentials) stored in an external configuration.</span></span> <span data-ttu-id="b7fc2-399">這項指導方針已在[十二個要素的應用程式](https://12factor.net/)中說明，如稍早的章節所述。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-399">This guidance is spelled out in the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="b7fc2-400">*因素 \#4*指定應該透過可定址的 URL 公開支援服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-400">*Factor \#4* specifies that backing services "should be exposed via an addressable URL.</span></span> <span data-ttu-id="b7fc2-401">這麼做會將資源與應用程式分離，讓它能夠互換。」</span><span class="sxs-lookup"><span data-stu-id="b7fc2-401">Doing so decouples the resource from the application, enabling it to be interchangeable."</span></span>

><span data-ttu-id="b7fc2-402">*因素 \#3*指定在程式碼以外的設定管理工具中，微服務和外部化會移出 configuration 資訊。」</span><span class="sxs-lookup"><span data-stu-id="b7fc2-402">*Factor \#3* specifies that "Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code."</span></span>

<span data-ttu-id="b7fc2-403">使用此模式時，可以附加及卸離支援服務，而不需要變更程式碼。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-403">With this pattern, a backing service can be attached and detached without code changes.</span></span> <span data-ttu-id="b7fc2-404">您可以將微服務從 QA 升級至預備環境。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-404">You might promote a microservice from QA to a staging environment.</span></span> <span data-ttu-id="b7fc2-405">您可以更新微服務設定，以指向預備環境中的支援服務，並透過環境變數將設定插入您的容器中。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-405">You update the microservice configuration to point to the backing services in staging and inject the settings into your container through an environment variable.</span></span>

<span data-ttu-id="b7fc2-406">雲端廠商會提供 Api，讓您與專屬的支援服務進行通訊。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-406">Cloud vendors provide APIs for you to communicate with their proprietary backing services.</span></span> <span data-ttu-id="b7fc2-407">這些程式庫會封裝管線和複雜度。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-407">These libraries encapsulate the plumbing and complexity.</span></span> <span data-ttu-id="b7fc2-408">直接與這些 Api 通訊會讓您的程式碼緊密結合到支援服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-408">Communicating directly with these APIs will tightly couple your code to the backing service.</span></span> <span data-ttu-id="b7fc2-409">更好的作法是將廠商 API 的執行細節隔離。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-409">It's a better practice to insulate the implementation details of the vendor API.</span></span> <span data-ttu-id="b7fc2-410">引進 intermediation 層或中繼 API，將一般作業公開至您的服務程式代碼。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-410">Introduce an intermediation layer, or intermediate API, exposing generic operations to your service code.</span></span> <span data-ttu-id="b7fc2-411">這種鬆散結合可讓您交換另一個支援服務，或將程式碼移至不同的公用雲端，而不需要對主線服務程式代碼進行變更。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-411">This loose coupling enables you to swap out one backing service for another or move your code to a different public cloud without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="b7fc2-412">支援服務會詳細討論第5章、*雲端原生資料模式*和第4章*雲端原生通訊模式*。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-412">Backing services are discussed in detail Chapter 5, *Cloud-Native Data Patterns*, and Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

## <a name="automation"></a><span data-ttu-id="b7fc2-413">Automation</span><span class="sxs-lookup"><span data-stu-id="b7fc2-413">Automation</span></span>

<span data-ttu-id="b7fc2-414">如您所見，雲端原生系統採用了微服務、容器和現代化的系統設計，以達成速度和靈活性。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-414">As you've seen, cloud-native systems embrace microservices, containers, and modern system design to achieve speed and agility.</span></span> <span data-ttu-id="b7fc2-415">不過，這只是故事的一部分。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-415">But, that's only part of the story.</span></span> <span data-ttu-id="b7fc2-416">您要如何布建這些系統執行所在的雲端環境？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-416">How do you provision the cloud environments upon which these systems run?</span></span> <span data-ttu-id="b7fc2-417">如何快速部署應用程式功能與更新？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-417">How do you rapidly deploy app features and updates?</span></span> <span data-ttu-id="b7fc2-418">您要如何將整個圖片四捨五入？</span><span class="sxs-lookup"><span data-stu-id="b7fc2-418">How do you round out the full picture?</span></span>

<span data-ttu-id="b7fc2-419">輸入[基礎結構](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)即程式碼或 IaC 的廣為接受做法。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-419">Enter the widely accepted practice of [Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), or IaC.</span></span>

<span data-ttu-id="b7fc2-420">透過 IaC，您可以將平臺布建和應用程式部署自動化。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-420">With IaC, you automate platform provisioning and application deployment.</span></span> <span data-ttu-id="b7fc2-421">您基本上會將軟體工程實務（例如測試和版本控制）套用至您的 DevOps 實務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-421">You essentially apply software engineering practices such as testing and versioning to your DevOps practices.</span></span> <span data-ttu-id="b7fc2-422">您的基礎結構和部署會自動化、一致且可重複。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-422">Your infrastructure and deployments are automated, consistent, and repeatable.</span></span>

### <a name="automating-infrastructure"></a><span data-ttu-id="b7fc2-423">自動化基礎結構</span><span class="sxs-lookup"><span data-stu-id="b7fc2-423">Automating infrastructure</span></span>

<span data-ttu-id="b7fc2-424">[Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/)、Terraform 和[Azure CLI](https://docs.microsoft.com/cli/azure/)等工具，可讓您以宣告方式編寫腳本所需的雲端基礎結構。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-424">Tools like [Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/), Terraform, and the [Azure CLI](https://docs.microsoft.com/cli/azure/), enable you to declaratively script the cloud infrastructure you require.</span></span> <span data-ttu-id="b7fc2-425">[資源名稱]、[位置]、[容量] 和 [密碼] 是參數化和動態。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-425">Resource names, locations, capacities, and secrets are parameterized and dynamic.</span></span> <span data-ttu-id="b7fc2-426">腳本會進行版本設定，並簽入原始檔控制做為專案的成品。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-426">The script is versioned and checked into source control as an artifact of your project.</span></span> <span data-ttu-id="b7fc2-427">您叫用腳本以在系統內容中布建一致且可重複的基礎結構，例如 QA、預備及生產。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-427">You invoke the script to provision a consistent and repeatable infrastructure across system environments, such as QA, staging, and production.</span></span> 

<span data-ttu-id="b7fc2-428">實際上，IaC 是等冪的，這表示您可以執行相同的腳本，而不會產生副作用。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-428">Under the hood, IaC is idempotent, meaning that you can run the same script over and over without side effects.</span></span> <span data-ttu-id="b7fc2-429">如果小組需要進行變更，他們會編輯並重新執行腳本。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-429">If the team needs to make a change, they edit and rerun the script.</span></span> <span data-ttu-id="b7fc2-430">只有更新的資源會受到影響。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-430">Only the updated resources are affected.</span></span>

<span data-ttu-id="b7fc2-431">在本文中，[什麼是基礎結構即程式碼](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)，作者 Sam 作者: guckenheimer 說明如何，「執行 IaC 的小組可以快速且大規模地提供穩定的環境。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-431">In the article, [What is Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), Author Sam Guckenheimer describes how, "Teams who implement IaC can deliver stable environments rapidly and at scale.</span></span> <span data-ttu-id="b7fc2-432">小組會避免手動設定環境，並藉由透過程式碼來表示其環境的期望狀態來強制執行一致性。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-432">Teams avoid manual configuration of environments and enforce consistency by representing the desired state of their environments via code.</span></span> <span data-ttu-id="b7fc2-433">使用 IaC 的基礎結構部署可重複，並防止設定漂移或遺失相依性所造成的執行時間問題。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-433">Infrastructure deployments with IaC are repeatable and prevent runtime issues caused by configuration drift or missing dependencies.</span></span> <span data-ttu-id="b7fc2-434">DevOps 小組可以與一組整合的實務和工具搭配運作，以快速、可靠且大規模地傳遞應用程式及其支援的基礎結構。」</span><span class="sxs-lookup"><span data-stu-id="b7fc2-434">DevOps teams can work together with a unified set of practices and tools to deliver applications and their supporting infrastructure rapidly, reliably, and at scale."</span></span>

### <a name="automating-deployments"></a><span data-ttu-id="b7fc2-435">自動化部署</span><span class="sxs-lookup"><span data-stu-id="b7fc2-435">Automating deployments</span></span>

<span data-ttu-id="b7fc2-436">稍早所討論的[十二個要素應用程式](https://12factor.net/)，會在將完成的程式碼轉換成執行中的應用程式時，呼叫個別的步驟。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-436">The [Twelve-Factor Application](https://12factor.net/), discussed earlier, calls for separate steps when transforming completed code into a running application.</span></span>

> <span data-ttu-id="b7fc2-437">*因素 \#5*指定「每個版本都必須在組建、發行和執行階段之間強制執行嚴格的分隔。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-437">*Factor \#5* specifies that "Each release must enforce a strict separation across the build, release and run stages.</span></span> <span data-ttu-id="b7fc2-438">每個都應該以唯一識別碼標記，並支援復原的能力。」</span><span class="sxs-lookup"><span data-stu-id="b7fc2-438">Each should be tagged with a unique ID and support the ability to roll back."</span></span>

<span data-ttu-id="b7fc2-439">新式 CI/CD 系統有助於滿足此原則。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-439">Modern CI/CD systems help fulfill this principle.</span></span> <span data-ttu-id="b7fc2-440">它們提供個別的部署步驟，並協助確保可立即提供給使用者的一致和品質程式碼。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-440">They provide separate deployment steps and help ensure consistent and quality code that's readily available to users.</span></span> 

<span data-ttu-id="b7fc2-441">圖1-8 顯示整個部署程式的分隔。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-441">Figure 1-8 shows the separation across the deployment process.</span></span>

![CI/CD 管線中的部署步驟](./media/build-release-run-pipeline.png)

<span data-ttu-id="b7fc2-443">**圖 1-8**。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-443">**Figure 1-8**.</span></span> <span data-ttu-id="b7fc2-444">CI/CD 管線中的部署步驟</span><span class="sxs-lookup"><span data-stu-id="b7fc2-444">Deployment steps in a CI/CD Pipeline</span></span>

<span data-ttu-id="b7fc2-445">在上圖中，請特別注意工作的分隔。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-445">In the previous figure, pay special attention to separation of tasks.</span></span> 

<span data-ttu-id="b7fc2-446">開發人員會在其開發環境中建立功能，逐一查看程式碼的「內部迴圈」、執行和 debug。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-446">The developer constructs a feature in their development environment, iterating through what is called the "inner loop" of code, run, and debug.</span></span> <span data-ttu-id="b7fc2-447">完成時，會將該程式碼*推送*至程式碼存放庫，例如 GitHub、Azure DevOps 或 BitBucket。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-447">When complete, that code is *pushed* into a code repository, such as GitHub, Azure DevOps, or BitBucket.</span></span> 

<span data-ttu-id="b7fc2-448">推送會觸發將程式碼轉換成二進位成品的組建階段。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-448">The push triggers a build stage that transforms the code into a binary artifact.</span></span> <span data-ttu-id="b7fc2-449">此工作是透過[持續整合（CI）](https://martinfowler.com/articles/continuousIntegration.html)管線來執行。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-449">The work is implemented with a [Continuous Integration (CI)](https://martinfowler.com/articles/continuousIntegration.html) pipeline.</span></span> <span data-ttu-id="b7fc2-450">它會自動建立、測試和封裝應用程式。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-450">It automatically builds, tests, and packages the application.</span></span> 

<span data-ttu-id="b7fc2-451">發行階段會挑選二進位成品、套用外部應用程式和環境設定資訊，並產生不可變的版本。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-451">The release stage picks up the binary artifact, applies external application and environment configuration information, and produces an immutable release.</span></span> <span data-ttu-id="b7fc2-452">發行會部署到指定的環境。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-452">The release is deployed to a specified environment.</span></span> <span data-ttu-id="b7fc2-453">此工作會使用[持續傳遞（CD）](https://martinfowler.com/bliki/ContinuousDelivery.html)管線來執行。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-453">The work is implemented with a [Continuous Delivery(CD)](https://martinfowler.com/bliki/ContinuousDelivery.html) pipeline.</span></span> <span data-ttu-id="b7fc2-454">每個版本都應該是可辨識的。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-454">Each release should be identifiable.</span></span> <span data-ttu-id="b7fc2-455">您可以說：「這個部署正在執行應用程式的版本2.1.1」。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-455">You can say, "This deployment is running Release 2.1.1 of the application."</span></span>

<span data-ttu-id="b7fc2-456">最後，已釋放的功能會在目標執行環境中執行。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-456">Finally, the released feature is run in the target execution environment.</span></span> <span data-ttu-id="b7fc2-457">版本是不可變的，這表示任何變更都必須建立新的版本。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-457">Releases are immutable meaning that any change must create a new release.</span></span> 

<span data-ttu-id="b7fc2-458">套用這些實務後，組織就已經徹底演變出軟體的方式。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-458">Applying these practices, organizations have radically evolved how they ship software.</span></span> <span data-ttu-id="b7fc2-459">許多已從季度版本移至隨選更新。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-459">Many have moved from quarterly releases to on-demand updates.</span></span> <span data-ttu-id="b7fc2-460">其目標是要及早在開發週期中攔截問題，而不需要修正這項成本。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-460">The goal is to catch problems early in the development cycle when they're less expensive to fix.</span></span> <span data-ttu-id="b7fc2-461">整合之間的持續時間愈長，解決的問題就愈昂貴。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-461">The longer the duration between integrations, the more expensive problems become to resolve.</span></span>  <span data-ttu-id="b7fc2-462">隨著整合程式的一致性，小組可以更頻繁地認可程式碼變更，進而提供更好的共同作業和軟體品質。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-462">With consistency in the integration process, teams can commit code changes more frequently, leading to better collaboration and software quality.</span></span>  

### <a name="azure-pipelines"></a><span data-ttu-id="b7fc2-463">Azure Pipelines</span><span class="sxs-lookup"><span data-stu-id="b7fc2-463">Azure Pipelines</span></span>

<span data-ttu-id="b7fc2-464">Azure 雲端包含一項新的 CI/CD 服務，其標題為[Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/)，這是如圖1-9 所示之[Azure DevOps](https://azure.microsoft.com/services/devops/)供應專案的一部分。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-464">The Azure cloud includes a new CI/CD service entitled [Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/), which is part of the [Azure DevOps](https://azure.microsoft.com/services/devops/) offering shown in Figure 1-9.</span></span>

![DevOps 中的 Azure Pipelines](./media/devops-components.png)

<span data-ttu-id="b7fc2-466">**圖 1-9**。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-466">**Figure 1-9**.</span></span> <span data-ttu-id="b7fc2-467">Azure DevOps 供應專案</span><span class="sxs-lookup"><span data-stu-id="b7fc2-467">Azure DevOps offerings</span></span>

<span data-ttu-id="b7fc2-468">Azure Pipelines 是結合持續整合（CI）與持續傳遞（CD）的雲端服務。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-468">Azure Pipelines is a cloud service that combines continuous integration (CI) and continuous delivery (CD).</span></span> <span data-ttu-id="b7fc2-469">您可以自動測試、建立程式碼，並將其傳送至任何目標。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-469">You can automatically test, build, and ship your code to any target.</span></span>

<span data-ttu-id="b7fc2-470">您會在 YAML 檔案中的程式碼中定義管線，連同應用程式的其餘程式碼。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-470">You define your pipeline in code in a YAML file alongside the rest of the code for your app.</span></span>

- <span data-ttu-id="b7fc2-471">管線會以您的程式碼建立版本，並遵循相同的分支結構。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-471">The pipeline is versioned with your code and follows the same branching structure.</span></span>
- <span data-ttu-id="b7fc2-472">您可以透過提取要求和分支組建原則中的程式碼審查，取得變更的驗證。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-472">You get validation of your changes through code reviews in pull requests and branch build policies.</span></span>
- <span data-ttu-id="b7fc2-473">您使用的每個分支都可以藉由修改 azure-pipelines. yml 檔案來自訂群組建原則。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-473">Every branch you use can customize the build policy by modifying the azure-pipelines.yml file.</span></span>
- <span data-ttu-id="b7fc2-474">管線檔案會簽入版本控制，並可在發生問題時進行調查。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-474">The pipeline file is checked into version control and can be investigated if there's a problem.</span></span>

<span data-ttu-id="b7fc2-475">Azure Pipelines 服務支援大部分的 Git 提供者，而且可以針對在 Linux、macOS 或 Windows 平臺上撰寫的應用程式產生部署管線。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-475">The Azure Pipelines service supports most Git providers and can generate deployment pipelines for applications written on the Linux, macOS, or Windows platforms.</span></span> <span data-ttu-id="b7fc2-476">其中包括 JAVA、.NET、JavaScript、Python、PHP、Go、XCode 和C++的支援。</span><span class="sxs-lookup"><span data-stu-id="b7fc2-476">It includes support for Java, .NET, JavaScript, Python, PHP, Go, XCode, and C++.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="b7fc2-477">[上一頁](introduction.md)
>[下一頁](candidate-apps.md)</span><span class="sxs-lookup"><span data-stu-id="b7fc2-477">[Previous](introduction.md)
[Next](candidate-apps.md)</span></span>
