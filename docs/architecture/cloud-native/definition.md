---
title: 雲端原生的定義
description: 瞭解為雲原生系統提供基岩的基礎支柱
author: robvet
ms.date: 08/20/2019
ms.openlocfilehash: 27191a67b2964ac2e1636a4d7dc55d5314b78439
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401568"
---
# <a name="defining-cloud-native"></a><span data-ttu-id="f9372-103">定義雲本機</span><span class="sxs-lookup"><span data-stu-id="f9372-103">Defining cloud native</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="f9372-104">停止你正在做的事情，給10位同事發短信。</span><span class="sxs-lookup"><span data-stu-id="f9372-104">Stop what you’re doing and text 10 of your colleagues.</span></span> <span data-ttu-id="f9372-105">請他們定義術語"雲原生"。</span><span class="sxs-lookup"><span data-stu-id="f9372-105">Ask them to define the term “Cloud Native.”</span></span> <span data-ttu-id="f9372-106">很有可能你會得到八個不同的答案。</span><span class="sxs-lookup"><span data-stu-id="f9372-106">Good chance you’ll get eight different answers.</span></span> <span data-ttu-id="f9372-107">有趣的是，六個月後，隨著雲原生技術和實踐的發展，它們的定義也會隨之發展。</span><span class="sxs-lookup"><span data-stu-id="f9372-107">Interestingly, six months from now, as cloud-native technologies and practices evolve, so will their definition.</span></span>

<span data-ttu-id="f9372-108">雲原生就是改變我們構建關鍵業務系統的方式。</span><span class="sxs-lookup"><span data-stu-id="f9372-108">Cloud native is all about changing the way we think about constructing critical business systems.</span></span>

<span data-ttu-id="f9372-109">雲原生系統旨在適應快速變化、大規模和彈性。</span><span class="sxs-lookup"><span data-stu-id="f9372-109">Cloud-native systems are designed to embrace rapid change, large scale, and resilience.</span></span>

<span data-ttu-id="f9372-110">雲原生計算基金會提供了一[個官方的定義](https://github.com/cncf/foundation/blob/master/charter.md)：</span><span class="sxs-lookup"><span data-stu-id="f9372-110">The Cloud Native Computing Foundation provides an [official definition](https://github.com/cncf/foundation/blob/master/charter.md):</span></span>

> <span data-ttu-id="f9372-111">*雲原生技術使組織能夠在公共、私有和混合雲等現代動態環境中構建和運行可擴展的應用程式。容器、服務同理、微服務、不可變基礎結構和聲明性 API 就是此方法的例證。*</span><span class="sxs-lookup"><span data-stu-id="f9372-111">*Cloud-native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.*</span></span>

> <span data-ttu-id="f9372-112">*這些技術支援具有彈性、可管理和可觀測的鬆散耦合系統。結合強大的自動化，它們使工程師能夠以最少的辛勞頻繁、可預見地進行高影響更改。*</span><span class="sxs-lookup"><span data-stu-id="f9372-112">*These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.*</span></span>

<span data-ttu-id="f9372-113">隨著使用者要求越來越高，應用程式變得越來越複雜。</span><span class="sxs-lookup"><span data-stu-id="f9372-113">Applications have become increasingly complex with users demanding more and more.</span></span> <span data-ttu-id="f9372-114">使用者期望快速回應、創新功能和零停機時間。</span><span class="sxs-lookup"><span data-stu-id="f9372-114">Users expect rapid responsiveness, innovative features, and zero downtime.</span></span> <span data-ttu-id="f9372-115">性能問題、反復出現的錯誤和無法快速移動不再為所接受。</span><span class="sxs-lookup"><span data-stu-id="f9372-115">Performance problems, recurring errors, and the inability to move fast are no longer acceptable.</span></span> <span data-ttu-id="f9372-116">他們很容易轉移到你的競爭對手。</span><span class="sxs-lookup"><span data-stu-id="f9372-116">They'll easily move to your competitor.</span></span>

<span data-ttu-id="f9372-117">雲原生是很多關於*速度和\*\*敏捷*性。</span><span class="sxs-lookup"><span data-stu-id="f9372-117">Cloud native is much about *speed* and *agility*.</span></span> <span data-ttu-id="f9372-118">業務系統正在從支援業務能力演變為戰略轉型、加快業務速度和增長的武器。</span><span class="sxs-lookup"><span data-stu-id="f9372-118">Business systems are evolving from enabling business capabilities to weapons of strategic transformation, accelerating business velocity and growth.</span></span> <span data-ttu-id="f9372-119">立即將創意推向市場勢在必行。</span><span class="sxs-lookup"><span data-stu-id="f9372-119">It’s imperative to get ideas to market immediately.</span></span>

<span data-ttu-id="f9372-120">以下是一些已經實施了這些技術的公司。</span><span class="sxs-lookup"><span data-stu-id="f9372-120">Here are some companies who have implemented these techniques.</span></span> <span data-ttu-id="f9372-121">考慮他們實現的速度、敏捷性和可擴充性。</span><span class="sxs-lookup"><span data-stu-id="f9372-121">Think about the speed, agility, and scalability they've achieved.</span></span>

| <span data-ttu-id="f9372-122">公司</span><span class="sxs-lookup"><span data-stu-id="f9372-122">Company</span></span> | <span data-ttu-id="f9372-123">體驗</span><span class="sxs-lookup"><span data-stu-id="f9372-123">Experience</span></span> |
| :-------- | :-------- |
| [<span data-ttu-id="f9372-124">Netflix</span><span class="sxs-lookup"><span data-stu-id="f9372-124">Netflix</span></span>](https://www.infoq.com/news/2013/06/netflix/) | <span data-ttu-id="f9372-125">有 600 多種生產服務。</span><span class="sxs-lookup"><span data-stu-id="f9372-125">Has 600+ services in production.</span></span> <span data-ttu-id="f9372-126">每天部署一百次。</span><span class="sxs-lookup"><span data-stu-id="f9372-126">Deploys a hundred times per day.</span></span> |
| [<span data-ttu-id="f9372-127">超級</span><span class="sxs-lookup"><span data-stu-id="f9372-127">Uber</span></span>](https://eng.uber.com/micro-deploy/) | <span data-ttu-id="f9372-128">生產中存儲了 1，000 多個服務。</span><span class="sxs-lookup"><span data-stu-id="f9372-128">Has 1,000+ services stored in production.</span></span> <span data-ttu-id="f9372-129">每週部署幾千個生成。</span><span class="sxs-lookup"><span data-stu-id="f9372-129">Deploys several thousand builds each week.</span></span> |
| [<span data-ttu-id="f9372-130">微信</span><span class="sxs-lookup"><span data-stu-id="f9372-130">WeChat</span></span>](https://www.cs.columbia.edu/~ruigu/papers/socc18-final100.pdf) | <span data-ttu-id="f9372-131">有 300 多種生產服務。</span><span class="sxs-lookup"><span data-stu-id="f9372-131">Has 300+ services in production.</span></span> <span data-ttu-id="f9372-132">每天進行近 1，000 次更改。</span><span class="sxs-lookup"><span data-stu-id="f9372-132">Makes almost 1,000 changes per day.</span></span> |

<span data-ttu-id="f9372-133">正如您所看到的，Netflix、優步和微信公開了由數百個獨立的微服務組成的系統。</span><span class="sxs-lookup"><span data-stu-id="f9372-133">As you can see, Netflix, Uber, and WeChat expose systems that consist of hundreds of independent microservices.</span></span> <span data-ttu-id="f9372-134">這種建築風格使他們能夠快速回應市場條件。</span><span class="sxs-lookup"><span data-stu-id="f9372-134">This architectural style enables them to rapidly respond to market conditions.</span></span> <span data-ttu-id="f9372-135">他們可以即時更新即時複雜應用程式的社區域，並根據需要單獨縮放這些區域。</span><span class="sxs-lookup"><span data-stu-id="f9372-135">They can instantaneously update small areas of a live, complex application, and individually scale those areas as needed.</span></span>

<span data-ttu-id="f9372-136">雲原生的速度和敏捷性來自許多因素。</span><span class="sxs-lookup"><span data-stu-id="f9372-136">The speed and agility of cloud native come about from a number of factors.</span></span> <span data-ttu-id="f9372-137">首先是雲基礎架構。</span><span class="sxs-lookup"><span data-stu-id="f9372-137">Foremost is cloud infrastructure.</span></span> <span data-ttu-id="f9372-138">圖 1-3 所示的另外五個基柱也為雲原生系統提供了基岩。</span><span class="sxs-lookup"><span data-stu-id="f9372-138">Five additional foundational pillars shown in Figure 1-3 also provide the bedrock for cloud-native systems.</span></span>

![雲原生基礎支柱](./media/cloud-native-foundational-pillars.png)

<span data-ttu-id="f9372-140">**圖1-3**。</span><span class="sxs-lookup"><span data-stu-id="f9372-140">**Figure 1-3**.</span></span> <span data-ttu-id="f9372-141">雲原生基礎支柱</span><span class="sxs-lookup"><span data-stu-id="f9372-141">Cloud-native foundational pillars</span></span>

<span data-ttu-id="f9372-142">讓我們花一些時間來更好地瞭解每個支柱的重要性。</span><span class="sxs-lookup"><span data-stu-id="f9372-142">Let’s take some time to better understand the significance of each pillar.</span></span>

## <a name="the-cloud"></a><span data-ttu-id="f9372-143">雲...</span><span class="sxs-lookup"><span data-stu-id="f9372-143">The cloud…</span></span>

<span data-ttu-id="f9372-144">雲原生系統充分利用了雲服務模型。</span><span class="sxs-lookup"><span data-stu-id="f9372-144">Cloud-native systems take full advantage of the cloud service model.</span></span>

<span data-ttu-id="f9372-145">這些系統旨在在動態虛擬化的雲環境中蓬勃發展，廣泛使用[平臺即服務 （PaaS）](https://azure.microsoft.com/overview/what-is-paas/)計算基礎架構和託管服務。</span><span class="sxs-lookup"><span data-stu-id="f9372-145">Designed to thrive in a dynamic, virtualized cloud environment, these systems make extensive use of [Platform as a Service (PaaS)](https://azure.microsoft.com/overview/what-is-paas/) compute infrastructure and managed services.</span></span> <span data-ttu-id="f9372-146">他們將底層基礎架構視為*一次性*基礎結構 - 在幾分鐘內預配，並通過自動化按需調整規模、縮放、移動或銷毀。</span><span class="sxs-lookup"><span data-stu-id="f9372-146">They treat the underlying infrastructure as *disposable* - provisioned in minutes and resized, scaled, moved, or destroyed on demand – via automation.</span></span>

<span data-ttu-id="f9372-147">考慮廣泛接受的DevOps概念[寵物與牛](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313)。</span><span class="sxs-lookup"><span data-stu-id="f9372-147">Consider the widely accepted DevOps concept of [Pets vs. Cattle](https://medium.com/@Joachim8675309/devops-concepts-pets-vs-cattle-2380b5aab313).</span></span> <span data-ttu-id="f9372-148">在傳統的資料中心中，伺服器被視為*寵物*：物理機器，被賦予一個有意義的名稱，並受到關注。</span><span class="sxs-lookup"><span data-stu-id="f9372-148">In a traditional data center, servers are treated as *Pets*: a physical machine, given a meaningful name, and cared for.</span></span> <span data-ttu-id="f9372-149">通過向同一電腦添加更多資源（向上擴展）進行擴展。</span><span class="sxs-lookup"><span data-stu-id="f9372-149">You scale by adding more resources to the same machine (scaling up).</span></span> <span data-ttu-id="f9372-150">如果伺服器生病，您將將其護理回運行狀況。</span><span class="sxs-lookup"><span data-stu-id="f9372-150">If the server becomes sick, you nurse it back to health.</span></span> <span data-ttu-id="f9372-151">如果伺服器不可用，每個人都會注意到。</span><span class="sxs-lookup"><span data-stu-id="f9372-151">Should the server become unavailable, everyone notices.</span></span>

<span data-ttu-id="f9372-152">*牛*服務模式不同。</span><span class="sxs-lookup"><span data-stu-id="f9372-152">The *Cattle* service model is different.</span></span> <span data-ttu-id="f9372-153">將每個實例預配為虛擬機器或容器。</span><span class="sxs-lookup"><span data-stu-id="f9372-153">You provision each instance as a virtual machine or container.</span></span> <span data-ttu-id="f9372-154">它們相同，並分配了系統識別碼，如服務-01、服務-02等。</span><span class="sxs-lookup"><span data-stu-id="f9372-154">They're identical and assigned a system identifier such as Service-01, Service-02, and so on.</span></span> <span data-ttu-id="f9372-155">您可以通過創建更多（向外擴展）進行擴展。</span><span class="sxs-lookup"><span data-stu-id="f9372-155">You scale by creating more of them (scaling out).</span></span> <span data-ttu-id="f9372-156">當一個人變得無法接通，沒有人會注意到。</span><span class="sxs-lookup"><span data-stu-id="f9372-156">When one becomes unavailable, nobody notices.</span></span>

<span data-ttu-id="f9372-157">牛模式擁抱*了不變的基礎設施*。</span><span class="sxs-lookup"><span data-stu-id="f9372-157">The cattle model embraces *immutable infrastructure*.</span></span> <span data-ttu-id="f9372-158">伺服器未修復或修改。</span><span class="sxs-lookup"><span data-stu-id="f9372-158">Servers aren't repaired or modified.</span></span> <span data-ttu-id="f9372-159">如果一個失敗或需要更新，它將被銷毀，並預配了新的更新 - 所有這些都通過自動化完成。</span><span class="sxs-lookup"><span data-stu-id="f9372-159">If one fails or requires updating, it's destroyed and a new one is provisioned – all done via automation.</span></span>

<span data-ttu-id="f9372-160">雲原生系統採用牛服務模式。</span><span class="sxs-lookup"><span data-stu-id="f9372-160">Cloud-native systems embrace the Cattle service model.</span></span> <span data-ttu-id="f9372-161">它們繼續隨著基礎結構的擴展或運行而運行，而不考慮運行的機器。</span><span class="sxs-lookup"><span data-stu-id="f9372-161">They continue to run as the infrastructure scales in or out with no regard to the machines upon which they're running.</span></span>

<span data-ttu-id="f9372-162">Azure 雲平臺支援這種類型的高彈性基礎架構，具有自動縮放、自我修復和監視功能。</span><span class="sxs-lookup"><span data-stu-id="f9372-162">The Azure cloud platform supports this type of highly elastic infrastructure with automatic scaling, self-healing, and monitoring capabilities.</span></span>

## <a name="modern-design"></a><span data-ttu-id="f9372-163">現代設計</span><span class="sxs-lookup"><span data-stu-id="f9372-163">Modern design</span></span>

<span data-ttu-id="f9372-164">您將如何設計雲原生應用？</span><span class="sxs-lookup"><span data-stu-id="f9372-164">How would you design a cloud-native app?</span></span> <span data-ttu-id="f9372-165">您的體系結構是什麼樣子的？</span><span class="sxs-lookup"><span data-stu-id="f9372-165">What would your architecture look like?</span></span> <span data-ttu-id="f9372-166">您會遵循哪些原則、模式和最佳實踐？</span><span class="sxs-lookup"><span data-stu-id="f9372-166">To what principles, patterns, and best practices would you adhere?</span></span> <span data-ttu-id="f9372-167">哪些基礎設施和運營問題很重要？</span><span class="sxs-lookup"><span data-stu-id="f9372-167">What infrastructure and operational concerns would be important?</span></span>

### <a name="the-twelve-factor-application"></a><span data-ttu-id="f9372-168">十二因數應用</span><span class="sxs-lookup"><span data-stu-id="f9372-168">The Twelve-Factor Application</span></span>

<span data-ttu-id="f9372-169">構建基於雲的應用程式是一種被廣泛接受的方法是[十二因數應用程式](https://12factor.net/)。</span><span class="sxs-lookup"><span data-stu-id="f9372-169">A widely accepted methodology for constructing cloud-based applications is the [Twelve-Factor Application](https://12factor.net/).</span></span> <span data-ttu-id="f9372-170">它描述了開發人員遵循的一組原則和實踐，以構建針對現代雲環境優化的應用程式。</span><span class="sxs-lookup"><span data-stu-id="f9372-170">It describes a set of principles and practices that developers follow to construct applications optimized for modern cloud environments.</span></span> <span data-ttu-id="f9372-171">特別注意跨環境的可攜性和聲明性自動化。</span><span class="sxs-lookup"><span data-stu-id="f9372-171">Special attention is given to portability across environments and declarative automation.</span></span>

<span data-ttu-id="f9372-172">雖然適用于任何基於 Web 的應用程式，但許多從業者認為它是構建雲原生應用的堅實基礎。</span><span class="sxs-lookup"><span data-stu-id="f9372-172">While applicable to any web-based application, many practitioners consider it as a solid foundation for building cloud-native apps.</span></span> <span data-ttu-id="f9372-173">基於這些原則構建的系統可以快速部署和擴展，並添加功能以快速回應市場變化。</span><span class="sxs-lookup"><span data-stu-id="f9372-173">Systems built upon these principles can deploy and scale rapidly and add features to react quickly to market changes.</span></span>

<span data-ttu-id="f9372-174">下表重點介紹了十二因數方法：</span><span class="sxs-lookup"><span data-stu-id="f9372-174">The following table highlights the Twelve-Factor methodology:</span></span>

|    |  <span data-ttu-id="f9372-175">因數</span><span class="sxs-lookup"><span data-stu-id="f9372-175">Factor</span></span> | <span data-ttu-id="f9372-176">說明</span><span class="sxs-lookup"><span data-stu-id="f9372-176">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="f9372-177">1</span><span class="sxs-lookup"><span data-stu-id="f9372-177">1</span></span> | <span data-ttu-id="f9372-178">代碼庫</span><span class="sxs-lookup"><span data-stu-id="f9372-178">Code Base</span></span> | <span data-ttu-id="f9372-179">每個微服務的單一代碼庫，存儲在其自己的存儲庫中。</span><span class="sxs-lookup"><span data-stu-id="f9372-179">A single code base for each microservice, stored in its own repository.</span></span> <span data-ttu-id="f9372-180">通過版本控制進行跟蹤，它可以部署到多個環境（QA、暫存、生產）。</span><span class="sxs-lookup"><span data-stu-id="f9372-180">Tracked with version control, it can deploy to multiple environments (QA, Staging, Production).</span></span> |
| <span data-ttu-id="f9372-181">2</span><span class="sxs-lookup"><span data-stu-id="f9372-181">2</span></span> | <span data-ttu-id="f9372-182">相依性</span><span class="sxs-lookup"><span data-stu-id="f9372-182">Dependencies</span></span> | <span data-ttu-id="f9372-183">每個微服務隔離和打包自己的依賴項，在不影響整個系統的情況下接受更改。</span><span class="sxs-lookup"><span data-stu-id="f9372-183">Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system.</span></span> |
| <span data-ttu-id="f9372-184">3</span><span class="sxs-lookup"><span data-stu-id="f9372-184">3</span></span> | <span data-ttu-id="f9372-185">組態</span><span class="sxs-lookup"><span data-stu-id="f9372-185">Configurations</span></span>  | <span data-ttu-id="f9372-186">配置資訊從微服務中移出，並通過代碼外部的建構管理工具進行外部化。</span><span class="sxs-lookup"><span data-stu-id="f9372-186">Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code.</span></span> <span data-ttu-id="f9372-187">相同的部署可以在應用正確配置的環境中傳播。</span><span class="sxs-lookup"><span data-stu-id="f9372-187">The same deployment can propagate across environments with the correct configuration applied.</span></span>  |
| <span data-ttu-id="f9372-188">4</span><span class="sxs-lookup"><span data-stu-id="f9372-188">4</span></span> | <span data-ttu-id="f9372-189">支援服務</span><span class="sxs-lookup"><span data-stu-id="f9372-189">Backing Services</span></span> | <span data-ttu-id="f9372-190">輔助資源（資料存儲、緩存、消息代理）應通過可定址 URL 公開。</span><span class="sxs-lookup"><span data-stu-id="f9372-190">Ancillary resources (data stores, caches, message brokers) should be exposed via an addressable URL.</span></span> <span data-ttu-id="f9372-191">這樣做會將資源與應用程式分離，使其可互換。</span><span class="sxs-lookup"><span data-stu-id="f9372-191">Doing so decouples the resource from the application, enabling it to be interchangeable.</span></span>  |
| <span data-ttu-id="f9372-192">5</span><span class="sxs-lookup"><span data-stu-id="f9372-192">5</span></span> | <span data-ttu-id="f9372-193">生成、發佈、運行</span><span class="sxs-lookup"><span data-stu-id="f9372-193">Build, Release, Run</span></span> | <span data-ttu-id="f9372-194">每個版本都必須在生成、發佈和運行階段強制實施嚴格的分離。</span><span class="sxs-lookup"><span data-stu-id="f9372-194">Each release must enforce a strict separation across the build, release, and run stages.</span></span> <span data-ttu-id="f9372-195">每個應標記一個唯一的 ID，並支援回滾的能力。</span><span class="sxs-lookup"><span data-stu-id="f9372-195">Each should be tagged with a unique ID and support the ability to roll back.</span></span> <span data-ttu-id="f9372-196">現代 CI/CD 系統有助於實現這一原則。</span><span class="sxs-lookup"><span data-stu-id="f9372-196">Modern CI/CD systems help fulfill this principle.</span></span> |
| <span data-ttu-id="f9372-197">6</span><span class="sxs-lookup"><span data-stu-id="f9372-197">6</span></span> | <span data-ttu-id="f9372-198">處理序</span><span class="sxs-lookup"><span data-stu-id="f9372-198">Processes</span></span> | <span data-ttu-id="f9372-199">每個微服務都應在自己的進程中執行，與其他正在運行的服務隔離。</span><span class="sxs-lookup"><span data-stu-id="f9372-199">Each microservice should execute in its own process,  isolated from other running services.</span></span> <span data-ttu-id="f9372-200">將所需狀態外部化到備份服務（如分散式緩存或資料存儲）。</span><span class="sxs-lookup"><span data-stu-id="f9372-200">Externalize required state to a backing service such as a distributed cache or data store.</span></span> |
| <span data-ttu-id="f9372-201">7</span><span class="sxs-lookup"><span data-stu-id="f9372-201">7</span></span> | <span data-ttu-id="f9372-202">連接埠繫結</span><span class="sxs-lookup"><span data-stu-id="f9372-202">Port Binding</span></span> | <span data-ttu-id="f9372-203">每個微服務都應自包含其介面和功能，並在其自己的埠上公開。</span><span class="sxs-lookup"><span data-stu-id="f9372-203">Each microservice should be self-contained with its interfaces and functionality exposed on its own port.</span></span> <span data-ttu-id="f9372-204">這樣做會與其他微服務隔離。</span><span class="sxs-lookup"><span data-stu-id="f9372-204">Doing so provides isolation from other microservices.</span></span> |
| <span data-ttu-id="f9372-205">8</span><span class="sxs-lookup"><span data-stu-id="f9372-205">8</span></span> | <span data-ttu-id="f9372-206">並行</span><span class="sxs-lookup"><span data-stu-id="f9372-206">Concurrency</span></span> | <span data-ttu-id="f9372-207">服務將擴展在大量小型相同進程（副本）上，而不是在最強大的電腦上擴展單個大型實例。</span><span class="sxs-lookup"><span data-stu-id="f9372-207">Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available.</span></span> |
| <span data-ttu-id="f9372-208">9</span><span class="sxs-lookup"><span data-stu-id="f9372-208">9</span></span> | <span data-ttu-id="f9372-209">可處置性</span><span class="sxs-lookup"><span data-stu-id="f9372-209">Disposability</span></span> | <span data-ttu-id="f9372-210">服務實例應該是一次性的，有利於快速啟動來增加可伸縮性機會和正常關機，使系統處於正確的狀態。</span><span class="sxs-lookup"><span data-stu-id="f9372-210">Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state.</span></span> <span data-ttu-id="f9372-211">Docker 容器以及協調器本身就滿足了此要求。</span><span class="sxs-lookup"><span data-stu-id="f9372-211">Docker containers along with an orchestrator inherently satisfy this requirement.</span></span> |
| <span data-ttu-id="f9372-212">10</span><span class="sxs-lookup"><span data-stu-id="f9372-212">10</span></span> | <span data-ttu-id="f9372-213">開發/昇冪同位</span><span class="sxs-lookup"><span data-stu-id="f9372-213">Dev/Prod Parity</span></span> | <span data-ttu-id="f9372-214">使整個應用程式生命週期中的環境盡可能相似，避免昂貴的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="f9372-214">Keep environments across the application lifecycle as similar as possible, avoiding costly shortcuts.</span></span> <span data-ttu-id="f9372-215">在這裡，採用容器可以極大地促進相同的執行環境。</span><span class="sxs-lookup"><span data-stu-id="f9372-215">Here, the adoption of containers can greatly contribute by promoting the same execution environment.</span></span> |
| <span data-ttu-id="f9372-216">11</span><span class="sxs-lookup"><span data-stu-id="f9372-216">11</span></span> | <span data-ttu-id="f9372-217">記錄</span><span class="sxs-lookup"><span data-stu-id="f9372-217">Logging</span></span> | <span data-ttu-id="f9372-218">將微服務生成的日誌視為事件流。</span><span class="sxs-lookup"><span data-stu-id="f9372-218">Treat logs generated by microservices as event streams.</span></span> <span data-ttu-id="f9372-219">使用事件聚合器處理它們，並將資料傳播到資料採礦/日誌管理工具（如 Azure 監視器或 Splunk），並最終進行長期存檔。</span><span class="sxs-lookup"><span data-stu-id="f9372-219">Process them with an event aggregator and propagate the data to data-mining/log management tools like Azure Monitor or Splunk and eventually long-term archival.</span></span> |
| <span data-ttu-id="f9372-220">12</span><span class="sxs-lookup"><span data-stu-id="f9372-220">12</span></span> | <span data-ttu-id="f9372-221">管理流程</span><span class="sxs-lookup"><span data-stu-id="f9372-221">Admin Processes</span></span> | <span data-ttu-id="f9372-222">將管理/管理工作作為一次性流程運行。</span><span class="sxs-lookup"><span data-stu-id="f9372-222">Run administrative/management tasks as one-off processes.</span></span> <span data-ttu-id="f9372-223">任務可以包括報表的資料清理和拉取分析。</span><span class="sxs-lookup"><span data-stu-id="f9372-223">Tasks can include data cleanup and pulling analytics for a report.</span></span> <span data-ttu-id="f9372-224">執行這些任務的工具應從生產環境調用，但與應用程式分開調用。</span><span class="sxs-lookup"><span data-stu-id="f9372-224">Tools executing these tasks should be  invoked from the production environment, but separately from the application.</span></span> |

<span data-ttu-id="f9372-225">在《 [十二因素應用》](https://content.pivotal.io/blog/beyond-the-twelve-factor-app)一書中，作者凱文·霍夫曼詳細介紹了最初的12個因素（寫于2011年）。</span><span class="sxs-lookup"><span data-stu-id="f9372-225">In the book, [Beyond the Twelve-Factor App](https://content.pivotal.io/blog/beyond-the-twelve-factor-app), author Kevin Hoffman details each of the original 12 factors (written in 2011).</span></span> <span data-ttu-id="f9372-226">此外，本書還提供了反映當今現代雲應用程式設計的三個附加因素。</span><span class="sxs-lookup"><span data-stu-id="f9372-226">Additionally, the book provides three additional factors that reflect today's modern cloud application design.</span></span>

|    |  <span data-ttu-id="f9372-227">新因素</span><span class="sxs-lookup"><span data-stu-id="f9372-227">New Factor</span></span> | <span data-ttu-id="f9372-228">說明</span><span class="sxs-lookup"><span data-stu-id="f9372-228">Explanation</span></span>  |
| :-------- | :-------- | :-------- |
| <span data-ttu-id="f9372-229">13</span><span class="sxs-lookup"><span data-stu-id="f9372-229">13</span></span> | <span data-ttu-id="f9372-230">API 優先</span><span class="sxs-lookup"><span data-stu-id="f9372-230">API First</span></span> | <span data-ttu-id="f9372-231">使一切成為服務。</span><span class="sxs-lookup"><span data-stu-id="f9372-231">Make everything a service.</span></span> <span data-ttu-id="f9372-232">假設您的代碼將被前端用戶端、閘道或其他服務使用。</span><span class="sxs-lookup"><span data-stu-id="f9372-232">Assume your code will be consumed by a front-end client, gateway, or another service.</span></span> |
| <span data-ttu-id="f9372-233">14</span><span class="sxs-lookup"><span data-stu-id="f9372-233">14</span></span> | <span data-ttu-id="f9372-234">遙測</span><span class="sxs-lookup"><span data-stu-id="f9372-234">Telemetry</span></span> | <span data-ttu-id="f9372-235">在工作站上，您可以深入瞭解應用程式及其行為。</span><span class="sxs-lookup"><span data-stu-id="f9372-235">On a workstation, you have deep visibility into your application and its behavior.</span></span> <span data-ttu-id="f9372-236">在雲中，你沒有。</span><span class="sxs-lookup"><span data-stu-id="f9372-236">In the cloud, you don't.</span></span> <span data-ttu-id="f9372-237">確保您的設計包括監視、特定于域和運行狀況/系統資料的集合。</span><span class="sxs-lookup"><span data-stu-id="f9372-237">Make sure your design includes the collection of monitoring, domain-specific, and health/system data.</span></span> |
| <span data-ttu-id="f9372-238">15</span><span class="sxs-lookup"><span data-stu-id="f9372-238">15</span></span> | <span data-ttu-id="f9372-239">身份驗證/授權</span><span class="sxs-lookup"><span data-stu-id="f9372-239">Authentication/ Authorization</span></span>  | <span data-ttu-id="f9372-240">從一開始就實現標識。</span><span class="sxs-lookup"><span data-stu-id="f9372-240">Implement identity from the start.</span></span> <span data-ttu-id="f9372-241">考慮公共雲中可用的[RBAC（基於角色的存取控制）](https://docs.microsoft.com/azure/role-based-access-control/overview)功能。</span><span class="sxs-lookup"><span data-stu-id="f9372-241">Consider [RBAC (role-based access control)](https://docs.microsoft.com/azure/role-based-access-control/overview) features available in public clouds.</span></span>  |

<span data-ttu-id="f9372-242">我們將參考本章和整個書中的 12 個以上因素中的許多。</span><span class="sxs-lookup"><span data-stu-id="f9372-242">We'll refer to many of the 12+ factors in this chapter and throughout the book.</span></span>

### <a name="critical-design-considerations"></a><span data-ttu-id="f9372-243">關鍵設計注意事項</span><span class="sxs-lookup"><span data-stu-id="f9372-243">Critical Design Considerations</span></span>

<span data-ttu-id="f9372-244">除了由十二因素方法提供的指導外，在構建分散式系統時，還必須做出一些關鍵的設計決策。</span><span class="sxs-lookup"><span data-stu-id="f9372-244">Beyond the guidance provided from the twelve-factor methodology, there are several critical design decisions you must make when constructing distributed systems.</span></span>

<span data-ttu-id="f9372-245">*通信*</span><span class="sxs-lookup"><span data-stu-id="f9372-245">*Communication*</span></span>

<span data-ttu-id="f9372-246">前端用戶端應用程式將如何與後端核心服務通信？</span><span class="sxs-lookup"><span data-stu-id="f9372-246">How will front-end client applications communicate with backed-end core services?</span></span> <span data-ttu-id="f9372-247">你會允許直接溝通嗎？</span><span class="sxs-lookup"><span data-stu-id="f9372-247">Will you allow direct communication?</span></span> <span data-ttu-id="f9372-248">或者，您是否使用提供靈活性、控制和安全性的閘道外觀抽象後端服務？</span><span class="sxs-lookup"><span data-stu-id="f9372-248">Or, might you abstract the back-end services with a gateway façade that provides  flexibility, control, and security?</span></span>

<span data-ttu-id="f9372-249">後端核心服務將如何相互通信？</span><span class="sxs-lookup"><span data-stu-id="f9372-249">How will back-end core services communicate with each other?</span></span> <span data-ttu-id="f9372-250">您是否允許直接 HTTP 調用導致耦合並影響性能和敏捷性？</span><span class="sxs-lookup"><span data-stu-id="f9372-250">Will you allow direct HTTP calls that lead to coupling and impact performance and agility?</span></span> <span data-ttu-id="f9372-251">或者，您可以考慮將消息傳送與佇列和主題技術分離？</span><span class="sxs-lookup"><span data-stu-id="f9372-251">Or might you consider decoupled messaging with queue and topic technologies?</span></span>

<span data-ttu-id="f9372-252">通信內容詳包括第 4 章，*雲-原生通訊模式*。</span><span class="sxs-lookup"><span data-stu-id="f9372-252">Communication is covered in detail Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

<span data-ttu-id="f9372-253">*復原*</span><span class="sxs-lookup"><span data-stu-id="f9372-253">*Resiliency*</span></span>

<span data-ttu-id="f9372-254">微服務體系結構將系統從進程內移動到網路通信。</span><span class="sxs-lookup"><span data-stu-id="f9372-254">A microservices architecture moves your system from in-process to network communication.</span></span> <span data-ttu-id="f9372-255">在分散式環境中，當服務 B 未回應服務 A 的呼叫時，您將執行什麼操作？</span><span class="sxs-lookup"><span data-stu-id="f9372-255">In a distributed environment, what will you do when Service B isn't responding to a call from Service A?</span></span> <span data-ttu-id="f9372-256">當服務 C 暫時不可用，其他調用它的服務將其堆疊並降低系統性能時，會發生什麼情況？</span><span class="sxs-lookup"><span data-stu-id="f9372-256">What happens when Service C becomes up temporarily unavailable and other services calling it stack and degrade system performance?</span></span>

<span data-ttu-id="f9372-257">復原能力詳包括第6章，*雲原生彈性*。</span><span class="sxs-lookup"><span data-stu-id="f9372-257">Resiliency is covered in detail Chapter 6, *Cloud-Native Resiliency*.</span></span>

<span data-ttu-id="f9372-258">*分散式資料*</span><span class="sxs-lookup"><span data-stu-id="f9372-258">*Distributed Data*</span></span>

<span data-ttu-id="f9372-259">根據設計，每個微服務封裝自己的資料，通過其公共介面公開操作。</span><span class="sxs-lookup"><span data-stu-id="f9372-259">By design, each microservice encapsulates its own data, exposing operations via its public interface.</span></span> <span data-ttu-id="f9372-260">如果是，您如何查詢資料或跨多個服務實現事務？</span><span class="sxs-lookup"><span data-stu-id="f9372-260">If so, how do you query data or implement a transaction across multiple services?</span></span>

<span data-ttu-id="f9372-261">分散式資料詳包括第 5 章，*雲原生資料模式*。</span><span class="sxs-lookup"><span data-stu-id="f9372-261">Distributed data is covered in detail Chapter 5, *Cloud-Native Data Patterns*.</span></span>

<span data-ttu-id="f9372-262">*身份*</span><span class="sxs-lookup"><span data-stu-id="f9372-262">*Identity*</span></span>

<span data-ttu-id="f9372-263">您的服務將如何識別訪問它的人員以及他們擁有哪些許可權？</span><span class="sxs-lookup"><span data-stu-id="f9372-263">How will your service identify who is accessing it and what permissions they have?</span></span>

<span data-ttu-id="f9372-264">身份詳包括第8章 *，《身份*》。</span><span class="sxs-lookup"><span data-stu-id="f9372-264">Identity is covered in detail Chapter 8, *Identity*.</span></span>

## <a name="microservices"></a><span data-ttu-id="f9372-265">微服務</span><span class="sxs-lookup"><span data-stu-id="f9372-265">Microservices</span></span>

<span data-ttu-id="f9372-266">雲原生系統採用微服務，這是構建現代應用程式的常用體系結構風格。</span><span class="sxs-lookup"><span data-stu-id="f9372-266">Cloud-native systems embrace microservices, a popular architectural style for constructing modern applications.</span></span>

<span data-ttu-id="f9372-267">微服務是一組分散式獨立服務，通過共用結構進行交互，具有以下特徵：</span><span class="sxs-lookup"><span data-stu-id="f9372-267">Built as a distributed set of small, independent services that interact through a shared fabric, microservices share the following characteristics:</span></span>

- <span data-ttu-id="f9372-268">每個在更大的網域內容中實現特定的業務功能。</span><span class="sxs-lookup"><span data-stu-id="f9372-268">Each implements a specific business capability within a larger domain context.</span></span>

- <span data-ttu-id="f9372-269">每個都是自主開發的，可以獨立部署。</span><span class="sxs-lookup"><span data-stu-id="f9372-269">Each is developed autonomously and can be deployed independently.</span></span>

- <span data-ttu-id="f9372-270">每個都是自包含封裝自己的資料存儲技術（SQL、NoSQL）和程式設計平臺。</span><span class="sxs-lookup"><span data-stu-id="f9372-270">Each is self-contained encapsulating its own data storage technology (SQL, NoSQL) and programming platform.</span></span>

- <span data-ttu-id="f9372-271">每個程式都運行在自己的進程中，並使用標準通訊協定（如 HTTP/HTTPS、WebSocket 或[AMQP）](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol)與他人通信。</span><span class="sxs-lookup"><span data-stu-id="f9372-271">Each runs in its own process and communicates with others using standard communication protocols such as HTTP/HTTPS, WebSockets, or [AMQP](https://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol).</span></span>

- <span data-ttu-id="f9372-272">它們組合在一起以形成一個應用程式。</span><span class="sxs-lookup"><span data-stu-id="f9372-272">They compose together to form an application.</span></span>

<span data-ttu-id="f9372-273">圖 1-4 將整體應用程式方法與微服務方法進行對比。</span><span class="sxs-lookup"><span data-stu-id="f9372-273">Figure 1-4 contrasts a monolithic application approach with a microservices approach.</span></span> <span data-ttu-id="f9372-274">請注意單體如何由分層體系結構組成，該體系結構在單個進程中執行。</span><span class="sxs-lookup"><span data-stu-id="f9372-274">Note how the monolith is composed of a layered architecture, which executes in a single process.</span></span> <span data-ttu-id="f9372-275">它通常使用關係資料庫。</span><span class="sxs-lookup"><span data-stu-id="f9372-275">It typically consumes a relational database.</span></span> <span data-ttu-id="f9372-276">但是，微服務方法將功能隔離到包含邏輯和資料的獨立服務中。</span><span class="sxs-lookup"><span data-stu-id="f9372-276">The microservice approach, however, segregates functionality into independent services that include logic and data.</span></span> <span data-ttu-id="f9372-277">每個微服務都託管自己的資料存儲。</span><span class="sxs-lookup"><span data-stu-id="f9372-277">Each microservice hosts its own datastore.</span></span>

![單片部署與微服務](./media/monolithic-vs-microservices.png)

<span data-ttu-id="f9372-279">**圖 1-4。**</span><span class="sxs-lookup"><span data-stu-id="f9372-279">**Figure 1-4.**</span></span> <span data-ttu-id="f9372-280">單片部署與微服務</span><span class="sxs-lookup"><span data-stu-id="f9372-280">Monolithic deployment versus microservices</span></span>

<span data-ttu-id="f9372-281">請注意，微服務如何從本章前面討論的[十二因數應用程式中](https://12factor.net/)推廣"一個代碼庫，一個應用程式"原則。</span><span class="sxs-lookup"><span data-stu-id="f9372-281">Note how microservices promote the "One Codebase, One Application" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="f9372-282">*因數\#1 指定"每個微服務的單一代碼庫，存儲在其自己的存儲庫中。通過版本控制進行跟蹤，它可以部署到多個環境。*</span><span class="sxs-lookup"><span data-stu-id="f9372-282">*Factor \#1  specifies "A single codebase for each microservice, stored in its own repository. Tracked with version control, it can deploy to multiple environments."*</span></span>

### <a name="why-microservices"></a><span data-ttu-id="f9372-283">使用微服務的理由？</span><span class="sxs-lookup"><span data-stu-id="f9372-283">Why microservices?</span></span>

<span data-ttu-id="f9372-284">微服務提供敏捷性。</span><span class="sxs-lookup"><span data-stu-id="f9372-284">Microservices provide agility.</span></span>

<span data-ttu-id="f9372-285">在本章前面，我們將構建為單一的電子商務應用程式與微服務進行了比較。</span><span class="sxs-lookup"><span data-stu-id="f9372-285">Earlier in the chapter, we compared an eCommerce application built as a monolith to that with microservices.</span></span> <span data-ttu-id="f9372-286">在此示例中，我們看到了一些明顯的好處：</span><span class="sxs-lookup"><span data-stu-id="f9372-286">In the example, we saw some clear benefits:</span></span>

- <span data-ttu-id="f9372-287">每個微服務都有自主生命週期，可以獨立發展並頻繁部署。</span><span class="sxs-lookup"><span data-stu-id="f9372-287">Each microservice has an autonomous lifecycle and can evolve independently and deploy frequently.</span></span> <span data-ttu-id="f9372-288">您不必等待季度版本來部署新功能或更新。</span><span class="sxs-lookup"><span data-stu-id="f9372-288">You don’t have to wait for a quarterly release to deploy a new features or update.</span></span> <span data-ttu-id="f9372-289">您可以更新複雜應用程式的一小塊區域，從而降低破壞整個系統的風險。</span><span class="sxs-lookup"><span data-stu-id="f9372-289">You can update a small area of a complex application with less risk of disrupting the entire system.</span></span>

- <span data-ttu-id="f9372-290">每個微服務都可以獨立擴展。</span><span class="sxs-lookup"><span data-stu-id="f9372-290">Each microservice can scale independently.</span></span> <span data-ttu-id="f9372-291">您只擴展那些需要更多處理能力或網路頻寬的服務，而不是將整個應用程式擴展為單個單元。</span><span class="sxs-lookup"><span data-stu-id="f9372-291">Instead of scaling the entire application as a single unit, you scale out only those services that require more processing power or network bandwidth.</span></span> <span data-ttu-id="f9372-292">這種細細微性的擴充方法可更好地控制系統，並有助於在擴展系統部分（而不是所有內容）時降低總體成本。</span><span class="sxs-lookup"><span data-stu-id="f9372-292">This  fine-grained approach to scaling provides for greater control of your system and helps to reduce overall costs as you scale portions of your system, not everything.</span></span>

<span data-ttu-id="f9372-293">理解微服務的優秀參考指南是[.NET 微服務：容器化 .NET 應用程式的體系結構](https://docs.microsoft.com/dotnet/standard/microservices-architecture/)。</span><span class="sxs-lookup"><span data-stu-id="f9372-293">An excellent reference guide for understanding microservices is [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/standard/microservices-architecture/).</span></span> <span data-ttu-id="f9372-294">這本書深入探討了微服務設計和建築。</span><span class="sxs-lookup"><span data-stu-id="f9372-294">The book deep dives into microservices design and architecture.</span></span> <span data-ttu-id="f9372-295">它是從 Microsoft 免費下載的[全棧微服務參考體系結構](https://github.com/dotnet-architecture/eShopOnContainers)的配套。</span><span class="sxs-lookup"><span data-stu-id="f9372-295">It's a companion for a [full-stack microservice reference architecture](https://github.com/dotnet-architecture/eShopOnContainers) available as a free download from Microsoft.</span></span>

### <a name="developing-microservices"></a><span data-ttu-id="f9372-296">開發微服務</span><span class="sxs-lookup"><span data-stu-id="f9372-296">Developing microservices</span></span>

<span data-ttu-id="f9372-297">微服務可以使用任何現代開發平臺創建。</span><span class="sxs-lookup"><span data-stu-id="f9372-297">Microservices can be created with any modern development platform.</span></span>

<span data-ttu-id="f9372-298">微軟 .NET 核心平臺是一個絕佳的選擇。</span><span class="sxs-lookup"><span data-stu-id="f9372-298">The Microsoft .NET Core platform is an excellent choice.</span></span> <span data-ttu-id="f9372-299">它具有許多內置功能，可簡化微服務開發， 具有免費和開源功能。</span><span class="sxs-lookup"><span data-stu-id="f9372-299">Free and open source, it has many built-in features to simplify microservice development.</span></span> <span data-ttu-id="f9372-300">.NET 核心是跨平臺的。</span><span class="sxs-lookup"><span data-stu-id="f9372-300">.NET Core is cross-platform.</span></span> <span data-ttu-id="f9372-301">可以在 Windows、macOS 和大多數 Linux 風格上構建和運行應用程式。</span><span class="sxs-lookup"><span data-stu-id="f9372-301">Applications can be built and run on Windows, macOS, and most flavors of Linux.</span></span>

<span data-ttu-id="f9372-302">.NET Core 性能極高，與 Node.js 和其他競爭平臺相比得分很高。</span><span class="sxs-lookup"><span data-stu-id="f9372-302">.NET Core is highly performant and has scored well in comparison to Node.js and other competing platforms.</span></span> <span data-ttu-id="f9372-303">有趣的是[，TechEmpower](https://www.techempower.com/)在許多 Web 應用程式平臺和框架中進行了一套廣泛的[性能基準](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext)測試。</span><span class="sxs-lookup"><span data-stu-id="f9372-303">Interestingly, [TechEmpower](https://www.techempower.com/) conducted an extensive set of [performance benchmarks](https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=plaintext) across many web application platforms and frameworks.</span></span> <span data-ttu-id="f9372-304">.NET Core 得分在前 10 名 - 遠高於 Node.js 和其他競爭平臺。</span><span class="sxs-lookup"><span data-stu-id="f9372-304">.NET Core scored in the top 10 - well above Node.js and other competing platforms.</span></span>

<span data-ttu-id="f9372-305">.NET 核心由 Microsoft 和 GitHub 上的 .NET 社區維護。</span><span class="sxs-lookup"><span data-stu-id="f9372-305">.NET Core is maintained by Microsoft and the .NET community on GitHub.</span></span>

## <a name="containers"></a><span data-ttu-id="f9372-306">容器</span><span class="sxs-lookup"><span data-stu-id="f9372-306">Containers</span></span>

<span data-ttu-id="f9372-307">如今，在任何有關*雲原生*的對話中，都自然而然地聽到術語*容器*。</span><span class="sxs-lookup"><span data-stu-id="f9372-307">Nowadays, it's natural to hear the term *container* mentioned in any conversation concerning *cloud native*.</span></span> <span data-ttu-id="f9372-308">在《[雲原生模式](https://www.manning.com/books/cloud-native-patterns)》一書中，作者科妮莉亞·大衛斯指出，"容器是雲原生軟體的一大推動因素。</span><span class="sxs-lookup"><span data-stu-id="f9372-308">In the book, [Cloud Native Patterns](https://www.manning.com/books/cloud-native-patterns), author Cornelia Davis observes that, "Containers are a great enabler of cloud-native software."</span></span> <span data-ttu-id="f9372-309">雲原生計算基金會將微服務容器化作為[雲原生跟蹤地圖](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png)的第一步 - 為企業開始雲原生之旅的指導。</span><span class="sxs-lookup"><span data-stu-id="f9372-309">The Cloud Native Computing Foundation places microservice containerization as the first step in their [Cloud-Native Trail Map](https://raw.githubusercontent.com/cncf/trailmap/master/CNCF_TrailMap_latest.png) - guidance for enterprises beginning their cloud-native journey.</span></span>

<span data-ttu-id="f9372-310">將微服務容器化簡單明瞭。</span><span class="sxs-lookup"><span data-stu-id="f9372-310">Containerizing a microservice is simple and straightforward.</span></span> <span data-ttu-id="f9372-311">代碼、其依賴項和運行時打包到稱為[容器映射](https://docs.docker.com/glossary/?term=image)的二進位檔案中。</span><span class="sxs-lookup"><span data-stu-id="f9372-311">The code, its dependencies, and runtime are packaged into a binary called a [container image](https://docs.docker.com/glossary/?term=image).</span></span> <span data-ttu-id="f9372-312">圖像存儲在[容器註冊表](https://caylent.com/container-registries/)中，它充當圖像的存儲庫或庫。</span><span class="sxs-lookup"><span data-stu-id="f9372-312">Images are stored in a [container registry](https://caylent.com/container-registries/), which acts as a repository or library for images.</span></span> <span data-ttu-id="f9372-313">註冊表可以位於開發電腦、資料中心或公共雲中。</span><span class="sxs-lookup"><span data-stu-id="f9372-313">A registry can be located on your development computer, in your data center, or in a public cloud.</span></span> <span data-ttu-id="f9372-314">Docker 本身通過 Docker [Hub](https://hub.docker.com/)維護公共註冊表。</span><span class="sxs-lookup"><span data-stu-id="f9372-314">Docker itself maintains a public registry via [Docker Hub](https://hub.docker.com/).</span></span> <span data-ttu-id="f9372-315">Azure 雲具有[容器註冊表](https://azure.microsoft.com/services/container-registry/)，用於存儲靠近將運行它們的雲應用程式的容器映射。</span><span class="sxs-lookup"><span data-stu-id="f9372-315">The Azure cloud features a [container registry](https://azure.microsoft.com/services/container-registry/) to store container images close to the cloud applications that will run them.</span></span>

<span data-ttu-id="f9372-316">如果需要，可以將映射轉換為正在運行的容器實例。</span><span class="sxs-lookup"><span data-stu-id="f9372-316">When needed, you transform the image into a running container instance.</span></span> <span data-ttu-id="f9372-317">實例在安裝了[容器運行時](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)引擎的任何電腦上運行。</span><span class="sxs-lookup"><span data-stu-id="f9372-317">The instance runs on any computer that has a [container runtime](https://kubernetes.io/docs/setup/production-environment/container-runtimes/) engine installed.</span></span> <span data-ttu-id="f9372-318">可以根據需要擁有盡可能多的容器化服務的實例。</span><span class="sxs-lookup"><span data-stu-id="f9372-318">You can have as many instances of the containerized service as needed.</span></span>

<span data-ttu-id="f9372-319">圖 1-5 顯示了三個不同的微服務，每個微服務都位於其自己的容器中，在單個主機上運行。</span><span class="sxs-lookup"><span data-stu-id="f9372-319">Figure 1-5 shows three different microservices, each in its own container, running on a single host.</span></span>

![在容器主機上執行的多個容器](./media/hosting-mulitple-containers.png)

<span data-ttu-id="f9372-321">**圖 1-5**.</span><span class="sxs-lookup"><span data-stu-id="f9372-321">**Figure 1-5**.</span></span> <span data-ttu-id="f9372-322">在容器主機上執行的多個容器</span><span class="sxs-lookup"><span data-stu-id="f9372-322">Multiple containers running on a container host</span></span>

<span data-ttu-id="f9372-323">請注意每個容器如何維護其自己的依賴項和運行時集，這些依賴項和運行時可能不同。</span><span class="sxs-lookup"><span data-stu-id="f9372-323">Note how each container maintains its own set of dependencies and runtime, which can be different.</span></span> <span data-ttu-id="f9372-324">在這裡，我們看到產品微服務的不同版本在同一主機上運行。</span><span class="sxs-lookup"><span data-stu-id="f9372-324">Here, we see different versions of the Product microservice running on the same host.</span></span> <span data-ttu-id="f9372-325">每個容器共用基礎主機作業系統、記憶體和處理器的一個切片，但彼此隔離。</span><span class="sxs-lookup"><span data-stu-id="f9372-325">Each container shares a slice of the underlying host operating system, memory, and processor, but is isolated from one another.</span></span>

<span data-ttu-id="f9372-326">請注意容器模型如何很好地接受[來自十二因數應用程式的](https://12factor.net/)"依賴"原則。</span><span class="sxs-lookup"><span data-stu-id="f9372-326">Note how well the container model embraces the "Dependencies" principle from the [Twelve-Factor Application](https://12factor.net/).</span></span>

> <span data-ttu-id="f9372-327">*因數\#2 指定"每個微服務隔離和打包其自己的依賴項，在不影響整個系統的情況下接受更改。*</span><span class="sxs-lookup"><span data-stu-id="f9372-327">*Factor \#2  specifies that "Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system."*</span></span>

<span data-ttu-id="f9372-328">容器同時支援 Linux 和 Windows 工作負載。</span><span class="sxs-lookup"><span data-stu-id="f9372-328">Containers support both Linux and Windows workloads.</span></span> <span data-ttu-id="f9372-329">Azure 雲公開包含這兩者。</span><span class="sxs-lookup"><span data-stu-id="f9372-329">The Azure cloud openly embraces both.</span></span> <span data-ttu-id="f9372-330">有趣的是，Linux，而不是Windows伺服器，已經成為Azure中最流行的作業系統。</span><span class="sxs-lookup"><span data-stu-id="f9372-330">Interestingly, it's Linux, not Windows Server, that has become the most popular operating system in Azure.</span></span>

<span data-ttu-id="f9372-331">雖然存在幾個集裝箱供應商，但 Docker 已經佔據了市場的大部分份額。</span><span class="sxs-lookup"><span data-stu-id="f9372-331">While several container vendors exist, Docker has captured the lion's share of the market.</span></span> <span data-ttu-id="f9372-332">該公司一直在推動軟體容器的移動。</span><span class="sxs-lookup"><span data-stu-id="f9372-332">The company has been driving the software container movement.</span></span> <span data-ttu-id="f9372-333">它已成為打包、部署和運行雲原生應用程式的實際標準。</span><span class="sxs-lookup"><span data-stu-id="f9372-333">It has become the de facto standard for packaging, deploying, and running cloud-native applications.</span></span>

### <a name="why-containers"></a><span data-ttu-id="f9372-334">為什麼選擇容器？</span><span class="sxs-lookup"><span data-stu-id="f9372-334">Why containers?</span></span>

<span data-ttu-id="f9372-335">容器提供可攜性，並保證跨環境的一致性。</span><span class="sxs-lookup"><span data-stu-id="f9372-335">Containers provide portability and guarantee consistency across environments.</span></span> <span data-ttu-id="f9372-336">通過將所有內容封裝到單個包中，您將微服務及其依賴項與基礎基礎結構*隔離*開來。</span><span class="sxs-lookup"><span data-stu-id="f9372-336">By encapsulating everything into a single package, you *isolate* the microservice and its dependencies from the underlying infrastructure.</span></span>

<span data-ttu-id="f9372-337">您可以在具有 Docker 運行時引擎的任何環境中部署同一容器。</span><span class="sxs-lookup"><span data-stu-id="f9372-337">You can deploy that same container in any environment that has the Docker runtime engine.</span></span> <span data-ttu-id="f9372-338">容器化工作負載還消除了使用框架、軟體庫和運行時引擎預先配置每個環境的費用。</span><span class="sxs-lookup"><span data-stu-id="f9372-338">Containerized workloads also eliminate the expense of pre-configuring each environment with frameworks, software libraries, and runtime engines.</span></span>

<span data-ttu-id="f9372-339">通過共用底層作業系統和主機資源，容器的佔用空間比整個虛擬機器小得多。</span><span class="sxs-lookup"><span data-stu-id="f9372-339">By sharing the underlying operating system and host resources, containers have a much smaller footprint than a full virtual machine.</span></span> <span data-ttu-id="f9372-340">較小的大小會增加給定主機可以同時運行的*密度*或微服務的數量。</span><span class="sxs-lookup"><span data-stu-id="f9372-340">The smaller size increases the *density*, or number of microservices, that a given host can run at one time.</span></span>

### <a name="container-orchestration"></a><span data-ttu-id="f9372-341">容器協調流程</span><span class="sxs-lookup"><span data-stu-id="f9372-341">Container orchestration</span></span>

<span data-ttu-id="f9372-342">雖然 Docker 等工具創建映射並運行容器，但您還需要工具來管理它們。</span><span class="sxs-lookup"><span data-stu-id="f9372-342">While tools such as Docker create images and run containers, you also need tools to manage them.</span></span> <span data-ttu-id="f9372-343">容器管理使用稱為容器協調器的特殊軟體程式來完成。</span><span class="sxs-lookup"><span data-stu-id="f9372-343">Container management is done with a special software program called a container orchestrator.</span></span> <span data-ttu-id="f9372-344">大規模運行時，容器編排至關重要。</span><span class="sxs-lookup"><span data-stu-id="f9372-344">When operating at scale, container orchestration is essential.</span></span>

<span data-ttu-id="f9372-345">圖 1-6 顯示了容器協調器提供的管理工作。</span><span class="sxs-lookup"><span data-stu-id="f9372-345">Figure 1-6 shows management tasks that container orchestrators provide.</span></span>

![容器協調器執行哪些操作](./media/what-container-orchestrators-do.png)

<span data-ttu-id="f9372-347">**圖1-6**.</span><span class="sxs-lookup"><span data-stu-id="f9372-347">**Figure 1-6**.</span></span> <span data-ttu-id="f9372-348">容器協調器執行哪些操作</span><span class="sxs-lookup"><span data-stu-id="f9372-348">What container orchestrators do</span></span>

<span data-ttu-id="f9372-349">下表描述了常見的業務流程任務。</span><span class="sxs-lookup"><span data-stu-id="f9372-349">The following table describes common orchestration tasks.</span></span>

|  <span data-ttu-id="f9372-350">工作</span><span class="sxs-lookup"><span data-stu-id="f9372-350">Tasks</span></span> | <span data-ttu-id="f9372-351">說明</span><span class="sxs-lookup"><span data-stu-id="f9372-351">Explanation</span></span>  |
| :-------- | :-------- |
| <span data-ttu-id="f9372-352">排程</span><span class="sxs-lookup"><span data-stu-id="f9372-352">Scheduling</span></span> | <span data-ttu-id="f9372-353">自動預配容器實例。</span><span class="sxs-lookup"><span data-stu-id="f9372-353">Automatically provision container instances.</span></span>|
| <span data-ttu-id="f9372-354">親和力/反親和力</span><span class="sxs-lookup"><span data-stu-id="f9372-354">Affinity/anti-affinity</span></span> | <span data-ttu-id="f9372-355">在附近或相距甚遠的地方預配容器，説明提供可用性和性能。</span><span class="sxs-lookup"><span data-stu-id="f9372-355">Provision containers nearby or far apart from each other, helping  availability and performance.</span></span> |
| <span data-ttu-id="f9372-356">健康狀況監視</span><span class="sxs-lookup"><span data-stu-id="f9372-356">Health monitoring</span></span> | <span data-ttu-id="f9372-357">自動檢測並糾正故障。</span><span class="sxs-lookup"><span data-stu-id="f9372-357">Automatically detect and correct failures.</span></span>|
| <span data-ttu-id="f9372-358">容錯移轉</span><span class="sxs-lookup"><span data-stu-id="f9372-358">Failover</span></span> | <span data-ttu-id="f9372-359">自動將失敗的實例重新調配到正常運行的電腦。</span><span class="sxs-lookup"><span data-stu-id="f9372-359">Automatically reprovision failed instance to healthy machines.</span></span>|
| <span data-ttu-id="f9372-360">調整大小</span><span class="sxs-lookup"><span data-stu-id="f9372-360">Scaling</span></span> | <span data-ttu-id="f9372-361">自動添加或刪除容器實例以滿足需求。</span><span class="sxs-lookup"><span data-stu-id="f9372-361">Automatically add or remove container instance to meet demand.</span></span>|
| <span data-ttu-id="f9372-362">網路功能</span><span class="sxs-lookup"><span data-stu-id="f9372-362">Networking</span></span> | <span data-ttu-id="f9372-363">管理容器通信的網路覆蓋。</span><span class="sxs-lookup"><span data-stu-id="f9372-363">Manage a networking overlay for container communication.</span></span>|
| <span data-ttu-id="f9372-364">服務探索</span><span class="sxs-lookup"><span data-stu-id="f9372-364">Service Discovery</span></span> | <span data-ttu-id="f9372-365">使容器能夠彼此定位。</span><span class="sxs-lookup"><span data-stu-id="f9372-365">Enable containers to locate each other.</span></span>|
| <span data-ttu-id="f9372-366">輪流升級</span><span class="sxs-lookup"><span data-stu-id="f9372-366">Rolling Upgrades</span></span> | <span data-ttu-id="f9372-367">通過零停機時間部署協調增量升級。</span><span class="sxs-lookup"><span data-stu-id="f9372-367">Coordinate incremental upgrades with zero downtime deployment.</span></span> <span data-ttu-id="f9372-368">自動回滾有問題的更改。</span><span class="sxs-lookup"><span data-stu-id="f9372-368">Automatically roll back problematic changes.</span></span>|

<span data-ttu-id="f9372-369">請注意，協調器如何接受本章前面討論的[十二因數應用程式中](https://12factor.net/)的可處置性和併發性原則。</span><span class="sxs-lookup"><span data-stu-id="f9372-369">Note how orchestrators embrace the disposability and concurrency principles from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

> <span data-ttu-id="f9372-370">*因數\#9 指定"服務實例應該是一次性的，有利於快速啟動來增加可伸縮性機會和正常關機，使系統處於正確的狀態。Docker 容器以及協調器本身就滿足了這一要求。*</span><span class="sxs-lookup"><span data-stu-id="f9372-370">*Factor \#9  specifies that "Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state. Docker containers along with an orchestrator inherently satisfy this requirement."*</span></span>

> <span data-ttu-id="f9372-371">*因數\#8 指定"服務跨大量小型相同進程（副本）進行橫向擴展，而不是在最強大的電腦上擴展單個大型實例。*</span><span class="sxs-lookup"><span data-stu-id="f9372-371">*Factor \#8  specifies that "Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available."*</span></span>

<span data-ttu-id="f9372-372">雖然存在多個容器協調器，[但庫伯奈斯](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/)已成為雲原生世界的實際標準。</span><span class="sxs-lookup"><span data-stu-id="f9372-372">While several container orchestrators exist, [Kubernetes](https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/) has become the de facto standard for the cloud-native world.</span></span> <span data-ttu-id="f9372-373">它是一個可移植的、可擴展的開源平臺，用於管理容器化工作負載。</span><span class="sxs-lookup"><span data-stu-id="f9372-373">It's a portable, extensible, open-source platform for managing containerized workloads.</span></span>

<span data-ttu-id="f9372-374">您可以託管自己的 Kubernetes 實例，但隨後您將負責預配和管理其資源-這可能很複雜。</span><span class="sxs-lookup"><span data-stu-id="f9372-374">You could host your own instance of Kubernetes, but then you'd be responsible for provisioning and managing its resources - which can be complex.</span></span> <span data-ttu-id="f9372-375">Azure 雲將庫伯奈斯作為託管服務[，Azure 庫伯奈斯服務 （AKS） 。](https://azure.microsoft.com/services/kubernetes-service/)</span><span class="sxs-lookup"><span data-stu-id="f9372-375">The Azure cloud features Kubernetes as a managed service, [Azure Kubernetes Service (AKS)](https://azure.microsoft.com/services/kubernetes-service/).</span></span> <span data-ttu-id="f9372-376">託管服務允許您充分利用其功能，而無需安裝和維護它。</span><span class="sxs-lookup"><span data-stu-id="f9372-376">A managed service allows you to fully leverage its features, without having to install and maintain it.</span></span>

<span data-ttu-id="f9372-377">Azure 庫伯奈斯服務詳細介紹了第 2 章"*擴展雲原生應用程式*"。</span><span class="sxs-lookup"><span data-stu-id="f9372-377">Azure Kubernetes Services is covered in detail Chapter 2, *Scaling Cloud-Native Applications*.</span></span>

## <a name="backing-services"></a><span data-ttu-id="f9372-378">支援服務</span><span class="sxs-lookup"><span data-stu-id="f9372-378">Backing services</span></span>

<span data-ttu-id="f9372-379">雲本機系統依賴于許多不同的輔助資源，如資料存儲、消息代理、監視和標識服務。</span><span class="sxs-lookup"><span data-stu-id="f9372-379">Cloud-native systems depend upon many different ancillary resources, such as data stores, message brokers, monitoring, and identity services.</span></span> <span data-ttu-id="f9372-380">這些服務被稱為[支援服務](https://12factor.net/backing-services)。</span><span class="sxs-lookup"><span data-stu-id="f9372-380">These services are known as [backing services](https://12factor.net/backing-services).</span></span>

 <span data-ttu-id="f9372-381">圖 1-7 顯示了雲本機系統使用的許多常見支援服務。</span><span class="sxs-lookup"><span data-stu-id="f9372-381">Figure 1-7 shows many common backing services that cloud-native systems consume.</span></span>

![常見的支援服務](./media/common-backing-services.png)

<span data-ttu-id="f9372-383">**圖 1-7**.</span><span class="sxs-lookup"><span data-stu-id="f9372-383">**Figure 1-7**.</span></span> <span data-ttu-id="f9372-384">常見的支援服務</span><span class="sxs-lookup"><span data-stu-id="f9372-384">Common backing services</span></span>

<span data-ttu-id="f9372-385">支援服務從本章前面討論的[十二因數應用](https://12factor.net/)中推廣"無國籍"原則。</span><span class="sxs-lookup"><span data-stu-id="f9372-385">Backing services promote the "Statelessness" principle from the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="f9372-386">*因數\#6*指定，"每個微服務都應在其自己的進程中執行，與其他正在運行的服務隔離。</span><span class="sxs-lookup"><span data-stu-id="f9372-386">*Factor \#6* specifies that, "Each microservice should execute in its own process, isolated from other running services.</span></span> <span data-ttu-id="f9372-387">將所需狀態外部化到備份服務（如分散式緩存或資料存儲）。</span><span class="sxs-lookup"><span data-stu-id="f9372-387">Externalize required state to a backing service such as a distributed cache or data store."</span></span>

<span data-ttu-id="f9372-388">您可以託管自己的支援服務，但隨後您將負責許可、預配和管理這些資源。</span><span class="sxs-lookup"><span data-stu-id="f9372-388">You could host your own backing services, but then you'd be responsible for licensing, provisioning, and managing those resources.</span></span>

<span data-ttu-id="f9372-389">雲供應商提供種類繁多的*託管支援服務。*</span><span class="sxs-lookup"><span data-stu-id="f9372-389">Cloud providers offer a rich assortment of *managed backing services.*</span></span> <span data-ttu-id="f9372-390">您只需使用該服務，而不是擁有該服務。</span><span class="sxs-lookup"><span data-stu-id="f9372-390">Instead of owning the service, you simply consume it.</span></span> <span data-ttu-id="f9372-391">供應商大規模運營資源，並負責性能、安全性和維護。</span><span class="sxs-lookup"><span data-stu-id="f9372-391">The provider operates the resource at scale and bears the responsibility for performance, security, and maintenance.</span></span> <span data-ttu-id="f9372-392">服務中內置了監視、冗余和可用性。</span><span class="sxs-lookup"><span data-stu-id="f9372-392">Monitoring, redundancy, and availability are built into the service.</span></span> <span data-ttu-id="f9372-393">供應商完全支援其託管服務 - 打開票證，他們修復您的問題。</span><span class="sxs-lookup"><span data-stu-id="f9372-393">Providers fully support their managed services - open a ticket and they fix your issue.</span></span>

<span data-ttu-id="f9372-394">雲原生系統青睞雲供應商的託管支援服務。</span><span class="sxs-lookup"><span data-stu-id="f9372-394">Cloud-native systems favor managed backing services from cloud vendors.</span></span> <span data-ttu-id="f9372-395">時間和工作力的節省很大。</span><span class="sxs-lookup"><span data-stu-id="f9372-395">The savings in time and labor are great.</span></span> <span data-ttu-id="f9372-396">託管您自己的操作風險和遇到麻煩可能會很快變得昂貴。</span><span class="sxs-lookup"><span data-stu-id="f9372-396">The operational risk of hosting your own and experiencing trouble can get expensive fast.</span></span>

<span data-ttu-id="f9372-397">最佳做法是將備份服務視為*附加資源*，動態繫結到微服務，其中資訊（URL 和憑據）存儲在外部配置中。</span><span class="sxs-lookup"><span data-stu-id="f9372-397">A best practice is to treat a backing service as an *attached resource*, dynamically bound to a microservice with information (a URL and credentials) stored in an external configuration.</span></span> <span data-ttu-id="f9372-398">本指南在本章前面討論的[十二因數應用程式中](https://12factor.net/)進行了詳細說明。</span><span class="sxs-lookup"><span data-stu-id="f9372-398">This guidance is spelled out in the [Twelve-Factor Application](https://12factor.net/), discussed earlier in the chapter.</span></span>

><span data-ttu-id="f9372-399">*因數\#4*指定支援服務"應通過可定址 URL 公開。</span><span class="sxs-lookup"><span data-stu-id="f9372-399">*Factor \#4* specifies that backing services "should be exposed via an addressable URL.</span></span> <span data-ttu-id="f9372-400">這樣做會將資源與應用程式分離，使其易於互換。</span><span class="sxs-lookup"><span data-stu-id="f9372-400">Doing so decouples the resource from the application, enabling it to be interchangeable."</span></span>

><span data-ttu-id="f9372-401">*因數\#3*指定"配置資訊從微服務中移出，並通過代碼外部的建構管理工具進行外部化。</span><span class="sxs-lookup"><span data-stu-id="f9372-401">*Factor \#3* specifies that "Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code."</span></span>

<span data-ttu-id="f9372-402">使用此模式，無需更改代碼即可連接和分離支援服務。</span><span class="sxs-lookup"><span data-stu-id="f9372-402">With this pattern, a backing service can be attached and detached without code changes.</span></span> <span data-ttu-id="f9372-403">您可以將微服務從 QA 提升為暫存環境。</span><span class="sxs-lookup"><span data-stu-id="f9372-403">You might promote a microservice from QA to a staging environment.</span></span> <span data-ttu-id="f9372-404">更新微服務配置以指向暫存中的備份服務，並通過環境變數將設置注入容器。</span><span class="sxs-lookup"><span data-stu-id="f9372-404">You update the microservice configuration to point to the backing services in staging and inject the settings into your container through an environment variable.</span></span>

<span data-ttu-id="f9372-405">雲供應商提供 API，以便您與其專有的支援服務進行通信。</span><span class="sxs-lookup"><span data-stu-id="f9372-405">Cloud vendors provide APIs for you to communicate with their proprietary backing services.</span></span> <span data-ttu-id="f9372-406">這些庫封裝了管道和複雜性。</span><span class="sxs-lookup"><span data-stu-id="f9372-406">These libraries encapsulate the plumbing and complexity.</span></span> <span data-ttu-id="f9372-407">直接與這些 API 通信會將代碼與備份服務緊密耦合。</span><span class="sxs-lookup"><span data-stu-id="f9372-407">Communicating directly with these APIs will tightly couple your code to the backing service.</span></span> <span data-ttu-id="f9372-408">最好隔離供應商 API 的實現詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="f9372-408">It's a better practice to insulate the implementation details of the vendor API.</span></span> <span data-ttu-id="f9372-409">引入仲介層或中間 API，將泛型操作公開給服務代碼。</span><span class="sxs-lookup"><span data-stu-id="f9372-409">Introduce an intermediation layer, or intermediate API, exposing generic operations to your service code.</span></span> <span data-ttu-id="f9372-410">這種鬆散的耦合使您能夠將一個備份服務交換到另一個備份服務，或者將代碼移動到其他公共雲，而無需更改主線服務代碼。</span><span class="sxs-lookup"><span data-stu-id="f9372-410">This loose coupling enables you to swap out one backing service for another or move your code to a different public cloud without having to make changes to the mainline service code.</span></span>

<span data-ttu-id="f9372-411">支援服務將詳細討論第 5 章，*雲原生資料模式*，和第 4 章，*雲-本機通訊模式*。</span><span class="sxs-lookup"><span data-stu-id="f9372-411">Backing services are discussed in detail Chapter 5, *Cloud-Native Data Patterns*, and Chapter 4, *Cloud-Native Communication Patterns*.</span></span>

## <a name="automation"></a><span data-ttu-id="f9372-412">自動化</span><span class="sxs-lookup"><span data-stu-id="f9372-412">Automation</span></span>

<span data-ttu-id="f9372-413">正如您所看到的，雲原生系統採用微服務、容器和現代系統設計，以實現速度和敏捷性。</span><span class="sxs-lookup"><span data-stu-id="f9372-413">As you've seen, cloud-native systems embrace microservices, containers, and modern system design to achieve speed and agility.</span></span> <span data-ttu-id="f9372-414">但是，這只是故事的一部分。</span><span class="sxs-lookup"><span data-stu-id="f9372-414">But, that's only part of the story.</span></span> <span data-ttu-id="f9372-415">如何預配這些系統運行的雲環境？</span><span class="sxs-lookup"><span data-stu-id="f9372-415">How do you provision the cloud environments upon which these systems run?</span></span> <span data-ttu-id="f9372-416">如何快速部署應用功能和更新？</span><span class="sxs-lookup"><span data-stu-id="f9372-416">How do you rapidly deploy app features and updates?</span></span> <span data-ttu-id="f9372-417">你如何全面瞭解情況？</span><span class="sxs-lookup"><span data-stu-id="f9372-417">How do you round out the full picture?</span></span>

<span data-ttu-id="f9372-418">輸入廣泛接受的[基礎結構作為代碼](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)，或 IaC 的實踐。</span><span class="sxs-lookup"><span data-stu-id="f9372-418">Enter the widely accepted practice of [Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), or IaC.</span></span>

<span data-ttu-id="f9372-419">使用 IaC，您可以自動執行平台佈建和應用程式部署。</span><span class="sxs-lookup"><span data-stu-id="f9372-419">With IaC, you automate platform provisioning and application deployment.</span></span> <span data-ttu-id="f9372-420">您基本上將軟體工程實踐（如測試和版本控制）應用於 DevOps 實踐。</span><span class="sxs-lookup"><span data-stu-id="f9372-420">You essentially apply software engineering practices such as testing and versioning to your DevOps practices.</span></span> <span data-ttu-id="f9372-421">您的基礎架構和部署是自動化、一致且可重複的。</span><span class="sxs-lookup"><span data-stu-id="f9372-421">Your infrastructure and deployments are automated, consistent, and repeatable.</span></span>

### <a name="automating-infrastructure"></a><span data-ttu-id="f9372-422">自動化基礎架構</span><span class="sxs-lookup"><span data-stu-id="f9372-422">Automating infrastructure</span></span>

<span data-ttu-id="f9372-423">Azure[資源管理器](https://azure.microsoft.com/documentation/articles/resource-group-overview/)、Terraform 和 Azure [CLI](https://docs.microsoft.com/cli/azure/)等工具使您能夠以聲明方式編寫所需的雲基礎結構的腳本。</span><span class="sxs-lookup"><span data-stu-id="f9372-423">Tools like [Azure Resource Manager](https://azure.microsoft.com/documentation/articles/resource-group-overview/), Terraform, and the [Azure CLI](https://docs.microsoft.com/cli/azure/), enable you to declaratively script the cloud infrastructure you require.</span></span> <span data-ttu-id="f9372-424">資源名稱、位置、容量和機密是參數化的和動態的。</span><span class="sxs-lookup"><span data-stu-id="f9372-424">Resource names, locations, capacities, and secrets are parameterized and dynamic.</span></span> <span data-ttu-id="f9372-425">腳本作為專案的專案版本控制和簽入原始程式碼管理。</span><span class="sxs-lookup"><span data-stu-id="f9372-425">The script is versioned and checked into source control as an artifact of your project.</span></span> <span data-ttu-id="f9372-426">調用腳本可跨系統內容（如 QA、暫存和生產）預配一致且可重複的基礎結構。</span><span class="sxs-lookup"><span data-stu-id="f9372-426">You invoke the script to provision a consistent and repeatable infrastructure across system environments, such as QA, staging, and production.</span></span>

<span data-ttu-id="f9372-427">在引擎蓋下，IaC是冪等的，這意味著你可以運行相同的腳本一遍又一遍沒有副作用。</span><span class="sxs-lookup"><span data-stu-id="f9372-427">Under the hood, IaC is idempotent, meaning that you can run the same script over and over without side effects.</span></span> <span data-ttu-id="f9372-428">如果團隊需要進行更改，他們將編輯並重新運行腳本。</span><span class="sxs-lookup"><span data-stu-id="f9372-428">If the team needs to make a change, they edit and rerun the script.</span></span> <span data-ttu-id="f9372-429">只有更新的資源受到影響。</span><span class="sxs-lookup"><span data-stu-id="f9372-429">Only the updated resources are affected.</span></span>

<span data-ttu-id="f9372-430">在《[什麼是基礎設施是代碼》](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code)一文中，作者 Sam Guckenheimer 描述了"實施 IaC 的團隊如何快速、大規模地提供穩定的環境。</span><span class="sxs-lookup"><span data-stu-id="f9372-430">In the article, [What is Infrastructure as Code](https://docs.microsoft.com/azure/devops/learn/what-is-infrastructure-as-code), Author Sam Guckenheimer describes how, "Teams who implement IaC can deliver stable environments rapidly and at scale.</span></span> <span data-ttu-id="f9372-431">團隊通過代碼表示其環境的所需狀態，避免手動設定環境並增強一致性。</span><span class="sxs-lookup"><span data-stu-id="f9372-431">Teams avoid manual configuration of environments and enforce consistency by representing the desired state of their environments via code.</span></span> <span data-ttu-id="f9372-432">具有 IaC 的基礎結構部署是可重複的，可防止由於配置漂移或缺少依賴項而導致的運行時問題。</span><span class="sxs-lookup"><span data-stu-id="f9372-432">Infrastructure deployments with IaC are repeatable and prevent runtime issues caused by configuration drift or missing dependencies.</span></span> <span data-ttu-id="f9372-433">DevOps 團隊可以協同使用一套統一的實踐和工具，快速、可靠、大規模地交付應用程式及其支援基礎架構。</span><span class="sxs-lookup"><span data-stu-id="f9372-433">DevOps teams can work together with a unified set of practices and tools to deliver applications and their supporting infrastructure rapidly, reliably, and at scale."</span></span>

### <a name="automating-deployments"></a><span data-ttu-id="f9372-434">自動化部署</span><span class="sxs-lookup"><span data-stu-id="f9372-434">Automating deployments</span></span>

<span data-ttu-id="f9372-435">前面討論的[十二因數應用程式](https://12factor.net/)要求在將已完成的代碼轉換為正在運行的應用程式時採取單獨的步驟。</span><span class="sxs-lookup"><span data-stu-id="f9372-435">The [Twelve-Factor Application](https://12factor.net/), discussed earlier, calls for separate steps when transforming completed code into a running application.</span></span>

> <span data-ttu-id="f9372-436">*因數\#5*指定"每個版本必須跨生成、發佈和運行階段強制實施嚴格的分離。</span><span class="sxs-lookup"><span data-stu-id="f9372-436">*Factor \#5* specifies that "Each release must enforce a strict separation across the build, release and run stages.</span></span> <span data-ttu-id="f9372-437">每個都應使用唯一的 ID 標記，並支援回滾的能力。</span><span class="sxs-lookup"><span data-stu-id="f9372-437">Each should be tagged with a unique ID and support the ability to roll back."</span></span>

<span data-ttu-id="f9372-438">現代 CI/CD 系統有助於實現這一原則。</span><span class="sxs-lookup"><span data-stu-id="f9372-438">Modern CI/CD systems help fulfill this principle.</span></span> <span data-ttu-id="f9372-439">它們提供了單獨的部署步驟，有助於確保使用者隨時可用的一致且高品質的代碼。</span><span class="sxs-lookup"><span data-stu-id="f9372-439">They provide separate deployment steps and help ensure consistent and quality code that's readily available to users.</span></span>

<span data-ttu-id="f9372-440">圖 1-8 顯示了整個部署過程的分離。</span><span class="sxs-lookup"><span data-stu-id="f9372-440">Figure 1-8 shows the separation across the deployment process.</span></span>

![CI/CD 管道中的部署步驟](./media/build-release-run-pipeline.png)

<span data-ttu-id="f9372-442">**圖 1-8**.</span><span class="sxs-lookup"><span data-stu-id="f9372-442">**Figure 1-8**.</span></span> <span data-ttu-id="f9372-443">CI/CD 管道中的部署步驟</span><span class="sxs-lookup"><span data-stu-id="f9372-443">Deployment steps in a CI/CD Pipeline</span></span>

<span data-ttu-id="f9372-444">在上圖中，特別注意任務分離。</span><span class="sxs-lookup"><span data-stu-id="f9372-444">In the previous figure, pay special attention to separation of tasks.</span></span>

<span data-ttu-id="f9372-445">開發人員在其開發環境中構造一個功能，通過代碼、運行和調試的所謂"內部迴圈"進行反覆運算。</span><span class="sxs-lookup"><span data-stu-id="f9372-445">The developer constructs a feature in their development environment, iterating through what is called the "inner loop" of code, run, and debug.</span></span> <span data-ttu-id="f9372-446">完成後，該代碼將*推送*到代碼存儲庫中，如 GitHub、Azure DevOps 或 BitBucket。</span><span class="sxs-lookup"><span data-stu-id="f9372-446">When complete, that code is *pushed* into a code repository, such as GitHub, Azure DevOps, or BitBucket.</span></span>

<span data-ttu-id="f9372-447">推送將觸發生成階段，將代碼轉換為二進位專案。</span><span class="sxs-lookup"><span data-stu-id="f9372-447">The push triggers a build stage that transforms the code into a binary artifact.</span></span> <span data-ttu-id="f9372-448">工作使用[持續集成 （CI）](https://martinfowler.com/articles/continuousIntegration.html)管道實現。</span><span class="sxs-lookup"><span data-stu-id="f9372-448">The work is implemented with a [Continuous Integration (CI)](https://martinfowler.com/articles/continuousIntegration.html) pipeline.</span></span> <span data-ttu-id="f9372-449">它會自動生成、測試和打包應用程式。</span><span class="sxs-lookup"><span data-stu-id="f9372-449">It automatically builds, tests, and packages the application.</span></span>

<span data-ttu-id="f9372-450">發佈階段拾取二進位專案，應用外部應用程式和環境配置資訊，並生成不可變版本。</span><span class="sxs-lookup"><span data-stu-id="f9372-450">The release stage picks up the binary artifact, applies external application and environment configuration information, and produces an immutable release.</span></span> <span data-ttu-id="f9372-451">該版本部署到指定的環境。</span><span class="sxs-lookup"><span data-stu-id="f9372-451">The release is deployed to a specified environment.</span></span> <span data-ttu-id="f9372-452">工作使用[連續交付 （CD）](https://martinfowler.com/bliki/ContinuousDelivery.html)管道實現。</span><span class="sxs-lookup"><span data-stu-id="f9372-452">The work is implemented with a [Continuous Delivery(CD)](https://martinfowler.com/bliki/ContinuousDelivery.html) pipeline.</span></span> <span data-ttu-id="f9372-453">每個版本都應可識別。</span><span class="sxs-lookup"><span data-stu-id="f9372-453">Each release should be identifiable.</span></span> <span data-ttu-id="f9372-454">您可以說，"此部署正在運行應用程式的第 2.1.1 版。</span><span class="sxs-lookup"><span data-stu-id="f9372-454">You can say, "This deployment is running Release 2.1.1 of the application."</span></span>

<span data-ttu-id="f9372-455">最後，在目標執行環境中運行釋放的功能。</span><span class="sxs-lookup"><span data-stu-id="f9372-455">Finally, the released feature is run in the target execution environment.</span></span> <span data-ttu-id="f9372-456">版本是不可變的，這意味著任何更改都必須創建新版本。</span><span class="sxs-lookup"><span data-stu-id="f9372-456">Releases are immutable meaning that any change must create a new release.</span></span>

<span data-ttu-id="f9372-457">應用這些實踐，組織已經從根本上改變了它們運送軟體的方式。</span><span class="sxs-lookup"><span data-stu-id="f9372-457">Applying these practices, organizations have radically evolved how they ship software.</span></span> <span data-ttu-id="f9372-458">許多產品已經從季度發佈遷移到按需更新。</span><span class="sxs-lookup"><span data-stu-id="f9372-458">Many have moved from quarterly releases to on-demand updates.</span></span> <span data-ttu-id="f9372-459">目標是在開發週期的早期發現問題，而問題修復成本較低。</span><span class="sxs-lookup"><span data-stu-id="f9372-459">The goal is to catch problems early in the development cycle when they're less expensive to fix.</span></span> <span data-ttu-id="f9372-460">集成之間的持續時間越長，解決問題的成本就越高。</span><span class="sxs-lookup"><span data-stu-id="f9372-460">The longer the duration between integrations, the more expensive problems become to resolve.</span></span>  <span data-ttu-id="f9372-461">通過集成過程的一致性，團隊可以更頻繁地提交代碼更改，從而提供更好的協作和軟體品質。</span><span class="sxs-lookup"><span data-stu-id="f9372-461">With consistency in the integration process, teams can commit code changes more frequently, leading to better collaboration and software quality.</span></span>

### <a name="azure-pipelines"></a><span data-ttu-id="f9372-462">Azure Pipelines</span><span class="sxs-lookup"><span data-stu-id="f9372-462">Azure Pipelines</span></span>

<span data-ttu-id="f9372-463">Azure 雲包括名為[Azure 管道](https://azure.microsoft.com/services/devops/pipelines/)的新 CI/CD 服務，該服務是圖 1-9 所示的[Azure DevOps](https://azure.microsoft.com/services/devops/)服務的一部分。</span><span class="sxs-lookup"><span data-stu-id="f9372-463">The Azure cloud includes a new CI/CD service entitled [Azure Pipelines](https://azure.microsoft.com/services/devops/pipelines/), which is part of the [Azure DevOps](https://azure.microsoft.com/services/devops/) offering shown in Figure 1-9.</span></span>

![開發人員中的 Azure 管道](./media/devops-components.png)

<span data-ttu-id="f9372-465">**圖 1-9**.</span><span class="sxs-lookup"><span data-stu-id="f9372-465">**Figure 1-9**.</span></span> <span data-ttu-id="f9372-466">Azure 開發人員計畫產品</span><span class="sxs-lookup"><span data-stu-id="f9372-466">Azure DevOps offerings</span></span>

<span data-ttu-id="f9372-467">Azure 管道是一種雲服務，結合了持續集成 （CI） 和持續交付 （CD）。</span><span class="sxs-lookup"><span data-stu-id="f9372-467">Azure Pipelines is a cloud service that combines continuous integration (CI) and continuous delivery (CD).</span></span> <span data-ttu-id="f9372-468">您可以自動測試、生成代碼並將代碼運送到任何目標。</span><span class="sxs-lookup"><span data-stu-id="f9372-468">You can automatically test, build, and ship your code to any target.</span></span>

<span data-ttu-id="f9372-469">在 YAML 檔中的代碼中定義管道，以及應用的其他代碼。</span><span class="sxs-lookup"><span data-stu-id="f9372-469">You define your pipeline in code in a YAML file alongside the rest of the code for your app.</span></span>

- <span data-ttu-id="f9372-470">管道使用代碼進行版本控制，並遵循相同的分支結構。</span><span class="sxs-lookup"><span data-stu-id="f9372-470">The pipeline is versioned with your code and follows the same branching structure.</span></span>
- <span data-ttu-id="f9372-471">通過在拉取請求和分支生成策略中的代碼評審來驗證更改。</span><span class="sxs-lookup"><span data-stu-id="f9372-471">You get validation of your changes through code reviews in pull requests and branch build policies.</span></span>
- <span data-ttu-id="f9372-472">使用的每個分支都可以通過修改 azure 管道.yml 檔來自訂生成策略。</span><span class="sxs-lookup"><span data-stu-id="f9372-472">Every branch you use can customize the build policy by modifying the azure-pipelines.yml file.</span></span>
- <span data-ttu-id="f9372-473">管道檔將簽入版本控制，如果存在問題，可以進行調查。</span><span class="sxs-lookup"><span data-stu-id="f9372-473">The pipeline file is checked into version control and can be investigated if there's a problem.</span></span>

<span data-ttu-id="f9372-474">Azure 管道服務支援大多數 Git 提供程式，並可以為在 Linux、macOS 或 Windows 平臺上編寫的應用程式生成部署管道。</span><span class="sxs-lookup"><span data-stu-id="f9372-474">The Azure Pipelines service supports most Git providers and can generate deployment pipelines for applications written on the Linux, macOS, or Windows platforms.</span></span> <span data-ttu-id="f9372-475">它包括對JAVA、.NET、JavaScript、Python、PHP、Go、XCode和C++的支援。</span><span class="sxs-lookup"><span data-stu-id="f9372-475">It includes support for Java, .NET, JavaScript, Python, PHP, Go, XCode, and C++.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="f9372-476">[上一個](introduction.md)
>[下一個](candidate-apps.md)</span><span class="sxs-lookup"><span data-stu-id="f9372-476">[Previous](introduction.md)
[Next](candidate-apps.md)</span></span>
