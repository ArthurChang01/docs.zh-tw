---
title: 查詢運算式基本概念 (C# 中的 LINQ)
description: 介紹查詢運算式的相關概念
ms.date: 11/30/2016
ms.assetid: 027db1f8-346f-44d2-a16e-043fcea3a4e0
ms.openlocfilehash: 68f338381e354f4944539d63ca3a3cc3500031c1
ms.sourcegitcommit: 4b6490b2529707627ad77c3a43fbe64120397175
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/10/2018
ms.locfileid: "44271399"
---
# <a name="query-expression-basics"></a><span data-ttu-id="1f151-103">查詢運算式基本概念</span><span class="sxs-lookup"><span data-stu-id="1f151-103">Query expression basics</span></span>

<span data-ttu-id="1f151-104">本文介紹與 C# 中查詢運算式相關的基本概念。</span><span class="sxs-lookup"><span data-stu-id="1f151-104">This article introduces the basic concepts related to query expressions in C#.</span></span>

## <a name="what-is-a-query-and-what-does-it-do"></a><span data-ttu-id="1f151-105">什麼是查詢？它有哪些功能？</span><span class="sxs-lookup"><span data-stu-id="1f151-105">What is a query and what does it do?</span></span>

<span data-ttu-id="1f151-106">「查詢」是一組指令，描述要從一個或多個指定資料來源擷取的資料以及所傳回資料應該具有的組織結構和組織。</span><span class="sxs-lookup"><span data-stu-id="1f151-106">A *query* is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have.</span></span> <span data-ttu-id="1f151-107">查詢與其產生的結果不同。</span><span class="sxs-lookup"><span data-stu-id="1f151-107">A query is distinct from the results that it produces.</span></span>

<span data-ttu-id="1f151-108">一般而言，來源資料也會以邏輯方式組織成一系列相同類型的項目。</span><span class="sxs-lookup"><span data-stu-id="1f151-108">Generally, the source data is organized logically as a sequence of elements of the same kind.</span></span> <span data-ttu-id="1f151-109">例如，SQL 資料庫資料表包含一系列的資料列。</span><span class="sxs-lookup"><span data-stu-id="1f151-109">For example, a SQL database table contains a sequence of rows.</span></span> <span data-ttu-id="1f151-110">在 XML 檔案中，有一「序列」的 XML 項目 (雖然這些都是以階層方式組織成樹狀結構)。</span><span class="sxs-lookup"><span data-stu-id="1f151-110">In an XML file, there is a "sequence" of XML elements (although these are organized hierarchically in a tree structure).</span></span> <span data-ttu-id="1f151-111">記憶體內部集合包含一系列的物件。</span><span class="sxs-lookup"><span data-stu-id="1f151-111">An in-memory collection contains a sequence of objects.</span></span>

<span data-ttu-id="1f151-112">從應用程式的觀點來看，原始來源資料的特定類型和結構並不重要。</span><span class="sxs-lookup"><span data-stu-id="1f151-112">From an application's viewpoint, the specific type and structure of the original source data is not important.</span></span> <span data-ttu-id="1f151-113">應用程式一律會將來源資料視為 <xref:System.Collections.Generic.IEnumerable%601> 或 <xref:System.Linq.IQueryable%601> 集合。</span><span class="sxs-lookup"><span data-stu-id="1f151-113">The application always sees the source data as an <xref:System.Collections.Generic.IEnumerable%601> or <xref:System.Linq.IQueryable%601> collection.</span></span> <span data-ttu-id="1f151-114">例如，在 LINQ to XML 中，來源資料就會顯示為 `IEnumerable`\<<xref:System.Xml.Linq.XElement>>。</span><span class="sxs-lookup"><span data-stu-id="1f151-114">For example, in LINQ to XML, the source data is made visible as an `IEnumerable`\<<xref:System.Xml.Linq.XElement>>.</span></span>

<span data-ttu-id="1f151-115">如果指定此來源序列，則查詢可能會執行三個事項之一︰</span><span class="sxs-lookup"><span data-stu-id="1f151-115">Given this source sequence, a query may do one of three things:</span></span>

- <span data-ttu-id="1f151-116">擷取項目子集，以產生新序列，而不需要修改個別項目。</span><span class="sxs-lookup"><span data-stu-id="1f151-116">Retrieve a subset of the elements to produce a new sequence without modifying the individual elements.</span></span> <span data-ttu-id="1f151-117">查詢接著可能會以各種方式排序或分組所傳回的序列，如下列範例所示 (假設 `scores` 是 `int[]`)：</span><span class="sxs-lookup"><span data-stu-id="1f151-117">The query may then sort or group the returned sequence in various ways, as shown in the following example (assume `scores` is an `int[]`):</span></span>

    [!code-csharp[csrefQueryExpBasics#45](~/samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]

- <span data-ttu-id="1f151-118">擷取上述範例中的一系列項目，但將它們轉換為新類型的物件。</span><span class="sxs-lookup"><span data-stu-id="1f151-118">Retrieve a sequence of elements as in the previous example but transform them to a new type of object.</span></span> <span data-ttu-id="1f151-119">例如，查詢只可能從資料來源的特定客戶記錄中擷取最後一個名稱。</span><span class="sxs-lookup"><span data-stu-id="1f151-119">For example, a query may retrieve only the last names from certain customer records in a data source.</span></span> <span data-ttu-id="1f151-120">或者，它可能會擷取完整記錄，接著先使用這筆記錄來建構另一個記憶體內部物件類型，或甚至 XML 資料，再產生最終結果序列。</span><span class="sxs-lookup"><span data-stu-id="1f151-120">Or it may retrieve the complete record and then use it to construct another in-memory object type or even XML data before generating the final result sequence.</span></span> <span data-ttu-id="1f151-121">下列範例示範從 `int` 到 `string` 的投影。</span><span class="sxs-lookup"><span data-stu-id="1f151-121">The following example shows a projection from an `int` to a `string`.</span></span> <span data-ttu-id="1f151-122">請注意 `highScoresQuery` 的新類型。</span><span class="sxs-lookup"><span data-stu-id="1f151-122">Note the new type of `highScoresQuery`.</span></span>

    [!code-csharp[csrefQueryExpBasics#46](~/samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]

- <span data-ttu-id="1f151-123">擷取來源資料的單一值，例如︰</span><span class="sxs-lookup"><span data-stu-id="1f151-123">Retrieve a singleton value about the source data, such as:</span></span>

  - <span data-ttu-id="1f151-124">符合特定條件的項目數。</span><span class="sxs-lookup"><span data-stu-id="1f151-124">The number of elements that match a certain condition.</span></span>

  - <span data-ttu-id="1f151-125">具有最大或最小值的項目。</span><span class="sxs-lookup"><span data-stu-id="1f151-125">The element that has the greatest or least value.</span></span>

  - <span data-ttu-id="1f151-126">符合條件或所指定項目集中特定值總和的第一個項目。</span><span class="sxs-lookup"><span data-stu-id="1f151-126">The first element that matches a condition, or the sum of particular values in a specified set of elements.</span></span> <span data-ttu-id="1f151-127">例如，下列查詢會傳回 `scores` 整數陣列中大於 80 的分數︰</span><span class="sxs-lookup"><span data-stu-id="1f151-127">For example, the following query returns the number of scores greater than 80 from the `scores` integer array:</span></span>

    [!code-csharp[csrefQueryExpBasics#47](~/samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]

    <span data-ttu-id="1f151-128">在上述範例中，請記住使用括號括住查詢運算式，再呼叫 `Count` 方法。</span><span class="sxs-lookup"><span data-stu-id="1f151-128">In the previous example, note the use of parentheses around the query expression before the call to the `Count` method.</span></span> <span data-ttu-id="1f151-129">您也可以使用新變數來儲存具體結果，以表示這項情況。</span><span class="sxs-lookup"><span data-stu-id="1f151-129">You can also express this by using a new variable to store the concrete result.</span></span> <span data-ttu-id="1f151-130">這項技術是更容易閱讀，因為它會區隔可儲存查詢的變數與可儲存結果的查詢。</span><span class="sxs-lookup"><span data-stu-id="1f151-130">This technique is more readable because it keeps the variable that stores the query separate from the query that stores a result.</span></span>

    [!code-csharp[csrefQueryExpBasics#48](~/samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]

<span data-ttu-id="1f151-131">在上述範例中，在呼叫 `Count` 時執行查詢，因為 `Count` 必須逐一查看結果，才能判斷 `highScoresQuery` 所傳回的項目數。</span><span class="sxs-lookup"><span data-stu-id="1f151-131">In the previous example, the query is executed in the call to `Count`, because `Count` must iterate over the results in order to determine the number of elements returned by `highScoresQuery`.</span></span>

## <a name="what-is-a-query-expression"></a><span data-ttu-id="1f151-132">什麼是查詢運算式？</span><span class="sxs-lookup"><span data-stu-id="1f151-132">What is a query expression?</span></span>

<span data-ttu-id="1f151-133">「查詢運算式」是以查詢語法表示的查詢。</span><span class="sxs-lookup"><span data-stu-id="1f151-133">A *query expression* is a query expressed in query syntax.</span></span> <span data-ttu-id="1f151-134">查詢運算式是第一類語言建構。</span><span class="sxs-lookup"><span data-stu-id="1f151-134">A query expression is a first-class language construct.</span></span> <span data-ttu-id="1f151-135">它就像任何其他運算式一樣，可以用於 C# 運算式有效的任何內容。</span><span class="sxs-lookup"><span data-stu-id="1f151-135">It is just like any other expression and can be used in any context in which a C# expression is valid.</span></span> <span data-ttu-id="1f151-136">查詢運算式包含以 SQL 或 XQuery 類似的宣告式語法所撰寫的一組子句。</span><span class="sxs-lookup"><span data-stu-id="1f151-136">A query expression consists of a set of clauses written in a declarative syntax similar to SQL or XQuery.</span></span> <span data-ttu-id="1f151-137">每個子句接著會包含一個或多個 C# 運算式，而且這些運算式本身可能是查詢運算式或包含查詢運算式。</span><span class="sxs-lookup"><span data-stu-id="1f151-137">Each clause in turn contains one or more C# expressions, and these expressions may themselves be either a query expression or contain a query expression.</span></span>

<span data-ttu-id="1f151-138">查詢運算式的開頭必須是 [from](../language-reference/keywords/from-clause.md) 子句，結尾則必須是 [select](../language-reference/keywords/select-clause.md) 或 [group](../language-reference/keywords/group-clause.md) 子句。</span><span class="sxs-lookup"><span data-stu-id="1f151-138">A query expression must begin with a [from](../language-reference/keywords/from-clause.md) clause and must end with a [select](../language-reference/keywords/select-clause.md) or [group](../language-reference/keywords/group-clause.md) clause.</span></span> <span data-ttu-id="1f151-139">在第一個 `from` 子句與最後一個 `select` 或 `group` 子句之間，它可以包含下列其中一個或多個選擇性子句︰[where](../language-reference/keywords/where-clause.md)、[orderby](../language-reference/keywords/orderby-clause.md)、[join](../language-reference/keywords/join-clause.md)、[let](../language-reference/keywords/let-clause.md)，甚至是額外的 [from](../language-reference/keywords/from-clause.md) 子句。</span><span class="sxs-lookup"><span data-stu-id="1f151-139">Between the first `from` clause and the last `select` or `group` clause, it can contain one or more of these optional clauses: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) and even additional [from](../language-reference/keywords/from-clause.md) clauses.</span></span> <span data-ttu-id="1f151-140">您也可以使用 [into](../language-reference/keywords/into.md) 關鍵字，讓 `join` 或 `group` 子句的結果作為相同查詢運算式中其他查詢子句的來源。</span><span class="sxs-lookup"><span data-stu-id="1f151-140">You can also use the [into](../language-reference/keywords/into.md) keyword to enable the result of a `join` or `group` clause to serve as the source for additional query clauses in the same query expression.</span></span>

### <a name="query-variable"></a><span data-ttu-id="1f151-141">查詢變數</span><span class="sxs-lookup"><span data-stu-id="1f151-141">Query variable</span></span>

<span data-ttu-id="1f151-142">在 LINQ 中，查詢變數是儲存「查詢」 而非查詢「結果」 的任何變數。</span><span class="sxs-lookup"><span data-stu-id="1f151-142">In LINQ, a query variable is any variable that stores a *query* instead of the *results* of a query.</span></span> <span data-ttu-id="1f151-143">更具體來說，在 `foreach` 陳述式中逐一查看查詢變數或直接呼叫其 `IEnumerator.MoveNext` 方法時，查詢變數一律是將產生一序列項目的可列舉類型。</span><span class="sxs-lookup"><span data-stu-id="1f151-143">More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a `foreach` statement or a direct call to its `IEnumerator.MoveNext` method.</span></span>

<span data-ttu-id="1f151-144">下列程式碼範例示範簡單查詢運算式，內含一個資料來源、一個篩選子句、一個排序子句，而且不需轉換來源項目。</span><span class="sxs-lookup"><span data-stu-id="1f151-144">The following code example shows a simple query expression with one data source, one filtering clause, one ordering clause, and no transformation of the source elements.</span></span> <span data-ttu-id="1f151-145">`select` 子句會結束查詢。</span><span class="sxs-lookup"><span data-stu-id="1f151-145">The `select` clause ends the query.</span></span>

[!code-csharp[csrefQueryExpBasics#49](~/samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]

<span data-ttu-id="1f151-146">在上述範例中，`scoreQuery` 是「查詢變數」，這有時指的就是「查詢」。</span><span class="sxs-lookup"><span data-stu-id="1f151-146">In the previous example, `scoreQuery` is a *query variable,* which is sometimes referred to as just a *query*.</span></span> <span data-ttu-id="1f151-147">查詢變數不會儲存 `foreach` 迴圈中所產生的任何實際結果資料。</span><span class="sxs-lookup"><span data-stu-id="1f151-147">The query variable stores no actual result data, which is produced in the `foreach` loop.</span></span> <span data-ttu-id="1f151-148">執行 `foreach` 陳述式時，透過查詢變數 `scoreQuery` 不會傳回查詢結果。</span><span class="sxs-lookup"><span data-stu-id="1f151-148">And when the `foreach` statement executes, the query results are not returned through the query variable `scoreQuery`.</span></span> <span data-ttu-id="1f151-149">而是會透過反覆運算變數 `testScore` 傳回。</span><span class="sxs-lookup"><span data-stu-id="1f151-149">Rather, they are returned through the iteration variable `testScore`.</span></span> <span data-ttu-id="1f151-150">可以在第二個 `foreach` 迴圈中逐一查看 `scoreQuery` 變數。</span><span class="sxs-lookup"><span data-stu-id="1f151-150">The `scoreQuery` variable can be iterated in a second `foreach` loop.</span></span> <span data-ttu-id="1f151-151">只要未修改過它或資料來源，就會產生相同的結果。</span><span class="sxs-lookup"><span data-stu-id="1f151-151">It will produce the same results as long as neither it nor the data source has been modified.</span></span>

<span data-ttu-id="1f151-152">查詢變數可能會儲存以查詢語法、方法語法或兩者組合表示的查詢。</span><span class="sxs-lookup"><span data-stu-id="1f151-152">A query variable may store a query that is expressed in query syntax or method syntax, or a combination of the two.</span></span> <span data-ttu-id="1f151-153">在下列範例中，`queryMajorCities` 和 `queryMajorCities2` 都是查詢變數︰</span><span class="sxs-lookup"><span data-stu-id="1f151-153">In the following examples, both `queryMajorCities` and `queryMajorCities2` are query variables:</span></span>

[!code-csharp[csrefQueryExpBasics#50](~/samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]

<span data-ttu-id="1f151-154">另一方面，下列兩個範例則是示範並非查詢變數的變數 (即使每個變數都是使用查詢進行初始化)。</span><span class="sxs-lookup"><span data-stu-id="1f151-154">On the other hand, the following two examples show variables that are not query variables even though each is initialized with a query.</span></span> <span data-ttu-id="1f151-155">它們會儲存結果，因此不是查詢變數：</span><span class="sxs-lookup"><span data-stu-id="1f151-155">They are not query variables because they store results:</span></span>

[!code-csharp[csrefQueryExpBasics#51](~/samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]

<span data-ttu-id="1f151-156">如需以不同方式表達查詢的詳細資訊，請參閱 [LINQ 中的查詢語法及方法語法](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md)。</span><span class="sxs-lookup"><span data-stu-id="1f151-156">For more information about the different ways to express queries, see [Query syntax and method syntax in LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span></span>

#### <a name="explicit-and-implicit-typing-of-query-variables"></a><span data-ttu-id="1f151-157">查詢變數的明確和隱含類型</span><span class="sxs-lookup"><span data-stu-id="1f151-157">Explicit and implicit typing of query variables</span></span>

<span data-ttu-id="1f151-158">這份文件通常會提供查詢變數的明確類型，以顯示查詢變數與 [select 子句](../language-reference/keywords/select-clause.md)之間的類型關聯性。</span><span class="sxs-lookup"><span data-stu-id="1f151-158">This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the [select clause](../language-reference/keywords/select-clause.md).</span></span> <span data-ttu-id="1f151-159">不過，您也可以使用 [var](../language-reference/keywords/var.md)關鍵字，指示編譯器在編譯時期推斷查詢變數 (或任何其他區域變數) 的類型。</span><span class="sxs-lookup"><span data-stu-id="1f151-159">However, you can also use the [var](../language-reference/keywords/var.md) keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time.</span></span> <span data-ttu-id="1f151-160">例如，也可以使用隱含類型來表示本主題先前所顯示的查詢範例︰</span><span class="sxs-lookup"><span data-stu-id="1f151-160">For example, the query example that was shown previously in this topic can also be expressed by using implicit typing:</span></span>

[!code-csharp[csrefQueryExpBasics#52](~/samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]

<span data-ttu-id="1f151-161">如需詳細資訊，請參閱[隱含類型區域變數](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md)和 [LINQ 查詢作業中的類型關聯性](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md)。</span><span class="sxs-lookup"><span data-stu-id="1f151-161">For more information, see [Implicitly typed local variables](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Type relationships in LINQ query operations](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span></span>

### <a name="starting-a-query-expression"></a><span data-ttu-id="1f151-162">啟動查詢運算式</span><span class="sxs-lookup"><span data-stu-id="1f151-162">Starting a query expression</span></span>

<span data-ttu-id="1f151-163">查詢運算式的開頭必須是 `from` 子句。</span><span class="sxs-lookup"><span data-stu-id="1f151-163">A query expression must begin with a `from` clause.</span></span> <span data-ttu-id="1f151-164">它會同時指定資料來源和範圍變數。</span><span class="sxs-lookup"><span data-stu-id="1f151-164">It specifies a data source together with a range variable.</span></span> <span data-ttu-id="1f151-165">範圍變數代表正在周遊來源序列時來源序列中的每個連續項目。</span><span class="sxs-lookup"><span data-stu-id="1f151-165">The range variable represents each successive element in the source sequence as the source sequence is being traversed.</span></span> <span data-ttu-id="1f151-166">根據資料來源中的項目類型，範圍變數是強類型。</span><span class="sxs-lookup"><span data-stu-id="1f151-166">The range variable is strongly typed based on the type of elements in the data source.</span></span> <span data-ttu-id="1f151-167">在下列範例中，因為 `countries` 是 `Country` 物件陣列，所以範圍變數的類型也是 `Country`。</span><span class="sxs-lookup"><span data-stu-id="1f151-167">In the following example, because `countries` is an array of `Country` objects, the range variable is also typed as `Country`.</span></span> <span data-ttu-id="1f151-168">因為範圍變數是強類型，所以您可以使用點運算子來存取該類型的任何可用成員。</span><span class="sxs-lookup"><span data-stu-id="1f151-168">Because the range variable is strongly typed, you can use the dot operator to access any available members of the type.</span></span>

[!code-csharp[csrefQueryExpBasics#53](~/samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]

<span data-ttu-id="1f151-169">除非使用分號或 *continuation* 子句結束查詢，否則範圍變數會在範圍內。</span><span class="sxs-lookup"><span data-stu-id="1f151-169">The range variable is in scope until the query is exited either with a semicolon or with a *continuation* clause.</span></span>

<span data-ttu-id="1f151-170">查詢運算式可能會包含多個 `from` 子句。</span><span class="sxs-lookup"><span data-stu-id="1f151-170">A query expression may contain multiple `from` clauses.</span></span> <span data-ttu-id="1f151-171">來源序列中的每個項目本身就是集合或包含集合時，請使用其他 `from` 子句。</span><span class="sxs-lookup"><span data-stu-id="1f151-171">Use additional `from` clauses when each element in the source sequence is itself a collection or contains a collection.</span></span> <span data-ttu-id="1f151-172">例如，假設您有 `Country` 物件集合，各包含名為 `Cities`的 `City` 物件。</span><span class="sxs-lookup"><span data-stu-id="1f151-172">For example, assume that you have a collection of `Country` objects, each of which contains a collection of `City` objects named `Cities`.</span></span> <span data-ttu-id="1f151-173">若要查詢每個 `Country` 中的 `City` 物件，請使用兩個 `from` 子句，如下所示︰</span><span class="sxs-lookup"><span data-stu-id="1f151-173">To query the `City` objects in each `Country`, use two `from` clauses as shown here:</span></span>

[!code-csharp[csrefQueryExpBasics#54](~/samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]

<span data-ttu-id="1f151-174">如需詳細資訊，請參閱 [from 子句](../language-reference/keywords/from-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="1f151-174">For more information, see [from clause](../language-reference/keywords/from-clause.md).</span></span>

### <a name="ending-a-query-expression"></a><span data-ttu-id="1f151-175">結束查詢運算式</span><span class="sxs-lookup"><span data-stu-id="1f151-175">Ending a query expression</span></span>

<span data-ttu-id="1f151-176">查詢運算式的結尾必須是 `group` 子句或 `select` 子句。</span><span class="sxs-lookup"><span data-stu-id="1f151-176">A query expression must end with either a `group` clause or a `select` clause.</span></span>

#### <a name="group-clause"></a><span data-ttu-id="1f151-177">group 子句</span><span class="sxs-lookup"><span data-stu-id="1f151-177">group clause</span></span>

<span data-ttu-id="1f151-178">使用 `group` 子句，產生依所指定的索引鍵所組織的一系列群組。</span><span class="sxs-lookup"><span data-stu-id="1f151-178">Use the `group` clause to produce a sequence of groups organized by a key that you specify.</span></span> <span data-ttu-id="1f151-179">索引鍵可以是任何資料類型。</span><span class="sxs-lookup"><span data-stu-id="1f151-179">The key can be any data type.</span></span> <span data-ttu-id="1f151-180">例如，下列查詢會建立一序列的群組，各包含一個或多個 `Country` 物件且其索引鍵是 `char` 值。</span><span class="sxs-lookup"><span data-stu-id="1f151-180">For example, the following query creates a sequence of groups that contains one or more `Country` objects and whose key is a `char` value.</span></span>

[!code-csharp[csrefQueryExpBasics#55](~/samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]

<span data-ttu-id="1f151-181">如需分組的詳細資訊，請參閱 [group 子句](../language-reference/keywords/group-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="1f151-181">For more information about grouping, see [group clause](../language-reference/keywords/group-clause.md).</span></span>

#### <a name="select-clause"></a><span data-ttu-id="1f151-182">select 子句</span><span class="sxs-lookup"><span data-stu-id="1f151-182">select clause</span></span>

<span data-ttu-id="1f151-183">使用 `select` 子句來產生所有其他類型的序列。</span><span class="sxs-lookup"><span data-stu-id="1f151-183">Use the `select` clause to produce all other types of sequences.</span></span> <span data-ttu-id="1f151-184">簡單 `select` 子句只會產生一系列相同類型的物件，作為資料來源中所包含的物件。</span><span class="sxs-lookup"><span data-stu-id="1f151-184">A simple `select` clause just produces a sequence of the same type of objects as the objects that are contained in the data source.</span></span> <span data-ttu-id="1f151-185">在此範例中，資料成員包含 `Country` 物件。</span><span class="sxs-lookup"><span data-stu-id="1f151-185">In this example, the data source contains `Country` objects.</span></span> <span data-ttu-id="1f151-186">`orderby` 子句只會將項目排序為新順序，而 `select` 子句會產生一系列的已排序 `Country` 物件。</span><span class="sxs-lookup"><span data-stu-id="1f151-186">The `orderby` clause just sorts the elements into a new order and the `select` clause produces a sequence of the reordered `Country` objects.</span></span>

[!code-csharp[csrefQueryExpBasics#56](~/samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]

<span data-ttu-id="1f151-187">`select` 子句可以用來將來源資料轉換為新類型的序列。</span><span class="sxs-lookup"><span data-stu-id="1f151-187">The `select` clause can be used to transform source data into sequences of new types.</span></span> <span data-ttu-id="1f151-188">這項轉換也稱為「投影」。</span><span class="sxs-lookup"><span data-stu-id="1f151-188">This transformation is also named a *projection*.</span></span> <span data-ttu-id="1f151-189">在下列範例中，`select` 子句會「投影」一序列的匿名類型，只包含原始項目中欄位的子集。</span><span class="sxs-lookup"><span data-stu-id="1f151-189">In the following example, the `select` clause *projects* a sequence of anonymous types which contains only a subset of the fields in the original element.</span></span> <span data-ttu-id="1f151-190">請注意，使用物件初始設定式，可以初始化新物件。</span><span class="sxs-lookup"><span data-stu-id="1f151-190">Note that the new objects are initialized by using an object initializer.</span></span>

[!code-csharp[csrefQueryExpBasics#57](~/samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]

<span data-ttu-id="1f151-191">如需 `select` 子句可用來轉換來源資料之所有方式的詳細資訊，請參閱 [select 子句](../language-reference/keywords/select-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="1f151-191">For more information about all the ways that a `select` clause can be used to transform source data, see [select clause](../language-reference/keywords/select-clause.md).</span></span>

#### <a name="continuations-with-into"></a><span data-ttu-id="1f151-192">"into" 的接續</span><span class="sxs-lookup"><span data-stu-id="1f151-192">Continuations with "into"</span></span>

<span data-ttu-id="1f151-193">您可以在 `select` 或 `group`子句中使用 `into` 關鍵字，以建立可儲存查詢的暫存識別碼。</span><span class="sxs-lookup"><span data-stu-id="1f151-193">You can use the `into` keyword in a `select` or `group` clause to create a temporary identifier that stores a query.</span></span> <span data-ttu-id="1f151-194">必須在分組或選取作業之後對查詢執行其他查詢作業時，請這麼做。</span><span class="sxs-lookup"><span data-stu-id="1f151-194">Do this when you must perform additional query operations on a query after a grouping or select operation.</span></span> <span data-ttu-id="1f151-195">在下列範例中，`countries` 會根據 1 千萬範圍中的個體進行分組。</span><span class="sxs-lookup"><span data-stu-id="1f151-195">In the following example `countries` are grouped according to population in ranges of 10 million.</span></span> <span data-ttu-id="1f151-196">建立這些群組之後，其他子句會篩選掉部分群組，接著依遞增順序排序群組。</span><span class="sxs-lookup"><span data-stu-id="1f151-196">After these groups are created, additional clauses filter out some groups, and then to sort the groups in ascending order.</span></span> <span data-ttu-id="1f151-197">若要執行這些其他作業，則需要 `countryGroup` 所代表的繼續。</span><span class="sxs-lookup"><span data-stu-id="1f151-197">To perform those additional operations, the continuation represented by `countryGroup` is required.</span></span>

[!code-csharp[csrefQueryExpBasics#58](~/samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]

<span data-ttu-id="1f151-198">如需詳細資訊，請參閱 [into](../language-reference/keywords/into.md)。</span><span class="sxs-lookup"><span data-stu-id="1f151-198">For more information, see [into](../language-reference/keywords/into.md).</span></span>

### <a name="filtering-ordering-and-joining"></a><span data-ttu-id="1f151-199">篩選、排序和聯結</span><span class="sxs-lookup"><span data-stu-id="1f151-199">Filtering, ordering, and joining</span></span>

<span data-ttu-id="1f151-200">在開始 `from` 子句與結束 `select` 或 `group` 子句之間，所有其他子句 (`where`、`join`、`orderby`、`from`、`let`) 都是選擇性的。</span><span class="sxs-lookup"><span data-stu-id="1f151-200">Between the starting `from` clause, and the ending `select` or `group` clause, all other clauses (`where`, `join`, `orderby`, `from`, `let`) are optional.</span></span> <span data-ttu-id="1f151-201">在查詢主體中，可能不會使用任何選擇性子句或使用多次。</span><span class="sxs-lookup"><span data-stu-id="1f151-201">Any of the optional clauses may be used zero times or multiple times in a query body.</span></span>

#### <a name="where-clause"></a><span data-ttu-id="1f151-202">where 子句</span><span class="sxs-lookup"><span data-stu-id="1f151-202">where clause</span></span>

<span data-ttu-id="1f151-203">使用 `where` 子句，會根據一個或多個述詞運算式來篩選掉來源資料中的項目。</span><span class="sxs-lookup"><span data-stu-id="1f151-203">Use the `where` clause to filter out elements from the source data based on one or more predicate expressions.</span></span> <span data-ttu-id="1f151-204">下列範例中的 `where` 子句會有一個具有兩個條件的述詞。</span><span class="sxs-lookup"><span data-stu-id="1f151-204">The `where` clause in the following example has one predicate with two conditions.</span></span>

[!code-csharp[csrefQueryExpBasics#59](~/samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]

<span data-ttu-id="1f151-205">如需詳細資訊，請參閱 [where 子句](../language-reference/keywords/where-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="1f151-205">For more information, see [where clause](../language-reference/keywords/where-clause.md).</span></span>

#### <a name="orderby-clause"></a><span data-ttu-id="1f151-206">orderby 子句</span><span class="sxs-lookup"><span data-stu-id="1f151-206">orderby clause</span></span>

<span data-ttu-id="1f151-207">使用 `orderby` 子句，依遞增或遞減順序來排序結果。</span><span class="sxs-lookup"><span data-stu-id="1f151-207">Use the `orderby` clause to sort the results in either ascending or descending order.</span></span> <span data-ttu-id="1f151-208">您也可以指定次要排序順序。</span><span class="sxs-lookup"><span data-stu-id="1f151-208">You can also specify secondary sort orders.</span></span> <span data-ttu-id="1f151-209">下列範例會使用 `Area` 屬性，以對 `country` 物件執行主要排序。</span><span class="sxs-lookup"><span data-stu-id="1f151-209">The following example performs a primary sort on the `country` objects by using the `Area` property.</span></span> <span data-ttu-id="1f151-210">它接著會使用 `Population` 屬性來執行次要排序。</span><span class="sxs-lookup"><span data-stu-id="1f151-210">It then performs a secondary sort by using the `Population` property.</span></span>

[!code-csharp[csrefQueryExpBasics#60](~/samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]

<span data-ttu-id="1f151-211">`ascending` 是選擇性關鍵字；如果未指定任何順序，則為預設排序順序。</span><span class="sxs-lookup"><span data-stu-id="1f151-211">The `ascending` keyword is optional; it is the default sort order if no order is specified.</span></span> <span data-ttu-id="1f151-212">如需詳細資訊，請參閱 [orderby 子句](../language-reference/keywords/orderby-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="1f151-212">For more information, see [orderby clause](../language-reference/keywords/orderby-clause.md).</span></span>

#### <a name="join-clause"></a><span data-ttu-id="1f151-213">join 子句</span><span class="sxs-lookup"><span data-stu-id="1f151-213">join clause</span></span>

<span data-ttu-id="1f151-214">使用 `join` 子句，會根據每個項目中所指定索引鍵之間的相等比較來建立某個資料來源中的項目與另一個資料來源中的項目的關聯和 (或) 將它們合併。</span><span class="sxs-lookup"><span data-stu-id="1f151-214">Use the `join` clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element.</span></span> <span data-ttu-id="1f151-215">在 LINQ 中，會對項目為不同類型的物件序列執行聯結作業。</span><span class="sxs-lookup"><span data-stu-id="1f151-215">In LINQ, join operations are performed on sequences of objects whose elements are different types.</span></span> <span data-ttu-id="1f151-216">聯結兩個序列之後，必須使用 `select` 或 `group` 陳述式來指定要儲存在輸出序列中的項目。</span><span class="sxs-lookup"><span data-stu-id="1f151-216">After you have joined two sequences, you must use a `select` or `group` statement to specify which element to store in the output sequence.</span></span> <span data-ttu-id="1f151-217">您也可以使用匿名類型，將每個相關聯項目集的屬性合併到輸出序列的新類型。</span><span class="sxs-lookup"><span data-stu-id="1f151-217">You can also use an anonymous type to combine properties from each set of associated elements into a new type for the output sequence.</span></span> <span data-ttu-id="1f151-218">下列範例會關聯 `prod` 物件，而其 `Category` 屬性符合 `categories` 字串陣列中的其中一個分類。</span><span class="sxs-lookup"><span data-stu-id="1f151-218">The following example associates `prod` objects whose `Category` property matches one of the categories in the `categories` string array.</span></span> <span data-ttu-id="1f151-219">會篩選掉 `Category` 不符合 `categories` 中任何字串的產品。`select` 陳述式會投影其屬性取自 `cat` 和 `prod` 的新類型。</span><span class="sxs-lookup"><span data-stu-id="1f151-219">Products whose `Category` does not match any string in `categories` are filtered out. The `select` statement projects a new type whose properties are taken from both `cat` and `prod`.</span></span>

[!code-csharp[csrefQueryExpBasics#61](~/samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]

<span data-ttu-id="1f151-220">您也可以使用 [into](../language-reference/keywords/into.md) 關鍵字將 `join` 作業的結果儲存到暫存變數，來執行群組聯結。</span><span class="sxs-lookup"><span data-stu-id="1f151-220">You can also perform a group join by storing the results of the `join` operation into a temporary variable by using the [into](../language-reference/keywords/into.md) keyword.</span></span> <span data-ttu-id="1f151-221">如需詳細資訊，請參閱 [join 子句](../language-reference/keywords/join-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="1f151-221">For more information, see [join clause](../language-reference/keywords/join-clause.md).</span></span>

#### <a name="let-clause"></a><span data-ttu-id="1f151-222">let 子句</span><span class="sxs-lookup"><span data-stu-id="1f151-222">let clause</span></span> 

<span data-ttu-id="1f151-223">使用 `let` 子句，將運算式的結果 (例如方法呼叫) 儲存在新的範圍變數中。</span><span class="sxs-lookup"><span data-stu-id="1f151-223">Use the `let` clause to store the result of an expression, such as a method call, in a new range variable.</span></span> <span data-ttu-id="1f151-224">在下列範例中，範圍變數 `firstName` 會儲存 `Split` 所傳回的字串陣列的第一個項目。</span><span class="sxs-lookup"><span data-stu-id="1f151-224">In the following example, the range variable `firstName` stores the first element of the array of strings that is returned by `Split`.</span></span>

[!code-csharp[csrefQueryExpBasics#62](~/samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]

<span data-ttu-id="1f151-225">如需詳細資訊，請參閱 [let 子句](../language-reference/keywords/let-clause.md)。</span><span class="sxs-lookup"><span data-stu-id="1f151-225">For more information, see [let clause](../language-reference/keywords/let-clause.md).</span></span>

### <a name="subqueries-in-a-query-expression"></a><span data-ttu-id="1f151-226">查詢運算式中的子查詢</span><span class="sxs-lookup"><span data-stu-id="1f151-226">Subqueries in a query expression</span></span>

<span data-ttu-id="1f151-227">查詢子句本身可能會包含查詢運算式，有時稱為「子查詢」。</span><span class="sxs-lookup"><span data-stu-id="1f151-227">A query clause may itself contain a query expression, which is sometimes referred to as a *subquery*.</span></span> <span data-ttu-id="1f151-228">每個子查詢的開頭都會是它自己的 `from` 子句，而子句不一定會指向第一個 `from` 子句中的相同資料來源。</span><span class="sxs-lookup"><span data-stu-id="1f151-228">Each subquery starts with its own `from` clause that does not necessarily point to the same data source in the first `from` clause.</span></span> <span data-ttu-id="1f151-229">例如，下列查詢示範用於 select 陳述式以擷取分組作業結果的查詢運算式。</span><span class="sxs-lookup"><span data-stu-id="1f151-229">For example, the following query shows a query expression that is used in the select statement to retrieve the results of a grouping operation.</span></span>

[!code-csharp[csrefQueryExpBasics#63](~/samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]

<span data-ttu-id="1f151-230">如需詳細資訊，請參閱[如何：在分組作業上執行子查詢](perform-a-subquery-on-a-grouping-operation.md)。</span><span class="sxs-lookup"><span data-stu-id="1f151-230">For more information, see [How to: perform a subquery on a grouping operation](perform-a-subquery-on-a-grouping-operation.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="1f151-231">另請參閱</span><span class="sxs-lookup"><span data-stu-id="1f151-231">See also</span></span>

- [<span data-ttu-id="1f151-232">C# 程式設計指南</span><span class="sxs-lookup"><span data-stu-id="1f151-232">C# programming guide</span></span>](../programming-guide/index.md)  
- [<span data-ttu-id="1f151-233">Language-Integrated Query (LINQ)</span><span class="sxs-lookup"><span data-stu-id="1f151-233">Language Integrated Query (LINQ)</span></span>](index.md)  
- [<span data-ttu-id="1f151-234">查詢關鍵字 (LINQ)</span><span class="sxs-lookup"><span data-stu-id="1f151-234">Query keywords (LINQ)</span></span>](../language-reference/keywords/query-keywords.md)  
- [<span data-ttu-id="1f151-235">標準查詢運算子概觀</span><span class="sxs-lookup"><span data-stu-id="1f151-235">Standard query operators overview</span></span>](../programming-guide/concepts/linq/standard-query-operators-overview.md)  