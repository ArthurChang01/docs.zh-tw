### YamlMime:Tutorial
title: <span data-ttu-id="dbccc-101">探索 C# 6 - C# 互動式 C# 教學課程</span><span class="sxs-lookup"><span data-stu-id="dbccc-101">Explore C# 6 - C# interactive C# tutorial</span></span>
metadata:
  title: 探索 C# 6 - 使用瀏覽器以互動方式嘗試 C# 6 的新功能
  description: 在本教學課程中，您將使用瀏覽器以互動方式探索 C# 6。 您將探索可與 C# 6 搭配使用的新慣用語，讓程式碼更精確且更容易閱讀。
  audience: Developer
  level: intermediate
  ms.date: 12/11/2018
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 0e76e18536bbf19d3c29e6bd78634956e5ec95c3
  ms.sourcegitcommit: d09c77414e9e4fc72c79b04deee7a756a120674e
  ms.translationtype: HT
  ms.contentlocale: zh-TW
  ms.lasthandoff: 01/08/2019
  ms.locfileid: "54085088"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="dbccc-105">本教學課程讓您以互動方式探索 C# 6，您將使用瀏覽器來撰寫 C#，並查看編譯和執行程式碼的結果。</span><span class="sxs-lookup"><span data-stu-id="dbccc-105">This tutorial lets you explore C# 6 interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="dbccc-106">它包含一系列課程，修改了先前 C# 實作以使用更新且更精確的 C# 6 功能。</span><span class="sxs-lookup"><span data-stu-id="dbccc-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 6 features.</span></span> <span data-ttu-id="dbccc-107">本文的其餘部分將概述每項功能，並提供連結以探索每項功能。</span><span class="sxs-lookup"><span data-stu-id="dbccc-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="dbccc-108">唯讀 Auto 屬性會啟用唯讀類型</span><span class="sxs-lookup"><span data-stu-id="dbccc-108">Read-only auto-properties enable read-only types</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"dbccc-109\">Auto 屬性語法的下列兩項增強功能可讓您更輕鬆地在更多地方使用 Auto 屬性：唯讀 Auto 屬性和 Auto 屬性初始設定式。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-109\">Two enhancements to auto-property syntax make it easier to use auto-properties in more places: read-only auto-properties and auto-property initializers.</span></span> <span data-ttu-id=\"dbccc-110\">請考慮使用這個小程式：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-110\">Consider this small program:</span></span>\n\n[!code-csharp[Starter](../../../../samples/csharp/tutorials/exploration/csharp6-starter/Program.cs)]  \n\n    \n <span data-ttu-id=\"dbccc-111\">進入焦點模式，將上述程式碼複製到 C# 互動式視窗。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-111\">Enter Focus mode, copy the preceding code into the C# interactive window.</span></span> <span data-ttu-id=\"dbccc-112\">然後，按一下 [執行] 以查看程式碼的作用。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-112\">Then, click *Run* to see what the code does.</span></span> <span data-ttu-id=\"dbccc-113\">`AllCaps` 具有修改屬性值及傳回大寫字串的非預期副作用。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-113\">`AllCaps` has the undesirable side effect of modifying the property values along with returning the uppercase string.</span></span> <span data-ttu-id=\"dbccc-114\">`Person` 類別的作者預期 `FirstName` 和 `LastName` 為唯讀字串。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-114\">The author of the `Person` class intended the strings for `FirstName` and `LastName` to be read-only.</span></span> <span data-ttu-id=\"dbccc-115\">使用 C# 6，您就可以清楚表達該意圖。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-115\">With C# 6, you can make that intent clear.</span></span> <span data-ttu-id=\"dbccc-116\">從這兩個屬性移除 `private set`，即可建立唯讀 Auto 屬性。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-116\">Remove the `private set` from both properties to create a read-only auto property.</span></span> <span data-ttu-id=\"dbccc-117\">按一下 [執行] 即會看到編譯器發現兩個位置中的 `FirstName` 和 `LastName` 屬性已變更，但這不應該發生。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-117\">Click *Run* to see that the compiler spots the two locations where the `FirstName` and `LastName` properties are changed when they should not have been.</span></span> <span data-ttu-id=\"dbccc-118\">您可以將 `AllCaps` 方法變更為下列程式碼來修正此編譯器錯誤：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-118\">You can change the `AllCaps` method to the following code to fix the compiler error:</span></span>\n\n```csharp\npublic string AllCaps()\n{\n  return ToString().ToUpper();\n}\n```\n\n<span data-ttu-id=\"dbccc-119\">使用這個新語法時，編譯器會確定屬性固定不變。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-119\">Using this new syntax, the compiler ensures that the properties are immutable.</span></span>\n"
- title: <span data-ttu-id="dbccc-120">初始化 Auto 屬性的支援欄位</span><span class="sxs-lookup"><span data-stu-id="dbccc-120">Initialize backing fields for auto-properties</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"dbccc-121\">C# 6 中的新語法可讓您對 Auto 屬性使用初始設定式。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-121\">New syntax in C# 6 enables you to use initializers for auto-properties.</span></span> <span data-ttu-id=\"dbccc-122\">這會隨著類別擴充新功能變得越來越重要。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-122\">This becomes more important as classes grow new capabilities.</span></span> <span data-ttu-id=\"dbccc-123\">將中間名屬性及接受三個字串之新建構函式新增至您的 `Person` 類別：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-123\">Add a middle name property, and a new constructor that takes three strings to your `Person` class:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#MiddleName)]  \n\n<span data-ttu-id=\"dbccc-124\">`MiddleName` 屬性上的指派即為初始設定式。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-124\">The assignment on the `MiddleName` property is an initializer.</span></span> <span data-ttu-id=\"dbccc-125\">它會初始化編譯器為中間名所產生的支援欄位。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-125\">It initializes the compiler-generated backing field for the middle name.</span></span>\n"
- title: <span data-ttu-id="dbccc-126">運算式主體成員</span><span class="sxs-lookup"><span data-stu-id="dbccc-126">Expression-bodied members</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="dbccc-127">運算式主體成員為輕量型方法提供輕量型語法。</span><span class="sxs-lookup"><span data-stu-id="dbccc-127">Expression-bodied members provide a lightweight syntax for lightweight methods.</span></span> <span data-ttu-id="dbccc-128">`Person` 類別有兩個很好的候選。</span><span class="sxs-lookup"><span data-stu-id="dbccc-128">The `Person` class has two great candidates.</span></span> <span data-ttu-id="dbccc-129">看一下 `ToString` 的宣告：</span><span class="sxs-lookup"><span data-stu-id="dbccc-129">Look at the declaration of `ToString`:</span></span>


    ```csharp

    public override string ToString()

    {
        return FirstName + " " + LastName;
    }

    ```


    <span data-ttu-id="dbccc-130">以下列程式碼取代 `ToString` 的宣告：</span><span class="sxs-lookup"><span data-stu-id="dbccc-130">Replace that declaration of `ToString` with the following code:</span></span>


    ```csharp

    public override string ToString() => FirstName + " " + LastName;

    ```


    <span data-ttu-id="dbccc-131">對 `Caps` 方法嘗試相同的動作。</span><span class="sxs-lookup"><span data-stu-id="dbccc-131">Try the same with the `Caps` method.</span></span> <span data-ttu-id="dbccc-132">雖然這項改善並不大，但明智使用時即可建立更容易閱讀的程式碼，特別是針對資料傳輸物件 (DTO) 及具有最小行為的其他類型。</span><span class="sxs-lookup"><span data-stu-id="dbccc-132">This is a small improvement, but when used wisely it creates much more readable code, especially for Data Transfer Objects (DTOs) and other types with minimal behavior.</span></span>
- title: <span data-ttu-id="dbccc-133">匯入單一類別</span><span class="sxs-lookup"><span data-stu-id="dbccc-133">Importing a single class</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"dbccc-134\">如果您在程式碼中重複使用類別的靜態方法，則每次包含類別名稱都會模糊您的程式碼意義。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-134\">If you repeatedly use a class' static methods throughout your code, including the class name each time obscures the meaning of your code.</span></span> <span data-ttu-id=\"dbccc-135\">`Person` 類別目前會匯入 `System` 命名空間，但只會使用 <xref:System.Console?displayProperty=nameWithType>。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-135\">The `Person` class currently imports the `System` namespace, even though only <xref:System.Console?displayProperty=nameWithType> is used.</span></span> <span data-ttu-id=\"dbccc-136\">修改 `using` 陳述式如下：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-136\">Modify the `using` statement as follows:</span></span>\n\n[!code-csharp[MiddleName](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#UsingStatic)]  \n\n<span data-ttu-id=\"dbccc-137\">`static using` 陳述式在更大型的程式中會變得更有用，這些程式會大量使用單一類別搭配許多靜態方法，例如 [`string`](xref:System.String) 類別或 <xref:System.Math?displayProperty=nameWithType> 類別。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-137\">The `static using` statement becomes more useful in larger programs that make extensive use of a single class with many static methods, like the [`string`](xref:System.String) class or the <xref:System.Math?displayProperty=nameWithType> class.</span></span>\n"
- title: <span data-ttu-id="dbccc-138">更佳的字串格式</span><span class="sxs-lookup"><span data-stu-id="dbccc-138">A better string format</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"dbccc-139\">C# 6 包含新的語法，可從字串和可評估的內嵌運算式撰寫字串，以產生其他字串值。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-139\">C# 6 contains new syntax for composing strings from a string and embedded expressions that are evaluated to produce other string values.</span></span> <span data-ttu-id=\"dbccc-140\">您可以變更 `ToString` 和 `AllCaps` 方法來使用此語法：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-140\">You can change the `ToString` and `AllCaps` methods to use this syntax:</span></span>\n\n[!code-csharp[StringInterpolation](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#StringInterpolation)]  \n\n<span data-ttu-id=\"dbccc-141\">您可以直接撰寫 C# 運算式，而不是在 `{` 和 `}` 之間放置引數。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-141\">Instead of positional arguments between the `{` and `}`, you write C# expressions directly.</span></span> <span data-ttu-id=\"dbccc-142\">您可以在 `Main` 方法中執行相同的動作。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-142\">You can do the same in the `Main` method.</span></span> <span data-ttu-id=\"dbccc-143\">將現有的程式碼取代為下列程式碼：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-143\">Replace the existing code with the following:</span></span>\n\n[!code-csharp[InterpolationMain](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#InterpolationMain)]  \n\n<span data-ttu-id=\"dbccc-144\">這些運算式中的變數並不限於一個。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-144\">You're not limited to a single variable in these expressions.</span></span> <span data-ttu-id=\"dbccc-145\">讓我們從新的範例開始，並修改以示範您可以搭配字串內插補點使用的其他運算式。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-145\">Let's start with a new example and modify it to demonstrate other expressions you can use with string interpolation.</span></span> <span data-ttu-id=\"dbccc-146\">在 `Main` 方法中將下列程式碼貼入互動式視窗：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-146\">Paste the following code into the interactive window in the `Main` method:</span></span>\n\n[!code-csharp[Phrases](../../../../samples/csharp/tutorials/exploration/csharp6-finished/Program.cs#Phrases)]  \n\n<span data-ttu-id=\"dbccc-147\">您可以移除區域變數 `average`，並當作內插字串運算式的一部分來計算。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-147\">You can remove the local variable `average` and perform that calculation as part of the interpolated string expression.</span></span> <span data-ttu-id=\"dbccc-148\">以下列程式碼取代最後兩行：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-148\">Replace the last two lines with the following:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average()}\");\n```\n\n<span data-ttu-id=\"dbccc-149\">執行上述範例時，您會發現，`Average` 的輸出小數位數超出您想要的位數。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-149\">Running the preceding example, you would find that the output for `Average` has more decimal places than you would like.</span></span> <span data-ttu-id=\"dbccc-150\">字串內插補點語法支援使用稍早格式化方法時可用的所有格式字串。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-150\">The string interpolation syntax supports all the format strings available using earlier formatting methods.</span></span> <span data-ttu-id=\"dbccc-151\">您在大括弧內指定了格式字串。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-151\">You specify the format string inside the braces.</span></span> <span data-ttu-id=\"dbccc-152\">在運算式之後新增 `:` 以格式化︰</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-152\">Add a `:` following the expression to format:</span></span>\n\n```csharp\nWriteLine($\"The average word length is: {wordLength.Average():F2}\");\n```\n"
- title: <span data-ttu-id="dbccc-153">快速又簡單的 Null 檢查</span><span class="sxs-lookup"><span data-stu-id="dbccc-153">Quick and easy null checks</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"dbccc-154\">`?.` (Null 條件) 運算子可讓您更輕鬆地撰寫邏輯來將 `null` 值順暢地列入考量，而不需要額外的 `if` 檢查。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-154\">The `?.` (null conditional) operator makes it easier to write logic that takes `null` values into account seamlessly, without extra `if` checks.</span></span> <span data-ttu-id=\"dbccc-155\">若要探索此功能，一開始請將下列程式碼複製到互動式視窗來嘗試執行：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-155\">To explore the feature, start by copying the following code into the interactive window to try it:</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n      string s = null;\n      Console.WriteLine(s.Length);\n    }\n}\n```\n\n<span data-ttu-id=\"dbccc-156\">當您執行範例時，它會擲回 <xref:System.NullReferenceException>。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-156\">It throws a <xref:System.NullReferenceException> when you run the sample.</span></span> <span data-ttu-id=\"dbccc-157\">將 `.` 成員存取運算子變更為 **null 條件運算子**：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-157\">Change the `.` member access operator to the **null conditional operator**:</span></span>\n\n```csharp\nConsole.WriteLine(s?.Length);\n``` \n\n<span data-ttu-id=\"dbccc-158\">這項變更後沒有任何輸出。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-158\">After this change, there's no output.</span></span> <span data-ttu-id=\"dbccc-159\">這是因為當 `s.Length` 的結果為 `int` 時，`s?.Length` 的結果為 `int?`。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-159\">That's because the result of `s?.Length` is a `int?` when the result of `s.Length` is an `int`.</span></span> <span data-ttu-id=\"dbccc-160\">在此範例中，`s?.Length` 為 `null`。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-160\">In this example, `s?.Length` is `null`.</span></span> <span data-ttu-id=\"dbccc-161\">如果左運算元為 `null`，`?.` 會傳回 `null`。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-161\">The `?.` returns `null` if its left operand is `null`.</span></span> <span data-ttu-id=\"dbccc-162\">如果右運算元的型別為實值型別，`?.` 運算子會針對該型別傳回可為 Null 的型別。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-162\">If the type of the right operand is a value type, the `?.` operator returns a nullable type for that type.</span></span> <span data-ttu-id=\"dbccc-163\">除了 `?.`，您還可以使用 `?[]` 進行陣列或索引子存取。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-163\">In addition to `?.` you can use `?[]` for array or indexer access.</span></span> <span data-ttu-id=\"dbccc-164\">在互動式視窗中嘗試下列程式碼：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-164\">Try the following code in the interactive window:</span></span>\n\n ```csharp\n char? c = s?[0];\n Console.WriteLine(c.HasValue);\n ```\n\n <span data-ttu-id=\"dbccc-165\">多個條件運算子可結合成一個運算式。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-165\">Multiple conditional operators can be combined into a single expression.</span></span> <span data-ttu-id=\"dbccc-166\">`null` 左運算元會產生 `null` 結果，讓您輕鬆地避免巢狀 if 子句來存取成員的成員。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-166\">A `null` left operand produces a `null` result, making it easy to avoid nested if clauses to access members of members.</span></span> <span data-ttu-id=\"dbccc-167\">例如，請在互動式視窗中嘗試下列程式碼：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-167\">For example, try the following code in the interactive window:</span></span>\n\n ```csharp\n string s = null;\n bool? hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext();\n Console.WriteLine(hasMore.HasValue);\n ```\n\n <span data-ttu-id=\"dbccc-168\">使用 **Null 聯合運算子**來提供預設值，即可簡化上述範例：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-168\">The preceding example can be simplified by using the **null coalescing operator** to provide a default value:</span></span>\n\n ```csharp\n bool hasMore = s?.ToCharArray()?.GetEnumerator()?.MoveNext() ?? false;\n Console.WriteLine(hasMore);\n ```\n\n <span data-ttu-id=\"dbccc-169\">**Null 條件運算子**可協助您撰寫程式碼來清楚表達您的核心邏輯，同時順暢地測試 `null` 值。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-169\">The **null conditional operator** helps you write code that makes your core logic clear while seamlessly testing for `null` values.</span></span>\n"
- title: <span data-ttu-id="dbccc-170">例外狀況篩選條件</span><span class="sxs-lookup"><span data-stu-id="dbccc-170">Exception filers</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"dbccc-171\">例外狀況篩選條件可讓您根據一些條件來攔截例外狀況。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-171\">Exception filters enable you to catch an exception based on some condition.</span></span> <span data-ttu-id=\"dbccc-172\">通常會用來建立記錄例外狀況，但絕不會處理這些例外狀況的篩選方法。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-172\">A typical use is to create a filter method that logs exceptions, but never handles those exceptions.</span></span> <span data-ttu-id=\"dbccc-173\">例外狀況篩選條件是布林運算式，若應該執行 `catch` 子句，則為 `true`；若 `catch` 子句不應該攔截例外狀況，則為 `false`。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-173\">An exception filter is a boolean expression that is `true` when the `catch` clause should be executed, and `false` when the exception should not be caught by the `catch` clause.</span></span> <span data-ttu-id=\"dbccc-174\">在互動式視窗中嘗試下列程式碼：它會將例外狀況類型和訊息記錄至主控台。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-174\">Try the following code in the interactive window: It logs the exception type and message to the console.</span></span> <span data-ttu-id=\"dbccc-175\">它會傳回 false，表示無法處理例外狀況。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-175\">It returns false which indicates that the exception can't be handled.</span></span> <span data-ttu-id=\"dbccc-176\">在互動式視窗中嘗試下列程式。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-176\">Try the program in the interactive window.</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        try \n        {\n            string s = null;\n            Console.WriteLine(s.Length);\n\n        } catch (Exception e) when (LogException(e))\n        {\n        }\n        Console.WriteLine(\"Exception must have been handled\");\n    }\n\n    private static bool LogException(Exception e)\n    {\n        Console.WriteLine($\"\\tIn the log routine. Caught {e.GetType()}\");\n        Console.WriteLine($\"\\tMessage: {e.Message}\");\n        return false;\n    }\n}\n```\n\n<span data-ttu-id=\"dbccc-177\">您應該從 `LogException` 方法傳送訊息，後面接著預設例外狀況訊息。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-177\">You should sen the message from the `LogException` method, followed by the default exception message.</span></span> <span data-ttu-id=\"dbccc-178\">若要試驗，請將 `return false` 陳述式變更為 `return true`，然後再執行一次。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-178\">Just to experiment, change the `return false` statement to `return true` and run this again.</span></span> <span data-ttu-id=\"dbccc-179\">現在，系統會攔截到例外狀況，且程式會完成執行。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-179\">Now, the exception is caught and the program runs to completion.</span></span>\n\n<span data-ttu-id=\"dbccc-180\">除了記錄情節，例外狀況篩選條件在下列情況可能最有用：當例外狀況的屬性會決定要採取的動作時。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-180\">Beyond logging scenarios, exception filters can be most useful when a property of the exception determines what action to take.</span></span> <span data-ttu-id=\"dbccc-181\">例如，您可以查看 <xref:System.AggregateException> 內部以了解包含哪些例外狀況，並根據特定例外狀況採取一些適當的動作。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-181\">For example, you can look inside an <xref:System.AggregateException> to see what the contained exceptions are and take some appropriate action depending on the specific exception.</span></span>\n"
- title: <span data-ttu-id="dbccc-182">使用 nameof</span><span class="sxs-lookup"><span data-stu-id="dbccc-182">Using nameof</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"dbccc-183\">`nameof` 運算子會傳回任何變數或類型的名稱。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-183\">The `nameof` operator returns the name of any variable or type.</span></span> <span data-ttu-id=\"dbccc-184\">在互動式視窗中嘗試下列程式碼，以查看其運作方式：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-184\">Try the following code in the interactive window to see how it works:</span></span>\n\n```csharp\nusing System;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(nameof(System.String));\n        int j = 5;\n        Console.WriteLine(nameof(j));\n        List<string> names = new List<string>();\n        Console.WriteLine(nameof(names));\n    }\n}\n```\n\n<span data-ttu-id=\"dbccc-185\">輸出會符合變數或類型的名稱。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-185\">The output matches the name of the variable or type.</span></span> <span data-ttu-id=\"dbccc-186\">即使您提供的是完整類型名稱 (例如 `System.String`)，`nameof` 運算子還是會傳回不完整的名稱。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-186\">Even when you provided the fully qualified type name (such as `System.String`) the `nameof` operator returns the unqualified name.</span></span> <span data-ttu-id=\"dbccc-187\">此功能在需要將參數或屬性名稱轉換成字串時最有用。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-187\">This feature is most useful when you need to convert a parameter or property name to a string.</span></span> <span data-ttu-id=\"dbccc-188\">範例包括擷取擲回 <xref:System.ArgumentNullException> 或 <xref:System.ArgumentException> 的引數名稱，或是擷取實作 <xref:System.ComponentModel.INotifyPropertyChanged> 時已變更的屬性名稱。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-188\">Examples include capturing the name of an argument for throwing a <xref:System.ArgumentNullException> or <xref:System.ArgumentException>, or capturing the name of a changed property when implementing <xref:System.ComponentModel.INotifyPropertyChanged>.</span></span> \n"
- title: <span data-ttu-id="dbccc-189">新的物件初始化語法</span><span class="sxs-lookup"><span data-stu-id="dbccc-189">New object initialization syntax</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"dbccc-190\">新的物件初始化可讓您建立方法，以便更輕鬆地初始化字典及其他類型。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-190\">New object initialization enables you to create methods that make it easier to initialize dictionaries, and other types.</span></span> <span data-ttu-id=\"dbccc-191\">從某個字典開始。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-191\">Start with a dictionary.</span></span> <span data-ttu-id=\"dbccc-192\">在互動式視窗中執行下列程式碼：</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-192\">Run the following code in the interactive window:</span></span>\n\n```csharp\nvar messages = new Dictionary<int, string>\n{\n    [404] = \"Page not Found\",\n    [302] = \"Page moved, but left a forwarding address.\",\n    [500] = \"The web server can't come out to play today.\"\n};\n\nConsole.WriteLine(messages[302]);\n```\n\n<span data-ttu-id=\"dbccc-193\">您可以將此語法擴充至實作 <xref:System.Collections.IEnumerable> 並具有可公開存取 `Add` 方法的任何類別。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-193\">You can extend this syntax to any class that implements <xref:System.Collections.IEnumerable> and has a publicly accessible `Add` method.</span></span>  <span data-ttu-id=\"dbccc-194\">在互動式視窗中嘗試下列範例。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-194\">Try the following sample in the interactive window.</span></span> <span data-ttu-id=\"dbccc-195\">它會建立 `Path` 類別，該類別實作 `IEnumerable<Point3D>`，並有一個方法可新增點來接受三個引數。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-195\">It creates a `Path` class that implements `IEnumerable<Point3D>` and has a method to add points that takes three arguments.</span></span> <span data-ttu-id=\"dbccc-196\">它也會結合本教學課程中已示範的其他技術，例如運算式主體成員及字串內插補點。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-196\">It also combines other techniques already demonstrated in this tutorial, such as expression-bodied members and string interpolation.</span></span> \n\n<span data-ttu-id=\"dbccc-197\">在 `Main` 方法中，您可以為這些點提供座標來初始化路徑。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-197\">In the `Main` method, you initialize a path by providing coordinates for the points.</span></span> <span data-ttu-id=\"dbccc-198\">這些點會透過 `Add` 方法新增至集合。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-198\">Those points are added to the collection through the `Add` method.</span></span>\n\n<span data-ttu-id=\"dbccc-199\">Add 方法也可以是延伸方法。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-199\">The Add method can also be an extension method.</span></span> <span data-ttu-id=\"dbccc-200\">您可以更新上述範例，如下所示。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-200\">You could update the preceding sample as follows.</span></span> <span data-ttu-id=\"dbccc-201\">由於沙箱限制，您無法在互動式體驗中編譯此範例。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-201\">This sample won't compile in the interactive experience because of sandbox limitations.</span></span> <span data-ttu-id=\"dbccc-202\">您可以在自己的電腦上嘗試。</span><span class=\"sxs-lookup\"><span data-stu-id=\"dbccc-202\">You can try it on your own machine.</span></span>\n\n```csharp\npublic class Path : IEnumerable<Point3D>\n{\n    private List<Point3D> points = new List<Point3D>();\n    public IEnumerator<Point3D> GetEnumerator() => points.GetEnumerator();\n    IEnumerator IEnumerable.GetEnumerator() => points.GetEnumerator();\n\n    public void Add(Point3D pt) => points.Add(pt);\n}\n\npublic static class Extensions\n{\n    public static void Add(this Path path, double x, double y, double z) => path.Add(new Point3D(x, y, z));\n}\n```\n"
- content: <span data-ttu-id="dbccc-203">您已完成探索 C# 6 的新功能。</span><span class="sxs-lookup"><span data-stu-id="dbccc-203">You've completed an exploration of the new features in C# 6.</span></span> <span data-ttu-id="dbccc-204">現在，請在您的應用程式中自行嘗試。</span><span class="sxs-lookup"><span data-stu-id="dbccc-204">Now try them yourself in your applications.</span></span>
