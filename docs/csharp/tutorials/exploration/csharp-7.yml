### YamlMime:Tutorial
title: <span data-ttu-id="b34ce-101">探索 C# 7.0 - C# 互動式教學課程</span><span class="sxs-lookup"><span data-stu-id="b34ce-101">Explore C# 7.0 - C# interactive tutorial</span></span>
metadata:
  title: 探索 C# 7.0 - 使用瀏覽器以互動方式嘗試 C# 7.0 的新功能
  description: 在本教學課程中，您將使用瀏覽器以互動方式探索 C# 7.0。 您將探索可與 C# 7.0 搭配使用的新慣用語，讓程式碼更精確且更容易閱讀。
  audience: Developer
  level: intermediate
  ms.date: 03/20/2019
  displayType: two-column
  interactive: csharp
  ms.openlocfilehash: 1b1de22769c86f75684f41635287a73558d1d15a
  ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
  ms.translationtype: HT
  ms.contentlocale: zh-TW
  ms.lasthandoff: 04/28/2019
  ms.locfileid: "64750377"
items:
- durationInMinutes: 1
  content: >
    <span data-ttu-id="b34ce-105">本教學課程讓您以互動方式探索 C# 7.0 功能，您將使用瀏覽器來撰寫 C#，並查看編譯和執行程式碼的結果。</span><span class="sxs-lookup"><span data-stu-id="b34ce-105">This tutorial lets you explore C# 7.0 features interactively, using your browser to write C# and see the results of compiling and running your code.</span></span> <span data-ttu-id="b34ce-106">它包含一系列課程，修改了先前 C# 實作以使用更新且更精確的 C# 7.0 功能。</span><span class="sxs-lookup"><span data-stu-id="b34ce-106">It contains a series of lessons that modify earlier C# practices to use newer, more concise C# 7.0 features.</span></span> <span data-ttu-id="b34ce-107">本文的其餘部分將概述每項功能，並提供連結以探索每項功能。</span><span class="sxs-lookup"><span data-stu-id="b34ce-107">The rest of this article provides an overview of each of these features, with a link to explore each feature.</span></span>
- title: <span data-ttu-id="b34ce-108">指派位置的 Out 變數宣告</span><span class="sxs-lookup"><span data-stu-id="b34ce-108">Out variable declarations at the assignment location</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"b34ce-109\">在這個版本中，支援 `out` 參數的現有語法已經過改善。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-109\">The existing syntax that supports `out` parameters has been improved in this version.</span></span> <span data-ttu-id=\"b34ce-110\">按一下本頁底部的 [進入焦點模式] 按鈕，然後在互動式視窗中嘗試下列程式碼：</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-110\">Click the *Enter Focus Mode* button at the bottom of this page, then try the following code in the interactive window:</span></span> \n\n[!code-csharp[OutVariableOldStyle](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableOldStyle \"classic out variable declaration\")]\n\n<span data-ttu-id=\"b34ce-111\">您現在可以在方法呼叫的引數清單中宣告 `out` 變數，而不是撰寫個別的宣告陳述式。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-111\">You can now declare `out` variables in the argument list of a method call, rather than writing a separate declaration statement.</span></span> <span data-ttu-id=\"b34ce-112\">您可以將宣告移至方法呼叫中。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-112\">You can move the declaration into the method call.</span></span> <span data-ttu-id=\"b34ce-113\">在互動式視窗底部加入下列程式碼：</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-113\">Add the following code to the bottom of the interactive window:</span></span>\n\n[!code-csharp[OutVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVariableDeclarations \"Out variable declarations\")]\n\n<span data-ttu-id=\"b34ce-114\">您可以將 `int` 宣告變更為 `var` 宣告。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-114\">You can change the `int` declaration to a `var` declaration.</span></span> <span data-ttu-id=\"b34ce-115\">在互動式視窗中加入下列程式碼：</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-115\">Add the following code to the interactive window:</span></span>\n\n[!code-csharp[OutVarVariableDeclarations](~/samples/snippets/csharp/new-in-7/program.cs#OutVarVariableDeclarations \"Implicitly typed Out variable\")]\n\n<span data-ttu-id=\"b34ce-116\">與現有的語法相比，新的語法提供了兩個重要優勢：</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-116\">The new syntax provides two important advantages over the existing syntax:</span></span>\n\n* <span data-ttu-id=\"b34ce-117\">程式碼更容易閱讀與理解。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-117\">The code is easier to read.</span></span> \n    - <span data-ttu-id=\"b34ce-118\">您在使用之處宣告 out 變數，而不是在上方另一行。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-118\">You declare the out variable where you use it, not on another line above.</span></span>\n* <span data-ttu-id=\"b34ce-119\">不需要指派初始值。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-119\">No need to assign an initial value.</span></span>\n    - <span data-ttu-id=\"b34ce-120\">藉由在方法呼叫中使用之處宣告 `out` 變數，就無法在指派它之前意外使用它。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-120\">By declaring the `out` variable where it is used in a method call, you can't accidentally use it before it is assigned.</span></span>\n\n<span data-ttu-id=\"b34ce-121\">宣告的變數範圍是封入 `if` 陳述式的範圍。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-121\">The declared variable's scope is the scope enclosing the `if` statement.</span></span> <span data-ttu-id=\"b34ce-122\">這可讓您在之後使用變數。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-122\">This allows you to use the variable afterwards.</span></span> <span data-ttu-id=\"b34ce-123\">修改最後一個 `if` 區塊，如下列程式碼片段所示。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-123\">Modify the last `if` block as shown in the following snippet.</span></span>\n\n```csharp\nif (!int.TryParse(input, out int result))\n{    \n    return null;\n}\n\nConsole.WriteLine(result);\n```\n"
- title: <span data-ttu-id="b34ce-124">Tuple 可建立輕量級的資料結構</span><span class="sxs-lookup"><span data-stu-id="b34ce-124">Tuples create light-weight data structures</span></span>
  durationInMinutes: 1
  content: "<span data-ttu-id=\"b34ce-125\">Tuple 是輕量的資料結構，其中包含多個欄位來代表資料成員。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-125\">Tuples are lightweight data structures that contain multiple fields to represent the data members.</span></span> <span data-ttu-id=\"b34ce-126\">這些欄位不會經過驗證，且您無法定義自己的方法。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-126\">The fields are not validated, and you cannot define your own methods.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"b34ce-127\">Tuple 在 C# 7.0 之前即可使用，但效率不彰且沒有語言支援。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-127\">Tuples were available before C# 7.0, but they were inefficient and had no language support.</span></span> <span data-ttu-id=\"b34ce-128\">這表示元組元素只能參考為 `Item1`及 `Item2` 等等。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-128\">This meant that tuple elements could only be referenced as `Item1`, `Item2` and so on.</span></span> <span data-ttu-id=\"b34ce-129\">C# 7.0 加入了 Tuple 的語言支援，讓 Tuple 欄位的語意名稱能使用全新且更具效率的 Tuple 型別。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-129\">C# 7.0 introduces language support for tuples, which enables semantic names for the fields of a tuple using new more efficient tuple types.</span></span>\n\n<span data-ttu-id=\"b34ce-130\">您可以為每個具名成員指派一個值，以建立 Tuple：</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-130\">You can create a tuple by assigning a value to each named member:</span></span>\n\n[!code-csharp[NamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#NamedTuple \"Named tuple\")]\n\n<span data-ttu-id=\"b34ce-131\">`namedLetters` Tuple 包含稱為 `Alpha` 和 `Beta` 的欄位。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-131\">The `namedLetters` tuple contains fields referred to as `Alpha` and `Beta`.</span></span> <span data-ttu-id=\"b34ce-132\">這些名稱只會在編譯時間存在而且在執行階段不會保留 (例如使用反映調查 Tuple 時)。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-132\">Those names exist only at compile time and are not preserved at runtime (when inspecting the tuple using reflection, for example).</span></span>\n\n<span data-ttu-id=\"b34ce-133\">在 Tuple 指派中，您也可以在指派的右邊，指定欄位的名稱︰</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-133\">In a tuple assignment, you can also specify the names of the fields on the right-hand side of the assignment:</span></span> \n\n[!code-csharp[ImplicitNamedTuple](~/samples/snippets/csharp/new-in-7/program.cs#ImplicitNamedTuple \"Implicitly named tuple\")]\n\n<span data-ttu-id=\"b34ce-134\">您可以在指定指派左側及右側的欄位名稱，但是右側的名稱會遭到忽略。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-134\">You can specify names for the fields on both the left and right-hand side of the assignment, but the names on the right side are ignored.</span></span>\n\n<span data-ttu-id=\"b34ce-135\">Tuple 最適合用作 `private` 和 `internal` 方法的傳回型別。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-135\">Tuples are most useful as return types for `private` and `internal` methods.</span></span> <span data-ttu-id=\"b34ce-136\">Tuple 提供簡單的語法，可讓方法傳回多個離散值。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-136\">Tuples provide a simple syntax for those methods to return multiple discrete values.</span></span>\n\n<span data-ttu-id=\"b34ce-137\">建立 Tuple 比建立類別或結構更有效率且更具生產力。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-137\">Creating a tuple is more efficient and more productive that creating a class or struct.</span></span> <span data-ttu-id=\"b34ce-138\">它是一個更簡單的輕量語法，可定義攜帶多個值的資料結構。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-138\">It has a simpler, lightweight syntax to define a data structure that carries more than one value.</span></span> <span data-ttu-id=\"b34ce-139\">下列範例方法會傳回在整數序列中找到的最小和最大值。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-139\">The example method below returns the minimum and maximum values found in a sequence of integers.</span></span> <span data-ttu-id=\"b34ce-140\">在瀏覽器中加入下列程式碼以嘗試它：</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-140\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[TupleReturningMethod](~/samples/snippets/csharp/new-in-7/program.cs#TupleReturningMethod \"Tuple returning method\")]\n\n<span data-ttu-id=\"b34ce-141\">有時候您可能會想要解除封裝已從方法傳回的 Tuple 成員。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-141\">There may be times when you want to unpackage the members of a tuple that were returned from a method.</span></span>  <span data-ttu-id=\"b34ce-142\">您可以藉由為 Tuple 中的每個值宣告不同變數來這麼做。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-142\">You can do that by declaring separate variables for each of the values in the tuple.</span></span> <span data-ttu-id=\"b34ce-143\">這稱為*解構* Tuple。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-143\">This is called *deconstructing* the tuple.</span></span> <span data-ttu-id=\"b34ce-144\">在瀏覽器中加入下列程式碼以嘗試它：</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-144\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[CallingWithDeconstructor](~/samples/snippets/csharp/new-in-7/program.cs#CallingWithDeconstructor \"Deconstructing a tuple\")]\n\n<span data-ttu-id=\"b34ce-145\">當您使用 Tuple 時，您會經常發現您沒有使用 Tuple 結果的所有成員。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-145\">As you work with tuples, you'll often find that you don't use all of the members of a tuple result.</span></span> <span data-ttu-id=\"b34ce-146\">發生這種情況時，您可以使用 `_` 取代變數，以捨棄一或多個傳回的值。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-146\">When that happens, you can discard one or more of the returned values by using `_` in place of a variable.</span></span> <span data-ttu-id=\"b34ce-147\">在瀏覽器中加入下列程式碼以嘗試它：</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-147\">Add the following code in your browser to try it:</span></span>\n\n[!code-csharp[DiscardTupleMember](~/samples/snippets/csharp/new-in-7/program.cs#DiscardMember \"Discard a tuple member\")]\n\n<span data-ttu-id=\"b34ce-148\">您可以在 [Tuple 文章](../../tuples.md)中深入了解 Tuple。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-148\">You can learn more in depth about tuples in the [tuples article](../../tuples.md).</span></span>\n<span data-ttu-id=\"b34ce-149\">您可以在[捨棄文章](../../discards.md)中深入了解捨棄。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-149\">You can learn more about discards in the [discards article](../../discards.md).</span></span>\n"
- title: <span data-ttu-id="b34ce-150">使用型別模式搭配運算式</span><span class="sxs-lookup"><span data-stu-id="b34ce-150">Use the type pattern with the is expression</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="b34ce-151">`is` 模式運算式會擴充熟悉的 [`is` 運算子](../../language-reference/keywords/is.md#pattern-matching-with-is)，來查詢其類型之外的物件。</span><span class="sxs-lookup"><span data-stu-id="b34ce-151">The `is` pattern expression extends the familiar [`is` operator](../../language-reference/keywords/is.md#pattern-matching-with-is) to query an object beyond its type.</span></span>


    <span data-ttu-id="b34ce-152">在瀏覽器視窗中嘗試下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="b34ce-152">Try the following code in your browser window:</span></span>


    [!code-csharp[SimpleIs](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleIsPattern "Simple Is pattern")]


    <span data-ttu-id="b34ce-153">改為將變數宣告變更為字串：</span><span class="sxs-lookup"><span data-stu-id="b34ce-153">Change the variable declaration to a string instead:</span></span>


    ```csharp

    object count = "5";

    ```


    <span data-ttu-id="b34ce-154">現在，`is` 運算式為 False，因此會執行 `else` 分支。</span><span class="sxs-lookup"><span data-stu-id="b34ce-154">Now, the `is` expression is false, so the `else` branch is executed.</span></span> <span data-ttu-id="b34ce-155">嘗試在 else 分支中，將 `count` 變更為 `number`：</span><span class="sxs-lookup"><span data-stu-id="b34ce-155">Try to change `count` to `number` in the else branch:</span></span>


    ```csharp

    Console.WriteLine($"{number} is not an integer");

    ```


    <span data-ttu-id="b34ce-156">上述不會編譯，因為在 `else` 分支中未指派 `number`。</span><span class="sxs-lookup"><span data-stu-id="b34ce-156">The above won't compile because `number` isn't assigned in the `else` branch.</span></span> <span data-ttu-id="b34ce-157">它只會在 `if` 陳述式的 `true` 分支中指派。</span><span class="sxs-lookup"><span data-stu-id="b34ce-157">It's only assigned in the `true` branch of the `if` statement.</span></span>


    <span data-ttu-id="b34ce-158">當您有少數的型別要測試時，`is` 運算式型別模式相當有用。</span><span class="sxs-lookup"><span data-stu-id="b34ce-158">The `is` expression type pattern is useful when you have a small number of types to test against.</span></span> <span data-ttu-id="b34ce-159">通常，您可能需要測試多個型別。</span><span class="sxs-lookup"><span data-stu-id="b34ce-159">Often, you may need to test multiple types.</span></span> <span data-ttu-id="b34ce-160">這需要模式比對 `switch` 陳述式。</span><span class="sxs-lookup"><span data-stu-id="b34ce-160">That requires the pattern matching `switch` statement.</span></span>
- title: <span data-ttu-id="b34ce-161">switch 陳述式中的模式比對</span><span class="sxs-lookup"><span data-stu-id="b34ce-161">Pattern matching in the switch statement</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="b34ce-162">「比對運算式」的語法很熟悉，是根據已屬於 C# 語言一部分的 `switch` 陳述式。</span><span class="sxs-lookup"><span data-stu-id="b34ce-162">The *match expression* has a familiar syntax, based on the `switch` statement already part of the C# language.</span></span> <span data-ttu-id="b34ce-163">根據您在上一頁探索的 `is` 運算式，讓我們從小型範例開始：</span><span class="sxs-lookup"><span data-stu-id="b34ce-163">Let's start with a small sample based on the `is` expression syntax you explored on the previous page:</span></span>


    [!code-csharp[SimpleSwitch](~/samples/snippets/csharp/new-in-7/patternmatch.cs#SimpleSwitchPattern "simple switch")]


    <span data-ttu-id="b34ce-164">上述程式碼會檢查 `int` 或 `null`。</span><span class="sxs-lookup"><span data-stu-id="b34ce-164">The preceding code checks for an `int` or `null`.</span></span> <span data-ttu-id="b34ce-165">其他每個型別都已達到預設的情況。</span><span class="sxs-lookup"><span data-stu-id="b34ce-165">Every other type reached the default case.</span></span> <span data-ttu-id="b34ce-166">加入下列兩行，以驗證其行為：</span><span class="sxs-lookup"><span data-stu-id="b34ce-166">Add the following two lines to verify the behavior:</span></span>


    [!code-csharp[AddLongCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestLong "Add a case for long")]


    <span data-ttu-id="b34ce-167">`switch` 運算式會將可為 Null 的型別轉換成其對應的型別。</span><span class="sxs-lookup"><span data-stu-id="b34ce-167">The `switch` expression will convert a nullable type to its corresponding type.</span></span> <span data-ttu-id="b34ce-168">加入下列以驗證：</span><span class="sxs-lookup"><span data-stu-id="b34ce-168">Add the following to verify:</span></span>


    [!code-csharp[NullableCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#NullableSwitch "Add a nullable case")]


    <span data-ttu-id="b34ce-169">您可以將任意數目的其他型別模式運算式加入至 switch 陳述式。</span><span class="sxs-lookup"><span data-stu-id="b34ce-169">You can add any number of other type pattern expressions to the switch statements.</span></span> <span data-ttu-id="b34ce-170">在 `null` 案例之前加入這些運算式：</span><span class="sxs-lookup"><span data-stu-id="b34ce-170">Add these before the `null` case:</span></span>


    [!code-csharp[MoreTypeCases](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreCases "Add more type cases")]


    <span data-ttu-id="b34ce-171">新增下列測試以確定這些運算式正常運作：</span><span class="sxs-lookup"><span data-stu-id="b34ce-171">Make sure these work by adding the following tests:</span></span>


    [!code-csharp[AddMoreTests](~/samples/snippets/csharp/new-in-7/patternmatch.cs#MoreTests "Add more type tests")]


    <span data-ttu-id="b34ce-172">比對運算式也支援常數。</span><span class="sxs-lookup"><span data-stu-id="b34ce-172">The match expressions also support constants.</span></span> <span data-ttu-id="b34ce-173">如此可以節省時間，因為已隔離簡單的案例︰</span><span class="sxs-lookup"><span data-stu-id="b34ce-173">This can save time by factoring out simple cases:</span></span>


    [!code-csharp[ConstantCase](~/samples/snippets/csharp/new-in-7/patternmatch.cs#ConstantCase "Add a constant case")]


    <span data-ttu-id="b34ce-174">您必須在 `case int:` 運算式*之前*加入上述案例。</span><span class="sxs-lookup"><span data-stu-id="b34ce-174">You must add the preceding case *before* the `case int:` expression.</span></span> <span data-ttu-id="b34ce-175">如果您在該案例之後加入它，編譯器會警告您，它已經過上一個案例處理。</span><span class="sxs-lookup"><span data-stu-id="b34ce-175">If you add it after that case, the compiler warns you that it has already been handled by a previous case.</span></span>


    <span data-ttu-id="b34ce-176">您可以將 `when` 子句加入至任何模式案例，讓您可以測試型別或常數值以外的其他條件。</span><span class="sxs-lookup"><span data-stu-id="b34ce-176">You can add a `when` clause to any pattern case so that you can test other conditions beyond a type or a constant value.</span></span> <span data-ttu-id="b34ce-177">在一般 `string` 案例上方加入下列案例來嘗試它：</span><span class="sxs-lookup"><span data-stu-id="b34ce-177">Try it by adding the following case above the general `string` case:</span></span>


    [!code-csharp[WhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#WhenClause "Add a when clause")]


    <span data-ttu-id="b34ce-178">使用類似下列程式碼的內容來測試它：</span><span class="sxs-lookup"><span data-stu-id="b34ce-178">Test it with something like the following code:</span></span>


    [!code-csharp[TestWhenClause](~/samples/snippets/csharp/new-in-7/patternmatch.cs#TestWhenClause "Test the when clause")]


    <span data-ttu-id="b34ce-179">模式比對運算式的新語法可讓您根據物件的型別或其他屬性，使用清楚且簡潔的語法，更輕鬆地建立分派演算法。</span><span class="sxs-lookup"><span data-stu-id="b34ce-179">The new syntax for pattern matching expressions makes it easier to create dispatch algorithms using a clear and concise syntax based on an object's type or other properties.</span></span> <span data-ttu-id="b34ce-180">模式比對運算式可讓在繼承方面不相關的資料類型上啟用這些建構。</span><span class="sxs-lookup"><span data-stu-id="b34ce-180">Pattern matching expressions enable these constructs on data types that are unrelated by inheritance.</span></span>


    <span data-ttu-id="b34ce-181">您可以在 [C# 中的模式比對](../../pattern-matching.md)專門文章中深入了解模式比對。</span><span class="sxs-lookup"><span data-stu-id="b34ce-181">You can learn more about pattern matching in the article dedicated to [pattern matching in C#](../../pattern-matching.md).</span></span>
- title: <span data-ttu-id="b34ce-182">使用 ref 區域變數和傳回，最佳化記憶體儲存空間</span><span class="sxs-lookup"><span data-stu-id="b34ce-182">Optimize memory storage using ref locals and returns</span></span>
  durationInMinutes: 2
  content: >
    <span data-ttu-id="b34ce-183">這項功能可以啟用使用和傳回在其他地方定義之變數參考的演算法。</span><span class="sxs-lookup"><span data-stu-id="b34ce-183">This feature enables algorithms that use and return references to variables defined elsewhere.</span></span> <span data-ttu-id="b34ce-184">其中一個範例是使用大型矩陣，並尋找具有特定特性的單一位置。</span><span class="sxs-lookup"><span data-stu-id="b34ce-184">One example is with large matrices and finding a single location with certain characteristics.</span></span> <span data-ttu-id="b34ce-185">一種方法會將兩個索引傳回矩陣中的單一位置︰</span><span class="sxs-lookup"><span data-stu-id="b34ce-185">One method would return the two indices a single location in the matrix:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#EverythingByValue "return indices by value")]


    <span data-ttu-id="b34ce-186">您可以使用下列程式碼測試此方法：</span><span class="sxs-lookup"><span data-stu-id="b34ce-186">You can test this method using the following code:</span></span>


    [!code-csharp[TestByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return indices by value")]



    <span data-ttu-id="b34ce-187">這個 `Find` 方法會將索引傳回到矩陣中的項目。</span><span class="sxs-lookup"><span data-stu-id="b34ce-187">This `Find` method returns the indices to the item in the matrix.</span></span> <span data-ttu-id="b34ce-188">那會導致呼叫端撰寫可使用那些索引對矩陣進行取值，並修改單一項目的程式碼。</span><span class="sxs-lookup"><span data-stu-id="b34ce-188">That leads callers to write code that uses those indices to dereference the matrix and modify a single element.</span></span> <span data-ttu-id="b34ce-189">相反地，您可以撰寫方法，傳回對您想要變更之矩陣項目的「參考」。</span><span class="sxs-lookup"><span data-stu-id="b34ce-189">You'd rather write a method that returns a *reference* to the element of the matrix that you want to change.</span></span>


    <span data-ttu-id="b34ce-190">讓我們逐步解說一系列的變更，以展示 ref 區域功能，並示範如何建立傳回對內部儲存體之參考的方法。</span><span class="sxs-lookup"><span data-stu-id="b34ce-190">Let's walk through a series of changes to demonstrate the ref local feature and show how to create a method that returns a reference to internal storage.</span></span> <span data-ttu-id="b34ce-191">在過程中，您將了解 ref 傳回和 ref 區域功能的規則，這些規則可防止您不小心誤用。</span><span class="sxs-lookup"><span data-stu-id="b34ce-191">Along the way, you'll learn the rules of the ref return and ref local feature that protect you from accidentally misusing it.</span></span>


    <span data-ttu-id="b34ce-192">一開始先修改 `Find` 方法宣告，讓它傳回 `ref int` 而不是 Tuple。</span><span class="sxs-lookup"><span data-stu-id="b34ce-192">Start by modifying the `Find` method declaration so that it returns a `ref int` instead of a tuple.</span></span>


    ```csharp

    ref int Find(int[,] matrix, Func<int, bool> predicate)

    ```


    <span data-ttu-id="b34ce-193">修改傳回陳述式以傳回正確索引處的項目：</span><span class="sxs-lookup"><span data-stu-id="b34ce-193">Modify the return statement to return the item at the correct indices:</span></span>


    ```csharp

    return matrix[i,j];

    ```


    <span data-ttu-id="b34ce-194">將最終傳回變更為擲回例外狀況：</span><span class="sxs-lookup"><span data-stu-id="b34ce-194">Change the final return to throw an exception instead:</span></span>


    ```csharp

    throw new InvalidOperationException("Not found");

    ```


    <span data-ttu-id="b34ce-195">請注意，這不會編譯。</span><span class="sxs-lookup"><span data-stu-id="b34ce-195">Note that this won't compile.</span></span> <span data-ttu-id="b34ce-196">方法宣告表示 `ref` 傳回，但是 return 陳述式會指定值傳回。</span><span class="sxs-lookup"><span data-stu-id="b34ce-196">The method declaration indicates a `ref` return, but the return statement specifies a value return.</span></span> <span data-ttu-id="b34ce-197">您必須將 `ref` 關鍵字加入至每個 return 陳述式。</span><span class="sxs-lookup"><span data-stu-id="b34ce-197">You must add the `ref` keyword to each return statement.</span></span> <span data-ttu-id="b34ce-198">那表示是以傳址方式傳回，並可協助稍後閱讀程式碼的開發人員記得該方法會以傳址方式傳回︰</span><span class="sxs-lookup"><span data-stu-id="b34ce-198">That indicates return by reference, and helps developers reading the code later remember that the method returns by reference:</span></span>


    ```csharp

    return ref matrix[i,j];

    ```


    <span data-ttu-id="b34ce-199">既然方法會傳回矩陣中整數值的參考，您需要修改呼叫它的位置。</span><span class="sxs-lookup"><span data-stu-id="b34ce-199">Now that the method returns a reference to the integer value in the matrix, you need to modify where it's called.</span></span> <span data-ttu-id="b34ce-200">`var` 宣告表示 `valItem` 現在是 `int`，而不是 Tuple。</span><span class="sxs-lookup"><span data-stu-id="b34ce-200">The `var` declaration means that `valItem` is now an `int` rather than a tuple.</span></span> <span data-ttu-id="b34ce-201">將呼叫程式碼變更為下列內容：</span><span class="sxs-lookup"><span data-stu-id="b34ce-201">Change the calling code to the following:</span></span>


    ```csharp

    var valItem = Find(matrix, (val) => val == 42);

    Console.WriteLine(valItem);

    valItem = 24;

    Console.WriteLine(matrix[4, 2]);

    ```


    <span data-ttu-id="b34ce-202">在上述範例中的第二個 `WriteLine` 陳述式會列印出值 `42`，而非 `24`。</span><span class="sxs-lookup"><span data-stu-id="b34ce-202">The second `WriteLine` statement in the example above prints out the value `42`, not `24`.</span></span> <span data-ttu-id="b34ce-203">變數 `valItem` 是 `int`，而非 `ref int`。</span><span class="sxs-lookup"><span data-stu-id="b34ce-203">The variable `valItem` is an `int`, not a `ref int`.</span></span> <span data-ttu-id="b34ce-204">`var` 關鍵字可讓編譯器指定型別，但不會隱含地加入 `ref` 修飾詞。</span><span class="sxs-lookup"><span data-stu-id="b34ce-204">The `var` keyword enables the compiler to specify the type but will not implicitly add the `ref` modifier.</span></span> <span data-ttu-id="b34ce-205">相反地，`ref return` 所指的值會「複製」到指派左手邊的變數。</span><span class="sxs-lookup"><span data-stu-id="b34ce-205">Instead, the value referred to by the `ref return` is *copied* to the variable on the left-hand side of the assignment.</span></span> <span data-ttu-id="b34ce-206">變數不是 `ref` 區域變數。</span><span class="sxs-lookup"><span data-stu-id="b34ce-206">The variable is not a `ref` local.</span></span>


    <span data-ttu-id="b34ce-207">若要修改傳回的參考，您需要將 `ref` 修飾詞加入至區域變數宣告，並在呼叫 `Find` 之前，如果傳回值是參考，讓變數成為參考。</span><span class="sxs-lookup"><span data-stu-id="b34ce-207">In order to modify the returned reference, you need to add the `ref` modifier to the local variable declaration and before the call to `Find` to make the variable a reference when the return value is a reference.</span></span> <span data-ttu-id="b34ce-208">修改瀏覽器中的測試程式碼以符合下列內容：</span><span class="sxs-lookup"><span data-stu-id="b34ce-208">Modify the test code in your browser to match the following:</span></span>


    [!code-csharp[EverythingByValue](~/samples/snippets/csharp/new-in-7/MatrixSearch.cs#TestByValue "test code for return object by reference")]


    <span data-ttu-id="b34ce-209">現在，在上述範例中的第二個 `WriteLine` 陳述式會印出值 `24`，表示已修改矩陣中的儲存體。</span><span class="sxs-lookup"><span data-stu-id="b34ce-209">Now, the second `WriteLine` statement in the example above prints out the value `24`, indicating that the storage in the matrix has been modified.</span></span> <span data-ttu-id="b34ce-210">區域變數已使用 `ref` 修飾詞宣告，而且它需要 `ref` 傳回。</span><span class="sxs-lookup"><span data-stu-id="b34ce-210">The local variable has been declared with the `ref` modifier, and it will take a `ref` return.</span></span> <span data-ttu-id="b34ce-211">您必須在宣告 `ref` 變數時先初始化；您無法分割宣告和初始化。</span><span class="sxs-lookup"><span data-stu-id="b34ce-211">You must initialize a `ref` variable when it is declared; you cannot split the declaration and the initialization.</span></span>


    <span data-ttu-id="b34ce-212">C# 語言有三個其他的規則可保護您免於濫用 `ref` 區域變數和傳回值︰</span><span class="sxs-lookup"><span data-stu-id="b34ce-212">The C# language has three other rules that protect you from misusing the `ref` locals and returns:</span></span>


    * <span data-ttu-id="b34ce-213">您無法將標準方法傳回值指派到 `ref` 區域變數。</span><span class="sxs-lookup"><span data-stu-id="b34ce-213">You cannot assign a standard method return value to a `ref` local variable.</span></span>

    * <span data-ttu-id="b34ce-214">您不能傳回 `ref` 給變數，而該變數存留期不超過方法的執行。</span><span class="sxs-lookup"><span data-stu-id="b34ce-214">You cannot return a `ref` to a variable whose lifetime does not extend beyond the execution of the method.</span></span>

    * <span data-ttu-id="b34ce-215">`ref` 區域變數及傳回值無法配合非同步方法使用。</span><span class="sxs-lookup"><span data-stu-id="b34ce-215">`ref` locals and returns can't be used with async methods.</span></span>


    <span data-ttu-id="b34ce-216">新增 ref 區域變數和 ref 傳回能啟用更有效率的演算法，方法是，避免複製值，或是多次執行取值作業。</span><span class="sxs-lookup"><span data-stu-id="b34ce-216">The addition of ref locals and ref returns enable algorithms that are more efficient by avoiding copying values or performing dereferencing operations multiple times.</span></span>


    <span data-ttu-id="b34ce-217">如需詳細資訊，請參閱 [ref 關鍵字](../../language-reference/keywords/ref.md)一文。</span><span class="sxs-lookup"><span data-stu-id="b34ce-217">For more information, see the [ref keyword](../../language-reference/keywords/ref.md) article.</span></span>
- title: <span data-ttu-id="b34ce-218">使用區域函式將程式碼的存取減至最少</span><span class="sxs-lookup"><span data-stu-id="b34ce-218">Minimize access to code with local functions</span></span>
  durationInMinutes: 2
  content: "<span data-ttu-id=\"b34ce-219\">您現在可以宣告嵌入在其他函式內的區域函式。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-219\">You can now declare local functions that are nested inside other functions.</span></span> <span data-ttu-id=\"b34ce-220\">這可讓您將這些函式的可見度降至最低。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-220\">This enables you to minimize the visibility of these functions.</span></span> <span data-ttu-id=\"b34ce-221\">區域函式有三個明顯的使用案例：</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-221\">There are three obvious use cases for local functions:</span></span>\n\n- <span data-ttu-id=\"b34ce-222\">遞迴函式</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-222\">Recursive functions.</span></span>\n- <span data-ttu-id=\"b34ce-223\">Iterator 方法。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-223\">Iterator methods.</span></span>\n- <span data-ttu-id=\"b34ce-224\">Asynchronous 方法。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-224\">Asynchronous methods.</span></span>\n\n<span data-ttu-id=\"b34ce-225\">讓我們從遞迴方法開始。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-225\">Let's start with recursive methods.</span></span> <span data-ttu-id=\"b34ce-226\">在瀏覽器中嘗試下列程式碼來計算 `6!` (階乘)：</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-226\">Try the following code in the browser to calculate `6!` (factorial):</span></span>\n\n```csharp\nint LocalFunctionFactorial(int n)\n{\n    return nthFactorial(n);\n\n    int nthFactorial(int number) => (number < 2) ? \n        1 : number * nthFactorial(number - 1);\n}\n\nConsole.WriteLine(LocalFunctionFactorial(6));\n```\n\n<span data-ttu-id=\"b34ce-227\">區域函式是實作遞迴演算法的絕佳方式。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-227\">Local functions are a great way to implement recursive algorithms.</span></span> <span data-ttu-id=\"b34ce-228\">其他常見的用法是供公用的 iterator 方法和公用的 async 方法使用。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-228\">Other common uses are for public iterator methods and public async methods.</span></span> <span data-ttu-id=\"b34ce-229\">這兩種方法都會產生程式碼，比程式設計人員想像更晚才報告錯誤。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-229\">Both types of methods generate     code that reports errors later than programmers might expect.</span></span> <span data-ttu-id=\"b34ce-230\">在 Iterator 方法的情況下，任何例外狀況只會在呼叫列舉傳回序列的程式碼時觀察到。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-230\">In the case of iterator methods, any exceptions are observed only when calling code that enumerates the returned sequence.</span></span> <span data-ttu-id=\"b34ce-231\">若是非同步方法，任何例外狀況只會在傳回的 `Task` 等候時觀察到。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-231\">In the case of async methods, any exceptions are only observed when the returned `Task` is awaited.</span></span>\n\n<span data-ttu-id=\"b34ce-232\">Iterator 方法比較容易在瀏覽器中探索，因此，讓我們在這次探索中使用這些 Iterator 方法。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-232\">Iterator methods are easier to explore in the browser, so let's use those in this exploration.</span></span> <span data-ttu-id=\"b34ce-233\">嘗試在瀏覽器中呼叫 iterator 方法的下列程式碼：</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-233\">Try the following code that calls an iterator method in your browser:</span></span>\n\n[!code-csharp[IteratorMethod](~/samples/snippets/csharp/new-in-7/Iterator.cs#SnippetIteratorMethod \"Iterator method\")]\n\n<span data-ttu-id=\"b34ce-234\">執行程式碼。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-234\">Run the code.</span></span> <span data-ttu-id=\"b34ce-235\">請注意，程式碼開始重複第二個結果集時，會擲回例外狀況。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-235\">Notice that the exception is thrown when the code begins iterating the second result set.</span></span> <span data-ttu-id=\"b34ce-236\">重複第一個結果集的程式碼已執行。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-236\">The code that iterates the first result set has already run.</span></span> <span data-ttu-id=\"b34ce-237\">此範例很小且不會變更任何資料結構，因此無害且易於修正。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-237\">This sample is both small and doesn't change any data structures, so it's harmless and easy to fix.</span></span> <span data-ttu-id=\"b34ce-238\">但在較大的程式中，兩個迭代器物件可能會在不同的子方法中建立，因此可能很難找到根本原因。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-238\">But, in a larger program, where the two iterator objects may be created in different child methods the root cause could be hard to find.</span></span> <span data-ttu-id=\"b34ce-239\">如果第一個 iterator 方法變更了資料狀態，它甚至可能會造成資料損毀。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-239\">If the first iterator method changed data state, it could even cause data corruption.</span></span> <span data-ttu-id=\"b34ce-240\">您會比較希望在任何工作完成之前，立即擲回例外狀況。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-240\">You'd prefer the exception was thrown immediately, before any work is done.</span></span> <span data-ttu-id=\"b34ce-241\">您可以重構程式碼，讓公用方法驗證所有引數，且讓區域函式執行列舉：</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-241\">You can refactor the code so that the public method validates all arguments, and a local function performs the enumeration:</span></span>\n\n[!code-csharp[IteratorMethodRefactored](~/samples/snippets/csharp/new-in-7/Iterator.cs#IteratorMethodLocalInteractive \"Iterator method refactored\")]\n\n<span data-ttu-id=\"b34ce-242\">上述的版本已闡明區域方法只會在外部方法的內容中參考。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-242\">The preceding version makes it clear that the local method is referenced only in the context of the outer method.</span></span> <span data-ttu-id=\"b34ce-243\">區域函式的規則也確保開發人員無法意外從類別中的另一個位置呼叫區域函式，並略過引數的驗證。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-243\">The rules for local functions also ensure that a developer can't accidentally call the local function from another location in the class and bypass the argument validation.</span></span>\n\n<span data-ttu-id=\"b34ce-244\">相同的技巧也可以運用在 `async` 方法，以確保在非同步工作開始之前，會擲回引數驗證所引發的例外狀況。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-244\">The same technique can be employed with `async` methods to ensure that exceptions arising from argument validation are thrown before the asynchronous work begins.</span></span>\n\n> [!NOTE]\n> <span data-ttu-id=\"b34ce-245\">區域函式支援的部分設計也可以使用「Lambda 運算式」完成。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-245\">Some of the designs that are supported by local functions could also be accomplished using *lambda expressions*.</span></span> <span data-ttu-id=\"b34ce-246\">有興趣的人可以[進一步了解差異](../../local-functions-vs-lambdas.md)。</span><span class=\"sxs-lookup\"><span data-stu-id=\"b34ce-246\">Those interested can [read more about the differences](../../local-functions-vs-lambdas.md).</span></span>\n"
- content: <span data-ttu-id="b34ce-247">您已完成探索 C# 7 的主要新功能。</span><span class="sxs-lookup"><span data-stu-id="b34ce-247">You've completed an exploration of the major new features in C# 7.</span></span> <span data-ttu-id="b34ce-248">現在，請在您的應用程式中自行嘗試。</span><span class="sxs-lookup"><span data-stu-id="b34ce-248">Now try them yourself in your applications.</span></span> <span data-ttu-id="b34ce-249">您可以在 [C# 7 的新功能](../../whats-new/csharp-7.md)一文中看到完整清單。</span><span class="sxs-lookup"><span data-stu-id="b34ce-249">You can see the full list in the [what's new in C# 7](../../whats-new/csharp-7.md) article.</span></span>
