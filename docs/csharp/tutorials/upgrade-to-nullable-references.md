---
title: 升級為可為 null 的參考型別
description: 這個 advanced 教學課程示範如何使用可為 null 的參考型別來遷移現有程式碼。
ms.date: 02/19/2019
ms.technology: csharp-null-safety
ms.custom: mvc
ms.openlocfilehash: 38619f9efa5da1f9b3264b3d4240103f0869afea
ms.sourcegitcommit: 43d10ef65f0f1fd6c3b515e363bde11a3fcd8d6d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/03/2020
ms.locfileid: "78240024"
---
# <a name="tutorial-migrate-existing-code-with-nullable-reference-types"></a><span data-ttu-id="d36f1-103">教學課程：使用可為 null 的參考型別來遷移現有程式碼</span><span class="sxs-lookup"><span data-stu-id="d36f1-103">Tutorial: Migrate existing code with nullable reference types</span></span>

<span data-ttu-id="d36f1-104">C# 8 引進了**可為 Null 的參考類型**，其可利用可為 Null 的實值類型補充實值類型的相同方式來補充參考類型。</span><span class="sxs-lookup"><span data-stu-id="d36f1-104">C# 8 introduces **nullable reference types**, which complement reference types the same way nullable value types complement value types.</span></span> <span data-ttu-id="d36f1-105">您可以藉由將  **附加至類型，來將變數宣告為**可為 Null 的參考類型`?`。</span><span class="sxs-lookup"><span data-stu-id="d36f1-105">You declare a variable to be a **nullable reference type** by appending a `?` to the type.</span></span> <span data-ttu-id="d36f1-106">例如，`string?` 代表可為 Null 的 `string`。</span><span class="sxs-lookup"><span data-stu-id="d36f1-106">For example, `string?` represents a nullable `string`.</span></span> <span data-ttu-id="d36f1-107">您可以使用這些新類型更清楚地表達設計意圖：部分變數「永遠都必須有值」，而其他變數「可能會遺漏值」。</span><span class="sxs-lookup"><span data-stu-id="d36f1-107">You can use these new types to more clearly express your design intent: some variables *must always have a value*, others *may be missing a value*.</span></span> <span data-ttu-id="d36f1-108">任何參考型別的現有變數都會解譯成不可為 Null 的參考型別。</span><span class="sxs-lookup"><span data-stu-id="d36f1-108">Any existing variables of a reference type would be interpreted as a non-nullable reference type.</span></span> 

<span data-ttu-id="d36f1-109">在本教學課程中，您將了解如何：</span><span class="sxs-lookup"><span data-stu-id="d36f1-109">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="d36f1-110">在您使用程式碼時啟用 Null 參考檢查。</span><span class="sxs-lookup"><span data-stu-id="d36f1-110">Enable null reference checks as you work with code.</span></span>
> - <span data-ttu-id="d36f1-111">診斷並修正與 Null 值相關的不同警告。</span><span class="sxs-lookup"><span data-stu-id="d36f1-111">Diagnose and correct different warnings related to null values.</span></span>
> - <span data-ttu-id="d36f1-112">管理啟用可為 Null 內容及停用可為 Null 內容之間的介面。</span><span class="sxs-lookup"><span data-stu-id="d36f1-112">Manage the interface between nullable enabled and nullable disabled contexts.</span></span>
> - <span data-ttu-id="d36f1-113">控制可為 Null 的註釋內容。</span><span class="sxs-lookup"><span data-stu-id="d36f1-113">Control nullable annotation contexts.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="d36f1-114">Prerequisites</span><span class="sxs-lookup"><span data-stu-id="d36f1-114">Prerequisites</span></span>

<span data-ttu-id="d36f1-115">您必須設定電腦以執行 .NET Core，包括C# 8.0 編譯器。</span><span class="sxs-lookup"><span data-stu-id="d36f1-115">You’ll need to set up your machine to run .NET Core, including the C# 8.0 compiler.</span></span> <span data-ttu-id="d36f1-116">從C# [Visual Studio 2019 16.3 版](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019)或[.net Core 3.0 SDK](https://dotnet.microsoft.com/download)開始，可以使用8個編譯器。</span><span class="sxs-lookup"><span data-stu-id="d36f1-116">The C# 8 compiler is available starting with [Visual Studio 2019 version 16.3](https://visualstudio.microsoft.com/downloads/?utm_medium=microsoft&utm_source=docs.microsoft.com&utm_campaign=inline+link&utm_content=download+vs2019) or [.NET Core 3.0 SDK](https://dotnet.microsoft.com/download).</span></span>

<span data-ttu-id="d36f1-117">本教學課程假設您已熟悉 C# 和 .NET，包括 Visual Studio 或 .NET Core CLI。</span><span class="sxs-lookup"><span data-stu-id="d36f1-117">This tutorial assumes you're familiar with C# and .NET, including either Visual Studio or the .NET Core CLI.</span></span>

## <a name="explore-the-sample-application"></a><span data-ttu-id="d36f1-118">探索應用程式範例</span><span class="sxs-lookup"><span data-stu-id="d36f1-118">Explore the sample application</span></span>

<span data-ttu-id="d36f1-119">您將遷移的應用程式範例是一個 RSS 摘要讀取器 Web 應用程式。</span><span class="sxs-lookup"><span data-stu-id="d36f1-119">The sample application that you'll migrate is an RSS feed reader web app.</span></span> <span data-ttu-id="d36f1-120">它會從單一 RSS 摘要讀取，並顯示最新文章的摘要。</span><span class="sxs-lookup"><span data-stu-id="d36f1-120">It reads from a single RSS feed and displays summaries for the most recent articles.</span></span> <span data-ttu-id="d36f1-121">您可以選取任何文章來造訪網站。</span><span class="sxs-lookup"><span data-stu-id="d36f1-121">You can select any of the articles to visit the site.</span></span> <span data-ttu-id="d36f1-122">應用程式相對較新，但是在可為 Null 參考型別開放使用前撰寫的。</span><span class="sxs-lookup"><span data-stu-id="d36f1-122">The application is relatively new but was written before nullable reference types were available.</span></span> <span data-ttu-id="d36f1-123">應用程式的設計決策代表了健全的準則，但並未利用這項重要的語言功能。</span><span class="sxs-lookup"><span data-stu-id="d36f1-123">The design decisions for the application represented sound principles, but don't take advantage of this important language feature.</span></span>

<span data-ttu-id="d36f1-124">應用程式範例包含了單元測試程式庫，可驗證應用程式的主要功能。</span><span class="sxs-lookup"><span data-stu-id="d36f1-124">The sample application includes a unit test library that validates the major functionality of the app.</span></span> <span data-ttu-id="d36f1-125">若您根據所產生的警告變更任何實作，該專案可使安全升級更為容易。</span><span class="sxs-lookup"><span data-stu-id="d36f1-125">That project will make it easier to upgrade safely, if you change any of the implementation based on the warnings generated.</span></span> <span data-ttu-id="d36f1-126">您可以從 [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/start) GitHub 存放庫下載起始程式碼。</span><span class="sxs-lookup"><span data-stu-id="d36f1-126">You can download the starter code from the [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/start) GitHub repository.</span></span>

<span data-ttu-id="d36f1-127">您的遷移專案目標應利用新的語言功能，使您可以清楚地表達您在變數可 NULL 性上的意圖，而透過這種方式進行此操作時，編譯器不會在您將可為 Null 註釋內容及可為 Null 警告內容設為 `enabled` 時產生警告。</span><span class="sxs-lookup"><span data-stu-id="d36f1-127">Your goal migrating a project should be to leverage the new language features so that you clearly express your intent on the nullability of variables, and do so in such a way that the compiler doesn't generate warnings when you have the nullable annotation context and nullable warning context set to `enabled`.</span></span>

## <a name="upgrade-the-projects-to-c-8"></a><span data-ttu-id="d36f1-128">將專案升級至 C# 8</span><span class="sxs-lookup"><span data-stu-id="d36f1-128">Upgrade the projects to C# 8</span></span>

<span data-ttu-id="d36f1-129">良好的第一個步驟，便是判斷移轉任務的範圍。</span><span class="sxs-lookup"><span data-stu-id="d36f1-129">A good first step is to determine the scope of the migration task.</span></span> <span data-ttu-id="d36f1-130">請從將專案升級至 C# 8.0 (或更新版本) 開始。</span><span class="sxs-lookup"><span data-stu-id="d36f1-130">Start by upgrading the project to C# 8.0 (or newer).</span></span> <span data-ttu-id="d36f1-131">將 `LangVersion` 元素加入至 Web 專案和單元測試專案之 .csproj 檔案中的 PropertyGroup：</span><span class="sxs-lookup"><span data-stu-id="d36f1-131">Add the `LangVersion` element to the PropertyGroup in both csproj files for the web project and the unit test project:</span></span>

```xml
<LangVersion>8.0</LangVersion>
```

<span data-ttu-id="d36f1-132">升級語言版本會選取 C# 8.0，但不會啟用可為 Null 註釋內容或可為 Null 警告內容。</span><span class="sxs-lookup"><span data-stu-id="d36f1-132">Upgrading the language version selects C# 8.0, but does not enable the nullable annotation context or the nullable warning context.</span></span> <span data-ttu-id="d36f1-133">重建專案，確保建置過程中沒有任何警告。</span><span class="sxs-lookup"><span data-stu-id="d36f1-133">Rebuild the project to ensure that it builds without warnings.</span></span>

<span data-ttu-id="d36f1-134">良好的下一個步驟，便是開啟可為 Null 註釋內容，查看產生了多少警告。</span><span class="sxs-lookup"><span data-stu-id="d36f1-134">A good next step is to turn on the nullable annotation context and see how many warnings are generated.</span></span> <span data-ttu-id="d36f1-135">將下列項目直接新增至解決方案中兩個 csproj 檔案的 `LangVersion` 項目下方：</span><span class="sxs-lookup"><span data-stu-id="d36f1-135">Add the following element to both csproj files in the solution, directly under the `LangVersion` element:</span></span>

```xml
<Nullable>enable</Nullable>
```

<span data-ttu-id="d36f1-136">執行測試建置，並注意警告清單。</span><span class="sxs-lookup"><span data-stu-id="d36f1-136">Do a test build, and notice the warning list.</span></span> <span data-ttu-id="d36f1-137">在這個小型應用程式中，編譯器產生五個警告，因此您很有可能會將可為 Null 註釋內容維持在啟用狀態，並開始修正整個專案的警告。</span><span class="sxs-lookup"><span data-stu-id="d36f1-137">In this small application, the compiler generates five warnings, so it's likely you'd leave the nullable annotation context enabled and start fixing warnings for the entire project.</span></span>

<span data-ttu-id="d36f1-138">但這種策略僅適用於較小的專案。</span><span class="sxs-lookup"><span data-stu-id="d36f1-138">That strategy works only for smaller projects.</span></span> <span data-ttu-id="d36f1-139">針對較大的專案，為整個程式碼基底啟用可為 Null 註釋內容，所產生警告數量可能會讓系統化修正警告的過程變得更為困難。</span><span class="sxs-lookup"><span data-stu-id="d36f1-139">For any larger projects, the number of warnings generated by enabling the nullable annotation context for the entire codebase makes it harder to fix the warnings systematically.</span></span> <span data-ttu-id="d36f1-140">針對較大的企業專案，建議您一次遷移一個專案。</span><span class="sxs-lookup"><span data-stu-id="d36f1-140">For larger enterprise projects, you'll often want to migrate one project at a time.</span></span> <span data-ttu-id="d36f1-141">在每個專案中，一次遷移一個類別或檔案。</span><span class="sxs-lookup"><span data-stu-id="d36f1-141">In each project, migrate one class or file at a time.</span></span>

## <a name="warnings-help-discover-original-design-intent"></a><span data-ttu-id="d36f1-142">警告可協助您探索原始的設計意圖</span><span class="sxs-lookup"><span data-stu-id="d36f1-142">Warnings help discover original design intent</span></span>

<span data-ttu-id="d36f1-143">有兩個類別會產生多個警告。</span><span class="sxs-lookup"><span data-stu-id="d36f1-143">There are two classes that generate multiple warnings.</span></span> <span data-ttu-id="d36f1-144">從 `NewsStoryViewModel` 類別開始。</span><span class="sxs-lookup"><span data-stu-id="d36f1-144">Start with the `NewsStoryViewModel` class.</span></span> <span data-ttu-id="d36f1-145">從兩個 csproj 檔案中移除 `Nullable` 項目，可讓您將警告範圍限制在您目前使用的程式碼區段。</span><span class="sxs-lookup"><span data-stu-id="d36f1-145">Remove the `Nullable` element from both csproj files so that you can limit the scope of warnings to the sections of code you're working with.</span></span> <span data-ttu-id="d36f1-146">開啟 *NewsStoryViewModel.cs* 檔案，新增下列指示詞，以啟用 `NewsStoryViewModel` 的可為 Null 註釋內容，並遵循該類別定義來還原它：</span><span class="sxs-lookup"><span data-stu-id="d36f1-146">Open the *NewsStoryViewModel.cs* file and add the following directives to enable the nullable annotation context for the `NewsStoryViewModel` and restore it following that class definition:</span></span>

```csharp
#nullable enable
public class NewsStoryViewModel
{
    public DateTimeOffset Published { get; set; }
    public string Title { get; set; }
    public string Uri { get; set; }
}
#nullable restore
```

<span data-ttu-id="d36f1-147">這兩個指示詞可協助您專注在移轉的工作上。</span><span class="sxs-lookup"><span data-stu-id="d36f1-147">These two directives help you focus your migration efforts.</span></span> <span data-ttu-id="d36f1-148">可為 Null 警告會針對您目前正在使用的程式碼區域產生。</span><span class="sxs-lookup"><span data-stu-id="d36f1-148">The nullable warnings are generated for the area of code you're actively working on.</span></span> <span data-ttu-id="d36f1-149">您會將它們維持在開啟狀態，直到您準備好為整個專案開啟警告為止。</span><span class="sxs-lookup"><span data-stu-id="d36f1-149">You'll leave them on until you're ready to turn on the warnings for the entire project.</span></span> <span data-ttu-id="d36f1-150">您應使用 `restore` 而非 `disable` 值，避免稍後在您開啟整個專案的可為 Null 註釋時意外停用內容。</span><span class="sxs-lookup"><span data-stu-id="d36f1-150">You should use the `restore` rather than `disable` value so that you don't accidentally disable the context later when you've turned on nullable annotations for the entire project.</span></span> <span data-ttu-id="d36f1-151">一旦您開啟了整個專案的可為 Null 註釋內容，您便可以移除該專案所有的 `#nullable` pragma。</span><span class="sxs-lookup"><span data-stu-id="d36f1-151">Once you've turned on the nullable annotation context for the entire project, you can remove all the `#nullable` pragmas from that project.</span></span>

<span data-ttu-id="d36f1-152">`NewsStoryViewModel` 類別是資料轉送物件 (DTO)，而其中兩個屬性為讀取/寫入字串：</span><span class="sxs-lookup"><span data-stu-id="d36f1-152">The `NewsStoryViewModel` class is a data transfer object (DTO) and two of the properties are read/write strings:</span></span>

[!code-csharp[InitialViewModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/ViewModels/NewsStoryViewModel.cs#StarterViewModel)]

<span data-ttu-id="d36f1-153">這兩個屬性會造成 `CS8618`，「不可為 Null 屬性尚未初始化」。</span><span class="sxs-lookup"><span data-stu-id="d36f1-153">These two properties cause `CS8618`, "Non-nullable property is uninitialized".</span></span> <span data-ttu-id="d36f1-154">這已相當清楚：兩個 `string` 屬性在建構 `null` 時都具備了 `NewsStoryViewModel` 預設值。</span><span class="sxs-lookup"><span data-stu-id="d36f1-154">That's clear enough: both `string` properties have the default value of `null` when a `NewsStoryViewModel` is constructed.</span></span> <span data-ttu-id="d36f1-155">重要的是探索 `NewsStoryViewModel` 物件的建構方式。</span><span class="sxs-lookup"><span data-stu-id="d36f1-155">What's important to discover is how `NewsStoryViewModel` objects are constructed.</span></span> <span data-ttu-id="d36f1-156">查看此類別，您無法辨識 `null` 值究竟是設計的一部分，還是這些物件會在建立其中一個時設為非 Null 值。</span><span class="sxs-lookup"><span data-stu-id="d36f1-156">Looking at this class, you can't tell if the `null` value is part of the design, or if these objects are set to non-null values whenever one is created.</span></span> <span data-ttu-id="d36f1-157">`GetNews` 類別的 `NewsService` 方法中建立了新的故事：</span><span class="sxs-lookup"><span data-stu-id="d36f1-157">The news stories are created in the `GetNews` method of the `NewsService` class:</span></span>

[!code-csharp[StarterCreateNewsItem](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Services/NewsService.cs#CreateNewsItem)]

<span data-ttu-id="d36f1-158">先前的程式碼區塊中此時又發生了一些事情。</span><span class="sxs-lookup"><span data-stu-id="d36f1-158">There's quite a bit going on in the preceding block of code.</span></span> <span data-ttu-id="d36f1-159">此應用程式使用 [AutoMapper](https://automapper.org/) NuGet 套件來從 `ISyndicationItem` 建構新的項目。</span><span class="sxs-lookup"><span data-stu-id="d36f1-159">This application uses the [AutoMapper](https://automapper.org/) NuGet package to construct a news item from an `ISyndicationItem`.</span></span> <span data-ttu-id="d36f1-160">您發現新的故事項目已經建構完成，而屬性也已在單一陳述式中設定。</span><span class="sxs-lookup"><span data-stu-id="d36f1-160">You've discovered that the news story items are constructed and the properties are set in that one statement.</span></span> <span data-ttu-id="d36f1-161">這表示 `NewsStoryViewModel` 的設計指出這些屬性永遠都不應該具備 `null` 值。</span><span class="sxs-lookup"><span data-stu-id="d36f1-161">That means the design for the `NewsStoryViewModel` indicates that these properties should never have the `null` value.</span></span> <span data-ttu-id="d36f1-162">這些屬性應為**不可為 Null 參考型別**。</span><span class="sxs-lookup"><span data-stu-id="d36f1-162">These properties should be **nonnullable reference types**.</span></span> <span data-ttu-id="d36f1-163">這種方式最能表達原始的設計意圖。</span><span class="sxs-lookup"><span data-stu-id="d36f1-163">That best expresses the original design intent.</span></span> <span data-ttu-id="d36f1-164">事實上，任何 `NewsStoryViewModel` 都會以非 null 值正確具*現*化。</span><span class="sxs-lookup"><span data-stu-id="d36f1-164">In fact, any `NewsStoryViewModel` *is* correctly instantiated with non-null values.</span></span> <span data-ttu-id="d36f1-165">這可讓下列的初始化程式碼成為有效修正：</span><span class="sxs-lookup"><span data-stu-id="d36f1-165">That makes the following initialization code a valid fix:</span></span>

```csharp
public class NewsStoryViewModel
{
    public DateTimeOffset Published { get; set; }
    public string Title { get; set; } = default!;
    public string Uri { get; set; } = default!;
}
```

<span data-ttu-id="d36f1-166">將 `Title` 和 `Uri` 指派為 `default` (針對 `null` 型別為 `string`) 不會變更程式的執行階段行為。</span><span class="sxs-lookup"><span data-stu-id="d36f1-166">The assignment of `Title` and `Uri` to `default` which is `null` for the `string` type doesn't change the runtime behavior of the program.</span></span> <span data-ttu-id="d36f1-167">`NewsStoryViewModel` 仍然會使用 Null 值建構，但現在編譯器不會再回報警告。</span><span class="sxs-lookup"><span data-stu-id="d36f1-167">The `NewsStoryViewModel` is still constructed with null values, but now the compiler reports no warnings.</span></span> <span data-ttu-id="d36f1-168">**Null 寬恕運算子** (即跟隨在 `!` 後方的 `default` 字元) 會告知編譯器先前的運算式並非 Null。</span><span class="sxs-lookup"><span data-stu-id="d36f1-168">The **null-forgiving operator**, the `!` character following the `default` expression tells the compiler that the preceding expression is not null.</span></span> <span data-ttu-id="d36f1-169">當其他變更對程式碼基底強制執行較大的變更時，這項技術可能會很方便，但在此應用程式中，有一個相對快速且更好的解決方案：使 `NewsStoryViewModel` 成為不變的型別，其中所有屬性都是在此函式中設定。</span><span class="sxs-lookup"><span data-stu-id="d36f1-169">This technique may be expedient when other changes force much larger changes to a code base, but in this application there is a relatively quick and better solution: Make the `NewsStoryViewModel` an immutable type where all the properties are set in the constructor.</span></span> <span data-ttu-id="d36f1-170">對 `NewsStoryViewModel` 進行下列變更：</span><span class="sxs-lookup"><span data-stu-id="d36f1-170">Make the following changes to the `NewsStoryViewModel`:</span></span>

[!code-csharp[FinishedViewModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/ViewModels/NewsStoryViewModel.cs#FinishedViewModel)]

<span data-ttu-id="d36f1-171">完成之後，您需要更新設定 AutoMapper 的程式碼，讓其使用建構函式而非設定屬性。</span><span class="sxs-lookup"><span data-stu-id="d36f1-171">Once that's done, you need to update the code that configures the AutoMapper so that it uses the constructor rather than setting properties.</span></span> <span data-ttu-id="d36f1-172">開啟 `NewsService.cs`，在檔案的底部尋找下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="d36f1-172">Open `NewsService.cs` and look for the following code at the bottom of the file:</span></span>

[!code-csharp[StarterAutoMapper](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Services/NewsService.cs#ConfigureAutoMapper)]

<span data-ttu-id="d36f1-173">該程式碼會將 `ISyndicationItem` 物件的屬性對應到 `NewsStoryViewModel` 屬性。</span><span class="sxs-lookup"><span data-stu-id="d36f1-173">That code maps properties of the `ISyndicationItem` object to the `NewsStoryViewModel` properties.</span></span> <span data-ttu-id="d36f1-174">您想要 AutoMapper 改為使用建構函式來提供對應。</span><span class="sxs-lookup"><span data-stu-id="d36f1-174">You want the AutoMapper to provide the mapping using a constructor instead.</span></span> <span data-ttu-id="d36f1-175">請使用下列 automapper 組態，取代以上程式碼：</span><span class="sxs-lookup"><span data-stu-id="d36f1-175">Replace the above code with the following automapper configuration:</span></span>

[!code-csharp[FinishedViewModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#ConfigureAutoMapper)]

<span data-ttu-id="d36f1-176">請注意，由於這個類別相當小且您已仔細地檢查過，您應在此類別的宣告上方開啟 `#nullable enable` 指示詞。</span><span class="sxs-lookup"><span data-stu-id="d36f1-176">Notice that because this class is small, and you've examined carefully, you should turn on the `#nullable enable` directive above this class declaration.</span></span> <span data-ttu-id="d36f1-177">對建構函式的變更可能會中斷某些東西，因此建議您在繼續之前執行所有測試並測試應用程式。</span><span class="sxs-lookup"><span data-stu-id="d36f1-177">The change to the constructor could have broken something, so it's worthwhile to run all the tests and test the application before moving on.</span></span>

<span data-ttu-id="d36f1-178">第一組變更示範了在原始設計指出變數不應設為 `null` 時探索的方式。</span><span class="sxs-lookup"><span data-stu-id="d36f1-178">The first set of changes showed you how to discover when the original design indicated that variables shouldn't be set to `null`.</span></span> <span data-ttu-id="d36f1-179">這項技術稱為**以建構修正**。</span><span class="sxs-lookup"><span data-stu-id="d36f1-179">The technique is referred to as **correct by construction**.</span></span> <span data-ttu-id="d36f1-180">您宣告物件及其屬性不可在建構時為 `null`。</span><span class="sxs-lookup"><span data-stu-id="d36f1-180">You declare that an object and its properties cannot be `null` when it's constructed.</span></span> <span data-ttu-id="d36f1-181">編譯器的流程分析會保證那些屬性在建構完成後不會設為 `null`。</span><span class="sxs-lookup"><span data-stu-id="d36f1-181">The compiler's flow analysis provides assurance that those properties aren't set to `null` after construction.</span></span> <span data-ttu-id="d36f1-182">請注意，此建構函式是由外部程式碼呼叫，而程式碼並非**可為 Null 遺忘**。</span><span class="sxs-lookup"><span data-stu-id="d36f1-182">Note that this constructor is called by external code, and that code is **nullable oblivious**.</span></span> <span data-ttu-id="d36f1-183">新的語法不會提供執行階段檢查。</span><span class="sxs-lookup"><span data-stu-id="d36f1-183">The new syntax doesn't provide runtime checking.</span></span> <span data-ttu-id="d36f1-184">外部程式碼可能會規避編譯器的流程分析。</span><span class="sxs-lookup"><span data-stu-id="d36f1-184">External code might circumvent the compiler's flow analysis.</span></span> 

<span data-ttu-id="d36f1-185">其他時候，類別的結構會提供意圖的不同線索。</span><span class="sxs-lookup"><span data-stu-id="d36f1-185">Other times, the structure of a class provides different clues to the intent.</span></span> <span data-ttu-id="d36f1-186">開啟 *Pages* 資料夾中的 *Error.cshtml.cs* 檔案。</span><span class="sxs-lookup"><span data-stu-id="d36f1-186">Open the *Error.cshtml.cs* file in the *Pages* folder.</span></span> <span data-ttu-id="d36f1-187">`ErrorViewModel` 包含下列程式碼：</span><span class="sxs-lookup"><span data-stu-id="d36f1-187">The `ErrorViewModel` contains the following code:</span></span>

[!code-csharp[StarterErrorModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Pages/Error.cshtml.cs#StartErrorModel)]

<span data-ttu-id="d36f1-188">將 `#nullable enable` 新增到類別宣告之前，並將 `#nullable restore` 指示詞新增到該宣告之後。</span><span class="sxs-lookup"><span data-stu-id="d36f1-188">Add the `#nullable enable` directive before the class declaration, and a `#nullable restore` directive after it.</span></span> <span data-ttu-id="d36f1-189">您會收到一個警告，告知您 `RequestId` 並未初始化。</span><span class="sxs-lookup"><span data-stu-id="d36f1-189">You'll get one warning that `RequestId` is not initialized.</span></span> <span data-ttu-id="d36f1-190">藉由查看類別，您應判斷該 `RequestId` 屬性在某些情況下應為 Null。</span><span class="sxs-lookup"><span data-stu-id="d36f1-190">By looking at the class, you should decide that the `RequestId` property should be null in some cases.</span></span> <span data-ttu-id="d36f1-191">`ShowRequestId` 屬性的存在指出可能遺失值。</span><span class="sxs-lookup"><span data-stu-id="d36f1-191">The existence of the `ShowRequestId` property indicates that missing values are possible.</span></span> <span data-ttu-id="d36f1-192">因為 `null` 是有效的，請在 `?` 型別上新增 `string` 來指出 `RequestId` 屬性是「可為 Null 的參考型別」。</span><span class="sxs-lookup"><span data-stu-id="d36f1-192">Because `null` is valid, add the `?` on the `string` type to indicate the `RequestId` property is a *nullable reference type*.</span></span> <span data-ttu-id="d36f1-193">最終類別看起來會和下列範例相似：</span><span class="sxs-lookup"><span data-stu-id="d36f1-193">The final class looks like the following example:</span></span>

[!code-csharp[FinishedErrorModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Error.cshtml.cs#ErrorModel)]

<span data-ttu-id="d36f1-194">檢查屬性的使用方式，您便會發現在與其建立關聯的頁面上，會在於標記中轉譯它之前檢查該屬性是否為 Null。</span><span class="sxs-lookup"><span data-stu-id="d36f1-194">Check for the uses of the property, and you see that in the associated page, the property is checked for null before rendering it in markup.</span></span> <span data-ttu-id="d36f1-195">這便是可為 Null 參考型別的安全使用方式，因此您已不須再對此類別進行任何操作。</span><span class="sxs-lookup"><span data-stu-id="d36f1-195">That's a safe use of a nullable reference type, so you're done with this class.</span></span>

## <a name="fixing-nulls-causes-change"></a><span data-ttu-id="d36f1-196">修正 Null 會造成變更</span><span class="sxs-lookup"><span data-stu-id="d36f1-196">Fixing nulls causes change</span></span>

<span data-ttu-id="d36f1-197">通常，修正一組警告會在相關程式碼中建立新的警告。</span><span class="sxs-lookup"><span data-stu-id="d36f1-197">Frequently, the fix for one set of warnings creates new warnings in related code.</span></span> <span data-ttu-id="d36f1-198">讓我們透過修正 `index.cshtml.cs` 類別，查看警告實際運作的方式。</span><span class="sxs-lookup"><span data-stu-id="d36f1-198">Let's see the warnings in action by fixing the `index.cshtml.cs` class.</span></span> <span data-ttu-id="d36f1-199">請開啟 `index.cshtml.cs` 檔案並檢查程式碼。</span><span class="sxs-lookup"><span data-stu-id="d36f1-199">Open the `index.cshtml.cs` file and examine the code.</span></span> <span data-ttu-id="d36f1-200">此檔案包含索引頁背後的程式碼：</span><span class="sxs-lookup"><span data-stu-id="d36f1-200">This file contains the code behind for the index page:</span></span>

[!code-csharp[StarterIndexModel](~/samples/snippets/csharp/tutorials/nullable-reference-migration/start/SimpleFeedReader/Pages/Index.cshtml.cs#IndexModelStart)]

<span data-ttu-id="d36f1-201">新增 `#nullable enable` 指示詞，您便會看到兩個警告。</span><span class="sxs-lookup"><span data-stu-id="d36f1-201">Add the `#nullable enable` directive and you'll see two warnings.</span></span> <span data-ttu-id="d36f1-202">`ErrorText` 屬性或 `NewsItems` 屬性都並未初始化。</span><span class="sxs-lookup"><span data-stu-id="d36f1-202">Neither the `ErrorText` property nor the `NewsItems` property is initialized.</span></span> <span data-ttu-id="d36f1-203">檢查這個類別會導致您認為這兩個屬性都應該是可為 null 的參考型別：兩者都有私用 setter。</span><span class="sxs-lookup"><span data-stu-id="d36f1-203">An examination of this class would lead you to believe that both properties should be nullable reference types: Both have private setters.</span></span> <span data-ttu-id="d36f1-204">其中剛好有一個已在 `OnGet` 方法中指派。</span><span class="sxs-lookup"><span data-stu-id="d36f1-204">Exactly one is assigned in the `OnGet` method.</span></span> <span data-ttu-id="d36f1-205">在進行變更前，請先觀察兩個屬性的消費者。</span><span class="sxs-lookup"><span data-stu-id="d36f1-205">Before making changes, look at the consumers of both properties.</span></span> <span data-ttu-id="d36f1-206">在頁面本身中，會在為任何錯誤產生標記前再度檢查 `ErrorText` 是否為 Null。</span><span class="sxs-lookup"><span data-stu-id="d36f1-206">In the page itself, the `ErrorText` is checked against null before generating markup for any errors.</span></span> <span data-ttu-id="d36f1-207">`NewsItems` 集合也會受到檢查是否為 `null`，以及檢查其是否具有項目。</span><span class="sxs-lookup"><span data-stu-id="d36f1-207">The `NewsItems` collection is checked against `null`, and checked to ensure the collection has items.</span></span> <span data-ttu-id="d36f1-208">一種快速修正的方式，便是將兩個屬性設為可為 Null 的參考型別。</span><span class="sxs-lookup"><span data-stu-id="d36f1-208">A quick fix would be to make both properties nullable reference types.</span></span> <span data-ttu-id="d36f1-209">更佳修正方式是將集合設為不可為 Null 的參考型別，並在擷取新聞時將項目新增到現有集合。</span><span class="sxs-lookup"><span data-stu-id="d36f1-209">A better fix would be to make the collection a nonnullable reference type, and add items to the existing collection when retrieving news.</span></span> <span data-ttu-id="d36f1-210">第一個修正是將 `?` 新增到 `string` 的 `ErrorText` 型別：</span><span class="sxs-lookup"><span data-stu-id="d36f1-210">The first fix is to add the `?` to the `string` type for the `ErrorText`:</span></span>

[!code-csharp[UpdateErrorText](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#UpdateErrorText)]

<span data-ttu-id="d36f1-211">這項變更不會影響其他程式碼，因為任何對 `ErrorText` 屬性的存取都已由 Null 檢查防護。</span><span class="sxs-lookup"><span data-stu-id="d36f1-211">That change won't ripple through other code, because any access to the `ErrorText` property was already guarded by null checks.</span></span> <span data-ttu-id="d36f1-212">接下來，請初始化 `NewsItems` 清單並移除屬性 setter，使其成為唯讀屬性：</span><span class="sxs-lookup"><span data-stu-id="d36f1-212">Next, initialize the `NewsItems` list and remove the property setter, making it a readonly property:</span></span>

[!code-csharp[InitializeNewsItems](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#InitializeNewsItems)]

<span data-ttu-id="d36f1-213">這會修正警告，但會引進另一項錯誤。</span><span class="sxs-lookup"><span data-stu-id="d36f1-213">That fixed the warning but introduced an error.</span></span> <span data-ttu-id="d36f1-214">`NewsItems` 清單現在已是**以建構修正**，但在 `OnGet` 中設定清單的程式碼也必須變更，才能符合新的 API。</span><span class="sxs-lookup"><span data-stu-id="d36f1-214">The `NewsItems` list is now **correct by construction**, but the code that sets the list in `OnGet` must change to match the new API.</span></span> <span data-ttu-id="d36f1-215">取代指派，請改為呼叫 `AddRange` 來將新的項目新增到現有清單：</span><span class="sxs-lookup"><span data-stu-id="d36f1-215">Instead of an assignment, call `AddRange` to add the news items to the existing list:</span></span>

[!code-csharp[AddRange](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Pages/Index.cshtml.cs#AddRange)]

<span data-ttu-id="d36f1-216">使用 `AddRange` 而非指派，表示 `GetNews` 方法可傳回 `IEnumerable` 而非 `List`。</span><span class="sxs-lookup"><span data-stu-id="d36f1-216">Using `AddRange` instead of an assignment means that the `GetNews` method can return an `IEnumerable` instead of a `List`.</span></span> <span data-ttu-id="d36f1-217">這會省下一個配置。</span><span class="sxs-lookup"><span data-stu-id="d36f1-217">That saves one allocation.</span></span> <span data-ttu-id="d36f1-218">變更方法的簽章並移除 `ToList` 呼叫，如下列程式碼範例所示：</span><span class="sxs-lookup"><span data-stu-id="d36f1-218">Change the signature of the method, and remove the `ToList` call, as shown in the following code sample:</span></span>

[!code-csharp[GetNews](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#GetNewsFinished)]

<span data-ttu-id="d36f1-219">變更簽章也會中斷其中一項測試。</span><span class="sxs-lookup"><span data-stu-id="d36f1-219">Changing the signature breaks one of tests as well.</span></span> <span data-ttu-id="d36f1-220">開啟 `NewsServiceTests.cs` 專案 `Services` 資料夾中的 `SimpleFeedReader.Tests` 檔案。</span><span class="sxs-lookup"><span data-stu-id="d36f1-220">Open the `NewsServiceTests.cs` file in the `Services` folder of the `SimpleFeedReader.Tests` project.</span></span> <span data-ttu-id="d36f1-221">巡覽至 `Returns_News_Stories_Given_Valid_Uri` 測試，並將 `result` 變數的型別變更為 `IEnumerable<NewsItem>`。</span><span class="sxs-lookup"><span data-stu-id="d36f1-221">Navigate to the `Returns_News_Stories_Given_Valid_Uri` test and change the type of the `result` variable to `IEnumerable<NewsItem>`.</span></span> <span data-ttu-id="d36f1-222">變更型別表示 `Count` 屬性不再開放使用，因此請將 `Count` 中的 `Assert` 屬性取代為對 `Any()` 的呼叫：</span><span class="sxs-lookup"><span data-stu-id="d36f1-222">Changing the type means the `Count` property is no longer available, so replace the `Count` property in the `Assert` with a call to `Any()`:</span></span>

[!code-csharp[FixTests](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader.Tests/Services/NewsServiceTests.cs#FixTestSignature)]

<span data-ttu-id="d36f1-223">您也需要將一個 `using System.Linq` 陳述式新增到檔案的開頭。</span><span class="sxs-lookup"><span data-stu-id="d36f1-223">You'll need to add a `using System.Linq` statement to the beginning of the file as well.</span></span>

<span data-ttu-id="d36f1-224">這組變更醒目提示更新包含泛型具現化之程式碼時的特別考量事項。</span><span class="sxs-lookup"><span data-stu-id="d36f1-224">This set of changes highlights special consideration when updating code that includes generic instantiations.</span></span> <span data-ttu-id="d36f1-225">不可為 Null 型別清單及清單中的項目。</span><span class="sxs-lookup"><span data-stu-id="d36f1-225">Both the list and the elements in the list of non-nullable types.</span></span> <span data-ttu-id="d36f1-226">其中之一或兩者都可以是可為 Null 型別。</span><span class="sxs-lookup"><span data-stu-id="d36f1-226">Either or both could be nullable types.</span></span> <span data-ttu-id="d36f1-227">允許下列所有宣告：</span><span class="sxs-lookup"><span data-stu-id="d36f1-227">All the following declarations are allowed:</span></span>

- <span data-ttu-id="d36f1-228">`List<NewsStoryViewModel>`：不可為 Null 檢視模型的不可為 Null 清單。</span><span class="sxs-lookup"><span data-stu-id="d36f1-228">`List<NewsStoryViewModel>`: nonnullable list of nonullable view models.</span></span>
- <span data-ttu-id="d36f1-229">`List<NewsStoryViewModel?>`：可為 Null 檢視模型的不可為 Null 清單。</span><span class="sxs-lookup"><span data-stu-id="d36f1-229">`List<NewsStoryViewModel?>`: nonnullable list of nullable view models.</span></span>
- <span data-ttu-id="d36f1-230">`List<NewsStoryViewModel>?`：不可為 Null 檢視模型的可為 Null 清單。</span><span class="sxs-lookup"><span data-stu-id="d36f1-230">`List<NewsStoryViewModel>?`: nullable list of nonnullable view models.</span></span>
- <span data-ttu-id="d36f1-231">`List<NewsStoryViewModel?>?`：可為 Null 檢視模型的可為 Null 清單。</span><span class="sxs-lookup"><span data-stu-id="d36f1-231">`List<NewsStoryViewModel?>?`: nullable list of nullable view models.</span></span>

## <a name="interfaces-with-external-code"></a><span data-ttu-id="d36f1-232">連接外部程式碼</span><span class="sxs-lookup"><span data-stu-id="d36f1-232">Interfaces with external code</span></span>

<span data-ttu-id="d36f1-233">您已對 `NewsService` 類別進行變更，因此請開啟該類別的 `#nullable enable` 註釋。</span><span class="sxs-lookup"><span data-stu-id="d36f1-233">You've made changes to the `NewsService` class, so turn on the `#nullable enable` annotation for that class.</span></span> <span data-ttu-id="d36f1-234">這將不會產生任何新的警告。</span><span class="sxs-lookup"><span data-stu-id="d36f1-234">This won't generate any new warnings.</span></span> <span data-ttu-id="d36f1-235">但是，仔細檢查類別有助於說明編譯器流程分析的一些限制。</span><span class="sxs-lookup"><span data-stu-id="d36f1-235">However, careful examination of the class helps to illustrate some of the limitations of the compiler's flow analysis.</span></span> <span data-ttu-id="d36f1-236">檢查建構函式：</span><span class="sxs-lookup"><span data-stu-id="d36f1-236">Examine the constructor:</span></span>

[!code-csharp[ServiceConstructor](~/samples/snippets/csharp/tutorials/nullable-reference-migration/finished/SimpleFeedReader/Services/NewsService.cs#ServiceConstructor)]

<span data-ttu-id="d36f1-237">`IMapper` 參數型別為不可為 Null 的參考。</span><span class="sxs-lookup"><span data-stu-id="d36f1-237">The `IMapper` parameter is typed as a nonnullable reference.</span></span> <span data-ttu-id="d36f1-238">ASP.NET Core 基礎結構程式碼會呼叫它，因此編譯器並不真的了解 `IMapper` 永遠不會為 Null。</span><span class="sxs-lookup"><span data-stu-id="d36f1-238">It's called by ASP.NET Core infrastructure code, so the compiler doesn't really know that the `IMapper` will never be null.</span></span> <span data-ttu-id="d36f1-239">若無法解析必要服務，預設 ASP.NET Core 相依性 (DI) 容器會擲回例外狀況，因此程式碼是正確的。</span><span class="sxs-lookup"><span data-stu-id="d36f1-239">The default ASP.NET Core dependency injection (DI) container throws an exception if it can't resolve a necessary service, so the code is correct.</span></span> <span data-ttu-id="d36f1-240">編譯器無法驗證所有對您公用 API 進行的呼叫，即使程式碼是在啟用可為 Null 註釋內容的情況下編譯也一樣。</span><span class="sxs-lookup"><span data-stu-id="d36f1-240">The compiler can't validate all calls to your public APIs, even if your code is compiled with nullable annotation contexts enabled.</span></span> <span data-ttu-id="d36f1-241">此外，您的程式庫可能會由專案取用，但那些專案可能尚未加入使用可為 Null 的參考型別。</span><span class="sxs-lookup"><span data-stu-id="d36f1-241">Furthermore, your libraries may be consumed by projects that have not yet opted into using nullable reference types.</span></span> <span data-ttu-id="d36f1-242">即使您已將它們宣告為不可為 Null 類型，也請驗證針對公用 API 進行的輸入。</span><span class="sxs-lookup"><span data-stu-id="d36f1-242">Validate inputs to public APIs even though you've declared them as nonnullable types.</span></span>

## <a name="get-the-code"></a><span data-ttu-id="d36f1-243">取得程式碼</span><span class="sxs-lookup"><span data-stu-id="d36f1-243">Get the code</span></span>

<span data-ttu-id="d36f1-244">您已修正您在初始測試編譯中識別的警告，因此現在您可以開啟兩個專案的可為 Null 註釋內容。</span><span class="sxs-lookup"><span data-stu-id="d36f1-244">You've fixed the warnings you identified in the initial test compile, so now you can turn on the nullable annotation context for both projects.</span></span> <span data-ttu-id="d36f1-245">重建專案，編譯器不會回報任何警告。</span><span class="sxs-lookup"><span data-stu-id="d36f1-245">Rebuild the projects; the compiler reports no warnings.</span></span> <span data-ttu-id="d36f1-246">您可以在 [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/finished) GitHub 存放庫取得完成專案的程式碼。</span><span class="sxs-lookup"><span data-stu-id="d36f1-246">You can get the code for the finished project in the [dotnet/samples](https://github.com/dotnet/samples/tree/master/csharp/tutorials/nullable-reference-migration/finished) GitHub repository.</span></span>

<span data-ttu-id="d36f1-247">支援可為 Null 參考型別的新功能，可協助您尋找並修正處理您程式碼中 `null` 值方式中潛在的錯誤。</span><span class="sxs-lookup"><span data-stu-id="d36f1-247">The new features that support nullable reference types help you find and fix potential errors in how you handle `null` values in your code.</span></span> <span data-ttu-id="d36f1-248">啟用可為 Null 註釋內容，可讓您表達您的設計意圖：有些變數永遠不該為 Null，其他變數則可以包含 Null 值。</span><span class="sxs-lookup"><span data-stu-id="d36f1-248">Enabling the nullable annotation context allows you to express your design intent: some variables should never be null, other variables may contain null values.</span></span> <span data-ttu-id="d36f1-249">這些功能可讓您更輕易地宣告設計意圖。</span><span class="sxs-lookup"><span data-stu-id="d36f1-249">These features make it easier for you to declare your design intent.</span></span> <span data-ttu-id="d36f1-250">同樣的，可為 Null 警告內容會指示編譯器，在您違反該意圖時發出警告。</span><span class="sxs-lookup"><span data-stu-id="d36f1-250">Similarly, the nullable warning context instructs the compiler to issue warnings when you have violated that intent.</span></span> <span data-ttu-id="d36f1-251">這些警告會引導您進行更新，讓您的程式碼復原性更佳，並降低在執行期間擲回 `NullReferenceException` 的機率。</span><span class="sxs-lookup"><span data-stu-id="d36f1-251">Those warnings guide you to make updates that make your code more resilient and less likely to throw a `NullReferenceException` during execution.</span></span> <span data-ttu-id="d36f1-252">您可以控制這些內容的範圍，讓您專注在要遷移的程式碼本機區域，而無須更動剩餘的程式碼基底。</span><span class="sxs-lookup"><span data-stu-id="d36f1-252">You can control the scope of these contexts so that you can focus on local areas of code to migrate while the remaining codebase is untouched.</span></span> <span data-ttu-id="d36f1-253">在實務上，您可以將此移轉任務作為您類別一般維護的一部分。</span><span class="sxs-lookup"><span data-stu-id="d36f1-253">In practice, you can make this migration task a part of regular maintenance to your classes.</span></span> <span data-ttu-id="d36f1-254">本教學課程示範了遷移應用程式，以使用可為 Null 參考型別的過程。</span><span class="sxs-lookup"><span data-stu-id="d36f1-254">This tutorial demonstrated the process to migrate an application to use nullable reference types.</span></span> <span data-ttu-id="d36f1-255">您可以透過檢查 [Jon Skeet](https://github.com/jskeet) 為了將可為 Null 參考型別併入 [NodaTime](https://github.com/nodatime/nodatime/pull/1240/commits) 所製作的 PR，來探索這項程序的更大實際範例。</span><span class="sxs-lookup"><span data-stu-id="d36f1-255">You can explore a larger real-world example of this process by examining the PR [Jon Skeet](https://github.com/jskeet) made to incorporate nullable reference types into [NodaTime](https://github.com/nodatime/nodatime/pull/1240/commits).</span></span> <span data-ttu-id="d36f1-256">或者，您也可以透過[Entity Framework Core-使用可為 null 的參考](/ef/core/miscellaneous/nullable-reference-types)型別，學習使用可為 null 的參考型別搭配 Entity Framework Core 的技術。</span><span class="sxs-lookup"><span data-stu-id="d36f1-256">Or just In addition, you can learn techniques for using nullable reference types with Entity Framework Core in [Entity Framework Core - Working with nullable reference types](/ef/core/miscellaneous/nullable-reference-types).</span></span>
