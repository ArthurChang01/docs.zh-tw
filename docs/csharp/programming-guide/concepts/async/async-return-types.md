---
title: 非同步方法的傳回型別 (C#)
ms.date: 05/29/2017
ms.assetid: ddb2539c-c898-48c1-ad92-245e4a996df8
ms.openlocfilehash: 3d3c7d610dd1287d2c7284a5edd9c92810a74dba
ms.sourcegitcommit: ea00c05e0995dae928d48ead99ddab6296097b4c
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/02/2018
ms.locfileid: "48036236"
---
# <a name="async-return-types-c"></a><span data-ttu-id="50c2f-102">非同步方法的傳回型別 (C#)</span><span class="sxs-lookup"><span data-stu-id="50c2f-102">Async Return Types (C#)</span></span>
<span data-ttu-id="50c2f-103">非同步方法可有下列傳回型別：</span><span class="sxs-lookup"><span data-stu-id="50c2f-103">Async methods can have the following return types:</span></span>

- <span data-ttu-id="50c2f-104">傳回值的非同步方法為 <xref:System.Threading.Tasks.Task%601>。</span><span class="sxs-lookup"><span data-stu-id="50c2f-104"><xref:System.Threading.Tasks.Task%601>, for an async method that returns a value.</span></span> 
 
-  <span data-ttu-id="50c2f-105">執行作業但不傳回任何值的非同步方法為 <xref:System.Threading.Tasks.Task>。</span><span class="sxs-lookup"><span data-stu-id="50c2f-105"><xref:System.Threading.Tasks.Task>, for an async method that performs an operation but returns no value.</span></span>

- <span data-ttu-id="50c2f-106">處理常式為 `void`。</span><span class="sxs-lookup"><span data-stu-id="50c2f-106">`void`, for an event handler.</span></span> 

- <span data-ttu-id="50c2f-107">自 C# 7.0 開始，任何具有可存取 `GetAwaiter` 方法的型別。</span><span class="sxs-lookup"><span data-stu-id="50c2f-107">Starting with C# 7.0, any type that has an accessible `GetAwaiter` method.</span></span> <span data-ttu-id="50c2f-108">`GetAwaiter` 方法傳回的物件必須實作 <xref:System.Runtime.CompilerServices.ICriticalNotifyCompletion?displayProperty=nameWithType> 介面。</span><span class="sxs-lookup"><span data-stu-id="50c2f-108">The object returned by the `GetAwaiter` method must implement the <xref:System.Runtime.CompilerServices.ICriticalNotifyCompletion?displayProperty=nameWithType> interface.</span></span>
  
<span data-ttu-id="50c2f-109">如需非同步方法的詳細資訊，請參閱[使用 async 和 await 進行非同步程式設計 (C#)](../../../../csharp/programming-guide/concepts/async/index.md)。</span><span class="sxs-lookup"><span data-stu-id="50c2f-109">For more information about async methods, see [Asynchronous Programming with async and await (C#)](../../../../csharp/programming-guide/concepts/async/index.md).</span></span>  
  
<span data-ttu-id="50c2f-110">每個傳回型別在下列其中一節探討，您可以在主題結尾處找到使用全部三種類型的完整範例。</span><span class="sxs-lookup"><span data-stu-id="50c2f-110">Each return type is examined in one of the following sections, and you can find a full example that uses all three types at the end of the topic.</span></span>  
  
##  <a name="BKMK_TaskTReturnType"></a> <span data-ttu-id="50c2f-111">Task\<TResult\> 傳回型別</span><span class="sxs-lookup"><span data-stu-id="50c2f-111">Task\<TResult\> Return Type</span></span>  
<span data-ttu-id="50c2f-112"><xref:System.Threading.Tasks.Task%601> 傳回型別用於非同步方法，此方法包含 [return](../../../../csharp/language-reference/keywords/return.md) (C#) 陳述式，其運算元的類型為 `TResult`。</span><span class="sxs-lookup"><span data-stu-id="50c2f-112">The <xref:System.Threading.Tasks.Task%601> return type is used for an async method that contains a [return](../../../../csharp/language-reference/keywords/return.md) (C#) statement in which the operand has type `TResult`.</span></span>  
  
<span data-ttu-id="50c2f-113">在下列範例中，`GetLeisureHours` 非同步方法包含一個傳回整數的 `return` 陳述式。</span><span class="sxs-lookup"><span data-stu-id="50c2f-113">In the following example, the `GetLeisureHours` async method contains a `return` statement that returns an integer.</span></span> <span data-ttu-id="50c2f-114">因此，方法宣告必須指定 `Task<int>` 傳回型別。</span><span class="sxs-lookup"><span data-stu-id="50c2f-114">Therefore, the method declaration must specify a return type of `Task<int>`.</span></span>  <span data-ttu-id="50c2f-115"><xref:System.Threading.Tasks.Task.FromResult%2A> 非同步方法是傳回字串作業的預留位置。</span><span class="sxs-lookup"><span data-stu-id="50c2f-115">The <xref:System.Threading.Tasks.Task.FromResult%2A> async method is a placeholder for an operation that returns a string.</span></span>
  
[!code-csharp[return-value](../../../../../samples/snippets/csharp/programming-guide/async/async-returns1.cs)]

<span data-ttu-id="50c2f-116">從 `ShowTodaysInfo` 方法的 await 運算式內呼叫 `GetLeisureHours` 時，await 運算式會擷取儲存在 `GetLeisureHours` 方法所傳回之工作中的整數值 (`leisureHours` 的值)。</span><span class="sxs-lookup"><span data-stu-id="50c2f-116">When `GetLeisureHours` is called from within an await expression in the `ShowTodaysInfo` method, the await expression retrieves the integer value (the value of `leisureHours`) that's stored in the task returned by the `GetLeisureHours` method.</span></span> <span data-ttu-id="50c2f-117">如需 await 運算式的詳細資訊，請參閱 [await](../../../../csharp/language-reference/keywords/await.md)。</span><span class="sxs-lookup"><span data-stu-id="50c2f-117">For more information about await expressions, see [await](../../../../csharp/language-reference/keywords/await.md).</span></span>  
  
<span data-ttu-id="50c2f-118">您可以藉由區隔對 `GetLeisureHours` 的呼叫與 `await` 的應用，深入了解這種運作方式，如下列程式碼所示。</span><span class="sxs-lookup"><span data-stu-id="50c2f-118">You can better understand how this happens by separating the call to `GetLeisureHours` from the application of `await`, as the following code shows.</span></span> <span data-ttu-id="50c2f-119">呼叫不會立即等候的 `GetLeisureHours` 方法，會傳回 `Task<int>`，如您所預期的方法宣告。</span><span class="sxs-lookup"><span data-stu-id="50c2f-119">A call to method `GetLeisureHours` that isn't immediately awaited returns a `Task<int>`, as you would expect from the declaration of the method.</span></span> <span data-ttu-id="50c2f-120">在範例中，工作會指派給 `infoTask` 變數。</span><span class="sxs-lookup"><span data-stu-id="50c2f-120">The task is assigned to the `infoTask` variable in the example.</span></span> <span data-ttu-id="50c2f-121">因為 `infoTask` 是 <xref:System.Threading.Tasks.Task%601>，所以它包含 `TResult` 類型的 <xref:System.Threading.Tasks.Task%601.Result> 屬性。</span><span class="sxs-lookup"><span data-stu-id="50c2f-121">Because `infoTask` is a <xref:System.Threading.Tasks.Task%601>, it contains a <xref:System.Threading.Tasks.Task%601.Result> property of type `TResult`.</span></span> <span data-ttu-id="50c2f-122">在本例中，`TResult` 代表整數類型。</span><span class="sxs-lookup"><span data-stu-id="50c2f-122">In this case, `TResult` represents an integer type.</span></span> <span data-ttu-id="50c2f-123">當 `await` 套用至 `infoTask` 時，await 運算式評估為 `infoTask` 之 <xref:System.Threading.Tasks.Task%601.Result%2A> 屬性的內容。</span><span class="sxs-lookup"><span data-stu-id="50c2f-123">When `await` is applied to `infoTask`, the await expression evaluates to the contents of the <xref:System.Threading.Tasks.Task%601.Result%2A> property of `infoTask`.</span></span> <span data-ttu-id="50c2f-124">值會指派給 `ret` 變數。</span><span class="sxs-lookup"><span data-stu-id="50c2f-124">The value is assigned to the `ret` variable.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="50c2f-125"><xref:System.Threading.Tasks.Task%601.Result%2A> 屬性是封鎖的屬性。</span><span class="sxs-lookup"><span data-stu-id="50c2f-125">The <xref:System.Threading.Tasks.Task%601.Result%2A> property is a blocking property.</span></span> <span data-ttu-id="50c2f-126">如果您嘗試在其工作完成之前先存取它，目前使用中的執行緒會封鎖，直到工作完成並且有可用的值為止。</span><span class="sxs-lookup"><span data-stu-id="50c2f-126">If you try to access it before its task is finished, the thread that's currently active is blocked until the task completes and the value is available.</span></span> <span data-ttu-id="50c2f-127">在大部分情況下，您應該使用 `await` 來存取值，而不是直接存取屬性。</span><span class="sxs-lookup"><span data-stu-id="50c2f-127">In most cases, you should access the value by using `await` instead of accessing the property directly.</span></span> <br/> <span data-ttu-id="50c2f-128">前一個範例擷取 <xref:System.Threading.Tasks.Task%601.Result%2A> 屬性的值，封鎖主執行緒，讓 `ShowTodaysInfo` 方法在應用程式結束之前可以完成執行。</span><span class="sxs-lookup"><span data-stu-id="50c2f-128">The previous example retrieved the value of the <xref:System.Threading.Tasks.Task%601.Result%2A> property to block the main thread so that the `ShowTodaysInfo` method could finish execution before the application ended.</span></span>  

[!code-csharp[return-value](../../../../../samples/snippets/csharp/programming-guide/async/async-returns1a.cs#1)]
  
##  <a name="BKMK_TaskReturnType"></a> <span data-ttu-id="50c2f-129">工作傳回型別</span><span class="sxs-lookup"><span data-stu-id="50c2f-129">Task Return Type</span></span>  
<span data-ttu-id="50c2f-130">不包含 `return` 陳述式的非同步方法，或包含不會傳回運算元的 `return` 陳述式的非同步方法，通常具有傳回型別 <xref:System.Threading.Tasks.Task>。</span><span class="sxs-lookup"><span data-stu-id="50c2f-130">Async methods that don't contain a `return` statement or that contain a `return` statement that doesn't return an operand usually have a return type of <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="50c2f-131">這類方法如果以同步方式執行，會傳回 `void`。</span><span class="sxs-lookup"><span data-stu-id="50c2f-131">Such methods return `void` if they run synchronously.</span></span> <span data-ttu-id="50c2f-132">如果您針對非同步方法使用 <xref:System.Threading.Tasks.Task> 傳回型別，則除非被呼叫的非同步方法完成，否則呼叫的方法可以使用 `await` 運算子暫止呼叫端完成。</span><span class="sxs-lookup"><span data-stu-id="50c2f-132">If you use a <xref:System.Threading.Tasks.Task> return type for an async method, a calling method can use an `await` operator to suspend the caller's completion until the called async method has finished.</span></span>  
  
<span data-ttu-id="50c2f-133">在下列範例中，`WaitAndApologize` 非同步方法不包含 `return` 陳述式，所以方法傳回 <xref:System.Threading.Tasks.Task> 物件。</span><span class="sxs-lookup"><span data-stu-id="50c2f-133">In the following example, the `WaitAndApologize` async method doesn't contain a `return` statement, so the method returns a <xref:System.Threading.Tasks.Task> object.</span></span> <span data-ttu-id="50c2f-134">這就讓 `WaitAndApologize` 成為等候的。</span><span class="sxs-lookup"><span data-stu-id="50c2f-134">This enables `WaitAndApologize` to be awaited.</span></span> <span data-ttu-id="50c2f-135">請注意，<xref:System.Threading.Tasks.Task> 類型不包含 `Result` 屬性，因為它沒有傳回值。</span><span class="sxs-lookup"><span data-stu-id="50c2f-135">Note that the <xref:System.Threading.Tasks.Task> type doesn't include a `Result` property because it has no return value.</span></span>  

[!code-csharp[return-value](../../../../../samples/snippets/csharp/programming-guide/async/async-returns2.cs)]  
  
<span data-ttu-id="50c2f-136">`WaitAndApologize` 是透過使用 await 陳述式而非 await 運算式成為等候的，類似同步 void 傳回方法的呼叫陳述式。</span><span class="sxs-lookup"><span data-stu-id="50c2f-136">`WaitAndApologize` is awaited by using an await statement instead of an await expression, similar to the calling statement for a synchronous void-returning method.</span></span> <span data-ttu-id="50c2f-137">在此情況下，await 運算子的應用不會產生值。</span><span class="sxs-lookup"><span data-stu-id="50c2f-137">The application of an await operator in this case doesn't produce a value.</span></span>  
  
<span data-ttu-id="50c2f-138">如先前的 <xref:System.Threading.Tasks.Task%601> 範例所示，您可以隔開對 `WaitAndApologize` 的呼叫和 await 運算子的應用程式，如下列程式碼所示。</span><span class="sxs-lookup"><span data-stu-id="50c2f-138">As in the previous <xref:System.Threading.Tasks.Task%601> example, you can separate the call to `WaitAndApologize` from the application of an await operator, as the following code shows.</span></span> <span data-ttu-id="50c2f-139">不過，請記住，`Task` 沒有 `Result` 屬性，且將 await 運算子套用至 `Task` 時不會產生任何值。</span><span class="sxs-lookup"><span data-stu-id="50c2f-139">However, remember that a `Task` doesn't have a `Result` property, and that no value is produced when an await operator is applied to a `Task`.</span></span>  
  
<span data-ttu-id="50c2f-140">下列程式碼隔開呼叫 `WaitAndApologize` 方法與等候方法傳回的工作。</span><span class="sxs-lookup"><span data-stu-id="50c2f-140">The following code separates calling the `WaitAndApologize` method from awaiting the task that the method returns.</span></span>  
 
[!code-csharp[return-value](../../../../../samples/snippets/csharp/programming-guide/async/async-returns2a.cs#1)]  
 
##  <a name="BKMK_VoidReturnType"></a> <span data-ttu-id="50c2f-141">Void 傳回型別</span><span class="sxs-lookup"><span data-stu-id="50c2f-141">Void return type</span></span>

<span data-ttu-id="50c2f-142">您在非同步事件處理常式中使用 `void` 傳回型別，這需要 `void` 傳回型別。</span><span class="sxs-lookup"><span data-stu-id="50c2f-142">You use the `void` return type in asynchronous event handlers, which require a `void` return type.</span></span> <span data-ttu-id="50c2f-143">對於不傳回值的事件處理常式以外的方法，您應該要改傳回 <xref:System.Threading.Tasks.Task>，因為傳回 `void` 的非同步方法不能是等候的。</span><span class="sxs-lookup"><span data-stu-id="50c2f-143">For methods other than event handlers that don't return a value, you should return a <xref:System.Threading.Tasks.Task> instead, because an async method that returns `void` can't be awaited.</span></span> <span data-ttu-id="50c2f-144">這種方法的任何呼叫端必須要能夠繼續完成而不需等待呼叫的非同步方法完成，且呼叫端必須與非同步方法產生的任何值或例外狀況無關。</span><span class="sxs-lookup"><span data-stu-id="50c2f-144">Any caller of such a method must be able to continue to completion without waiting for the called async method to finish, and the caller must be independent of any values or exceptions that the async method generates.</span></span>  
  
<span data-ttu-id="50c2f-145">傳回 void 的非同步方法的呼叫端無法攔截方法擲回的例外狀況，這類未處理的例外狀況有可能造成應用程式失敗。</span><span class="sxs-lookup"><span data-stu-id="50c2f-145">The caller of a void-returning async method can't catch exceptions that are thrown from the method, and such unhandled exceptions are likely to cause your application to fail.</span></span> <span data-ttu-id="50c2f-146">如果例外狀況發生在會傳回 <xref:System.Threading.Tasks.Task> 或 <xref:System.Threading.Tasks.Task%601> 的非同步方法，則例外狀況會儲存在傳回的工作中，並在等候工作時再次擲回。</span><span class="sxs-lookup"><span data-stu-id="50c2f-146">If an exception occurs in an async method that returns a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601>, the exception is stored in the returned task and is rethrown when the task is awaited.</span></span> <span data-ttu-id="50c2f-147">因此，請確定任何可能會產生例外狀況的非同步方法具有傳回型別 <xref:System.Threading.Tasks.Task> 或 <xref:System.Threading.Tasks.Task%601>，且會等候對方法的呼叫。</span><span class="sxs-lookup"><span data-stu-id="50c2f-147">Therefore, make sure that any async method that can produce an exception has a return type of <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> and that calls to the method are awaited.</span></span>  
  
<span data-ttu-id="50c2f-148">如需如何在非同步方法中攔截例外狀況的詳細資訊，請參閱 [try-catch](../../../language-reference/keywords/try-catch.md) 主題的[非同步方法中的例外狀況](../../../language-reference/keywords/try-catch.md#exceptions-in-async-methods)一節。</span><span class="sxs-lookup"><span data-stu-id="50c2f-148">For more information about how to catch exceptions in async methods, see the [Exceptions in Async Methods](../../../language-reference/keywords/try-catch.md#exceptions-in-async-methods) section of the [try-catch](../../../language-reference/keywords/try-catch.md) topic.</span></span>  
  
<span data-ttu-id="50c2f-149">下列範例示範非同步事件處理常式的行為。</span><span class="sxs-lookup"><span data-stu-id="50c2f-149">The following example shows the behavior of an async event handler.</span></span> <span data-ttu-id="50c2f-150">請注意，在範例程式碼中，非同步事件處理常式完成時必須讓主執行緒知道。</span><span class="sxs-lookup"><span data-stu-id="50c2f-150">Note that in the example code, an async event handler must let the main thread know when it finishes.</span></span> <span data-ttu-id="50c2f-151">然後主執行緒可以等候非同步事件處理常式完成，再結束程式。</span><span class="sxs-lookup"><span data-stu-id="50c2f-151">Then the main thread can wait for an async event handler to complete before exiting the program.</span></span>
 
[!code-csharp[return-value](../../../../../samples/snippets/csharp/programming-guide/async/async-returns3.cs)]  
 
## <a name="generalized-async-return-types-and-valuetasktresult"></a><span data-ttu-id="50c2f-152">通用的非同步傳回型別和 ValueTask\<TResult\></span><span class="sxs-lookup"><span data-stu-id="50c2f-152">Generalized async return types and ValueTask\<TResult\></span></span>

<span data-ttu-id="50c2f-153">自 C# 7.0 開始，非同步方法可以傳回具有可存取 `GetAwaiter` 方法的任何型別。</span><span class="sxs-lookup"><span data-stu-id="50c2f-153">Starting with C# 7.0, an async method can return any type that has an accessible `GetAwaiter` method.</span></span>
 
<span data-ttu-id="50c2f-154">因為 <xref:System.Threading.Tasks.Task> 和 <xref:System.Threading.Tasks.Task%601> 是參考型別，所以效能關鍵路徑中的記憶體配置，會對效能造成不良影響，特別是當配置出現在緊密迴圈中時。</span><span class="sxs-lookup"><span data-stu-id="50c2f-154">Because <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> are reference types, memory allocation in performance-critical paths, particularly when allocations occur in tight loops, can adversely affect performance.</span></span> <span data-ttu-id="50c2f-155">支援通用的傳回型別，表示您可以傳回輕量型的實值型別，而不是參考型別，以避免額外的記憶體配置。</span><span class="sxs-lookup"><span data-stu-id="50c2f-155">Support for generalized return types means that you can return a lightweight value type instead of a reference type to avoid additional memory allocations.</span></span> 

<span data-ttu-id="50c2f-156">.NET 提供 <xref:System.Threading.Tasks.ValueTask%601?displayProperty=nameWithType> 結構做為通用工作傳回值的輕量級實作。</span><span class="sxs-lookup"><span data-stu-id="50c2f-156">.NET provides the <xref:System.Threading.Tasks.ValueTask%601?displayProperty=nameWithType> structure as a light-weight implementation of a generalized task-returning value.</span></span> <span data-ttu-id="50c2f-157">若要使用 <xref:System.Threading.Tasks.ValueTask%601?displayProperty=nameWithType> 類型，您必須將 `System.Threading.Tasks.Extensions` NuGet 套件新增至專案。</span><span class="sxs-lookup"><span data-stu-id="50c2f-157">To use the <xref:System.Threading.Tasks.ValueTask%601?displayProperty=nameWithType> type, you must add the `System.Threading.Tasks.Extensions` NuGet package to your project.</span></span> <span data-ttu-id="50c2f-158">下列範例會使用 <xref:System.Threading.Tasks.ValueTask%601> 結構，擷取擲兩次骰子的值。</span><span class="sxs-lookup"><span data-stu-id="50c2f-158">The following example uses the <xref:System.Threading.Tasks.ValueTask%601> structure to retrieve the value of two dice rolls.</span></span> 
  
[!code-csharp[return-value](../../../../../samples/snippets/csharp/programming-guide/async/async-valuetask.cs)]

## <a name="see-also"></a><span data-ttu-id="50c2f-159">請參閱</span><span class="sxs-lookup"><span data-stu-id="50c2f-159">See Also</span></span>

- <xref:System.Threading.Tasks.Task.FromResult%2A>   
- [<span data-ttu-id="50c2f-160">逐步解說：使用 async 和 await 存取 Web (C#)</span><span class="sxs-lookup"><span data-stu-id="50c2f-160">Walkthrough: Accessing the Web by Using async and await (C#)</span></span>](../../../../csharp/programming-guide/concepts/async/walkthrough-accessing-the-web-by-using-async-and-await.md)   
- [<span data-ttu-id="50c2f-161">非同步程式中的控制流程 (C#)</span><span class="sxs-lookup"><span data-stu-id="50c2f-161">Control Flow in Async Programs (C#)</span></span>](../../../../csharp/programming-guide/concepts/async/control-flow-in-async-programs.md)   
- [<span data-ttu-id="50c2f-162">async</span><span class="sxs-lookup"><span data-stu-id="50c2f-162">async</span></span>](../../../../csharp/language-reference/keywords/async.md)   
- [<span data-ttu-id="50c2f-163">await</span><span class="sxs-lookup"><span data-stu-id="50c2f-163">await</span></span>](../../../../csharp/language-reference/keywords/await.md)
