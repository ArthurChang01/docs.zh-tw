---
title: "擴充方法 (C# 程式設計手冊)"
ms.date: 07/20/2015
ms.prod: .net
ms.technology: devlang-csharp
ms.topic: article
helpviewer_keywords:
- methods [C#], adding to existing types
- extension methods [C#]
- methods [C#], extension
ms.assetid: 175ce3ff-9bbf-4e64-8421-faeb81a0bb51
caps.latest.revision: "35"
author: BillWagner
ms.author: wiwagn
ms.openlocfilehash: 4c94e6cd2894959d64fe463c85b4460893f2bf96
ms.sourcegitcommit: c0dd436f6f8f44dc80dc43b07f6841a00b74b23f
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/19/2018
---
# <a name="extension-methods-c-programming-guide"></a><span data-ttu-id="60704-102">擴充方法 (C# 程式設計手冊)</span><span class="sxs-lookup"><span data-stu-id="60704-102">Extension Methods (C# Programming Guide)</span></span>
<span data-ttu-id="60704-103">擴充方法可讓您在現有類型中「加入」方法，而不需要建立新的衍生類型、重新編譯，或是修改原始類型。</span><span class="sxs-lookup"><span data-stu-id="60704-103">Extension methods enable you to "add" methods to existing types without creating a new derived type, recompiling, or otherwise modifying the original type.</span></span> <span data-ttu-id="60704-104">擴充方法是一種特殊的靜態方法，但是會將它們當成擴充類型上的執行個體方法來呼叫。</span><span class="sxs-lookup"><span data-stu-id="60704-104">Extension methods are a special kind of static method, but they are called as if they were instance methods on the extended type.</span></span> <span data-ttu-id="60704-105">對於以 C#、F# 和 Visual Basic 撰寫的用戶端程式碼，呼叫擴充方法或是在類型中實際定義的方法，兩者之間並沒有明顯的差別。</span><span class="sxs-lookup"><span data-stu-id="60704-105">For client code written in C#, F# and Visual Basic, there is no apparent difference between calling an extension method and the methods that are actually defined in a type.</span></span>  
  
 <span data-ttu-id="60704-106">最常見的擴充方法是 [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] 標準查詢運算子，這些運算子會將查詢功能新增至現有的 <xref:System.Collections.IEnumerable?displayProperty=nameWithType> 和 <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> 類型。</span><span class="sxs-lookup"><span data-stu-id="60704-106">The most common extension methods are the [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] standard query operators that add query functionality to the existing <xref:System.Collections.IEnumerable?displayProperty=nameWithType> and <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="60704-107">若要使用標準查詢運算子，請先使用 `using System.Linq` 指示詞將它們帶入範圍內。</span><span class="sxs-lookup"><span data-stu-id="60704-107">To use the standard query operators, first bring them into scope with a `using System.Linq` directive.</span></span> <span data-ttu-id="60704-108">接著，任何實作 <xref:System.Collections.Generic.IEnumerable%601> 的類型都會具有執行個體方法，如 <xref:System.Linq.Enumerable.GroupBy%2A>、<xref:System.Linq.Enumerable.OrderBy%2A>、<xref:System.Linq.Enumerable.Average%2A> 等。</span><span class="sxs-lookup"><span data-stu-id="60704-108">Then any type that implements <xref:System.Collections.Generic.IEnumerable%601> appears to have instance methods such as <xref:System.Linq.Enumerable.GroupBy%2A>, <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.Average%2A>, and so on.</span></span> <span data-ttu-id="60704-109">如果在 <xref:System.Collections.Generic.IEnumerable%601> 類型 (如 <xref:System.Collections.Generic.List%601> 或 <xref:System.Array>) 的執行個體後面輸入「點」，就可以在 IntelliSense 陳述式完成時看到這些額外的方法。</span><span class="sxs-lookup"><span data-stu-id="60704-109">You can see these additional methods in IntelliSense statement completion when you type "dot" after an instance of an <xref:System.Collections.Generic.IEnumerable%601> type such as <xref:System.Collections.Generic.List%601> or <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="60704-110">下列範例將示範如何在整數陣列上呼叫標準查詢運算子 `OrderBy` 方法。</span><span class="sxs-lookup"><span data-stu-id="60704-110">The following example shows how to call the standard query operator `OrderBy` method on an array of integers.</span></span> <span data-ttu-id="60704-111">括號括住的運算式就是 Lambda 運算式。</span><span class="sxs-lookup"><span data-stu-id="60704-111">The expression in parentheses is a lambda expression.</span></span> <span data-ttu-id="60704-112">許多標準查詢運算子會將 Lambda 運算式當成參數，但是擴充方法不會強制這樣做。</span><span class="sxs-lookup"><span data-stu-id="60704-112">Many standard query operators take lambda expressions as parameters, but this is not a requirement for extension methods.</span></span> <span data-ttu-id="60704-113">如需詳細資訊，請參閱 [Lambda 運算式](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)。</span><span class="sxs-lookup"><span data-stu-id="60704-113">For more information, see [Lambda Expressions](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#3](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_1.cs)]  
  
 <span data-ttu-id="60704-114">擴充方法會定義為靜態方法，但透過執行個體方法語法呼叫。</span><span class="sxs-lookup"><span data-stu-id="60704-114">Extension methods are defined as static methods but are called by using instance method syntax.</span></span> <span data-ttu-id="60704-115">擴充方法的第一個參數會指定方法作業所在的類型，而且參數前面會加上 [this](../../../csharp/language-reference/keywords/this.md) 修飾詞。</span><span class="sxs-lookup"><span data-stu-id="60704-115">Their first parameter specifies which type the method operates on, and the parameter is preceded by the [this](../../../csharp/language-reference/keywords/this.md) modifier.</span></span> <span data-ttu-id="60704-116">您必須使用 `using` 指示詞將命名空間明確匯入至原始程式碼，擴充方法才會進入範圍中。</span><span class="sxs-lookup"><span data-stu-id="60704-116">Extension methods are only in scope when you explicitly import the namespace into your source code with a `using` directive.</span></span>  
  
 <span data-ttu-id="60704-117">下列範例將示範針對 <xref:System.String?displayProperty=nameWithType> 類別定義的擴充方法。</span><span class="sxs-lookup"><span data-stu-id="60704-117">The following example shows an extension method defined for the <xref:System.String?displayProperty=nameWithType> class.</span></span> <span data-ttu-id="60704-118">請注意，擴充方法是定義在非巢狀且非泛型的靜態類別內：</span><span class="sxs-lookup"><span data-stu-id="60704-118">Note that it is defined inside a non-nested, non-generic static class:</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#4](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_2.cs)]  
  
 <span data-ttu-id="60704-119">使用這個 `WordCount` 指示詞就可以將 `using` 擴充方法帶入範圍中：</span><span class="sxs-lookup"><span data-stu-id="60704-119">The `WordCount` extension method can be brought into scope with this `using` directive:</span></span>  
  
```  
using ExtensionMethods;  
```  
  
 <span data-ttu-id="60704-120">而使用下列語法，就可以從應用程式中呼叫它：</span><span class="sxs-lookup"><span data-stu-id="60704-120">And it can be called from an application by using this syntax:</span></span>  
  
```  
string s = "Hello Extension Methods";  
int i = s.WordCount();  
```  
  
 <span data-ttu-id="60704-121">在您的程式碼中，可以利用執行個體方法語法來叫用擴充方法。</span><span class="sxs-lookup"><span data-stu-id="60704-121">In your code you invoke the extension method with instance method syntax.</span></span> <span data-ttu-id="60704-122">不過，編譯器所產生的中繼語言 (IL) 會將您的程式碼轉譯為靜態方法上的呼叫。</span><span class="sxs-lookup"><span data-stu-id="60704-122">However, the intermediate language (IL) generated by the compiler translates your code into a call on the static method.</span></span> <span data-ttu-id="60704-123">因此，實際上並未違反封裝 (Encapsulation) 的準則。</span><span class="sxs-lookup"><span data-stu-id="60704-123">Therefore, the principle of encapsulation is not really being violated.</span></span> <span data-ttu-id="60704-124">事實上，擴充方法無法存取它們所擴充之類型中的私用變數。</span><span class="sxs-lookup"><span data-stu-id="60704-124">In fact, extension methods cannot access private variables in the type they are extending.</span></span>  
  
 <span data-ttu-id="60704-125">如需詳細資訊，請參閱[如何：實作和呼叫自訂擴充方法](../../../csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method.md)。</span><span class="sxs-lookup"><span data-stu-id="60704-125">For more information, see [How to: Implement and Call a Custom  Extension Method](../../../csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method.md).</span></span>  
  
 <span data-ttu-id="60704-126">一般而言，您呼叫擴充方法的頻率將遠高於實作自己的方法。</span><span class="sxs-lookup"><span data-stu-id="60704-126">In general, you will probably be calling extension methods far more often than implementing your own.</span></span> <span data-ttu-id="60704-127">因為擴充方法是使用執行個體方法語法進行呼叫，所以不需要任何特殊知識就可以從用戶端程式碼使用它們。</span><span class="sxs-lookup"><span data-stu-id="60704-127">Because extension methods are called by using instance method syntax, no special knowledge is required to use them from client code.</span></span> <span data-ttu-id="60704-128">若要啟用特定類型的擴充方法，只要針對定義這些方法所在的命名空間加入 `using` 指示詞即可。</span><span class="sxs-lookup"><span data-stu-id="60704-128">To enable extension methods for a particular type, just add a `using` directive for the namespace in which the methods are defined.</span></span> <span data-ttu-id="60704-129">例如，若要使用標準查詢運算子，請將下面這個 `using` 指示詞加入至程式碼：</span><span class="sxs-lookup"><span data-stu-id="60704-129">For example, to use the standard query operators, add this `using` directive to your code:</span></span>  
  
```  
using System.Linq;  
```  
  
 <span data-ttu-id="60704-130">(您可能也要加入對 System.Core.dll 的參考)。您將會注意到，標準查詢運算子現在出現在 IntelliSense 中，做為適用於大部分 <xref:System.Collections.Generic.IEnumerable%601> 類型的額外方法。</span><span class="sxs-lookup"><span data-stu-id="60704-130">(You may also have to add a reference to System.Core.dll.) You will notice that the standard query operators now appear in IntelliSense as additional methods available for most <xref:System.Collections.Generic.IEnumerable%601> types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60704-131">雖然標準查詢運算子未針對 <xref:System.String> 出現在 IntelliSense 中，但是您仍然可以使用它們。</span><span class="sxs-lookup"><span data-stu-id="60704-131">Although standard query operators do not appear in IntelliSense for <xref:System.String>, they are still available.</span></span>  
  
## <a name="binding-extension-methods-at-compile-time"></a><span data-ttu-id="60704-132">在編譯時期繫結擴充方法</span><span class="sxs-lookup"><span data-stu-id="60704-132">Binding Extension Methods at Compile Time</span></span>  
 <span data-ttu-id="60704-133">您可以使用擴充方法來擴充類別或介面，但無法覆寫它們。</span><span class="sxs-lookup"><span data-stu-id="60704-133">You can use extension methods to extend a class or interface, but not to override them.</span></span> <span data-ttu-id="60704-134">而且永遠不會呼叫擁有與介面或類別方法相同名稱和簽章的擴充方法。</span><span class="sxs-lookup"><span data-stu-id="60704-134">An extension method with the same name and signature as an interface or class method will never be called.</span></span> <span data-ttu-id="60704-135">在編譯時期，擴充方法的優先順序一律低於類型本身中定義的執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="60704-135">At compile time, extension methods always have lower priority than instance methods defined in the type itself.</span></span> <span data-ttu-id="60704-136">換句話說，如果類型具有名為 `Process(int i)` 的方法，而您的擴充方法也具有相同的簽章，則編譯器一律會繫結至執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="60704-136">In other words, if a type has a method named `Process(int i)`, and you have an extension method with the same signature, the compiler will always bind to the instance method.</span></span> <span data-ttu-id="60704-137">編譯器遇到方法引動過程時，會先在類型的執行個體方法中尋找相符項目。</span><span class="sxs-lookup"><span data-stu-id="60704-137">When the compiler encounters a method invocation, it first looks for a match in the type's instance methods.</span></span> <span data-ttu-id="60704-138">如果找不到相符項目，則會搜尋任何針對該類型定義的擴充方法，並繫結至找到的第一個擴充方法。</span><span class="sxs-lookup"><span data-stu-id="60704-138">If no match is found, it will search for any extension methods that are defined for the type, and bind to the first extension method that it finds.</span></span> <span data-ttu-id="60704-139">下列範例將示範編譯器如何判斷要繫結的擴充方法或執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="60704-139">The following example demonstrates how the compiler determines which extension method or instance method to bind to.</span></span>  
  
## <a name="example"></a><span data-ttu-id="60704-140">範例</span><span class="sxs-lookup"><span data-stu-id="60704-140">Example</span></span>  
 <span data-ttu-id="60704-141">下列範例將示範 C# 編譯器遵循的規則，用以判斷要將方法呼叫繫結至類型上的執行個體方法，還是繫結至擴充方法。</span><span class="sxs-lookup"><span data-stu-id="60704-141">The following example demonstrates the rules that the C# compiler follows in determining whether to bind a method call to an instance method on the type, or to an extension method.</span></span> <span data-ttu-id="60704-142">靜態類別 `Extensions` 包含針對任何實作 `IMyInterface` 之類型定義的擴充方法。</span><span class="sxs-lookup"><span data-stu-id="60704-142">The static class `Extensions` contains extension methods defined for any type that implements `IMyInterface`.</span></span> <span data-ttu-id="60704-143">類別 `A`、`B` 和 `C` 都會實作這個介面。</span><span class="sxs-lookup"><span data-stu-id="60704-143">Classes `A`, `B`, and `C` all implement the interface.</span></span>  
  
 <span data-ttu-id="60704-144">因為 `MethodB` 擴充方法的名稱和簽章與這些類別已實作的方法完全相同，所以絕不會呼叫該方法。</span><span class="sxs-lookup"><span data-stu-id="60704-144">The `MethodB` extension method is never called because its name and signature exactly match methods already implemented by the classes.</span></span>  
  
 <span data-ttu-id="60704-145">當編譯器找不到具有相符簽章的執行個體方法時，就會繫結至相符的擴充方法 (如果有的話)。</span><span class="sxs-lookup"><span data-stu-id="60704-145">When the compiler cannot find an instance method with a matching signature, it will bind to a matching extension method if one exists.</span></span>  
  
 [!code-csharp[csProgGuideExtensionMethods#5](../../../csharp/programming-guide/classes-and-structs/codesnippet/CSharp/extension-methods_3.cs)]  
  
## <a name="general-guidelines"></a><span data-ttu-id="60704-146">一般方針</span><span class="sxs-lookup"><span data-stu-id="60704-146">General Guidelines</span></span>  
 <span data-ttu-id="60704-147">一般而言，建議您應謹慎地實作擴充方法，而且只有在必要時才實作。</span><span class="sxs-lookup"><span data-stu-id="60704-147">In general, we recommend that you implement extension methods sparingly and only when you have to.</span></span> <span data-ttu-id="60704-148">當用戶端程式碼必須擴充現有的類型時，應該盡可能以建立衍生自現有類型的新類型來達成此目的。</span><span class="sxs-lookup"><span data-stu-id="60704-148">Whenever possible, client code that must extend an existing type should do so by creating a new type derived from the existing type.</span></span> <span data-ttu-id="60704-149">如需詳細資訊，請參閱[繼承](../../../csharp/programming-guide/classes-and-structs/inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="60704-149">For more information, see [Inheritance](../../../csharp/programming-guide/classes-and-structs/inheritance.md).</span></span>  
  
 <span data-ttu-id="60704-150">使用擴充方法來擴充無法變更其原始程式碼的類型時，會有類型實作的變更導致擴充方法中斷的風險。</span><span class="sxs-lookup"><span data-stu-id="60704-150">When using an extension method to extend a type whose source code you cannot change, you run the risk that a change in the implementation of the type will cause your extension method to break.</span></span>  
  
 <span data-ttu-id="60704-151">如果您要實作所指定類型的擴充方法，請記住下列幾點：</span><span class="sxs-lookup"><span data-stu-id="60704-151">If you do implement extension methods for a given type, remember the following points:</span></span>  
  
-   <span data-ttu-id="60704-152">如果擴充方法的簽章與類型中定義的方法相同，則絕不會呼叫擴充方法。</span><span class="sxs-lookup"><span data-stu-id="60704-152">An extension method will never be called if it has the same signature as a method defined in the type.</span></span>  
  
-   <span data-ttu-id="60704-153">擴充方法是帶入命名空間層級的範圍。</span><span class="sxs-lookup"><span data-stu-id="60704-153">Extension methods are brought into scope at the namespace level.</span></span> <span data-ttu-id="60704-154">例如，如果有多個靜態類別在名為 `Extensions` 的單一命名空間中包含擴充方法，則 `using Extensions;` 指示詞會將這些擴充方法全都帶入範圍中。</span><span class="sxs-lookup"><span data-stu-id="60704-154">For example, if you have multiple static classes that contain extension methods in a single namespace named `Extensions`, they will all be brought into scope by the `using Extensions;` directive.</span></span>  
  
 <span data-ttu-id="60704-155">針對實作的類別庫，您不應該使用擴充方法阻止組件的版本號碼遞增。</span><span class="sxs-lookup"><span data-stu-id="60704-155">For a class library that you implemented, you shouldn't use extension methods to avoid incrementing the version number of an assembly.</span></span> <span data-ttu-id="60704-156">如果您要在擁有其原始程式碼的程式庫中加入重要功能，則應遵循組件版本控制的標準 .NET Framework 方針。</span><span class="sxs-lookup"><span data-stu-id="60704-156">If you want to add significant functionality to a library for which you own the source code, you should follow the standard .NET Framework guidelines for assembly versioning.</span></span> <span data-ttu-id="60704-157">如需詳細資訊，請參閱[組件版本控制](../../../../docs/framework/app-domains/assembly-versioning.md)。</span><span class="sxs-lookup"><span data-stu-id="60704-157">For more information, see [Assembly Versioning](../../../../docs/framework/app-domains/assembly-versioning.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="60704-158">請參閱</span><span class="sxs-lookup"><span data-stu-id="60704-158">See Also</span></span>  
 [<span data-ttu-id="60704-159">C# 程式設計指南</span><span class="sxs-lookup"><span data-stu-id="60704-159">C# Programming Guide</span></span>](../../../csharp/programming-guide/index.md)  
 [<span data-ttu-id="60704-160">平行程式設計範例 (包括許多範例擴充方法)</span><span class="sxs-lookup"><span data-stu-id="60704-160">Parallel Programming Samples (these include many example extension methods)</span></span>](http://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364)  
 [<span data-ttu-id="60704-161">Lambda 運算式</span><span class="sxs-lookup"><span data-stu-id="60704-161">Lambda Expressions</span></span>](../../../csharp/programming-guide/statements-expressions-operators/lambda-expressions.md)  
 [<span data-ttu-id="60704-162">標準查詢運算子概觀</span><span class="sxs-lookup"><span data-stu-id="60704-162">Standard Query Operators Overview</span></span>](http://msdn.microsoft.com/library/24cda21e-8af8-4632-b519-c404a839b9b2)  
 <span data-ttu-id="60704-163">[Conversion rules for Instance parameters and their impact](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/conversion-rules-for-instance-parameters-and-their-impact) (執行個體參數的轉換規則與其影響)</span><span class="sxs-lookup"><span data-stu-id="60704-163">[Conversion rules for Instance parameters and their impact](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/conversion-rules-for-instance-parameters-and-their-impact)</span></span>  
 <span data-ttu-id="60704-164">[Extension methods Interoperability between languages](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/extension-methods-interoperability-between-languages) (語言之間擴充方法的互通性)</span><span class="sxs-lookup"><span data-stu-id="60704-164">[Extension methods Interoperability between languages](https://blogs.msdn.microsoft.com/sreekarc/2007/10/11/extension-methods-interoperability-between-languages)</span></span>  
 <span data-ttu-id="60704-165">[Extension methods and Curried Delegates](https://blogs.msdn.microsoft.com/sreekarc/2007/05/01/extension-methods-and-curried-delegates) (擴充方法和局部調用委派)</span><span class="sxs-lookup"><span data-stu-id="60704-165">[Extension methods and Curried Delegates](https://blogs.msdn.microsoft.com/sreekarc/2007/05/01/extension-methods-and-curried-delegates)</span></span>  
 <span data-ttu-id="60704-166">[Extension method Binding and Error reporting](https://blogs.msdn.microsoft.com/sreekarc/2007/04/26/extension-method-binding-and-error-reporting) (擴充方法繫結和錯誤報告)</span><span class="sxs-lookup"><span data-stu-id="60704-166">[Extension method Binding and Error reporting](https://blogs.msdn.microsoft.com/sreekarc/2007/04/26/extension-method-binding-and-error-reporting)</span></span>
