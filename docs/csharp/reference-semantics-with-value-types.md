---
title: "具有實值類型的參考語意"
description: "了解最小化安全地複製結構的語言功能"
author: billwagner
ms.author: wiwagn
ms.date: 11/10/2017
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.custom: mvc
ms.openlocfilehash: 9eeaf201c1f5a58044db62e356199b609c4c035a
ms.sourcegitcommit: 7e99f66ef09d2903e22c789c67ff5a10aa953b2f
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/18/2017
---
# <a name="reference-semantics-with-value-types"></a><span data-ttu-id="278da-103">具有實值類型的參考語意</span><span class="sxs-lookup"><span data-stu-id="278da-103">Reference semantics with value types</span></span>

<span data-ttu-id="278da-104">若要使用實值類型的優點是它們通常避免堆積配置。</span><span class="sxs-lookup"><span data-stu-id="278da-104">An advantage to using value types is that they often avoid heap allocations.</span></span>
<span data-ttu-id="278da-105">對應的缺點是它們傳值方式複製。</span><span class="sxs-lookup"><span data-stu-id="278da-105">The corresponding disadvantage is that they are copied by value.</span></span> <span data-ttu-id="278da-106">這些權衡取捨更難最佳化大量的資料運作的演算法。</span><span class="sxs-lookup"><span data-stu-id="278da-106">This tradeoff makes it harder to optimize algorithms that operate on large amounts of data.</span></span> <span data-ttu-id="278da-107">C# 7.2 的新語言功能提供的傳址方式傳遞具有實值類型的語意。</span><span class="sxs-lookup"><span data-stu-id="278da-107">New language features in C# 7.2 provide mechanisms that enable pass-by-reference semantics with value types.</span></span> <span data-ttu-id="278da-108">如果明智地使用這些功能可減少兩個配置和複製作業。</span><span class="sxs-lookup"><span data-stu-id="278da-108">If you use these features wisely you can minimize both allocations and copy operations.</span></span> <span data-ttu-id="278da-109">這篇文章探討這些新功能。</span><span class="sxs-lookup"><span data-stu-id="278da-109">This article explores those new features.</span></span>

<span data-ttu-id="278da-110">大部分本文章中的範例程式碼會示範 C# 7.2 中新增的功能。</span><span class="sxs-lookup"><span data-stu-id="278da-110">Much of the sample code in this article demonstrates features added in C# 7.2.</span></span> <span data-ttu-id="278da-111">若要使用這些功能，您必須將專案設定為在您的專案中使用 C# 7.2 或更新版本。</span><span class="sxs-lookup"><span data-stu-id="278da-111">In order to use those features, you have to configure your project to use C# 7.2 or later in your project.</span></span> <span data-ttu-id="278da-112">您可以使用 Visual Studio，來選取它。</span><span class="sxs-lookup"><span data-stu-id="278da-112">You can use Visual Studio to select it.</span></span> <span data-ttu-id="278da-113">針對每個專案中，選取**專案**功能表，然後從**屬性**。</span><span class="sxs-lookup"><span data-stu-id="278da-113">For each project, select **Project** from the menu, then **Properties**.</span></span> <span data-ttu-id="278da-114">選取**建置**索引標籤上，按一下 **進階**。</span><span class="sxs-lookup"><span data-stu-id="278da-114">Select the **Build** tab and click **Advanced**.</span></span> <span data-ttu-id="278da-115">從該處，您可以設定的語言版本。</span><span class="sxs-lookup"><span data-stu-id="278da-115">From there, you can configure the language version.</span></span> <span data-ttu-id="278da-116">選擇 「 7.2"，或 「 最新 」。</span><span class="sxs-lookup"><span data-stu-id="278da-116">Choose either "7.2", or "latest".</span></span>  <span data-ttu-id="278da-117">您可以編輯或*csproj*檔案，然後加入下列節點：</span><span class="sxs-lookup"><span data-stu-id="278da-117">Or you can edit the *csproj* file and add the following node:</span></span>

```XML
  <PropertyGroup>
    <LangVersion>7.2</LangVersion>
  </PropertyGroup>
```

<span data-ttu-id="278da-118">您可以使用 「 7.2 」 或 「 最新 」 值。</span><span class="sxs-lookup"><span data-stu-id="278da-118">You can use either "7.2" or "latest" for the value.</span></span>

## <a name="specifying-in-parameters"></a><span data-ttu-id="278da-119">指定`in`參數</span><span class="sxs-lookup"><span data-stu-id="278da-119">Specifying `in` parameters</span></span>

<span data-ttu-id="278da-120">將 C# 7.2`in`關鍵字來補充現有`ref`和`out`關鍵字，當您撰寫的傳址方式傳遞引數的方法。</span><span class="sxs-lookup"><span data-stu-id="278da-120">C# 7.2 adds the `in` keyword to complement the existing `ref` and `out` keywords when you write a method that passes arguments by reference.</span></span> <span data-ttu-id="278da-121">`in`關鍵字指定您傳址方式傳遞參數，且所呼叫的方法不會修改傳遞給它的值。</span><span class="sxs-lookup"><span data-stu-id="278da-121">The `in` keyword specifies that you are passing the parameter by reference and the called method does not modify the value passed to it.</span></span> 

<span data-ttu-id="278da-122">此新增可提供完整的詞彙來表達您的設計目的。</span><span class="sxs-lookup"><span data-stu-id="278da-122">This addition provides a full vocabulary to express your design intent.</span></span> <span data-ttu-id="278da-123">實值類型會複製時傳遞至呼叫的方法，當您未指定任何下列修飾詞。</span><span class="sxs-lookup"><span data-stu-id="278da-123">Value types are copied when passed to a called method when you do not specify any of the following modifiers.</span></span> <span data-ttu-id="278da-124">每個這些修飾詞指定的實值類型由參考傳遞，避免複製。</span><span class="sxs-lookup"><span data-stu-id="278da-124">Each of these modifiers specify that a value type is passed by reference, avoiding the copy.</span></span> <span data-ttu-id="278da-125">每個修飾詞表示不同的目的：</span><span class="sxs-lookup"><span data-stu-id="278da-125">Each modifier expresses a different intent:</span></span>

- <span data-ttu-id="278da-126">`out`： 這個方法會設定做為此參數的引數的值。</span><span class="sxs-lookup"><span data-stu-id="278da-126">`out`: This method sets the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="278da-127">`ref`： 這個方法可能會設定做為此參數的引數的值。</span><span class="sxs-lookup"><span data-stu-id="278da-127">`ref`: This method may set the value of the argument used as this parameter.</span></span>
- <span data-ttu-id="278da-128">`in`： 這個方法不會修改引數做為此參數的值。</span><span class="sxs-lookup"><span data-stu-id="278da-128">`in`: This method does not modify the value of the argument used as this parameter.</span></span>

<span data-ttu-id="278da-129">當您將加入`in`修飾詞，以引數傳址方式傳遞，您會宣告您的設計目的是傳遞引數所參考，以避免不必要的複製。</span><span class="sxs-lookup"><span data-stu-id="278da-129">When you add the `in` modifier to pass an argument by reference, you declare your design intent is to pass arguments by reference to avoid unnecessary copying.</span></span> <span data-ttu-id="278da-130">您不想修改做為該引數的物件。</span><span class="sxs-lookup"><span data-stu-id="278da-130">You do not intend to modify the object used as that argument.</span></span> <span data-ttu-id="278da-131">下列程式碼會顯示在 3D 空間中的兩個點之間的距離會計算方法的範例。</span><span class="sxs-lookup"><span data-stu-id="278da-131">The following code shows an example of a method that calculates the distance between two points in 3D space.</span></span> 

[!code-csharp[InArgument](../../samples/csharp/reference-semantics/Program.cs#InArgument "Specifying an In argument")]

<span data-ttu-id="278da-132">引數是兩個結構，其中每個包含三個雙精度浮點數。</span><span class="sxs-lookup"><span data-stu-id="278da-132">The arguments are two structures that each contain three doubles.</span></span> <span data-ttu-id="278da-133">Double 是 8 個位元組，因此每個引數是 24 個位元組。</span><span class="sxs-lookup"><span data-stu-id="278da-133">A double is 8 bytes, so each argument is 24 bytes.</span></span> <span data-ttu-id="278da-134">藉由指定`in`修飾詞，您 4 或 8 個位元組將參考傳遞給這些引數，根據電腦的架構。</span><span class="sxs-lookup"><span data-stu-id="278da-134">By specifying the `in` modifier, you pass 4-byte or 8-byte reference to those arguments, depending on the architecture of the machine.</span></span> <span data-ttu-id="278da-135">大小差異很小，但是當您的應用程式使用許多不同的值在緊密迴圈中呼叫這個方法時，它可以快速地在加入。</span><span class="sxs-lookup"><span data-stu-id="278da-135">The difference in size is small, but it can quickly add up when your application calls this method in a tight loop using many different values.</span></span>
 
<span data-ttu-id="278da-136">`in`修飾詞補充`out`和`ref`以及其他的方式。</span><span class="sxs-lookup"><span data-stu-id="278da-136">The `in` modifier complements `out` and `ref` in other ways as well.</span></span> <span data-ttu-id="278da-137">您無法建立只存在的不同方法的多載`in`，`out`或`ref`。</span><span class="sxs-lookup"><span data-stu-id="278da-137">You cannot create overloads of a method that differ only in the presence of `in`, `out` or `ref`.</span></span> <span data-ttu-id="278da-138">這些新的規則擴充一律為已定義的行為相同`out`和`ref`參數。</span><span class="sxs-lookup"><span data-stu-id="278da-138">These new rules extend the same behavior that had always been defined for `out` and `ref` parameters.</span></span>

<span data-ttu-id="278da-139">`in`修飾詞可能會套用至參數的任何成員： 方法、 委派、 lambda、 區域函式、 索引子、 運算子。</span><span class="sxs-lookup"><span data-stu-id="278da-139">The `in` modifier may be applied to any member that takes parameters: methods, delegates, lambdas, local functions, indexers, operators.</span></span>

<span data-ttu-id="278da-140">不同於`ref`和`out`引數，您可以使用常值或常數的引數的`in`參數。</span><span class="sxs-lookup"><span data-stu-id="278da-140">Unlike `ref` and `out` arguments, you may use literal values or constants for the argument to an `in` parameter.</span></span> <span data-ttu-id="278da-141">此外，不同於`ref`或`out`參數，您不需要套用`in`位於呼叫位置的修飾詞。</span><span class="sxs-lookup"><span data-stu-id="278da-141">Also, unlike a `ref` or `out` parameter, you don't need to apply the `in` modifier at the call site.</span></span> <span data-ttu-id="278da-142">下列程式碼會示範兩個呼叫的例子`CalculateDistance`方法。</span><span class="sxs-lookup"><span data-stu-id="278da-142">The following code shows you two examples of calling the `CalculateDistance` method.</span></span> <span data-ttu-id="278da-143">第一個使用傳址方式傳遞的兩個本機變數。</span><span class="sxs-lookup"><span data-stu-id="278da-143">The first uses two local variables passed by reference.</span></span> <span data-ttu-id="278da-144">第二個包含方法呼叫的過程中建立的暫存變數。</span><span class="sxs-lookup"><span data-stu-id="278da-144">The second includes a temporary variable created as part of the method call.</span></span> 

[!code-csharp[UseInArgument](../../samples/csharp/reference-semantics/Program.cs#UseInArgument "Specifying an In argument")]

<span data-ttu-id="278da-145">有數種方式，在其中編譯器可確保唯讀性質`in`引數會強制執行。</span><span class="sxs-lookup"><span data-stu-id="278da-145">There are several ways in which the compiler ensures that the read-only nature of an `in` argument is enforced.</span></span>  <span data-ttu-id="278da-146">首先，呼叫的方法無法直接指派給`in`參數。</span><span class="sxs-lookup"><span data-stu-id="278da-146">First of all, the called method can't directly assign to an `in` parameter.</span></span> <span data-ttu-id="278da-147">它不能直接指派到的任何欄位`in`參數。</span><span class="sxs-lookup"><span data-stu-id="278da-147">It can't directly assign to any field of an `in` parameter.</span></span> <span data-ttu-id="278da-148">此外，您無法將傳遞`in`任何方法要求 (demand) 的參數`ref`或`out`修飾詞。</span><span class="sxs-lookup"><span data-stu-id="278da-148">In addition, you cannot pass an `in` parameter to any method demanding the `ref` or `out` modifier.</span></span>
<span data-ttu-id="278da-149">編譯器會強制執行的`in`引數是唯讀變數。</span><span class="sxs-lookup"><span data-stu-id="278da-149">The compiler enforces that the `in` argument is a readonly variable.</span></span> <span data-ttu-id="278da-150">您可以呼叫任何使用傳值方式傳遞語意的執行個體方法。</span><span class="sxs-lookup"><span data-stu-id="278da-150">You can call any instance method that uses pass-by-value semantics.</span></span> <span data-ttu-id="278da-151">在這些情況下，一份`in`建立參數。</span><span class="sxs-lookup"><span data-stu-id="278da-151">In those instances, a copy of the `in` parameter is created.</span></span> <span data-ttu-id="278da-152">因為編譯器可能會建立暫存變數，針對任何`in`參數，您也可以指定預設值為任何`in`參數。</span><span class="sxs-lookup"><span data-stu-id="278da-152">Because the compiler can create a temporary variable for any `in` parameter, you can also specify default values for any `in` parameter.</span></span> <span data-ttu-id="278da-153">下列程式碼會使用該值來第二個點的預設值為指定的原點 （0，0 點）：</span><span class="sxs-lookup"><span data-stu-id="278da-153">The follow code uses that to specify the origin (point 0,0) as the default value for the second point:</span></span>

[!code-csharp[InArgumentDefault](../../samples/csharp/reference-semantics/Program.cs#InArgumentDefault "Specifying defaults for an in parameter")]

<span data-ttu-id="278da-154">`in`參數指定也可以搭配參考類型或內建的數字值。</span><span class="sxs-lookup"><span data-stu-id="278da-154">The `in` parameter designation can also be used with reference types or built in numeric values.</span></span> <span data-ttu-id="278da-155">不過，這兩種情況的優點是降到最低。</span><span class="sxs-lookup"><span data-stu-id="278da-155">However, the benefits in both cases are minimal, if any.</span></span>

## <a name="ref-readonly-returns"></a><span data-ttu-id="278da-156">`ref readonly`傳回</span><span class="sxs-lookup"><span data-stu-id="278da-156">`ref readonly` returns</span></span>

<span data-ttu-id="278da-157">您也可能想要實值類型傳址方式傳回，但不允許呼叫端修改該值。</span><span class="sxs-lookup"><span data-stu-id="278da-157">You may also want to return a value type by reference, but disallow the caller from modifying that value.</span></span> <span data-ttu-id="278da-158">使用`ref readonly`修飾詞來表示該設計的意圖。</span><span class="sxs-lookup"><span data-stu-id="278da-158">Use the `ref readonly` modifier to express that design intent.</span></span> <span data-ttu-id="278da-159">它會通知讀取器，所傳回的參考現有的資料，但是不允許修改。</span><span class="sxs-lookup"><span data-stu-id="278da-159">It notifies readers that you are returning a reference to existing data, but not allowing modification.</span></span> 

<span data-ttu-id="278da-160">編譯器會強制執行，而呼叫端無法修改的參考。</span><span class="sxs-lookup"><span data-stu-id="278da-160">The compiler enforces that the caller cannot modify the reference.</span></span> <span data-ttu-id="278da-161">若要直接指派給值的嘗試產生編譯時期錯誤。</span><span class="sxs-lookup"><span data-stu-id="278da-161">Attempts to assign to the value directly generate a compile-time error.</span></span> <span data-ttu-id="278da-162">不過，編譯器無法知道是否任何成員方法會修改該結構的狀態。</span><span class="sxs-lookup"><span data-stu-id="278da-162">However, the compiler cannot know if any member method modifies the state of the struct.</span></span>
<span data-ttu-id="278da-163">若要確保不會修改物件，編譯器會建立複本，並使用該複本的參考，呼叫成員。</span><span class="sxs-lookup"><span data-stu-id="278da-163">To ensure that the object is not modified, the compiler creates a copy and calls member references using that copy.</span></span> <span data-ttu-id="278da-164">任何修改，就該防禦的複本。</span><span class="sxs-lookup"><span data-stu-id="278da-164">Any modifications are to that defensive copy.</span></span> 

<span data-ttu-id="278da-165">可能是，程式庫使用`Point3D`通常會使用整個程式碼的來源。</span><span class="sxs-lookup"><span data-stu-id="278da-165">It's likely that the library using `Point3D` would often use the origin throughout the code.</span></span> <span data-ttu-id="278da-166">每個執行個體建立新的物件在堆疊上。</span><span class="sxs-lookup"><span data-stu-id="278da-166">Every instance creates a new object on the stack.</span></span> <span data-ttu-id="278da-167">它可能會有幫助建立常數和傳址方式傳回。</span><span class="sxs-lookup"><span data-stu-id="278da-167">It may be advantageous to create a constant and return it by reference.</span></span> <span data-ttu-id="278da-168">但是，如果您傳回內部儲存的參考，您可能想要強制呼叫端不能修改參照的儲存體。</span><span class="sxs-lookup"><span data-stu-id="278da-168">But, if you return a reference to internal storage, you may want to enforce that the caller cannot modify the referenced storage.</span></span> <span data-ttu-id="278da-169">下列程式碼會定義傳回的唯讀屬性`readonly ref`至`Point3D`所指定的來源。</span><span class="sxs-lookup"><span data-stu-id="278da-169">The following code defines a read-only property that returns a `readonly ref` to a `Point3D` that specifies the origin.</span></span>

[!code-csharp[OriginReference](../../samples/csharp/reference-semantics/Point3D.cs#OriginReference "Creating a readonly Origin reference")]

<span data-ttu-id="278da-170">建立一份 ref readonly 傳回十分簡單： 只要將它指派給未宣告的變數`ref readonly`修飾詞。</span><span class="sxs-lookup"><span data-stu-id="278da-170">Creating a copy of a ref readonly return is easy: Just assign it to a variable not declared with the `ref readonly` modifier.</span></span> <span data-ttu-id="278da-171">編譯器產生的程式碼將物件複製作業的一部分。</span><span class="sxs-lookup"><span data-stu-id="278da-171">The compiler generates code to copy the object as part of the assignment.</span></span> 

<span data-ttu-id="278da-172">當您指派的變數`ref readonly return`，您可以指定`ref readonly`變數或依值複本的唯讀參考：</span><span class="sxs-lookup"><span data-stu-id="278da-172">When you assign a variable to a `ref readonly return`, you can specify either a `ref readonly` variable, or a by-value copy of the readonly reference:</span></span>

[!code-csharp[AssignRefReadonly](../../samples/csharp/reference-semantics/Program.cs#AssignRefReadonly "Assigning a ref readonly")]

<span data-ttu-id="278da-173">在上述程式碼中的第一個指派會建立一份`Origin`常數，並將複製的指派。</span><span class="sxs-lookup"><span data-stu-id="278da-173">The first assignment in the preceding code makes a copy of the `Origin` constant and assigns that copy.</span></span> <span data-ttu-id="278da-174">第二個指派的參考。</span><span class="sxs-lookup"><span data-stu-id="278da-174">The second assigns a reference.</span></span> <span data-ttu-id="278da-175">請注意，`readonly`修飾詞必須是變數的宣告的一部分。</span><span class="sxs-lookup"><span data-stu-id="278da-175">Notice that the `readonly` modifier must be part of the declaration of the variable.</span></span> <span data-ttu-id="278da-176">無法修改它所參考的參考。</span><span class="sxs-lookup"><span data-stu-id="278da-176">The reference to which it refers cannot be modified.</span></span> <span data-ttu-id="278da-177">若要這樣做的嘗試會導致編譯時期錯誤。</span><span class="sxs-lookup"><span data-stu-id="278da-177">Attempts to do so result in a compile-time error.</span></span>

## <a name="readonly-struct-type"></a><span data-ttu-id="278da-178">`readonly struct` 類型</span><span class="sxs-lookup"><span data-stu-id="278da-178">`readonly struct` type</span></span>

<span data-ttu-id="278da-179">套用`ref readonly`到高流量使用的結構應該就足夠。</span><span class="sxs-lookup"><span data-stu-id="278da-179">Applying `ref readonly` to high-traffic uses of a struct may be sufficient.</span></span>
<span data-ttu-id="278da-180">其他時候，您可能想要建立不可變的結構。</span><span class="sxs-lookup"><span data-stu-id="278da-180">Other times, you may want to create an immutable struct.</span></span> <span data-ttu-id="278da-181">然後您可以一律傳遞唯讀參考。</span><span class="sxs-lookup"><span data-stu-id="278da-181">Then you can always pass by readonly reference.</span></span> <span data-ttu-id="278da-182">當您存取做為結構的方法時，所發生練習移除防衛複製`in`參數。</span><span class="sxs-lookup"><span data-stu-id="278da-182">That practice removes the defensive copies that take place when you access methods of a struct used as an `in` parameter.</span></span>

<span data-ttu-id="278da-183">您可以執行此動作建立`readonly struct`型別。</span><span class="sxs-lookup"><span data-stu-id="278da-183">You can do that by creating a `readonly struct` type.</span></span> <span data-ttu-id="278da-184">您可以加入`readonly`結構宣告修飾詞。</span><span class="sxs-lookup"><span data-stu-id="278da-184">You can add the `readonly` modifier to a struct declaration.</span></span> <span data-ttu-id="278da-185">編譯器會強制執行該結構的所有成員都都`readonly`;`struct`必須是不變。</span><span class="sxs-lookup"><span data-stu-id="278da-185">The compiler enforces that all members of the struct are `readonly`; the `struct` must be immutable.</span></span>

<span data-ttu-id="278da-186">有其他最佳化`readonly struct`。</span><span class="sxs-lookup"><span data-stu-id="278da-186">There are other optimizations for a `readonly struct`.</span></span> <span data-ttu-id="278da-187">您可以使用`in`修飾詞在每個位置其中`readonly struct`是引數。</span><span class="sxs-lookup"><span data-stu-id="278da-187">You can use the `in` modifier at every location where a `readonly struct` is an argument.</span></span> <span data-ttu-id="278da-188">此外，您可以傳回`readonly struct`為`ref return`傳回其存留期超過方法傳回的物件範圍的物件。</span><span class="sxs-lookup"><span data-stu-id="278da-188">In addition, you can return a `readonly struct` as a `ref return` when you are returning an object whose lifetime extends beyond the scope of the method returning the object.</span></span>

<span data-ttu-id="278da-189">最後，編譯器會產生更有效率的程式碼呼叫的成員時`readonly struct`:`this`參考，而不是 的副本收件者，一律為`in`成員方法參考所傳遞的參數。</span><span class="sxs-lookup"><span data-stu-id="278da-189">Finally, the compiler generates more efficient code when you call members of a `readonly struct`: The `this` reference, instead of a copy of the receiver, is always an `in` parameter passed by reference to the member method.</span></span> <span data-ttu-id="278da-190">此最佳化儲存當您使用多個複製`readonly struct`。</span><span class="sxs-lookup"><span data-stu-id="278da-190">This optimization saves more copying when you use a `readonly struct`.</span></span> <span data-ttu-id="278da-191">`Point3D`是很好的候選項目，這項變更。</span><span class="sxs-lookup"><span data-stu-id="278da-191">The `Point3D` is a great candidate for this change.</span></span> <span data-ttu-id="278da-192">下列程式碼顯示更新`ReadonlyPoint3D`結構：</span><span class="sxs-lookup"><span data-stu-id="278da-192">The following code shows an updated `ReadonlyPoint3D` structure:</span></span>

[!code-csharp[ReadonlyOnlyPoint3D](../../samples/csharp/reference-semantics/Point3D.cs#ReadonlyOnlyPoint3D "Defining an immutable structure")]

## <a name="ref-struct-type"></a><span data-ttu-id="278da-193">`ref struct` 類型</span><span class="sxs-lookup"><span data-stu-id="278da-193">`ref struct` type</span></span>

<span data-ttu-id="278da-194">另一項相關的語言功能是能夠宣告必須為堆疊配置的實值類型。</span><span class="sxs-lookup"><span data-stu-id="278da-194">Another related language feature is the ability to declare a value type that must be stack allocated.</span></span> <span data-ttu-id="278da-195">換句話說，這些類型可以永遠不會建立在堆積上以另一類別的成員。</span><span class="sxs-lookup"><span data-stu-id="278da-195">In other words, these types can never be created on the heap as a member of another class.</span></span> <span data-ttu-id="278da-196">這項功能的主要動機是<xref:System.Span%601>和相關的結構。</span><span class="sxs-lookup"><span data-stu-id="278da-196">The primary motivation for this feature was <xref:System.Span%601> and related structures.</span></span> <span data-ttu-id="278da-197"><xref:System.Span%601>可能包含 managed 的指標做為其中一個成員，另一個則是範圍的長度。</span><span class="sxs-lookup"><span data-stu-id="278da-197"><xref:System.Span%601> may contain a managed pointer as one of its members, the other being the length of the span.</span></span> <span data-ttu-id="278da-198">因為 C# 不支援不安全的環境之外的 managed 記憶體的指標，則它是實際稍有不同實作。</span><span class="sxs-lookup"><span data-stu-id="278da-198">It's actually implemented a bit differently because C# doesn't support pointers to managed memory outside of an unsafe context.</span></span> <span data-ttu-id="278da-199">變更指標和長度的任何寫入不是不可部分完成的。</span><span class="sxs-lookup"><span data-stu-id="278da-199">Any write that changes the pointer and the length is not atomic.</span></span> <span data-ttu-id="278da-200">這表示<xref:System.Span%601>會受限於超出範圍的錯誤或其他型別安全違規不限於單一的堆疊框架。</span><span class="sxs-lookup"><span data-stu-id="278da-200">That means a <xref:System.Span%601> would be subject to out of range errors or other type safety violations were it not constrained to a single stack frame.</span></span> <span data-ttu-id="278da-201">此外，將 managed 的指標放置在 GC 堆積上通常會損毀在 JIT 時間。</span><span class="sxs-lookup"><span data-stu-id="278da-201">In addition, putting a managed pointer on the GC heap typically crashes at JIT time.</span></span>

<span data-ttu-id="278da-202">您可能會有類似的需求，建立使用的記憶體使用[ `stackalloc` ](language-reference/keywords/stackalloc.md)或在使用 interop 應用程式開發介面的記憶體。</span><span class="sxs-lookup"><span data-stu-id="278da-202">You may have similar requirements working with memory created using [`stackalloc`](language-reference/keywords/stackalloc.md) or when using memory from interop APIs.</span></span> <span data-ttu-id="278da-203">您可以定義自己`ref struct`這些需求的類型。</span><span class="sxs-lookup"><span data-stu-id="278da-203">You can define your own `ref struct` types for those needs.</span></span> <span data-ttu-id="278da-204">在本文中，您會看到使用範例`Span<T>`為了簡單起見。</span><span class="sxs-lookup"><span data-stu-id="278da-204">In this article, you see examples using `Span<T>` for simplicity.</span></span>

<span data-ttu-id="278da-205">`ref struct`宣告會宣告此類型的結構必須是在堆疊上。</span><span class="sxs-lookup"><span data-stu-id="278da-205">The `ref struct` declaration declares that a struct of this type must be on the stack.</span></span> <span data-ttu-id="278da-206">語言規則可確保安全使用這些型別。</span><span class="sxs-lookup"><span data-stu-id="278da-206">The language rules ensure the safe use of these types.</span></span> <span data-ttu-id="278da-207">其他類型宣告為`ref struct`包含<xref:System.ReadOnlySpan%601>。</span><span class="sxs-lookup"><span data-stu-id="278da-207">Other types declared as `ref struct` include <xref:System.ReadOnlySpan%601>.</span></span> 

<span data-ttu-id="278da-208">保留目標`ref struct`堆疊配置的變數導入了數個規則，編譯器會強制執行所有輸入`ref struct`型別。</span><span class="sxs-lookup"><span data-stu-id="278da-208">The goal of keeping a `ref struct` type as a stack-allocated variable introduces several rules that the compiler enforces for all `ref struct` types.</span></span>

- <span data-ttu-id="278da-209">您無法 box 處理`ref struct`。</span><span class="sxs-lookup"><span data-stu-id="278da-209">You can't box a `ref struct`.</span></span> <span data-ttu-id="278da-210">您無法將指派`ref struct`型別的型別變數`object`， `dynamic`，或任何介面類型。</span><span class="sxs-lookup"><span data-stu-id="278da-210">You cannot assign a `ref struct` type to a variable of type `object`, `dynamic`, or any interface type.</span></span>
- <span data-ttu-id="278da-211">您無法宣告`ref struct`類別或一般結構的成員。</span><span class="sxs-lookup"><span data-stu-id="278da-211">You can't declare a `ref struct` as a member of a class or a normal struct.</span></span>
- <span data-ttu-id="278da-212">您無法宣告區域變數的`ref struct`非同步方法中的型別。</span><span class="sxs-lookup"><span data-stu-id="278da-212">You cannot declare local variables that are `ref struct` types in async methods.</span></span> <span data-ttu-id="278da-213">您也可以在傳回的同步方法中宣告`Task`，`Task<T>`或類似工作的類型。</span><span class="sxs-lookup"><span data-stu-id="278da-213">You can declare them in synchronous methods that return `Task`, `Task<T>` or Task-like types.</span></span>
- <span data-ttu-id="278da-214">您無法宣告`ref struct`迭代器中的本機變數。</span><span class="sxs-lookup"><span data-stu-id="278da-214">You cannot declare `ref struct` local variables in iterators.</span></span>
- <span data-ttu-id="278da-215">您無法擷取`ref struct`lambda 運算式或區域函式中的變數。</span><span class="sxs-lookup"><span data-stu-id="278da-215">You cannot capture `ref struct` variables in lambda expressions or local functions.</span></span>

<span data-ttu-id="278da-216">這些限制可確保您沒有不小心使用`ref struct`無法將它升級為 managed 堆積的方式。</span><span class="sxs-lookup"><span data-stu-id="278da-216">These restrictions ensure that you do not accidentally use a `ref struct` in a manner that could promote it to the managed heap.</span></span>

## <a name="conclusions"></a><span data-ttu-id="278da-217">結論</span><span class="sxs-lookup"><span data-stu-id="278da-217">Conclusions</span></span>

<span data-ttu-id="278da-218">這些增強功能的 C# 語言專為效能關鍵的演算法，可以達到所需的效能非常重要之記憶體配置。</span><span class="sxs-lookup"><span data-stu-id="278da-218">These enhancements to the C# language are designed for performance critical algorithms where memory allocations can be critical to achieving the necessary performance.</span></span> <span data-ttu-id="278da-219">您可能會發現您通常不使用這些功能在您撰寫的程式碼中。</span><span class="sxs-lookup"><span data-stu-id="278da-219">You may find that you don't often use these features in the code you write.</span></span> <span data-ttu-id="278da-220">不過，這些增強功能已採用在.NET Framework 中的許多位置。</span><span class="sxs-lookup"><span data-stu-id="278da-220">However, these enhancements have been adopted in many locations in the .NET Framework.</span></span> <span data-ttu-id="278da-221">當有越來越多的 Api 使用這些功能，您會看到您自己的應用程式的效能改善。</span><span class="sxs-lookup"><span data-stu-id="278da-221">As more and more APIs make use of these features, you'll see the performance of your own applications improve.</span></span>
