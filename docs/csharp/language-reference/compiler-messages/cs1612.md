---
title: 編譯器錯誤 CS1612
ms.date: 07/20/2015
f1_keywords:
- CS1612
helpviewer_keywords:
- CS1612
ms.assetid: ef5db985-030a-4f15-b53f-e92c9297c6a3
ms.openlocfilehash: 80813a587f3d518d3cd3f37a3628ea5ea49fbafd
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/04/2018
ms.locfileid: "33217017"
---
# <a name="compiler-error-cs1612"></a><span data-ttu-id="cc8f4-102">編譯器錯誤 CS1612</span><span class="sxs-lookup"><span data-stu-id="cc8f4-102">Compiler Error CS1612</span></span>
<span data-ttu-id="cc8f4-103">無法修改 'expression' 的傳回值，因為它不是變數</span><span class="sxs-lookup"><span data-stu-id="cc8f4-103">Cannot modify the return value of 'expression' because it is not a variable</span></span>  
  
 <span data-ttu-id="cc8f4-104">嘗試修改因中繼運算式而產生但未儲存在變數中的實值型別。</span><span class="sxs-lookup"><span data-stu-id="cc8f4-104">An attempt was made to modify a value type that is produced as the result of an intermediate expression but is not stored in a variable.</span></span> <span data-ttu-id="cc8f4-105">當您嘗試直接修改泛型集合中的結構時發生此錯誤，如下列範例所示︰</span><span class="sxs-lookup"><span data-stu-id="cc8f4-105">This error can occur when you attempt to directly modify a struct in a generic collection, as shown in the following example:</span></span>  
  
```csharp  
List<myStruct> list = {…};  
list[0].Name = "MyStruct42"; //CS1612  
```  
  
 <span data-ttu-id="cc8f4-106">若要修改結構，請先將它指派給區域變數，並修改變數，然後將變數指派回集合中的項目。</span><span class="sxs-lookup"><span data-stu-id="cc8f4-106">To modify the struct, first assign it to a local variable, modify the variable, then assign the variable back to the item in the collection.</span></span>  
  
```csharp  
List<myStruct> list = {…};  
MyStruct ms = list[0];  
ms.Name = "MyStruct42";  
list[0] = ms;  
```  
  
 <span data-ttu-id="cc8f4-107">因為指派時複製實值型別，所以發生此錯誤。</span><span class="sxs-lookup"><span data-stu-id="cc8f4-107">This error occurs because value types are copied on assignment.</span></span> <span data-ttu-id="cc8f4-108">當您從屬性或索引子擷取實值型別時，會收到物件的複本，而不是物件本身的參考。</span><span class="sxs-lookup"><span data-stu-id="cc8f4-108">When you retrieve a value type from a property or indexer, you are getting a copy of the object, not a reference to the object itself.</span></span> <span data-ttu-id="cc8f4-109">屬性或索引子不會儲存所傳回的複本，因為它們實際上是方法，而不是儲存位置 (變數)。</span><span class="sxs-lookup"><span data-stu-id="cc8f4-109">The copy that is returned is not stored by the property or indexer because they are actually methods, not storage locations (variables).</span></span> <span data-ttu-id="cc8f4-110">您必須先將該複本儲存至所宣告的變數，才能進行修改。</span><span class="sxs-lookup"><span data-stu-id="cc8f4-110">You must store the copy into a variable that you declare before you can modify it.</span></span>  
  
 <span data-ttu-id="cc8f4-111">參考類型未發生錯誤，因為在該情況下的屬性或索引子會傳回現有物件的參考，即儲存位置。</span><span class="sxs-lookup"><span data-stu-id="cc8f4-111">The error does not occur with reference types because a property or indexer in that case returns a reference to an existing object, which is a storage location.</span></span>  
  
 <span data-ttu-id="cc8f4-112">如果您要定義類別或結構，則修改屬性宣告以提供結構成員存取權，即可解決這個錯誤。</span><span class="sxs-lookup"><span data-stu-id="cc8f4-112">If you are defining the class or struct, you can resolve this error by modifying your property declaration to provide access to the members of a struct.</span></span> <span data-ttu-id="cc8f4-113">如果您要撰寫用戶端程式碼，則建立專屬結構執行個體，並修改其欄位，然後將整個結構指派回屬性，即可解決錯誤。</span><span class="sxs-lookup"><span data-stu-id="cc8f4-113">If you are writing client code, you can resolve the error by creating your own instance of the struct, modifying its fields, and then assigning the entire struct back to the property.</span></span> <span data-ttu-id="cc8f4-114">第三個替代方式是您可以將結構變更為類別。</span><span class="sxs-lookup"><span data-stu-id="cc8f4-114">As a third alternative, you can change your struct to a class.</span></span>  
  
## <a name="example"></a><span data-ttu-id="cc8f4-115">範例</span><span class="sxs-lookup"><span data-stu-id="cc8f4-115">Example</span></span>  
 <span data-ttu-id="cc8f4-116">嘗試透過要傳回整個結構之封入類別上的屬性來存取結構成員時，也會發生 CS1612，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="cc8f4-116">CS1612 also occurs when you attempt to access the member of a struct through a property on an enclosing class that is returning the entire struct, as shown in the following example:</span></span>  
  
```csharp  
// CS1612.cs  
using System;  
  
public struct MyStruct  
{  
    public int Width;  
}  
  
public class ListView  
{  
    MyStruct ms;  
    public MyStruct Size  
    {  
        get { return ms; }  
        set { ms = value; }  
    }  
}  
  
public class MyClass  
{  
    public MyClass()  
    {  
        ListView lvi;  
        lvi = new ListView();  
        lvi.Size.Width = 5; // CS1612  
  
        // You can use the following lines instead.  
        // MyStruct ms;  
        // ms.Width = 5;  
        // lvi.Size = ms;  // CS1612  
    }  
  
    public static void Main()   
    {  
        MyClass mc = new MyClass();  
        // Keep the console open in debug mode.  
        Console.WriteLine("Press any key to exit.");  
        Console.ReadKey();     
    }  
}  
```  
  
## <a name="see-also"></a><span data-ttu-id="cc8f4-117">請參閱</span><span class="sxs-lookup"><span data-stu-id="cc8f4-117">See Also</span></span>  
 [<span data-ttu-id="cc8f4-118">結構</span><span class="sxs-lookup"><span data-stu-id="cc8f4-118">Structs</span></span>](../../../csharp/programming-guide/classes-and-structs/structs.md)  
 [<span data-ttu-id="cc8f4-119">實值型別</span><span class="sxs-lookup"><span data-stu-id="cc8f4-119">Value Types</span></span>](../../../csharp/language-reference/keywords/value-types.md)  
 [<span data-ttu-id="cc8f4-120">參考型別</span><span class="sxs-lookup"><span data-stu-id="cc8f4-120">Reference Types</span></span>](../../../csharp/language-reference/keywords/reference-types.md)
