---
title: "模式比對 | C# 指南"
description: "深入了解 C 中的模式比對運算式#"
keywords: .NET, .NET Core, C#
ms.date: 01/24/2017
ms.author: wiwagn
ms.topic: article
ms.prod: .net
ms.technology: devlang-csharp
ms.devlang: csharp
ms.assetid: 1e575c32-2e2b-4425-9dca-7d118f3ed15b
ms.translationtype: Human Translation
ms.sourcegitcommit: a06bd2a17f1d6c7308fa6337c866c1ca2e7281c0
ms.openlocfilehash: c5b1ef4b6de108e2ea3967630e9e37e52a97245c
ms.contentlocale: zh-tw
ms.lasthandoff: 03/13/2017

---

# <a name="pattern-matching"></a><span data-ttu-id="e1f8f-104">模式比對</span><span class="sxs-lookup"><span data-stu-id="e1f8f-104">Pattern Matching</span></span> #

<span data-ttu-id="e1f8f-105">模式可測試某值是否具有特定的「圖形」**，而且當該值有符合的圖形時，可從該值「擷取」**資訊。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-105">Patterns test that a value has a certain *shape*, and can *extract* information from the value when it has the matching shape.</span></span> <span data-ttu-id="e1f8f-106">模式比對會提供更簡潔的語法提供目前所用的演算法使用。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-106">Pattern matching provides more concise syntax for algorithms you already use today.</span></span> <span data-ttu-id="e1f8f-107">您已使用現有的語法建立模式比對演算法。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-107">You already create pattern matching algorithms using existing syntax.</span></span> <span data-ttu-id="e1f8f-108">您撰寫 `if` 或 `switch` 陳述式測試值。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-108">You write `if` or `switch` statements that test values.</span></span> <span data-ttu-id="e1f8f-109">然後，當這些陳述式符合時，使用從該值擷取的資訊。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-109">Then, when those statements match, you extract and use information from that value.</span></span> <span data-ttu-id="e1f8f-110">新的語法項目是您已熟悉的陳述式延伸模組︰`is` 和 `switch`。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-110">The new syntax elements are extensions to statements you are already familiar with: `is` and `switch`.</span></span> <span data-ttu-id="e1f8f-111">這些新的延伸模組結合測試值及擷取該資訊。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-111">These new extensions combine testing a value and extracting that information.</span></span>

<span data-ttu-id="e1f8f-112">在本主題中，我們會探討新的語法，告訴您它如何讓程式碼易讀又簡潔。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-112">In this topic, we'll look at the new syntax to show you how it enables readable, concise code.</span></span> <span data-ttu-id="e1f8f-113">模式比對可使用資料和程式碼分隔的慣用句，不像物件取向的設計，資料和操作資料的方法是緊密結合的。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-113">Pattern matching enables idioms where data and the code are separated, unlike object oriented designs where data and the methods that manipulate them are tightly coupled.</span></span>

<span data-ttu-id="e1f8f-114">為說明這些新的慣用句，讓我們使用模式比對陳述式來處理表示幾何圖形的結構。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-114">To illustrate these new idioms, let's work with structures that represent geometric shapes using pattern matching statements.</span></span> <span data-ttu-id="e1f8f-115">您可能熟悉以物件的執行階段型別為基礎，建置類別階層架構以及建立[虛擬方法和覆寫方法](methods.md#inherited)來自訂物件行為。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-115">You are probably familiar with building class hierarchies and creating [virtual methods and overridden methods](methods.md#inherited) to customize object behavior based on the runtime type of the object.</span></span>

<span data-ttu-id="e1f8f-116">這些技術不是用來處理非以類別階層結構化的資料。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-116">Those techniques aren't possible for data that isn't structured in a class hierarchy.</span></span> <span data-ttu-id="e1f8f-117">當資料和方法分開時，您需要其他工具。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-117">When data and methods are separate, you need other tools.</span></span> <span data-ttu-id="e1f8f-118">新的「模式比對」**建構能用更簡潔的語法來檢視資料，並根據該資料的任何條件來管理控制流程。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-118">The new *pattern matching* constructs enable cleaner syntax to examine data and manipulate control flow based on any condition of that data.</span></span> <span data-ttu-id="e1f8f-119">您已經撰寫測試變數值的 `if` 陳述式和 `switch`。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-119">You already write `if` statements and `switch` that test a variable's value.</span></span> <span data-ttu-id="e1f8f-120">您撰寫了測試變數類型的 `is` 陳述式。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-120">You write `is` statements that test a variable's type.</span></span> <span data-ttu-id="e1f8f-121">「模式比對」**將新功能加 入這些陳述式。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-121">*Pattern matching* adds new capabilities to those statements.</span></span>

<span data-ttu-id="e1f8f-122">在本主題中，您會建置一種方法，計算不同幾何圖形的面積。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-122">In this topic, you'll build a method  that computes the area of different geometric shapes.</span></span> <span data-ttu-id="e1f8f-123">但是，您在執行作業時不必訴諸物件導向技術，也不用建置不同圖形的類別階層。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-123">But, you'll do it without resorting to object oriented techniques and building a class hierarchy for the different shapes.</span></span>
<span data-ttu-id="e1f8f-124">您要改用「模式比對」**。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-124">You'll use *pattern matching* instead.</span></span> <span data-ttu-id="e1f8f-125">為進一步強調我們不使用繼承，您需要將每個圖形變成 `struct` 而非類別。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-125">To further emphasize that we're not using inheritance, you'll make each shape a `struct` instead of a class.</span></span> <span data-ttu-id="e1f8f-126">請注意，不同的 `struct` 型別不能指定一般使用者定義的基底型別，因此繼承不是可行的設計。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-126">Note that different `struct` types cannot specify a common user defined base type, so inheritance is not a possible design.</span></span>
<span data-ttu-id="e1f8f-127">當您瀏覽此範例時，請將此程式碼與它如何結構化為物件階層進行對比。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-127">As you go through this sample, contrast this code with how it would be structured as an object hierarchy.</span></span> <span data-ttu-id="e1f8f-128">當您必須查詢及操作的資料不是類別階層時，模式比對可使用非常簡潔的設計。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-128">When the data you must query and manipulate is not a class hierarchy, pattern matching enables very elegant designs.</span></span>

<span data-ttu-id="e1f8f-129">不是從抽象圖形定義與加入不同的特定圖形類別開始，讓我們改從只定義每個幾何圖形的簡單資料開始︰</span><span class="sxs-lookup"><span data-stu-id="e1f8f-129">Rather than starting with an abstract shape definition and adding different specific shape classes, let's start instead with simple data only definitions for each of the geometric shapes:</span></span>

<span data-ttu-id="e1f8f-130">[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "圖形定義")]</span><span class="sxs-lookup"><span data-stu-id="e1f8f-130">[!code-csharp[ShapeDefinitions](../../samples/csharp/PatternMatching/Shapes.cs#01_ShapeDefinitions "Shape definitions")]</span></span>

<span data-ttu-id="e1f8f-131">讓我們從這些結構撰寫方法，計算某些圖形的面積。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-131">From these structures, let's write a method that computes the area of some shape.</span></span>

## <a name="the-is-type-pattern-expression"></a><span data-ttu-id="e1f8f-132">`is` 型別模式運算式</span><span class="sxs-lookup"><span data-stu-id="e1f8f-132">The `is` type pattern expression</span></span>

<span data-ttu-id="e1f8f-133">C# 7 之前，您需要以一系列的 `if` 和 `is` 陳述式測試每個型別︰</span><span class="sxs-lookup"><span data-stu-id="e1f8f-133">Before C# 7, you'd need to test each type in a series of `if` and `is` statements:</span></span>

<span data-ttu-id="e1f8f-134">[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "傳統型別模式使用是")]</span><span class="sxs-lookup"><span data-stu-id="e1f8f-134">[!code-csharp[ClassicIsExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#02_ClassicIsExpression "Classic type pattern using is")]</span></span>

<span data-ttu-id="e1f8f-135">上述程式碼是「型別模式」**的傳統運算式︰您要測試變數，以判斷其型別並根據該型別採取不同的動作。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-135">That code above is a classic expression of the *type pattern*: You're testing a variable to determine its type and taking a different action based on that type.</span></span>

<span data-ttu-id="e1f8f-136">如果測試成功，使用 `is` 運算式的延伸模組來指派變數，此程式碼會變得更簡單：</span><span class="sxs-lookup"><span data-stu-id="e1f8f-136">This code becomes simpler using extensions to the `is` expression to assign a variable if the test succeeds:</span></span>

<span data-ttu-id="e1f8f-137">[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "是模式運算式")]</span><span class="sxs-lookup"><span data-stu-id="e1f8f-137">[!code-csharp[IsPatternExpression](../../samples/csharp/PatternMatching/GeometricUtilities.cs#03_IsPatternExpression "is pattern expression")]</span></span>

<span data-ttu-id="e1f8f-138">在此更新的版本中，`is` 運算式會測試變數並將它指派給適當型別的新變數。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-138">In this updated version, the `is` expression both tests the variable and assigns it to a new variable of the proper type.</span></span> <span data-ttu-id="e1f8f-139">另請注意，此版本包含 `Rectangle` 型別，它是 `struct`。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-139">Also, notice that this version includes the `Rectangle` type, which is a `struct`.</span></span> <span data-ttu-id="e1f8f-140">新的 `is` 運算式可搭配實值型別以及參考型別。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-140">The new `is` expression works with value types as well as reference types.</span></span>

<span data-ttu-id="e1f8f-141">模式比對運算式的語言規則可協助您避免誤用比對運算式的結果。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-141">Language rules for pattern matching expressions help you avoid misusing the results of a match expression.</span></span> <span data-ttu-id="e1f8f-142">在上例中，當個別的模式比對運算式有 `true` 結果時，變數 `s`、 `c` 和 `r` 只能在範圍內且要確實指派。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-142">In the example above, the variables `s`,  `c`, and `r` are only in scope and definitely assigned when the respective pattern match expressions have `true` results.</span></span> <span data-ttu-id="e1f8f-143">如果您嘗試在另一個位置使用任一變數，您的程式碼就會產生編譯器錯誤。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-143">If you try to use either variable in another location, your code generates compiler errors.</span></span>

<span data-ttu-id="e1f8f-144">讓我們仔細檢查這兩項規則，就從範圍開始。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-144">Let's examine both of those rules in detail, beginning with scope.</span></span> <span data-ttu-id="e1f8f-145">變數 `c` 只有在第一個 `if` 陳述式的 `else` 分支中時才在範圍內。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-145">The variable `c` is in scope only in the `else` branch of the first `if` statement.</span></span> <span data-ttu-id="e1f8f-146">`s` 變數位於 `ComputeArea` 方法的範圍中。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-146">The variable `s` is in scope in the method `ComputeArea`.</span></span> <span data-ttu-id="e1f8f-147">這是因為 `if` 陳述式的每個分支都會建立變數的個別範圍。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-147">That's because each branch of an `if` statement establishes a separate scope for variables.</span></span> <span data-ttu-id="e1f8f-148">不過，`if` 陳述式本身並不會。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-148">However, the `if` statement itself does not.</span></span> <span data-ttu-id="e1f8f-149">這表示在 `if` 陳述式中宣告的變數和 `if` 陳述式 (本例中的方法) 是在相同範圍中。此行為不是針對模式比對，但卻是變數範圍以及 `if` 和 `else` 陳述式的定義行為。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-149">That means variables declared in the `if` statement are in the same scope as the `if` statement (the method in this case.) This behavior is not specific to pattern matching, but is the defined behavior for variable scopes and `if` and `else` statements.</span></span>

<span data-ttu-id="e1f8f-150">當個別的 `if` 陳述式為 true 時會指派變數 `c` 和 `s`，因為 true 機制時會明確指派。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-150">The variables `c` and `s` are assigned when the respective `if` statements are true because of the definitely assigned when true mechanism.</span></span>

> [!TIP]
> <span data-ttu-id="e1f8f-151">本主題中的範例使用建議的建構，其模式比對 `is` 運算式會在 `if` 陳述式的 `true` 分支中明確指派比對變數。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-151">The samples in this topic use the recommended construct where a pattern match `is` expression definitely assigns the match variable in the `true` branch of the `if` statement.</span></span>
> <span data-ttu-id="e1f8f-152">您可以說明只在 `false` 分支中明確指派 `if (!(shape is Square s))` 和變數 `s`，以回復邏輯。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-152">You could reverse the logic by saying `if (!(shape is Square s))` and the variable `s` would be definitely assigned only in the `false` branch.</span></span> <span data-ttu-id="e1f8f-153">雖然這是有效的 C#，但不建議，因為遵循邏輯會更令人困惑。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-153">While this is valid C#, it is not recommended because it is more confusing to follow the logic.</span></span>

<span data-ttu-id="e1f8f-154">這些規則表示您不太可能在不符合此模式時，不小心存取模式比對運算式的結果。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-154">These rules mean that you are unlikely to accidentally access the result of a pattern match expression when that pattern was not met.</span></span>

## <a name="using-pattern-matching-switch-statements"></a><span data-ttu-id="e1f8f-155">使用模式比對 `switch` 陳述式</span><span class="sxs-lookup"><span data-stu-id="e1f8f-155">Using pattern matching `switch` statements</span></span>

<span data-ttu-id="e1f8f-156">日積月累下，您可能需要支援其他的圖形類型。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-156">As time goes on, you may need to support other shape types.</span></span> <span data-ttu-id="e1f8f-157">隨著要測試的條件數目增長，您會發現使用 `is` 模式比對運算式會變得很麻煩。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-157">As the number of conditions you are testing grows, you'll find that using the `is` pattern matching expressions can become cumbersome.</span></span> <span data-ttu-id="e1f8f-158">除了每個要檢查的型別都需要 `if` 陳述式，如果輸入符合某單一型別，`is` 運算式還會限於測試。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-158">In addition to requiring `if` statements on each type you want to check, the `is` expressions are limited to testing if the input matches a single type.</span></span> <span data-ttu-id="e1f8f-159">在此情況下，您會發現 `switch` 模式比對運算式會是較好的選擇。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-159">In this case, you'll find that the `switch` pattern matching expressions becomes a better choice.</span></span> 

<span data-ttu-id="e1f8f-160">傳統 `switch` 陳述式以前是模式運算式︰它支援常數模式。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-160">The traditional `switch` statement was a pattern expression: it supported the constant pattern.</span></span>
<span data-ttu-id="e1f8f-161">您可以比較變數和 `case` 陳述式使用的常數︰</span><span class="sxs-lookup"><span data-stu-id="e1f8f-161">You could compare a variable to any constant used in a `case` statement:</span></span>

<span data-ttu-id="e1f8f-162">[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "傳統 switch 陳述式")]</span><span class="sxs-lookup"><span data-stu-id="e1f8f-162">[!code-csharp[ClassicSwitch](../../samples/csharp/PatternMatching/GeometricUtilities.cs#04_ClassicSwitch "Classic switch statement")]</span></span>

<span data-ttu-id="e1f8f-163">`switch` 陳述式以前支援的唯一模式是常數模式。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-163">The only pattern supported by the `switch` statement was the constant pattern.</span></span> <span data-ttu-id="e1f8f-164">以前更限制為數值型別和 `string` 型別。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-164">It was further limited to numeric types and the `string` type.</span></span>
<span data-ttu-id="e1f8f-165">這些限制現已移除，而且您可以使用型別模式撰寫 `switch` 陳述式︰</span><span class="sxs-lookup"><span data-stu-id="e1f8f-165">Those restrictions have been removed, and you can now write a `switch` statement using the type pattern:</span></span>

<span data-ttu-id="e1f8f-166">[!code-csharp[切換型別模式](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "使用 `switch` 運算式計算")]</span><span class="sxs-lookup"><span data-stu-id="e1f8f-166">[!code-csharp[Switch Type Pattern](../../samples/csharp/PatternMatching/GeometricUtilities.cs#05_SwitchTypePattern "Compute with `switch` expression")]</span></span>

<span data-ttu-id="e1f8f-167">模式比對 `switch` 陳述式使用開發人員熟悉的語法，而開發人員之前使用傳統的 C 樣式 `switch` 陳述式。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-167">The pattern matching `switch` statement uses familiar syntax to developers who have used the traditional C-style `switch` statement.</span></span> <span data-ttu-id="e1f8f-168">已評估每個 `case`，且執行符合輸入變數的條件下程式碼。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-168">Each `case` is evaluated and the code beneath the condition that matches the input variable is executed.</span></span> <span data-ttu-id="e1f8f-169">程式碼無法從一個 case 運算式「繼續」執行到下一個，`case` 陳述式的語法需要每個 `case` 以 `break`、`return` 或 `goto` 結束。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-169">Code execution cannot "fall through" from one case expression to the next; the syntax of the `case` statement requires that each `case` end with a `break`, `return`, or `goto`.</span></span>

> [!NOTE]
> <span data-ttu-id="e1f8f-170">`goto` 陳述式跳至另一個標籤只有針對常數模式才有效，即傳統的 switch 陳述式。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-170">The `goto` statements to jump to another label are valid only for the constant pattern, the classic switch statement.</span></span>

<span data-ttu-id="e1f8f-171">具有控管 `switch` 陳述式的新重要規則。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-171">There are important new rules governing the `switch` statement.</span></span> <span data-ttu-id="e1f8f-172">`switch` 運算式已移除變數型別限制。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-172">The restrictions on the type of the variable in the `switch` expression have been removed.</span></span>
<span data-ttu-id="e1f8f-173">可使用任何型別，例如本例的 `object`。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-173">Any type, such as `object` in this example, may be used.</span></span> <span data-ttu-id="e1f8f-174">Case 運算式不再限於常數值。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-174">The case expressions are no longer limited to constant values.</span></span> <span data-ttu-id="e1f8f-175">移除該限制表示重新排列 `switch` 區段可能會變更程式的行為。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-175">Removing that limitation means that reordering `switch` sections may change a program's behavior.</span></span>

<span data-ttu-id="e1f8f-176">當限於常數值時，只會有一個 `case` 標籤符合 `switch` 運算式的值。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-176">When limited to constant values, no more than one `case` label could match the value of the `switch` expression.</span></span> <span data-ttu-id="e1f8f-177">給合每一個 `switch` 區段絕不繼續到下個區段的規則，它跟著的 `switch` 區段可能會以任何順序重新排列，但不影響行為。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-177">Combine that with the rule that every `switch` section must not fall through to the next section, and it followed that the `switch` sections could be rearranged in any order without affecting behavior.</span></span>
<span data-ttu-id="e1f8f-178">現在，使用更一般化的 `switch` 運算式，順序對每個區段都很重要。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-178">Now, with more generalized `switch` expressions, the order of each section matters.</span></span> <span data-ttu-id="e1f8f-179">`switch` 運算式會以文字順序進行評估。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-179">The `switch` expressions are evaluated in textual order.</span></span> <span data-ttu-id="e1f8f-180">執行會傳送至符合 `switch` 運算式的第一個 `switch` 標籤。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-180">Execution transfers to the first `switch` label that matches the `switch` expression.</span></span>  
<span data-ttu-id="e1f8f-181">請注意，只有無任何其他狀況標籤符合時才會執行 `default` 狀況。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-181">Note that the `default` case will only be executed if no other case labels match.</span></span> <span data-ttu-id="e1f8f-182">無論其文字順序為何，`default` 狀況都是最後才評估。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-182">The `default` case is evaluated last, regardless of its textual order.</span></span> <span data-ttu-id="e1f8f-183">如果沒有任何 `default` 狀況，且無其他 `case` 陳述式相符，就繼續執行 `switch` 陳述式後面的陳述式。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-183">If there is no `default` case, and none of the other `case` statements match, execution continues at the statement following the `switch` statement.</span></span> <span data-ttu-id="e1f8f-184">不執行任何 `case` 標籤程式碼。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-184">None of the `case` labels code is executed.</span></span>

## <a name="when-clauses-in-case-expressions"></a><span data-ttu-id="e1f8f-185">`case` 運算式中的 `when` 子句</span><span class="sxs-lookup"><span data-stu-id="e1f8f-185">`when` clauses in `case` expressions</span></span>

<span data-ttu-id="e1f8f-186">對 `case` 標籤使用 `when` 子句，可為面積為 0 的圖形建立特殊案例。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-186">You can make special cases for those shapes that have 0 area by using a `when` clause on the `case` label.</span></span> <span data-ttu-id="e1f8f-187">邊長為 0 的正方形或半徑為 0 的圓形，面積皆為 0。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-187">A square with a side length of 0, or a circle with a radius of 0 has a 0 area.</span></span> <span data-ttu-id="e1f8f-188">您可以對 `case` 標籤使用 `when` 子句來指定該條件︰</span><span class="sxs-lookup"><span data-stu-id="e1f8f-188">You specify that condition using a `when` clause on the `case` label:</span></span>  

<span data-ttu-id="e1f8f-189">[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "計算面積為 0 的圖形")]</span><span class="sxs-lookup"><span data-stu-id="e1f8f-189">[!code-csharp[ComputeDegenerateShapes](../../samples/csharp/PatternMatching/GeometricUtilities.cs#07_ComputeDegenerateShapes "Compute shapes with 0 area")]</span></span>

<span data-ttu-id="e1f8f-190">這項變更會示範新語法的幾個重點。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-190">This change demonstrates a few important points about the new syntax.</span></span> <span data-ttu-id="e1f8f-191">首先，多個 `case` 標籤可以套用到一個 `switch` 區段。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-191">First, multiple `case` labels can be applied to one `switch` section.</span></span> <span data-ttu-id="e1f8f-192">當這些標籤的任何一個為 `true` 時，會執行陳述式區塊。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-192">The statement block is executed when any of those labels is `true`.</span></span> <span data-ttu-id="e1f8f-193">在此情況下，如果 `switch` 運算式是面積為 0 的圓形或正方形，則方法會傳回常數 0。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-193">In this instance, if the `switch` expression is either a circle or a square with 0 area, the method returns the constant 0.</span></span>

<span data-ttu-id="e1f8f-194">本例介紹第一個 `switch` 區塊中，兩個 `case` 標籤中的兩個不同變數。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-194">This example introduces two different variables in the two `case` labels for the first `switch` block.</span></span> <span data-ttu-id="e1f8f-195">請注意，`switch` 區塊中的陳述式不使用變數 `c` (圓形) 或 `s` (正方形)。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-195">Notice that the statements in this `switch` block do not use either the variables `c` (for the circle) or `s` (for the square).</span></span>
<span data-ttu-id="e1f8f-196">這些變數都不會明確指派在這個 `switch` 區塊中。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-196">Neither of those variables is definitely assigned in this `switch` block.</span></span>
<span data-ttu-id="e1f8f-197">如果符合任一種狀況，顯然指派了其中一個變數。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-197">If either of these cases match, clearly one of the variables has been assigned.</span></span>
<span data-ttu-id="e1f8f-198">不過，在編譯時期不可能分辨「哪個」**已指派，因為在執行階段任何一種情況都可能符合。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-198">However, it is impossible to tell *which* has been assigned at compile-time, because either case could match at runtime.</span></span> <span data-ttu-id="e1f8f-199">因此，大多數時候當您在同一個區塊使用多個 `case` 標籤時，您不會在 `case` 陳述式中引入新的變數，或只會在 `when` 子句中使用變數。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-199">For that reason, most times when you use multiple `case` labels for the same block, you won't introduce a new variable in the `case` statement, or you will only use the variable in the `when` clause.</span></span>

<span data-ttu-id="e1f8f-200">新增這些面積為 0 的圖形後，讓我們再新增幾個圖形型別︰矩形和三角形︰</span><span class="sxs-lookup"><span data-stu-id="e1f8f-200">Having added those shapes with 0 area, let's add a couple more shape types: a rectangle and a triangle:</span></span>

<span data-ttu-id="e1f8f-201">[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "增矩形和三角形")]</span><span class="sxs-lookup"><span data-stu-id="e1f8f-201">[!code-csharp[AddRectangleAndTriangle](../../samples/csharp/PatternMatching/GeometricUtilities.cs#09_AddRectangleAndTriangle "Add rectangle and triangle")]</span></span>

 <span data-ttu-id="e1f8f-202">這組變更會新增退化狀況的 `case` 標籤，以及每個新圖形的標籤和區塊。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-202">This set of changes adds `case` labels for the degenerate case, and labels and blocks for each of the new shapes.</span></span> 

<span data-ttu-id="e1f8f-203">最後，您可以新增 `null` 狀況，以確保引數不是 `null`：</span><span class="sxs-lookup"><span data-stu-id="e1f8f-203">Finally, you can add a `null` case to ensure the argument is not `null`:</span></span>

<span data-ttu-id="e1f8f-204">[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "新增 null 狀況")]</span><span class="sxs-lookup"><span data-stu-id="e1f8f-204">[!code-csharp[NullCase](../../samples/csharp/PatternMatching/GeometricUtilities.cs#10_NullCase "Add null case")]</span></span>

<span data-ttu-id="e1f8f-205">`null` 模式的特殊狀況很有趣，因為常數 `null` 沒有型別，但可以轉換成任何參考型別或可為 Null 的型別。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-205">The special case for the `null` pattern is interesting because the constant `null` does not have a type, but can be converted to any reference type or nullable type.</span></span> 

## <a name="conclusions"></a><span data-ttu-id="e1f8f-206">結論</span><span class="sxs-lookup"><span data-stu-id="e1f8f-206">Conclusions</span></span>

<span data-ttu-id="e1f8f-207">「模式比對建構」**可讓您輕鬆管理不依繼承階層而關聯之不同變數和型別的控制流程。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-207">*Pattern Matching constructs* enable you to easily manage control flow among different variables and types that are not related by an inheritance hierarchy.</span></span> <span data-ttu-id="e1f8f-208">您也可以控制邏輯，在變數上使用任何測試條件。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-208">You can also control logic to use any condition you test on the variable.</span></span> <span data-ttu-id="e1f8f-209">在您建置分散程度更高的應用程式時，即資料和操作資料的方法是分開的，它可讓您使用最常用的模式和慣用句。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-209">It enables patterns and idioms that you'll need more often as you build more distributed applications, where data and the methods that manipulate that data are separate.</span></span> <span data-ttu-id="e1f8f-210">您會發現本例使用的圖形結構不包含任何方法，只有唯讀屬性。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-210">You'll notice that the shape structs used in this sample do not contain any methods, just read-only properties.</span></span>
<span data-ttu-id="e1f8f-211">模式比對適用於任何資料型別。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-211">Pattern Matching works with any data type.</span></span> <span data-ttu-id="e1f8f-212">您會撰寫檢查物件的運算式，並根據這些條件決定控制流程。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-212">You write expressions that examine the object, and make control flow decisions based on those conditions.</span></span>

<span data-ttu-id="e1f8f-213">比較此範例的程式碼與遵循建立抽象 `Shape` 類別階層的設計，以及各有其虛擬方法以實作計算面積的特定衍生圖形。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-213">Compare the code from this sample with the design that would follow from creating a class hierarchy for an abstract `Shape` and specific derived shapes each with their own implementation of a virtual method to calculate the area.</span></span> <span data-ttu-id="e1f8f-214">當您要處理資料，而且想要分別考量資料儲存和行為時，您會經常發現模式比對運算式是非常有用的工具。</span><span class="sxs-lookup"><span data-stu-id="e1f8f-214">You'll often find that pattern matching expressions can be a very useful tool when you are working with data and want to separate the data storage concerns from the behavior concerns.</span></span>


