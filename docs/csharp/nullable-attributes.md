---
title: 使用定義對空值的預期的屬性升級可空引用類型的 API
description: 瞭解如何使用描述性屬性「允許無效」、可能無效、無虛無等來完全描述 API 的空狀態。
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: 7f78bd0224f93b4b9dcc2b9d4e3577db06497907
ms.sourcegitcommit: c91110ef6ee3fedb591f3d628dc17739c4a7071e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/15/2020
ms.locfileid: "81389590"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a><span data-ttu-id="726be-103">更新函式庫以使用空引言類型,並將無效規則傳達給呼叫者</span><span class="sxs-lookup"><span data-stu-id="726be-103">Update libraries to use nullable reference types and communicate nullable rules to callers</span></span>

<span data-ttu-id="726be-104">新增[可取消的引用類型](nullable-references.md)意味著您`null`可以聲明 是否允許或預期每個變數的值。</span><span class="sxs-lookup"><span data-stu-id="726be-104">The addition of [nullable reference types](nullable-references.md) means you can declare whether or not a `null` value is allowed or expected for every variable.</span></span> <span data-ttu-id="726be-105">此外`AllowNull`,還可以應用許多屬性: `DisallowNull` `MaybeNull`、 `NotNull` `NotNullWhen`、 `MaybeNullWhen` `NotNullIfNotNull` 、 、 、 、 、 、 、 、 、 、 、 和, 並完全描述參數和返回值的 null 狀態。</span><span class="sxs-lookup"><span data-stu-id="726be-105">In addition, you can apply a number of attributes: `AllowNull`, `DisallowNull`, `MaybeNull`, `NotNull`, `NotNullWhen`, `MaybeNullWhen`, and `NotNullIfNotNull` to completely describe the null states of argument and return values.</span></span> <span data-ttu-id="726be-106">在編寫代碼時,這提供了很好的體驗。</span><span class="sxs-lookup"><span data-stu-id="726be-106">That provides a great experience as you write code.</span></span> <span data-ttu-id="726be-107">如果非空變數可能設置為`null`,則會收到警告。</span><span class="sxs-lookup"><span data-stu-id="726be-107">You get warnings if a non-nullable variable might be set to `null`.</span></span> <span data-ttu-id="726be-108">如果在取消引用之前未選中空變數,則會收到警告。</span><span class="sxs-lookup"><span data-stu-id="726be-108">You get warnings if a nullable variable isn't null-checked before you dereference it.</span></span> <span data-ttu-id="726be-109">更新庫可能需要一些時間,但回報是值得的。</span><span class="sxs-lookup"><span data-stu-id="726be-109">Updating your libraries can take time, but the payoffs are worth it.</span></span> <span data-ttu-id="726be-110">您向編譯器提供的關於*何時*允許`null`或禁止 值的資訊越多,API 使用者得到的更好警告。</span><span class="sxs-lookup"><span data-stu-id="726be-110">The more information you provide to the compiler about *when* a `null` value is allowed or prohibited, the better warnings users of your API will get.</span></span> <span data-ttu-id="726be-111">讓我們從一個熟悉的例子開始。</span><span class="sxs-lookup"><span data-stu-id="726be-111">Let's start with a familiar example.</span></span> <span data-ttu-id="726be-112">假設您的函式庫有以下 API 來檢索資源字串:</span><span class="sxs-lookup"><span data-stu-id="726be-112">Imagine your library has the following API to retrieve a resource string:</span></span>

```csharp
bool TryGetMessage(string key, out string message)
```

<span data-ttu-id="726be-113">前面的範例遵循 .NET`Try*`中熟悉的模式。</span><span class="sxs-lookup"><span data-stu-id="726be-113">The preceding example follows the familiar `Try*` pattern in .NET.</span></span> <span data-ttu-id="726be-114">此 API 有兩個引用`key`參數:`message`與 參數 。</span><span class="sxs-lookup"><span data-stu-id="726be-114">There are two reference arguments for this API: the `key` and the `message` parameter.</span></span> <span data-ttu-id="726be-115">此 API 有以下與這些參數的不合法的規則:</span><span class="sxs-lookup"><span data-stu-id="726be-115">This API has the following rules relating to the nullness of these arguments:</span></span>

- <span data-ttu-id="726be-116">調用方不應作為`null``key`的參數傳遞。</span><span class="sxs-lookup"><span data-stu-id="726be-116">Callers shouldn't pass `null` as the argument for `key`.</span></span>
- <span data-ttu-id="726be-117">調用方可以傳遞其值為`null``message`的變數作為 的 參數。</span><span class="sxs-lookup"><span data-stu-id="726be-117">Callers can pass a variable whose value is `null` as the argument for `message`.</span></span>
- <span data-ttu-id="726be-118">如果`TryGetMessage`方法`true`返回`message`,則 的值不為空。</span><span class="sxs-lookup"><span data-stu-id="726be-118">If the `TryGetMessage` method returns `true`, the value of `message` isn't null.</span></span> <span data-ttu-id="726be-119">如果傳回值`false,``message`為 (及其 null 狀態) 的值為 null。</span><span class="sxs-lookup"><span data-stu-id="726be-119">If the return value is `false,` the value of `message` (and its null state) is null.</span></span>

<span data-ttu-id="726be-120">的規則`key`可以通過變數類型完全表示`key`: 應該是一個不可空的引用類型。</span><span class="sxs-lookup"><span data-stu-id="726be-120">The rule for `key` can be completely expressed by the variable type: `key` should be a non-nullable reference type.</span></span> <span data-ttu-id="726be-121">參數`message`更為複雜。</span><span class="sxs-lookup"><span data-stu-id="726be-121">The `message` parameter is more complex.</span></span> <span data-ttu-id="726be-122">它允許`null`作為參數,但保證,在成功時,`out`該 參數不為空。</span><span class="sxs-lookup"><span data-stu-id="726be-122">It allows `null` as the argument, but guarantees that, on success, that `out` argument isn't null.</span></span> <span data-ttu-id="726be-123">對於這些方案,您需要更豐富的詞彙來描述期望值。</span><span class="sxs-lookup"><span data-stu-id="726be-123">For these scenarios, you need a richer vocabulary to describe the expectations.</span></span>

<span data-ttu-id="726be-124">更新庫以進行空引用需要的不僅僅是灑`?`灑某些變數和類型名稱。</span><span class="sxs-lookup"><span data-stu-id="726be-124">Updating your library for nullable references requires more than sprinkling `?` on some of the variables and type names.</span></span> <span data-ttu-id="726be-125">前面的範例表明,您需要檢查 API 並考慮您對每個輸入參數的期望。</span><span class="sxs-lookup"><span data-stu-id="726be-125">The preceding example shows that you need to examine your APIs and consider your expectations for each input argument.</span></span> <span data-ttu-id="726be-126">考慮返回值的保證,以及方法返回時`out`的`ref`任何 或參數。</span><span class="sxs-lookup"><span data-stu-id="726be-126">Consider the guarantees for the return value, and any `out` or `ref` arguments upon the method's return.</span></span> <span data-ttu-id="726be-127">然後,將這些規則傳達給編譯器,當調用方不遵守這些規則時,編譯器將提供警告。</span><span class="sxs-lookup"><span data-stu-id="726be-127">Then communicate those rules to the compiler, and the compiler will provide warnings when callers don't abide by those rules.</span></span>

<span data-ttu-id="726be-128">這項工作需要時間。</span><span class="sxs-lookup"><span data-stu-id="726be-128">This work takes time.</span></span> <span data-ttu-id="726be-129">讓我們從使庫或應用程式具有空感知性的策略開始,同時平衡其他要求和可交付成果。</span><span class="sxs-lookup"><span data-stu-id="726be-129">Let's start with strategies to make your library or application nullable-aware, while balancing other requirements and deliverables.</span></span> <span data-ttu-id="726be-130">您將看到如何平衡支援空引用類型的持續開發。</span><span class="sxs-lookup"><span data-stu-id="726be-130">You'll see how to balance ongoing development enabling nullable reference types.</span></span> <span data-ttu-id="726be-131">您將瞭解泛型類型定義的挑戰。</span><span class="sxs-lookup"><span data-stu-id="726be-131">You'll learn challenges for generic type definitions.</span></span> <span data-ttu-id="726be-132">您將學習應用屬性來描述單個 API 的預置和後置條件。</span><span class="sxs-lookup"><span data-stu-id="726be-132">You'll learn to apply attributes to describe pre- and post-conditions on individual APIs.</span></span>

## <a name="choose-a-strategy-for-nullable-reference-types"></a><span data-ttu-id="726be-133">選擇空白的引言型態</span><span class="sxs-lookup"><span data-stu-id="726be-133">Choose a strategy for nullable reference types</span></span>

<span data-ttu-id="726be-134">第一種選擇是預設是可空引用類型應打開還是關閉。</span><span class="sxs-lookup"><span data-stu-id="726be-134">The first choice is whether nullable reference types should be on or off by default.</span></span> <span data-ttu-id="726be-135">您有兩種策略:</span><span class="sxs-lookup"><span data-stu-id="726be-135">You have two strategies:</span></span>

- <span data-ttu-id="726be-136">為整個項目啟用空引用類型,並在未準備好的代碼中禁用它。</span><span class="sxs-lookup"><span data-stu-id="726be-136">Enable nullable reference types for the entire project, and disable it in code that's not ready.</span></span>
- <span data-ttu-id="726be-137">僅為已為空引用類型提供已註明的代碼的可啟用引用類型。</span><span class="sxs-lookup"><span data-stu-id="726be-137">Only enable nullable reference types for code that's been annotated for nullable reference types.</span></span>

<span data-ttu-id="726be-138">當您為庫更新其他要素以進行空引用類型更新時,第一個策略效果最佳。</span><span class="sxs-lookup"><span data-stu-id="726be-138">The first strategy works best when you're adding other features to the library as you update it for nullable reference types.</span></span> <span data-ttu-id="726be-139">所有新開發都是空意識的。</span><span class="sxs-lookup"><span data-stu-id="726be-139">All new development is nullable aware.</span></span> <span data-ttu-id="726be-140">更新現有代碼時,在這些類中啟用空引用類型。</span><span class="sxs-lookup"><span data-stu-id="726be-140">As you update existing code, you enable nullable reference types in those classes.</span></span>

<span data-ttu-id="726be-141">遵循第一個策略,執行以下操作:</span><span class="sxs-lookup"><span data-stu-id="726be-141">Following this first strategy, you do the following:</span></span>

1. <span data-ttu-id="726be-142">通過將元素添加到`<Nullable>enable</Nullable>`*csproj*檔,為整個項目啟用可無效的引用類型。</span><span class="sxs-lookup"><span data-stu-id="726be-142">Enable nullable reference types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="726be-143">將`#nullable disable`實用方案添加到專案中的每個源檔。</span><span class="sxs-lookup"><span data-stu-id="726be-143">Add the `#nullable disable` pragma to every source file in your project.</span></span>
1. <span data-ttu-id="726be-144">處理每個檔時,請刪除雜注並解決任何警告。</span><span class="sxs-lookup"><span data-stu-id="726be-144">As you work on each file, remove the pragma and address any warnings.</span></span>

<span data-ttu-id="726be-145">第一個策略具有更多的前期工作,以將實用處理添加到每個檔。</span><span class="sxs-lookup"><span data-stu-id="726be-145">This first strategy has more up-front work to add the pragma to every file.</span></span> <span data-ttu-id="726be-146">優點是,添加到專案的每個新代碼檔都將為空。</span><span class="sxs-lookup"><span data-stu-id="726be-146">The advantage is that every new code file added to the project will be nullable enabled.</span></span> <span data-ttu-id="726be-147">任何新工作都將是可撤銷的;只能更新現有代碼。</span><span class="sxs-lookup"><span data-stu-id="726be-147">Any new work will be nullable aware; only existing code must be updated.</span></span>

<span data-ttu-id="726be-148">如果庫總體穩定,第二種策略效果更好,開發的重點是採用可無引用類型。</span><span class="sxs-lookup"><span data-stu-id="726be-148">The second strategy works better if the library is generally stable, and the main focus of the development is to adopt nullable reference types.</span></span> <span data-ttu-id="726be-149">在對 API 進行編號時,打開可取消的引用類型。</span><span class="sxs-lookup"><span data-stu-id="726be-149">You turn on nullable reference types as you annotate APIs.</span></span> <span data-ttu-id="726be-150">完成後,將對整個項目啟用空引用類型。</span><span class="sxs-lookup"><span data-stu-id="726be-150">When you've finished, you enable nullable reference types for the entire project.</span></span>

<span data-ttu-id="726be-151">遵循第二個策略,您可以執行以下操作:</span><span class="sxs-lookup"><span data-stu-id="726be-151">Following this second strategy you do the following:</span></span>

1. <span data-ttu-id="726be-152">將`#nullable enable`雜注添加到要使空感知的檔中。</span><span class="sxs-lookup"><span data-stu-id="726be-152">Add the `#nullable enable` pragma to the file you want to make nullable aware.</span></span>
1. <span data-ttu-id="726be-153">解決任何警告。</span><span class="sxs-lookup"><span data-stu-id="726be-153">Address any warnings.</span></span>
1. <span data-ttu-id="726be-154">繼續前兩個步驟,直到使整個庫都為空所知。</span><span class="sxs-lookup"><span data-stu-id="726be-154">Continue these first two steps until you've made the entire library nullable aware.</span></span>
1. <span data-ttu-id="726be-155">通過將元素添加到`<Nullable>enable</Nullable>`*csproj*檔,為整個項目啟用可無效的類型。</span><span class="sxs-lookup"><span data-stu-id="726be-155">Enable nullable types for the entire project by adding the `<Nullable>enable</Nullable>` element to your *csproj* files.</span></span>
1. <span data-ttu-id="726be-156">刪除`#nullable enable`雜注,因為它們不再需要。</span><span class="sxs-lookup"><span data-stu-id="726be-156">Remove the `#nullable enable` pragmas, as they're no longer needed.</span></span>

<span data-ttu-id="726be-157">第二種戰略前期工作較少。</span><span class="sxs-lookup"><span data-stu-id="726be-157">This second strategy has less work up-front.</span></span> <span data-ttu-id="726be-158">權衡是,創建新檔時的第一個任務是添加雜注並使之無效。</span><span class="sxs-lookup"><span data-stu-id="726be-158">The tradeoff is that the first task when you create a new file is to add the pragma and make it nullable aware.</span></span> <span data-ttu-id="726be-159">如果團隊中的任何開發人員忘記了該新代碼,則新代碼現在處於工作積壓中,以使所有代碼都為空所知。</span><span class="sxs-lookup"><span data-stu-id="726be-159">If any developers on your team forget, that new code is now in the backlog of work to make all code nullable aware.</span></span>

<span data-ttu-id="726be-160">您選擇哪些策略取決於專案中正在進行多少主動開發。</span><span class="sxs-lookup"><span data-stu-id="726be-160">Which of these strategies you pick depends on how much active development is taking place in your project.</span></span> <span data-ttu-id="726be-161">專案越成熟、越穩定,第二個策略越好。</span><span class="sxs-lookup"><span data-stu-id="726be-161">The more mature and stable your project, the better the second strategy.</span></span> <span data-ttu-id="726be-162">正在開發的功能越多,第一個策略越好。</span><span class="sxs-lookup"><span data-stu-id="726be-162">The more features being developed, the better the first strategy.</span></span>

## <a name="should-nullable-warnings-introduce-breaking-changes"></a><span data-ttu-id="726be-163">不合法警告是否應引入重大更改?</span><span class="sxs-lookup"><span data-stu-id="726be-163">Should nullable warnings introduce breaking changes?</span></span>

<span data-ttu-id="726be-164">開啟可取消參考型態之前,變數被被被被被*被被被被被被被被被被被被被被被被被被被被被被被被被被被被被被*</span><span class="sxs-lookup"><span data-stu-id="726be-164">Before you enable nullable reference types, variables are considered *nullable oblivious*.</span></span> <span data-ttu-id="726be-165">開啟空引引型態後,所有這些變數都是*非空的*。</span><span class="sxs-lookup"><span data-stu-id="726be-165">Once you enable nullable reference types, all those variables are *non-nullable*.</span></span> <span data-ttu-id="726be-166">如果這些變數未初始化為非空值,編譯器將發出警告。</span><span class="sxs-lookup"><span data-stu-id="726be-166">The compiler will issue warnings if those variables aren't initialized to non-null values.</span></span>

<span data-ttu-id="726be-167">另一個可能的警告來源是在尚未初始化該值時返回值。</span><span class="sxs-lookup"><span data-stu-id="726be-167">Another likely source of warnings is return values when the value hasn't been initialized.</span></span>

<span data-ttu-id="726be-168">解決編譯器警告的第一步是對參數和返回類型`?`使用註釋來指示參數或返回值何時可能為空。</span><span class="sxs-lookup"><span data-stu-id="726be-168">The first step in addressing the compiler warnings is to use `?` annotations on parameter and return types to indicate when arguments or return values may be null.</span></span> <span data-ttu-id="726be-169">當引用變數不能為空時,原始聲明是正確的。</span><span class="sxs-lookup"><span data-stu-id="726be-169">When reference variables must not be null, the original declaration is correct.</span></span> <span data-ttu-id="726be-170">執行此操作時,您的目標不僅僅是修復警告。</span><span class="sxs-lookup"><span data-stu-id="726be-170">As you do this, your goal isn't just to fix warnings.</span></span> <span data-ttu-id="726be-171">更重要的目標是使編譯器瞭解您對於潛在空值的意圖。</span><span class="sxs-lookup"><span data-stu-id="726be-171">The more important goal is to make the compiler understand your intent for potential null values.</span></span> <span data-ttu-id="726be-172">在檢查警告時,您將得出庫的下一個重大決策。</span><span class="sxs-lookup"><span data-stu-id="726be-172">As you examine the warnings, you reach your next major decision for your library.</span></span> <span data-ttu-id="726be-173">是否要考慮修改 API 簽名以更清楚地傳達您的設計意圖?</span><span class="sxs-lookup"><span data-stu-id="726be-173">Do you want to consider modifying API signatures to more clearly communicate your design intent?</span></span> <span data-ttu-id="726be-174">前面檢查`TryGetMessage`的方法更好的 API 簽章可以是:</span><span class="sxs-lookup"><span data-stu-id="726be-174">A better API signature for the `TryGetMessage` method examined earlier could be:</span></span>

```csharp
string? TryGetMessage(string key);
```

<span data-ttu-id="726be-175">返回值指示成功或失敗,如果找到該值,則攜帶該值。</span><span class="sxs-lookup"><span data-stu-id="726be-175">The return value indicates success or failure, and carries the value if the value was found.</span></span> <span data-ttu-id="726be-176">在許多情況下,更改 API 簽名可以改進它們傳達空值的方式。</span><span class="sxs-lookup"><span data-stu-id="726be-176">In many cases, changing API signatures can improve how they communicate null values.</span></span>

<span data-ttu-id="726be-177">但是,對於公共圖書館或具有大型使用者群的庫,您可能不希望引入任何 API 簽名更改。</span><span class="sxs-lookup"><span data-stu-id="726be-177">However, for public libraries, or libraries with large user bases, you may prefer not introducing any API signature changes.</span></span> <span data-ttu-id="726be-178">對於這些情況和其他常見模式,可以將屬性應用於更明確地定義參數或返回值何時可能是`null`。</span><span class="sxs-lookup"><span data-stu-id="726be-178">For those cases, and other common patterns, you can apply attributes to more clearly define when an argument or return value may be `null`.</span></span> <span data-ttu-id="726be-179">無論您是否考慮更改 API 的表面,您都可能會發現,僅類型註釋`null`不足以描述 參數或返回值的值。</span><span class="sxs-lookup"><span data-stu-id="726be-179">Whether or not you consider changing the surface of your API, you'll likely find that type annotations alone aren't sufficient for describing `null` values for arguments or return values.</span></span> <span data-ttu-id="726be-180">在這些情況下,可以將屬性應用於更清晰地描述 API。</span><span class="sxs-lookup"><span data-stu-id="726be-180">In those instances, you can apply attributes to more clearly describe an API.</span></span>

## <a name="attributes-extend-type-annotations"></a><span data-ttu-id="726be-181">屬性延伸型態</span><span class="sxs-lookup"><span data-stu-id="726be-181">Attributes extend type annotations</span></span>

<span data-ttu-id="726be-182">添加了多個屬性以表示有關變數的 null 狀態的其他資訊。</span><span class="sxs-lookup"><span data-stu-id="726be-182">Several attributes have been added to express additional information about the null state of variables.</span></span> <span data-ttu-id="726be-183">在 C# 8 引入可無引用類型之前編寫的所有代碼都是*無效的。*</span><span class="sxs-lookup"><span data-stu-id="726be-183">All code you wrote before C# 8 introduced nullable reference types was *null oblivious*.</span></span> <span data-ttu-id="726be-184">這意味著任何引用類型變數可能為空,但不需要 null 檢查。</span><span class="sxs-lookup"><span data-stu-id="726be-184">That means any reference type variable may be null, but null checks aren't required.</span></span> <span data-ttu-id="726be-185">一旦代碼*是空的,* 這些規則就會改變。</span><span class="sxs-lookup"><span data-stu-id="726be-185">Once your code is *nullable aware*, those rules change.</span></span> <span data-ttu-id="726be-186">引用類型絕不應為`null`值,並且在取消引用之前必須`null`針對 選中可消除的引用類型。</span><span class="sxs-lookup"><span data-stu-id="726be-186">Reference types should never be the `null` value, and nullable reference types must be checked against `null` before being dereferenced.</span></span>

<span data-ttu-id="726be-187">API 的規則可能更為複雜,正如您在 API 方案中所`TryGetValue`看到的那樣 。</span><span class="sxs-lookup"><span data-stu-id="726be-187">The rules for your APIs are likely more complicated, as you saw with the `TryGetValue` API scenario.</span></span> <span data-ttu-id="726be-188">許多 API 對於變數可以或不能`null`是 時,都有更複雜的規則。</span><span class="sxs-lookup"><span data-stu-id="726be-188">Many of your APIs have more complex rules for when variables can or can't be `null`.</span></span> <span data-ttu-id="726be-189">在這些情況下,您將使用屬性來表達這些規則。</span><span class="sxs-lookup"><span data-stu-id="726be-189">In these cases, you'll use attributes to express those rules.</span></span> <span data-ttu-id="726be-190">描述 API 語義的屬性見關於[影響可撤銷分析的屬性](./language-reference/attributes/nullable-analysis.md)的文章中。</span><span class="sxs-lookup"><span data-stu-id="726be-190">The attributes that describe the semantics of your API are found in the article on [Attributes that impact nullable analysis](./language-reference/attributes/nullable-analysis.md).</span></span>

## <a name="generic-definitions-and-nullability"></a><span data-ttu-id="726be-191">一般定義與空值</span><span class="sxs-lookup"><span data-stu-id="726be-191">Generic definitions and nullability</span></span>

<span data-ttu-id="726be-192">正確傳達泛型類型和泛型方法的 null 狀態需要特別注意。</span><span class="sxs-lookup"><span data-stu-id="726be-192">Correctly communicating the null state of generic types and generic methods requires special care.</span></span> <span data-ttu-id="726be-193">這是因為可 null 值類型和空引用類型根本不同。</span><span class="sxs-lookup"><span data-stu-id="726be-193">This stems from the fact that a nullable value type and a nullable reference type are fundamentally different.</span></span> <span data-ttu-id="726be-194">是 的`Nullable<int>`同 義詞`string?`,而與編譯`string`器添加 的屬性`int?`一起。</span><span class="sxs-lookup"><span data-stu-id="726be-194">An `int?` is a synonym for `Nullable<int>`, whereas `string?` is `string` with an attribute added by the compiler.</span></span> <span data-ttu-id="726be-195">`T?`結果是,如果不知道是`T``class`. 或 , 編譯器無法`struct`生成正確的代碼。</span><span class="sxs-lookup"><span data-stu-id="726be-195">The result is that the compiler can't generate correct code for `T?` without knowing if `T` is a `class` or a `struct`.</span></span>

<span data-ttu-id="726be-196">這並不意味著不能使用空類型(值類型或引用類型)作為閉合泛型的類型參數。</span><span class="sxs-lookup"><span data-stu-id="726be-196">This doesn't mean you can't use a nullable type (either value type or reference type) as the type argument for a closed generic type.</span></span> <span data-ttu-id="726be-197">和`List<string?>``List<int?>`都是`List<T>`的有效實例化。</span><span class="sxs-lookup"><span data-stu-id="726be-197">Both `List<string?>` and `List<int?>` are valid instantiations of `List<T>`.</span></span>

<span data-ttu-id="726be-198">它的意思是,在泛型類或方法聲明中,`T?`沒有約束,不能使用。</span><span class="sxs-lookup"><span data-stu-id="726be-198">What it does mean is that you can't use `T?` in a generic class or method declaration without constraints.</span></span> <span data-ttu-id="726be-199">例如,<xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType>不會變更為`T?`傳回 。</span><span class="sxs-lookup"><span data-stu-id="726be-199">For example, <xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType> won't be changed to return `T?`.</span></span> <span data-ttu-id="726be-200">您可以通過添加`struct``class`或約束來克服此限制。</span><span class="sxs-lookup"><span data-stu-id="726be-200">You can overcome this limitation by adding either the `struct` or `class` constraint.</span></span> <span data-ttu-id="726be-201">對於其中任一約束,編譯器知道如何為和`T``T?`生成代碼。</span><span class="sxs-lookup"><span data-stu-id="726be-201">With either of those constraints, the compiler knows how to generate code for both `T` and `T?`.</span></span>

<span data-ttu-id="726be-202">您可能希望將泛型類型參數使用的類型限制為非空類型。</span><span class="sxs-lookup"><span data-stu-id="726be-202">You may want to restrict the types used for a generic type argument to be non-nullable types.</span></span> <span data-ttu-id="726be-203">可以通過添加該類型參數的`notnull`約束 來執行此操作。</span><span class="sxs-lookup"><span data-stu-id="726be-203">You can do that by adding the `notnull` constraint on that type argument.</span></span> <span data-ttu-id="726be-204">應用該約束時,類型參數不能為空類型。</span><span class="sxs-lookup"><span data-stu-id="726be-204">When that constraint is applied, the type argument must not be a nullable type.</span></span>
