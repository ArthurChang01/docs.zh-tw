---
title: 更新程式庫以使用空引言型態
description: 選擇升級代碼庫使用空引用類型的最佳策略。
ms.technology: csharp-null-safety
ms.date: 07/31/2019
ms.openlocfilehash: b4a10863aea5c47b47c2a017afb20786b1e67528
ms.sourcegitcommit: 73aa9653547a1cd70ee6586221f79cc29b588ebd
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/23/2020
ms.locfileid: "82103524"
---
# <a name="update-libraries-to-use-nullable-reference-types-and-communicate-nullable-rules-to-callers"></a>更新函式庫以使用空引言類型,並將無效規則傳達給呼叫者

新增[可取消的引用類型](nullable-references.md)意味著您`null`可以聲明 是否允許或預期每個變數的值。 此外`AllowNull`,還可以應用許多屬性: `DisallowNull` `MaybeNull`、 `NotNull` `NotNullWhen`、 `MaybeNullWhen` `NotNullIfNotNull` 、 、 、 、 、 、 、 、 、 、 、 和, 並完全描述參數和返回值的 null 狀態。 在編寫代碼時,這提供了很好的體驗。 如果非空變數可能設置為`null`,則會收到警告。 如果在取消引用之前未選中空變數,則會收到警告。 更新庫可能需要一些時間,但回報是值得的。 您向編譯器提供的關於*何時*允許`null`或禁止 值的資訊越多,API 使用者得到的更好警告。 讓我們從一個熟悉的例子開始。 假設您的函式庫有以下 API 來檢索資源字串:

```csharp
bool TryGetMessage(string key, out string message)
```

前面的範例遵循 .NET`Try*`中熟悉的模式。 此 API 有兩個引用`key`參數:`message`與 參數 。 此 API 有以下與這些參數的不合法的規則:

- 調用方不應作為`null``key`的參數傳遞。
- 調用方可以傳遞其值為`null``message`的變數作為 的 參數。
- 如果`TryGetMessage`方法`true`返回`message`,則 的值不為空。 如果傳回值`false,``message`為 (及其 null 狀態) 的值為 null。

的規則`key`可以通過變數類型完全表示`key`: 應該是一個不可空的引用類型。 參數`message`更為複雜。 它允許`null`作為參數,但保證,在成功時,`out`該 參數不為空。 對於這些方案,您需要更豐富的詞彙來描述期望值。

更新庫以進行空引用需要的不僅僅是灑`?`灑某些變數和類型名稱。 前面的範例表明,您需要檢查 API 並考慮您對每個輸入參數的期望。 考慮返回值的保證,以及方法返回時`out`的`ref`任何 或參數。 然後,將這些規則傳達給編譯器,當調用方不遵守這些規則時,編譯器將提供警告。

這項工作需要時間。 讓我們從使庫或應用程式具有空感知性的策略開始,同時平衡其他要求和可交付成果。 您將看到如何平衡支援空引用類型的持續開發。 您將瞭解泛型類型定義的挑戰。 您將學習應用屬性來描述單個 API 的預置和後置條件。

## <a name="choose-a-strategy-for-nullable-reference-types"></a>選擇空白的引言型態

第一種選擇是預設是可空引用類型應打開還是關閉。 您有兩種策略:

- 為整個項目啟用空引用類型,並在未準備好的代碼中禁用它。
- 僅為已為空引用類型提供已註明的代碼的可啟用引用類型。

當您為庫更新其他要素以進行空引用類型更新時,第一個策略效果最佳。 所有新開發都是空意識的。 更新現有代碼時,在這些類中啟用空引用類型。

遵循第一個策略,執行以下操作:

1. 通過將元素添加到`<Nullable>enable</Nullable>`*csproj*檔,為整個項目啟用可無效的引用類型。
1. 將`#nullable disable`實用方案添加到專案中的每個源檔。
1. 處理每個檔時,請刪除雜注並解決任何警告。

第一個策略具有更多的前期工作,以將實用處理添加到每個檔。 優點是,添加到專案的每個新代碼檔都將為空。 任何新工作都將是可撤銷的;只能更新現有代碼。

如果庫總體穩定,第二種策略效果更好,開發的重點是採用可無引用類型。 在對 API 進行編號時,打開可取消的引用類型。 完成後,將對整個項目啟用空引用類型。

遵循第二個策略,您可以執行以下操作:

1. 將`#nullable enable`雜注添加到要使空感知的檔中。
1. 解決任何警告。
1. 繼續前兩個步驟,直到使整個庫都為空所知。
1. 通過將元素添加到`<Nullable>enable</Nullable>`*csproj*檔,為整個項目啟用可無效的類型。
1. 刪除`#nullable enable`雜注,因為它們不再需要。

第二種戰略前期工作較少。 權衡是,創建新檔時的第一個任務是添加雜注並使之無效。 如果團隊中的任何開發人員忘記了該新代碼,則新代碼現在處於工作積壓中,以使所有代碼都為空所知。

您選擇哪些策略取決於專案中正在進行多少主動開發。 專案越成熟、越穩定,第二個策略越好。 正在開發的功能越多,第一個策略越好。

## <a name="should-nullable-warnings-introduce-breaking-changes"></a>不合法警告是否應引入重大更改?

開啟可取消參考型態之前,變數被被被被被*被被被被被被被被被被被被被被被被被被被被被被被被被被被被被被* 開啟空引引型態後,所有這些變數都是*非空的*。 如果這些變數未初始化為非空值,編譯器將發出警告。

另一個可能的警告來源是在尚未初始化該值時返回值。

解決編譯器警告的第一步是對參數和返回類型`?`使用註釋來指示參數或返回值何時可能為空。 當引用變數不能為空時,原始聲明是正確的。 執行此操作時,您的目標不僅僅是修復警告。 更重要的目標是使編譯器瞭解您對於潛在空值的意圖。 在檢查警告時,您將得出庫的下一個重大決策。 是否要考慮修改 API 簽名以更清楚地傳達您的設計意圖? 前面檢查`TryGetMessage`的方法更好的 API 簽章可以是:

```csharp
string? TryGetMessage(string key);
```

返回值指示成功或失敗,如果找到該值,則攜帶該值。 在許多情況下,更改 API 簽名可以改進它們傳達空值的方式。

但是,對於公共圖書館或具有大型使用者群的庫,您可能不希望引入任何 API 簽名更改。 對於這些情況和其他常見模式,可以將屬性應用於更明確地定義參數或返回值何時可能是`null`。 無論您是否考慮更改 API 的表面,您都可能會發現,僅類型註釋`null`不足以描述 參數或返回值的值。 在這些情況下,可以將屬性應用於更清晰地描述 API。

## <a name="attributes-extend-type-annotations"></a>屬性延伸型態

添加了多個屬性以表示有關變數的 null 狀態的其他資訊。 在 C# 8 引入可無引用類型之前編寫的所有代碼都是*無效的。* 這意味著任何引用類型變數可能為空,但不需要 null 檢查。 一旦代碼*是空的,* 這些規則就會改變。 引用類型絕不應為`null`值,並且在取消引用之前必須`null`針對 選中可消除的引用類型。

API 的規則可能更為複雜,正如您在 API 方案中所`TryGetValue`看到的那樣 。 許多 API 對於變數可以或不能`null`是 時,都有更複雜的規則。 在這些情況下,您將使用屬性來表達這些規則。 描述 API 語義的屬性見關於[影響可撤銷分析的屬性](./language-reference/attributes/nullable-analysis.md)的文章中。

## <a name="generic-definitions-and-nullability"></a>一般定義與空值

正確傳達泛型類型和泛型方法的 null 狀態需要特別注意。 這是因為可 null 值類型和空引用類型根本不同。 是 的`Nullable<int>`同 義詞`string?`,而與編譯`string`器添加 的屬性`int?`一起。 `T?`結果是,如果不知道是`T``class`. 或 , 編譯器無法`struct`生成正確的代碼。

這並不意味著不能使用空類型(值類型或引用類型)作為閉合泛型的類型參數。 和`List<string?>``List<int?>`都是`List<T>`的有效實例化。

它的意思是,在泛型類或方法聲明中,`T?`沒有約束,不能使用。 例如,<xref:System.Linq.Enumerable.FirstOrDefault%60%601(System.Collections.Generic.IEnumerable%7B%60%600%7D)?displayProperty=nameWithType>不會變更為`T?`傳回 。 您可以通過添加`struct``class`或約束來克服此限制。 對於其中任一約束,編譯器知道如何為和`T``T?`生成代碼。

您可能希望將泛型類型參數使用的類型限制為非空類型。 可以通過添加該類型參數的`notnull`約束 來執行此操作。 應用該約束時,類型參數不能為空類型。
