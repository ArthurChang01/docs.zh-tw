---
title: "Try...Catch...Finally 陳述式 (Visual Basic)"
ms.date: 07/20/2015
ms.prod: .net
ms.reviewer: 
ms.suite: 
ms.technology: devlang-visual-basic
ms.topic: article
f1_keywords:
- vb.Try...Catch...Finally
- vb.when
- vb.Finally
- vb.Catch
- vb.Try
helpviewer_keywords:
- Try...Catch...Finally statements
- Try statement [Visual Basic]
- try-catch exception handling, Try...Catch...Finally statements
- error handling, while running code
- Try statement [Visual Basic], Try...Catch...Finally
- Finally keyword [Visual Basic], Try...Catch...Finally
- Catch statement [Visual Basic]
- When keyword [Visual Basic]
- Visual Basic code, handling errors while running
- structured exception handling, Try...Catch...Finally statements
ms.assetid: d6488026-ccb3-42b8-a810-0d97b9d6472b
caps.latest.revision: "69"
author: dotnet-bot
ms.author: dotnetcontent
ms.openlocfilehash: 56dd7fc339c452d64eb18211337b9a7674a83e1c
ms.sourcegitcommit: 685143b62385500f59bc36274b8adb191f573a16
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/09/2017
---
# <a name="trycatchfinally-statement-visual-basic"></a><span data-ttu-id="4ca78-102">Try...Catch...Finally 陳述式 (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="4ca78-102">Try...Catch...Finally Statement (Visual Basic)</span></span>
<span data-ttu-id="4ca78-103">提供了處理部分或所有可能的錯誤時繼續執行程式碼中指定的一段程式碼，可能發生的方式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-103">Provides a way to handle some or all possible errors that may occur in a given block of code, while still running code.</span></span>  
  
## <a name="syntax"></a><span data-ttu-id="4ca78-104">語法</span><span class="sxs-lookup"><span data-stu-id="4ca78-104">Syntax</span></span>  
  
```  
Try  
    [ tryStatements ]  
    [ Exit Try ]  
[ Catch [ exception [ As type ] ] [ When expression ]  
    [ catchStatements ]  
    [ Exit Try ] ]  
[ Catch ... ]  
[ Finally  
    [ finallyStatements ] ]  
End Try  
```  
  
## <a name="parts"></a><span data-ttu-id="4ca78-105">組件</span><span class="sxs-lookup"><span data-stu-id="4ca78-105">Parts</span></span>  
  
|<span data-ttu-id="4ca78-106">詞彙</span><span class="sxs-lookup"><span data-stu-id="4ca78-106">Term</span></span>|<span data-ttu-id="4ca78-107">定義</span><span class="sxs-lookup"><span data-stu-id="4ca78-107">Definition</span></span>|  
|---|---|  
|`tryStatements`|<span data-ttu-id="4ca78-108">選擇項。</span><span class="sxs-lookup"><span data-stu-id="4ca78-108">Optional.</span></span> <span data-ttu-id="4ca78-109">可能發生錯誤的陳述式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-109">Statement(s) where an error can occur.</span></span> <span data-ttu-id="4ca78-110">可以是複合陳述式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-110">Can be a compound statement.</span></span>|  
|`Catch`|<span data-ttu-id="4ca78-111">選擇項。</span><span class="sxs-lookup"><span data-stu-id="4ca78-111">Optional.</span></span> <span data-ttu-id="4ca78-112">多個`Catch`允許的區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-112">Multiple `Catch` blocks permitted.</span></span> <span data-ttu-id="4ca78-113">如果發生例外狀況處理時`Try`區塊，每個`Catch`陳述式會檢查以判斷是否處理例外狀況，以文字順序`exception`代表已擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-113">If an exception occurs when processing the `Try` block, each `Catch` statement is examined in textual order to determine whether it handles the exception, with `exception` representing the exception that has been thrown.</span></span>|  
|`exception`|<span data-ttu-id="4ca78-114">選擇項。</span><span class="sxs-lookup"><span data-stu-id="4ca78-114">Optional.</span></span> <span data-ttu-id="4ca78-115">任何變數名稱。</span><span class="sxs-lookup"><span data-stu-id="4ca78-115">Any variable name.</span></span> <span data-ttu-id="4ca78-116">`exception` 的初始值就是擲回之錯誤的值。</span><span class="sxs-lookup"><span data-stu-id="4ca78-116">The initial value of `exception` is the value of the thrown error.</span></span> <span data-ttu-id="4ca78-117">搭配`Catch`來指定錯誤攔截。</span><span class="sxs-lookup"><span data-stu-id="4ca78-117">Used with `Catch` to specify the error caught.</span></span> <span data-ttu-id="4ca78-118">如果省略，`Catch`陳述式攔截任何例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-118">If omitted, the `Catch` statement catches any exception.</span></span>|  
|`type`|<span data-ttu-id="4ca78-119">選擇項。</span><span class="sxs-lookup"><span data-stu-id="4ca78-119">Optional.</span></span> <span data-ttu-id="4ca78-120">指定類別篩選條件類型。</span><span class="sxs-lookup"><span data-stu-id="4ca78-120">Specifies the type of class filter.</span></span> <span data-ttu-id="4ca78-121">如果值`exception`所指定型別的`type`或衍生類型的識別項會變成繫結至例外狀況物件。</span><span class="sxs-lookup"><span data-stu-id="4ca78-121">If the value of `exception` is of the type specified by `type` or of a derived type, the identifier becomes bound to the exception object.</span></span>|  
|`When`|<span data-ttu-id="4ca78-122">選擇項。</span><span class="sxs-lookup"><span data-stu-id="4ca78-122">Optional.</span></span> <span data-ttu-id="4ca78-123">A`Catch`陳述式搭配`When`子句會攔截例外狀況時，才`expression`評估為`True`。</span><span class="sxs-lookup"><span data-stu-id="4ca78-123">A `Catch` statement with a `When` clause catches exceptions only when `expression` evaluates to `True`.</span></span> <span data-ttu-id="4ca78-124">A`When`檢查例外狀況，類型之後，才套用子句和`expression`可能會參考表示例外狀況的識別項。</span><span class="sxs-lookup"><span data-stu-id="4ca78-124">A `When` clause is applied only after checking the type of the exception, and `expression` may refer to the identifier representing the exception.</span></span>|  
|`expression`|<span data-ttu-id="4ca78-125">選擇項。</span><span class="sxs-lookup"><span data-stu-id="4ca78-125">Optional.</span></span> <span data-ttu-id="4ca78-126">必須是隱含地轉換成`Boolean`。</span><span class="sxs-lookup"><span data-stu-id="4ca78-126">Must be implicitly convertible to `Boolean`.</span></span> <span data-ttu-id="4ca78-127">描述一般篩選器的任何運算式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-127">Any expression that describes a generic filter.</span></span> <span data-ttu-id="4ca78-128">通常用來篩選錯誤號碼。</span><span class="sxs-lookup"><span data-stu-id="4ca78-128">Typically used to filter by error number.</span></span> <span data-ttu-id="4ca78-129">搭配`When`關鍵字來指定的情況下會攔截錯誤。</span><span class="sxs-lookup"><span data-stu-id="4ca78-129">Used with `When` keyword to specify circumstances under which the error is caught.</span></span>|  
|`catchStatements`|<span data-ttu-id="4ca78-130">選擇項。</span><span class="sxs-lookup"><span data-stu-id="4ca78-130">Optional.</span></span> <span data-ttu-id="4ca78-131">陳述式來處理發生在相關聯的錯誤`Try`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-131">Statement(s) to handle errors that occur in the associated `Try` block.</span></span> <span data-ttu-id="4ca78-132">可以是複合陳述式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-132">Can be a compound statement.</span></span>|  
|`Exit Try`|<span data-ttu-id="4ca78-133">選擇項。</span><span class="sxs-lookup"><span data-stu-id="4ca78-133">Optional.</span></span> <span data-ttu-id="4ca78-134">中斷的關鍵字`Try...Catch...Finally`結構。</span><span class="sxs-lookup"><span data-stu-id="4ca78-134">Keyword that breaks out of the `Try...Catch...Finally` structure.</span></span> <span data-ttu-id="4ca78-135">使用程式碼後置節點就會繼續執行`End Try`陳述式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-135">Execution resumes with the code immediately following the `End Try` statement.</span></span> <span data-ttu-id="4ca78-136">`Finally`仍可執行陳述式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-136">The `Finally` statement will still be executed.</span></span> <span data-ttu-id="4ca78-137">中不允許`Finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-137">Not allowed in `Finally` blocks.</span></span>|  
|`Finally`|<span data-ttu-id="4ca78-138">選擇項。</span><span class="sxs-lookup"><span data-stu-id="4ca78-138">Optional.</span></span> <span data-ttu-id="4ca78-139">A`Finally`當執行離開的任何部分時，就會永遠執行區塊`Try...Catch`陳述式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-139">A `Finally` block is always executed when execution leaves any part of the `Try...Catch` statement.</span></span>|  
|`finallyStatements`|<span data-ttu-id="4ca78-140">選擇項。</span><span class="sxs-lookup"><span data-stu-id="4ca78-140">Optional.</span></span> <span data-ttu-id="4ca78-141">所有其他錯誤處理都發生之後執行的陳述式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-141">Statement(s) that are executed after all other error processing has occurred.</span></span>|  
|`End Try`|<span data-ttu-id="4ca78-142">終止`Try...Catch...Finally`結構。</span><span class="sxs-lookup"><span data-stu-id="4ca78-142">Terminates the `Try...Catch...Finally` structure.</span></span>|  
  
## <a name="remarks"></a><span data-ttu-id="4ca78-143">備註</span><span class="sxs-lookup"><span data-stu-id="4ca78-143">Remarks</span></span>  
 <span data-ttu-id="4ca78-144">如果您預期特定的例外狀況可能會發生在特定的一段程式碼時，將程式碼放`Try`封鎖，並使用`Catch`保留控制項和處理例外狀況，如果發生的區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-144">If you expect that a particular exception might occur during a particular section of code, put the code in a `Try` block and use a `Catch` block to retain control and handle the exception if it occurs.</span></span>  
  
 <span data-ttu-id="4ca78-145">A`Try…Catch`陳述式組成`Try`區塊後面接著一個或多個`Catch`子句，指定不同的例外狀況處理常式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-145">A `Try…Catch` statement consists of a `Try` block followed by one or more `Catch` clauses, which specify handlers for various exceptions.</span></span> <span data-ttu-id="4ca78-146">當擲回例外狀況`Try`區塊，[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]尋找`Catch`處理例外狀況的陳述式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-146">When an exception is thrown in a `Try` block, [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] looks for the `Catch` statement that handles the exception.</span></span> <span data-ttu-id="4ca78-147">如果比對`Catch`找不到陳述式，[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]會檢查呼叫目前的方法，在呼叫堆疊向上等的方法。</span><span class="sxs-lookup"><span data-stu-id="4ca78-147">If a matching `Catch` statement is not found, [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] examines the method that called the current method, and so on up the call stack.</span></span> <span data-ttu-id="4ca78-148">如果沒有`Catch`找不到區塊，[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]向使用者顯示未處理的例外狀況訊息，並停止執行程式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-148">If no `Catch` block is found, [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] displays an unhandled exception message to the user and stops execution of the program.</span></span>  
  
 <span data-ttu-id="4ca78-149">您可以使用多個`Catch`陳述式中的`Try…Catch`陳述式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-149">You can use more than one `Catch` statement in a `Try…Catch` statement.</span></span> <span data-ttu-id="4ca78-150">如果您這樣做，請的順序`Catch`子句十分重要，因為它們會依順序檢查。</span><span class="sxs-lookup"><span data-stu-id="4ca78-150">If you do this, the order of the `Catch` clauses is significant because they are examined in order.</span></span> <span data-ttu-id="4ca78-151">在較不特定的例外狀況之前攔截較特定的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-151">Catch the more specific exceptions before the less specific ones.</span></span>  
  
 <span data-ttu-id="4ca78-152">下列`Catch`陳述式條件最特定且將會攔截所有例外狀況衍生自<xref:System.Exception>類別。</span><span class="sxs-lookup"><span data-stu-id="4ca78-152">The following `Catch` statement conditions are the least specific, and will catch all exceptions that derive from the <xref:System.Exception> class.</span></span> <span data-ttu-id="4ca78-153">您通常應該使用其中一個這些變化最後`Catch`中區塊`Try...Catch...Finally`結構之後攔截您預期的所有特定例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-153">You should ordinarily use one of these variations as the last `Catch` block in the `Try...Catch...Finally` structure, after catching all the specific exceptions you expect.</span></span> <span data-ttu-id="4ca78-154">控制流程可以永遠無法抵達`Catch`遵循其中一個這些變化的區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-154">Control flow can never reach a `Catch` block that follows either of these variations.</span></span>  
  
-   <span data-ttu-id="4ca78-155">`type`是`Exception`，例如：`Catch ex As Exception`</span><span class="sxs-lookup"><span data-stu-id="4ca78-155">The `type` is `Exception`, for example: `Catch ex As Exception`</span></span>  
  
-   <span data-ttu-id="4ca78-156">陳述式沒有`exception`變數，例如：`Catch`</span><span class="sxs-lookup"><span data-stu-id="4ca78-156">The statement has no `exception` variable, for example: `Catch`</span></span>  
  
 <span data-ttu-id="4ca78-157">當`Try…Catch…Finally`陳述式巢狀方式置於另一個`Try`區塊，[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]先檢查每個`Catch`陳述式中最內側`Try`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-157">When a `Try…Catch…Finally` statement is nested in another `Try` block, [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] first examines each `Catch` statement in the innermost `Try` block.</span></span> <span data-ttu-id="4ca78-158">如果沒有相符的`Catch`找不到陳述式，搜尋會繼續進行`Catch`陳述式的外部`Try…Catch…Finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-158">If no matching `Catch` statement is found, the search proceeds to the `Catch` statements of the outer `Try…Catch…Finally` block.</span></span>  
  
 <span data-ttu-id="4ca78-159">從本機變數`Try`區塊中沒有`Catch`封鎖，因為它們是不同的區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-159">Local variables from a `Try` block are not available in a `Catch` block because they are separate blocks.</span></span> <span data-ttu-id="4ca78-160">如果您想要使用多個區塊中的變數，將外部變數宣告`Try...Catch...Finally`結構。</span><span class="sxs-lookup"><span data-stu-id="4ca78-160">If you want to use a variable in more than one block, declare the variable outside the `Try...Catch...Finally` structure.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="4ca78-161">`Try…Catch…Finally`陳述式是可從 IntelliSense 程式碼片段。</span><span class="sxs-lookup"><span data-stu-id="4ca78-161">The `Try…Catch…Finally` statement is available as an IntelliSense code snippet.</span></span> <span data-ttu-id="4ca78-162">在程式碼片段管理員中，依序展開**程式碼模式-If、 For Each、 Try Catch，屬性，等**，然後**錯誤處理 （例外狀況）**。</span><span class="sxs-lookup"><span data-stu-id="4ca78-162">In the Code Snippets Manager, expand **Code Patterns - If, For Each, Try Catch, Property, etc**, and then **Error Handling (Exceptions)**.</span></span> <span data-ttu-id="4ca78-163">如需詳細資訊，請參閱[程式碼片段](/visualstudio/ide/code-snippets)。</span><span class="sxs-lookup"><span data-stu-id="4ca78-163">For more information, see [Code Snippets](/visualstudio/ide/code-snippets).</span></span>  
  
## <a name="finally-block"></a><span data-ttu-id="4ca78-164">Finally 區塊</span><span class="sxs-lookup"><span data-stu-id="4ca78-164">Finally Block</span></span>  
 <span data-ttu-id="4ca78-165">如果您有一或多個陳述式，然後再結束必須執行`Try`結構時，請使用`Finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-165">If you have one or more statements that must run before you exit the `Try` structure, use a `Finally` block.</span></span> <span data-ttu-id="4ca78-166">控制權會傳遞給`Finally`區塊之前的傳遞`Try…Catch`結構。</span><span class="sxs-lookup"><span data-stu-id="4ca78-166">Control passes to the `Finally` block just before it passes out of the `Try…Catch` structure.</span></span> <span data-ttu-id="4ca78-167">這是 true，即使內任意處發生例外狀況`Try`結構。</span><span class="sxs-lookup"><span data-stu-id="4ca78-167">This is true even if an exception occurs anywhere inside the `Try` structure.</span></span>  
  
 <span data-ttu-id="4ca78-168">A`Finally`區塊在執行任何程式碼必須執行，即使發生例外狀況是很有用。</span><span class="sxs-lookup"><span data-stu-id="4ca78-168">A `Finally` block is useful for running any code that must execute even if there is an exception.</span></span> <span data-ttu-id="4ca78-169">控制權會傳遞給`Finally`不論區塊`Try...Catch`區塊會結束。</span><span class="sxs-lookup"><span data-stu-id="4ca78-169">Control is passed to the `Finally` block regardless of how the `Try...Catch` block exits.</span></span>  
  
 <span data-ttu-id="4ca78-170">中的程式碼`Finally`封鎖執行，即使您的程式碼發生`Return`陳述式中的`Try`或`Catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-170">The code in a `Finally` block runs even if your code encounters a `Return` statement in a `Try` or `Catch` block.</span></span> <span data-ttu-id="4ca78-171">控制項不會從傳遞`Try`或`Catch`封鎖對應`Finally`封鎖在下列情況：</span><span class="sxs-lookup"><span data-stu-id="4ca78-171">Control does not pass from a `Try` or `Catch` block to the corresponding `Finally` block in the following cases:</span></span>  
  
-   <span data-ttu-id="4ca78-172">[End 陳述式](../../../visual-basic/language-reference/statements/end-statement.md)中遇到`Try`或`Catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-172">An [End Statement](../../../visual-basic/language-reference/statements/end-statement.md) is encountered in the `Try` or `Catch` block.</span></span>  
  
-   <span data-ttu-id="4ca78-173">A<xref:System.StackOverflowException>中擲回`Try`或`Catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-173">A <xref:System.StackOverflowException> is thrown in the `Try` or `Catch` block.</span></span>  
  
 <span data-ttu-id="4ca78-174">若要明確地傳輸到執行無效`Finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-174">It is not valid to explicitly transfer execution into a `Finally` block.</span></span> <span data-ttu-id="4ca78-175">傳送執行出`Finally`區塊不是有效的除了透過例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-175">Transferring execution out of a `Finally` block is not valid, except through an exception.</span></span>  
  
 <span data-ttu-id="4ca78-176">如果`Try`陳述式未包含至少一個`Catch`區塊，它必須包含`Finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-176">If a `Try` statement does not contain at least one `Catch` block, it must contain a `Finally` block.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="4ca78-177">如果您不需要攔截特定例外狀況，`Using`陳述式的行為類似`Try…Finally`區塊，以及保證處置的資源，不論您如何結束區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-177">If you do not have to catch specific exceptions, the `Using` statement behaves like a `Try…Finally` block, and guarantees disposal of the resources, regardless of how you exit the block.</span></span> <span data-ttu-id="4ca78-178">這是即使有未處理的例外狀況，則為 true。</span><span class="sxs-lookup"><span data-stu-id="4ca78-178">This is true even with an unhandled exception.</span></span> <span data-ttu-id="4ca78-179">如需詳細資訊，請參閱 [Using 陳述式](../../../visual-basic/language-reference/statements/using-statement.md)。</span><span class="sxs-lookup"><span data-stu-id="4ca78-179">For more information, see [Using Statement](../../../visual-basic/language-reference/statements/using-statement.md).</span></span>  
  
## <a name="exception-argument"></a><span data-ttu-id="4ca78-180">例外狀況引數</span><span class="sxs-lookup"><span data-stu-id="4ca78-180">Exception Argument</span></span>  
 <span data-ttu-id="4ca78-181">`Catch`區塊`exception`引數是的執行個體<xref:System.Exception>類別或衍生自類別`Exception`類別。</span><span class="sxs-lookup"><span data-stu-id="4ca78-181">The `Catch` block `exception` argument is an instance of the <xref:System.Exception> class or a class that derives from the `Exception` class.</span></span> <span data-ttu-id="4ca78-182">`Exception`類別執行個體對應至錯誤的發生`Try`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-182">The `Exception` class instance corresponds to the error that occurred in the `Try` block.</span></span>  
  
 <span data-ttu-id="4ca78-183">內容`Exception`物件來識別可能的原因和位置的例外狀況的說明。</span><span class="sxs-lookup"><span data-stu-id="4ca78-183">The properties of the `Exception` object help to identify the cause and location of an exception.</span></span> <span data-ttu-id="4ca78-184">例如，<xref:System.Exception.StackTrace%2A>屬性清單導致例外狀況，可幫助您尋找程式碼中發生錯誤的呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="4ca78-184">For example, the <xref:System.Exception.StackTrace%2A> property lists the called methods that led to the exception, helping you find where the error occurred in the code.</span></span> <span data-ttu-id="4ca78-185"><xref:System.Exception.Message%2A>傳回描述例外狀況的訊息。</span><span class="sxs-lookup"><span data-stu-id="4ca78-185"><xref:System.Exception.Message%2A> returns a message that describes the exception.</span></span> <span data-ttu-id="4ca78-186"><xref:System.Exception.HelpLink%2A>傳回相關聯的說明檔的連結。</span><span class="sxs-lookup"><span data-stu-id="4ca78-186"><xref:System.Exception.HelpLink%2A> returns a link to an associated Help file.</span></span> <span data-ttu-id="4ca78-187"><xref:System.Exception.InnerException%2A>傳回`Exception`造成目前例外狀況，或它的物件傳回`Nothing`如果沒有任何原始`Exception`。</span><span class="sxs-lookup"><span data-stu-id="4ca78-187"><xref:System.Exception.InnerException%2A> returns the `Exception` object that caused the current exception, or it returns `Nothing` if there is no original `Exception`.</span></span>  
  
## <a name="considerations-when-using-a-trycatch-statement"></a><span data-ttu-id="4ca78-188">考量時使用 Try...Catch 陳述式</span><span class="sxs-lookup"><span data-stu-id="4ca78-188">Considerations When Using a Try…Catch Statement</span></span>  
 <span data-ttu-id="4ca78-189">使用`Try…Catch`陳述式只能用來表示不尋常或非預期的程式事件的發生。</span><span class="sxs-lookup"><span data-stu-id="4ca78-189">Use a `Try…Catch` statement only to signal the occurrence of unusual or unanticipated program events.</span></span> <span data-ttu-id="4ca78-190">這麼做的原因包括：</span><span class="sxs-lookup"><span data-stu-id="4ca78-190">Reasons for this include the following:</span></span>  
  
-   <span data-ttu-id="4ca78-191">在執行階段攔截例外狀況會建立額外的負荷，並可能會低於預先檢查，以避免例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-191">Catching exceptions at runtime creates additional overhead, and is likely to be slower than pre-checking to avoid exceptions.</span></span>  
  
-   <span data-ttu-id="4ca78-192">如果`Catch`區塊未正確處理、 例外狀況可能不會報告正確的使用者。</span><span class="sxs-lookup"><span data-stu-id="4ca78-192">If a `Catch` block is not handled correctly, the exception might not be reported correctly to users.</span></span>  
  
-   <span data-ttu-id="4ca78-193">例外狀況處理可讓您更複雜的程式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-193">Exception handling makes a program more complex.</span></span>  
  
 <span data-ttu-id="4ca78-194">您不一定需要`Try…Catch`可能發生的情況，檢查陳述式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-194">You do not always need a `Try…Catch` statement to check for a condition that is likely to occur.</span></span> <span data-ttu-id="4ca78-195">下列範例會檢查檔案是否存在然後再嘗試將它開啟。</span><span class="sxs-lookup"><span data-stu-id="4ca78-195">The following example checks whether a file exists before trying to open it.</span></span> <span data-ttu-id="4ca78-196">這會減少需要攔截，所擲回的例外狀況<xref:System.IO.File.OpenText%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4ca78-196">This reduces the need for catching an exception thrown by the <xref:System.IO.File.OpenText%2A> method.</span></span>  
  
 [!code-vb[VbVbalrStatements#94](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/try-catch-finally-statement_1.vb)]  
  
 <span data-ttu-id="4ca78-197">請確定該程式碼中的`Catch`區塊可以正確地報告例外狀況給使用者，不論是透過安全執行緒的記錄或適當的訊息。</span><span class="sxs-lookup"><span data-stu-id="4ca78-197">Ensure that code in `Catch` blocks can properly report exceptions to users, whether through thread-safe logging or appropriate messages.</span></span> <span data-ttu-id="4ca78-198">否則，您可能會維持未知例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-198">Otherwise, exceptions might remain unknown.</span></span>  
  
## <a name="async-methods"></a><span data-ttu-id="4ca78-199">非同步方法</span><span class="sxs-lookup"><span data-stu-id="4ca78-199">Async Methods</span></span>  
 <span data-ttu-id="4ca78-200">如果您將某個方法[非同步](../../../visual-basic/language-reference/modifiers/async.md)修飾詞，您可以使用[Await](../../../visual-basic/language-reference/operators/await-operator.md)方法中的運算子。</span><span class="sxs-lookup"><span data-stu-id="4ca78-200">If you mark a method with the [Async](../../../visual-basic/language-reference/modifiers/async.md) modifier, you can use the [Await](../../../visual-basic/language-reference/operators/await-operator.md) operator in the method.</span></span> <span data-ttu-id="4ca78-201">陳述式搭配`Await`運算子會暫停執行方法，直到等候的工作完成。</span><span class="sxs-lookup"><span data-stu-id="4ca78-201">A statement with the `Await` operator suspends execution of the method until the awaited task completes.</span></span> <span data-ttu-id="4ca78-202">工作代表進行中的工作。</span><span class="sxs-lookup"><span data-stu-id="4ca78-202">The task represents ongoing work.</span></span> <span data-ttu-id="4ca78-203">當相關聯的工作`Await`運算子完成時，在相同方法中的繼續執行。</span><span class="sxs-lookup"><span data-stu-id="4ca78-203">When the task that's associated with the `Await` operator finishes, execution resumes in the same method.</span></span> <span data-ttu-id="4ca78-204">如需詳細資訊，請參閱[非同步程式中的控制流程](../../../visual-basic/programming-guide/concepts/async/control-flow-in-async-programs.md)。</span><span class="sxs-lookup"><span data-stu-id="4ca78-204">For more information, see [Control Flow in Async Programs](../../../visual-basic/programming-guide/concepts/async/control-flow-in-async-programs.md).</span></span>  
  
 <span data-ttu-id="4ca78-205">工作傳回非同步方法最後可能處於錯誤狀態，指出它完成因未處理的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-205">A task returned by an Async method may end in a faulted state, indicating that it completed due to an unhandled exception.</span></span> <span data-ttu-id="4ca78-206">工作可能也會在取消的狀態，導致結束`OperationCanceledException`移出 await 運算式擲回。</span><span class="sxs-lookup"><span data-stu-id="4ca78-206">A task may also end in a canceled state, which results in an `OperationCanceledException` being thrown out of the await expression.</span></span> <span data-ttu-id="4ca78-207">若要攔截例外狀況的任一種，放置`Await`中的工作與相關聯的運算式`Try`區塊，並攔截的例外狀況中`Catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-207">To catch either type of exception, place the `Await` expression that's associated with the task in a `Try` block, and catch the exception in the `Catch` block.</span></span> <span data-ttu-id="4ca78-208">在本主題稍後的範例。</span><span class="sxs-lookup"><span data-stu-id="4ca78-208">An example is provided later in this topic.</span></span>  
  
 <span data-ttu-id="4ca78-209">工作可能處於錯誤狀態，因為多個例外狀況是負責其判定為失敗。</span><span class="sxs-lookup"><span data-stu-id="4ca78-209">A task can be in a faulted state because multiple exceptions were responsible for its faulting.</span></span> <span data-ttu-id="4ca78-210">例如，工作可能是對 <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> 呼叫的結果。</span><span class="sxs-lookup"><span data-stu-id="4ca78-210">For example, the task might be the result of a call to <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4ca78-211">當您等候這類工作時，攔截的例外狀況只是其中一個例外狀況，且您無法預測會攔截的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-211">When you await such a task, the caught exception is only one of the exceptions, and you can't predict which exception will be caught.</span></span> <span data-ttu-id="4ca78-212">在本主題稍後的範例。</span><span class="sxs-lookup"><span data-stu-id="4ca78-212">An example is provided later in this topic.</span></span>  
  
 <span data-ttu-id="4ca78-213">`Await`運算式不能在`Catch`區塊或`Finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-213">An `Await` expression can't be inside a `Catch` block or `Finally` block.</span></span>  
  
## <a name="iterators"></a><span data-ttu-id="4ca78-214">Iterator</span><span class="sxs-lookup"><span data-stu-id="4ca78-214">Iterators</span></span>  
 <span data-ttu-id="4ca78-215">Iterator 函式或`Get`存取子會對集合執行自訂反覆項目。</span><span class="sxs-lookup"><span data-stu-id="4ca78-215">An iterator function or `Get` accessor performs a custom iteration over a collection.</span></span> <span data-ttu-id="4ca78-216">迭代器會使用[產生](../../../visual-basic/language-reference/statements/yield-statement.md)陳述式來傳回一次一個集合的每個項目。</span><span class="sxs-lookup"><span data-stu-id="4ca78-216">An iterator uses a [Yield](../../../visual-basic/language-reference/statements/yield-statement.md) statement to return each element of the collection one at a time.</span></span> <span data-ttu-id="4ca78-217">您可以使用呼叫 iterator 函式[每個...下一個陳述式](../../../visual-basic/language-reference/statements/for-each-next-statement.md)。</span><span class="sxs-lookup"><span data-stu-id="4ca78-217">You call an iterator function by using a [For Each...Next Statement](../../../visual-basic/language-reference/statements/for-each-next-statement.md).</span></span>  
  
 <span data-ttu-id="4ca78-218">A`Yield`陳述式可以是內部`Try`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-218">A `Yield` statement can be inside a `Try` block.</span></span> <span data-ttu-id="4ca78-219">A`Try`包含區塊`Yield`陳述式可以有`Catch`封鎖了，而且可以有`Finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-219">A `Try` block that contains a `Yield` statement can have `Catch` blocks, and can have a `Finally` block.</span></span> <span data-ttu-id="4ca78-220">請參閱 「 嘗試區塊在 Visual Basic 中 」 一節[迭代器](http://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7)的範例。</span><span class="sxs-lookup"><span data-stu-id="4ca78-220">See the "Try Blocks in Visual Basic" section of [Iterators](http://msdn.microsoft.com/library/f45331db-d595-46ec-9142-551d3d1eb1a7) for an example.</span></span>  
  
 <span data-ttu-id="4ca78-221">A`Yield`陳述式不能在`Catch`區塊或`Finally`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-221">A `Yield` statement cannot be inside a `Catch` block or a `Finally` block.</span></span>  
  
 <span data-ttu-id="4ca78-222">如果`For Each`（之外的迭代器函式） 的主體就會擲回例外狀況， `Catch` iterator 函式中的區塊不會執行，但`Finally`就會執行 iterator 函式中的區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-222">If the `For Each` body (outside of the iterator function) throws an exception, a `Catch` block in the iterator function is not executed, but a `Finally` block in the iterator function is executed.</span></span> <span data-ttu-id="4ca78-223">A`Catch`迭代器函式內的區塊會攔截迭代器函式內發生的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-223">A `Catch` block inside an iterator function catches only exceptions that occur inside the iterator function.</span></span>  
  
## <a name="partial-trust-situations"></a><span data-ttu-id="4ca78-224">部分信任的情況下</span><span class="sxs-lookup"><span data-stu-id="4ca78-224">Partial-Trust Situations</span></span>  
 <span data-ttu-id="4ca78-225">在部分信任情況下，應用程式裝載在網路共用，例如`Try...Catch...Finally`不會攔截包含呼叫的方法會叫用之前，發生安全性例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-225">In partial-trust situations, such as an application hosted on a network share, `Try...Catch...Finally` does not catch security exceptions that occur before the method that contains the call is invoked.</span></span> <span data-ttu-id="4ca78-226">下列範例中，當您將它放在伺服器共用和執行之後，會產生錯誤 「 System.Security.SecurityException： 要求失敗。 」</span><span class="sxs-lookup"><span data-stu-id="4ca78-226">The following example, when you put it on a server share and run from there, produces the error "System.Security.SecurityException: Request Failed."</span></span> <span data-ttu-id="4ca78-227">如需安全性例外狀況的詳細資訊，請參閱<xref:System.Security.SecurityException>類別。</span><span class="sxs-lookup"><span data-stu-id="4ca78-227">For more information about security exceptions, see the <xref:System.Security.SecurityException> class.</span></span>  
  
 [!code-vb[VbVbalrStatements#85](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/try-catch-finally-statement_2.vb)]  
  
 <span data-ttu-id="4ca78-228">這類的部分信任情況下，您必須將`Process.Start`在個別的陳述式`Sub`。</span><span class="sxs-lookup"><span data-stu-id="4ca78-228">In such a partial-trust situation, you have to put the `Process.Start` statement in a separate `Sub`.</span></span> <span data-ttu-id="4ca78-229">一次呼叫`Sub`將會失敗。</span><span class="sxs-lookup"><span data-stu-id="4ca78-229">The initial call to the `Sub` will fail.</span></span> <span data-ttu-id="4ca78-230">這可讓`Try...Catch`攔截它之前`Sub`包含`Process.Start`已啟動並產生安全性例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-230">This enables `Try...Catch` to catch it before the `Sub` that contains `Process.Start` is started and the security exception produced.</span></span>  
  
## <a name="example"></a><span data-ttu-id="4ca78-231">範例</span><span class="sxs-lookup"><span data-stu-id="4ca78-231">Example</span></span>  
 <span data-ttu-id="4ca78-232">下列範例說明結構`Try...Catch...Finally`陳述式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-232">The following example illustrates the structure of the `Try...Catch...Finally` statement.</span></span>  
  
 [!code-vb[VbVbalrStatements#86](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/try-catch-finally-statement_3.vb)]  
  
## <a name="example"></a><span data-ttu-id="4ca78-233">範例</span><span class="sxs-lookup"><span data-stu-id="4ca78-233">Example</span></span>  
 <span data-ttu-id="4ca78-234">在下列範例中，`CreateException`方法會擲回`NullReferenceException`。</span><span class="sxs-lookup"><span data-stu-id="4ca78-234">In the following example, the `CreateException` method throws a `NullReferenceException`.</span></span> <span data-ttu-id="4ca78-235">不會產生例外狀況的程式碼是`Try`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-235">The code that generates the exception is not in a `Try` block.</span></span> <span data-ttu-id="4ca78-236">因此，`CreateException`方法不會處理例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-236">Therefore, the `CreateException` method does not handle the exception.</span></span> <span data-ttu-id="4ca78-237">`RunSample`方法未處理例外狀況，因為呼叫`CreateException`方法是位於`Try`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-237">The `RunSample` method does handle the exception because the call to the `CreateException` method is in a `Try` block.</span></span>  
  
 <span data-ttu-id="4ca78-238">此範例也包含`Catch`陳述式中的幾種類型的例外狀況，排序從最特定到最普遍。</span><span class="sxs-lookup"><span data-stu-id="4ca78-238">The example includes `Catch` statements for several types of exceptions, ordered from the most specific to the most general.</span></span>  
  
 [!code-vb[VbVbalrStatements#91](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/try-catch-finally-statement_4.vb)]  
  
## <a name="example"></a><span data-ttu-id="4ca78-239">範例</span><span class="sxs-lookup"><span data-stu-id="4ca78-239">Example</span></span>  
 <span data-ttu-id="4ca78-240">下列範例示範如何使用`Catch When`篩選條件運算式的陳述式。</span><span class="sxs-lookup"><span data-stu-id="4ca78-240">The following example shows how to use a `Catch When` statement to filter on a conditional expression.</span></span> <span data-ttu-id="4ca78-241">如果條件運算式評估為`True`中的程式碼`Catch`封鎖執行。</span><span class="sxs-lookup"><span data-stu-id="4ca78-241">If the conditional expression evaluates to `True`, the code in the `Catch` block runs.</span></span>  
  
 [!code-vb[VbVbalrStatements#92](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/try-catch-finally-statement_5.vb)]  
  
## <a name="example"></a><span data-ttu-id="4ca78-242">範例</span><span class="sxs-lookup"><span data-stu-id="4ca78-242">Example</span></span>  
 <span data-ttu-id="4ca78-243">下列範例具有`Try…Catch`陳述式中所包含`Try`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-243">The following example has a `Try…Catch` statement that is contained in a `Try` block.</span></span> <span data-ttu-id="4ca78-244">內部`Catch`區塊擲回例外狀況有其`InnerException`屬性設為原始的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-244">The inner `Catch` block throws an exception that has its `InnerException` property set to the original exception.</span></span> <span data-ttu-id="4ca78-245">外部`Catch`區塊會報告它自己的例外狀況，以及內部例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-245">The outer `Catch` block reports its own exception and the inner exception.</span></span>  
  
 [!code-vb[VbVbalrStatements#93](../../../visual-basic/language-reference/error-messages/codesnippet/VisualBasic/try-catch-finally-statement_6.vb)]  
  
## <a name="example"></a><span data-ttu-id="4ca78-246">範例</span><span class="sxs-lookup"><span data-stu-id="4ca78-246">Example</span></span>  
 <span data-ttu-id="4ca78-247">下列範例說明非同步方法的例外狀況處理。</span><span class="sxs-lookup"><span data-stu-id="4ca78-247">The following example illustrates exception handling for async methods.</span></span> <span data-ttu-id="4ca78-248">若要攔截例外狀況，適用於一項非同步工作，`Await`運算式是在`Try`的呼叫端和例外狀況區塊中攔截`Catch`區塊。</span><span class="sxs-lookup"><span data-stu-id="4ca78-248">To catch an exception that applies to an async task, the `Await` expression is in a `Try` block of the caller, and the exception is caught in the `Catch` block.</span></span>  
  
 <span data-ttu-id="4ca78-249">取消註解範例中的 `Throw New Exception` 行來示範例外狀況處理。</span><span class="sxs-lookup"><span data-stu-id="4ca78-249">Uncomment the `Throw New Exception` line in the example to demonstrate exception handling.</span></span> <span data-ttu-id="4ca78-250">中攔截例外狀況`Catch`封鎖工作的`IsFaulted`屬性設定為`True`，以及使用 「 工作`Exception.InnerException`屬性設定為例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-250">The exception is caught in the `Catch` block, the task's `IsFaulted` property is set to `True`, and the task's `Exception.InnerException` property is set to the exception.</span></span>  
  
 <span data-ttu-id="4ca78-251">取消註解 `Throw New OperationCancelledException` 行來示範取消非同步處理序時會發生的情況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-251">Uncomment the `Throw New OperationCancelledException` line to demonstrate what happens when you cancel an asynchronous process.</span></span> <span data-ttu-id="4ca78-252">中攔截例外狀況`Catch`區塊，以及工作的`IsCanceled`屬性設定為`True`。</span><span class="sxs-lookup"><span data-stu-id="4ca78-252">The exception is caught in the `Catch` block, and the task's `IsCanceled` property is set to `True`.</span></span> <span data-ttu-id="4ca78-253">不過，在不適用於此範例中，某些情況下`IsFaulted`設`True`和`IsCanceled`設`False`。</span><span class="sxs-lookup"><span data-stu-id="4ca78-253">However, under some conditions that don't apply to this example, `IsFaulted` is set to `True` and `IsCanceled` is set to `False`.</span></span>  
  
 [!code-vb[csAsyncExceptions#1](../../../csharp/language-reference/keywords/codesnippet/VisualBasic/try-catch-finally-statement_7.vb)]  
  
## <a name="example"></a><span data-ttu-id="4ca78-254">範例</span><span class="sxs-lookup"><span data-stu-id="4ca78-254">Example</span></span>  
 <span data-ttu-id="4ca78-255">下列範例說明多項工作可能會導致多個例外狀況的例外狀況處理。</span><span class="sxs-lookup"><span data-stu-id="4ca78-255">The following example illustrates exception handling where multiple tasks can result in multiple exceptions.</span></span> <span data-ttu-id="4ca78-256">`Try`區塊都具有`Await`工作的運算式，<xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>傳回。</span><span class="sxs-lookup"><span data-stu-id="4ca78-256">The `Try` block has the `Await` expression for the task that <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> returned.</span></span> <span data-ttu-id="4ca78-257">工作已完成的三個工作的<xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType>套用都已完成。</span><span class="sxs-lookup"><span data-stu-id="4ca78-257">The task is complete when the three tasks to which <xref:System.Threading.Tasks.Task.WhenAll%2A?displayProperty=nameWithType> is applied are complete.</span></span>  
  
 <span data-ttu-id="4ca78-258">這三個工作都會造成例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4ca78-258">Each of the three tasks causes an exception.</span></span> <span data-ttu-id="4ca78-259">`Catch`區塊逐一查看例外狀況，在找到`Exception.InnerExceptions`工作的屬性，`Task.WhenAll`傳回。</span><span class="sxs-lookup"><span data-stu-id="4ca78-259">The `Catch` block iterates through the exceptions, which are found in the `Exception.InnerExceptions` property of the task that `Task.WhenAll` returned.</span></span>  
  
 [!code-vb[csAsyncExceptions#3](../../../csharp/language-reference/keywords/codesnippet/VisualBasic/try-catch-finally-statement_8.vb)]  
  
## <a name="see-also"></a><span data-ttu-id="4ca78-260">另請參閱</span><span class="sxs-lookup"><span data-stu-id="4ca78-260">See Also</span></span>  
 <xref:Microsoft.VisualBasic.Information.Err%2A>  
 <xref:System.Exception>  
 [<span data-ttu-id="4ca78-261">Exit 陳述式</span><span class="sxs-lookup"><span data-stu-id="4ca78-261">Exit Statement</span></span>](../../../visual-basic/language-reference/statements/exit-statement.md)  
 [<span data-ttu-id="4ca78-262">On Error 陳述式</span><span class="sxs-lookup"><span data-stu-id="4ca78-262">On Error Statement</span></span>](../../../visual-basic/language-reference/statements/on-error-statement.md)  
 [<span data-ttu-id="4ca78-263">使用程式碼片段的最佳作法</span><span class="sxs-lookup"><span data-stu-id="4ca78-263">Best Practices for Using Code Snippets</span></span>](/visualstudio/ide/best-practices-for-using-code-snippets)  
 [<span data-ttu-id="4ca78-264">例外狀況處理</span><span class="sxs-lookup"><span data-stu-id="4ca78-264">Exception Handling</span></span>](../../../../docs/standard/parallel-programming/exception-handling-task-parallel-library.md)  
 [<span data-ttu-id="4ca78-265">Throw 陳述式</span><span class="sxs-lookup"><span data-stu-id="4ca78-265">Throw Statement</span></span>](../../../visual-basic/language-reference/statements/throw-statement.md)
