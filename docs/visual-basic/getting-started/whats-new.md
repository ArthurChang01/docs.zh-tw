---
title: Visual Basic 的新功能
ms.date: 02/15/2018
ms.prod: .net
ms.technology:
- devlang-visual-basic
ms.topic: article
f1_keywords:
- VB.StartPage.WhatsNew
helpviewer_keywords:
- new features, Visual Basic
- what's new [Visual Basic]
- Visual Basic, what's new
ms.assetid: d7e97396-7f42-4873-a81c-4ebcc4b6ca02
caps.latest.revision: 145
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: 34c7e7147ce7ae43926de1796bee433667f08331
ms.sourcegitcommit: 86adcc06e35390f13c1e372c36d2e044f1fc31ef
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/26/2018
---
# <a name="whats-new-for-visual-basic"></a><span data-ttu-id="a20cc-102">Visual Basic 的新功能</span><span class="sxs-lookup"><span data-stu-id="a20cc-102">What's new for Visual Basic</span></span>

<span data-ttu-id="a20cc-103">本主題列出每個 Visual Basic 版本的主要功能名稱，並詳細說明該語言最新版本的新功能和增強功能。</span><span class="sxs-lookup"><span data-stu-id="a20cc-103">This topic lists key feature names for each version of Visual Basic, with detailed descriptions of the new and enhanced features in the lastest version of the language.</span></span>
  
## <a name="current-version"></a><span data-ttu-id="a20cc-104">目前版本</span><span class="sxs-lookup"><span data-stu-id="a20cc-104">Current Version</span></span>

<span data-ttu-id="a20cc-105">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="a20cc-105">Visual Basic 15.5</span></span>   
<span data-ttu-id="a20cc-106">如需了解新功能，請參閱 [Visual Basic 15.5](#visual-basic-155)</span><span class="sxs-lookup"><span data-stu-id="a20cc-106">For new features, see [Visual Basic 15.5](#visual-basic-155)</span></span>

## <a name="previous-versions"></a><span data-ttu-id="a20cc-107">舊版本</span><span class="sxs-lookup"><span data-stu-id="a20cc-107">Previous versions</span></span>

<span data-ttu-id="a20cc-108">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="a20cc-108">Visual Basic 15.3</span></span>   
<span data-ttu-id="a20cc-109">如需了解新功能，請參閱 [Visual Basic 15.3](#visual-basic-153)</span><span class="sxs-lookup"><span data-stu-id="a20cc-109">For new features, see [Visual Basic 15.3](#visual-basic-153)</span></span>

<span data-ttu-id="a20cc-110">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="a20cc-110">Visual Basic 2017</span></span>   
<span data-ttu-id="a20cc-111">如需了解新功能，請參閱 [Visual Basic 2017](#visual-basic-2017)。</span><span class="sxs-lookup"><span data-stu-id="a20cc-111">For new features, see [Visual Basic 2017](#visual-basic-2017)</span></span>

<span data-ttu-id="a20cc-112">Visual Basic / Visual Studio .NET 2015</span><span class="sxs-lookup"><span data-stu-id="a20cc-112">Visual Basic / Visual Studio .NET 2015</span></span>   
<span data-ttu-id="a20cc-113">如需了解新功能，請參閱 [Visual Basic 14](#visual-basic-14)。</span><span class="sxs-lookup"><span data-stu-id="a20cc-113">For new features, see [Visual Basic 14](#visual-basic-14)</span></span>

<span data-ttu-id="a20cc-114">Visual Basic / Visual Studio .NET 2013</span><span class="sxs-lookup"><span data-stu-id="a20cc-114">Visual Basic / Visual Studio .NET 2013</span></span>  
<span data-ttu-id="a20cc-115">.NET 編譯器平台 ("Roslyn") 的技術預覽</span><span class="sxs-lookup"><span data-stu-id="a20cc-115">Technology previews of the .NET Compiler Platform (“Roslyn”)</span></span>

<span data-ttu-id="a20cc-116">Visual Basic / Visual Studio .NET 2012</span><span class="sxs-lookup"><span data-stu-id="a20cc-116">Visual Basic / Visual Studio .NET 2012</span></span>   
<span data-ttu-id="a20cc-117">`Async` 和 `await` 關鍵字、迭代器、呼叫端資訊屬性</span><span class="sxs-lookup"><span data-stu-id="a20cc-117">`Async` and `await` keywords, iterators, caller info attributes</span></span>

<span data-ttu-id="a20cc-118">Visual Basic / Visual Studio .NET 2010</span><span class="sxs-lookup"><span data-stu-id="a20cc-118">Visual Basic, Visual Studio .NET 2010</span></span>   
<span data-ttu-id="a20cc-119">自動實作的屬性、集合初始設定式、隱含行接續符號、動態、泛型共變數/反變數、全域命名空間存取</span><span class="sxs-lookup"><span data-stu-id="a20cc-119">Auto-implemented properties, collection initializers, implicit line continuation, dynamic, generic co/contra variance, global namespace access</span></span>

<span data-ttu-id="a20cc-120">Visual Basic / Visual Studio .NET 2008</span><span class="sxs-lookup"><span data-stu-id="a20cc-120">Visual Basic / Visual Studio .NET 2008</span></span>   
<span data-ttu-id="a20cc-121">Language Integrated Query (LINQ)、XML 常值、區域類型推斷、物件初始設定式、匿名類型、擴充方法、區域 `var` 類型推斷、Lambda 運算式、`if` 運算子、部分方法、可為 Null 的實值類型</span><span class="sxs-lookup"><span data-stu-id="a20cc-121">Language Integrated Query (LINQ), XML literals, local type inference, object initializers, anonymous types, extension methods, local `var` type inference, lambda expressions, `if` operator, partial methods, nullable value types</span></span>  

<span data-ttu-id="a20cc-122">Visual Basic / Visual Studio .NET 2005</span><span class="sxs-lookup"><span data-stu-id="a20cc-122">Visual Basic / Visual Studio .NET 2005</span></span>   
<span data-ttu-id="a20cc-123">`My` 類型和協助程式類型 (應用程式、電腦、檔案系統、網路的存取)</span><span class="sxs-lookup"><span data-stu-id="a20cc-123">The `My` type and helper types (access to app, computer, files system, network)</span></span>

<span data-ttu-id="a20cc-124">Visual Basic / Visual Studio .NET 2003</span><span class="sxs-lookup"><span data-stu-id="a20cc-124">Visual Basic / Visual Studio .NET 2003</span></span>   
<span data-ttu-id="a20cc-125">位元移位運算子、迴圈變數宣告</span><span class="sxs-lookup"><span data-stu-id="a20cc-125">Bit-shift operators, loop variable declaration</span></span>

<span data-ttu-id="a20cc-126">Visual Basic / Visual Studio .NET 2002</span><span class="sxs-lookup"><span data-stu-id="a20cc-126">Visual Basic / Visual Studio .NET 2002</span></span>   
<span data-ttu-id="a20cc-127">第一版的 Visual Basic .NET</span><span class="sxs-lookup"><span data-stu-id="a20cc-127">The first release of Visual Basic .NET</span></span>

## <a name="visual-basic-155"></a><span data-ttu-id="a20cc-128">Visual Basic 15.5</span><span class="sxs-lookup"><span data-stu-id="a20cc-128">Visual Basic 15.5</span></span>

[<span data-ttu-id="a20cc-129">無後置具名引數</span><span class="sxs-lookup"><span data-stu-id="a20cc-129">Non-trailing named arguments</span></span>](../programming-guide/language-features/procedures/passing-arguments-by-position-and-by-name.md#mixing-arguments-by-position-and-by-name)

<span data-ttu-id="a20cc-130">在 Visual Basic 15.3 和更早版本中，當方法呼叫同時包含位置和名稱引數時，位置引數必須在具名引數之前。</span><span class="sxs-lookup"><span data-stu-id="a20cc-130">In Visual Basic 15.3 and earlier versions, when a method call included arguments both by position and by name, positional arguments had to precede named arguments.</span></span> <span data-ttu-id="a20cc-131">從 Visual Basic 15.5 開始，位置和具名引數可依任何順序顯示，但前提是最後一個位置引數之前的所有引數都位於正確位置。</span><span class="sxs-lookup"><span data-stu-id="a20cc-131">Starting with Visual Basic 15.5, positional and named arguments can appear in any order as long as all arguments up to the last positional argument are in the correct position.</span></span> <span data-ttu-id="a20cc-132">當使用具名引數讓程式碼更容易閱讀時，這會特別有用。</span><span class="sxs-lookup"><span data-stu-id="a20cc-132">This is particularly useful when named arguments are used to make code more readable.</span></span>

<span data-ttu-id="a20cc-133">例如，下列方法呼叫在具名引數之間有兩個位置引數。</span><span class="sxs-lookup"><span data-stu-id="a20cc-133">For example, the following method call has two positional arguments between a named argument.</span></span> <span data-ttu-id="a20cc-134">具名引數清楚指出值 19 表示年齡。</span><span class="sxs-lookup"><span data-stu-id="a20cc-134">The named argument makes it clear that the value 19 represents an age.</span></span>

```vb
StudentInfo.Display("Mary", age:=19, #9/21/1998#)
```

<span data-ttu-id="a20cc-135">**前置十六進位/二進位/八進位分隔符號**</span><span class="sxs-lookup"><span data-stu-id="a20cc-135">**Leading hex/binary/octal separator**</span></span>

<span data-ttu-id="a20cc-136">Visual Basic 2017 新增了將底線字元 (`_`) 當作數字分隔符號的支援。</span><span class="sxs-lookup"><span data-stu-id="a20cc-136">Visual Basic 2017 added support for the underscore character (`_`) as a digit separator.</span></span> <span data-ttu-id="a20cc-137">從 Visual Basic 15.5 開始，您可以使用底線字元作為前置字元與十六進位、二進位或八進位數字之間的前置分隔符號。</span><span class="sxs-lookup"><span data-stu-id="a20cc-137">Starting with Visual Basic 15.5, you can use the underscore character as a leading separator between the prefix and hexadecimal, binary, or octal digits.</span></span> <span data-ttu-id="a20cc-138">下列範例使用前置數字分隔符號，將 3,271,948,384 定義為十六進位數字：</span><span class="sxs-lookup"><span data-stu-id="a20cc-138">The following example uses a leading digit separator to define 3,271,948,384 as a hexadecimal number:</span></span>

```vb
Dim number As Integer = &H_C305_F860
``` 
<span data-ttu-id="a20cc-139">若要使用底線字元作為前置分隔符號，您必須將下列項目新增至 Visual Basic 專案 (\*.vbproj) 檔：</span><span class="sxs-lookup"><span data-stu-id="a20cc-139">To use the underscore character as a leading separator, you must add the following element to your Visual Basic project (\*.vbproj) file:</span></span>

```xml
<PropertyGroup>
  <LangVersion>15.5</LangVersion>
</PropertyGroup>
```

## <a name="visual-basic-153"></a><span data-ttu-id="a20cc-140">Visual Basic 15.3</span><span class="sxs-lookup"><span data-stu-id="a20cc-140">Visual Basic 15.3</span></span>

[<span data-ttu-id="a20cc-141">**具名元組推斷**</span><span class="sxs-lookup"><span data-stu-id="a20cc-141">**Named tuple inference**</span></span>](../programming-guide/language-features/data-types/tuples.md#inferred-tuple-element-names)

<span data-ttu-id="a20cc-142">當您從變數指派元組項目值時，Visual Basic 會從對應的變數名稱推斷元組項目的名稱；您不需要明確命名元組項目。</span><span class="sxs-lookup"><span data-stu-id="a20cc-142">When you assign the value of tuple elements from variables, Visual Basic infers the name of tuple elements from the corresponding variable names; you do not have to explicitly name a tuple element.</span></span> <span data-ttu-id="a20cc-143">下列範例使用推斷來建立包含三個具名項目的元組：`state`、`stateName` 和 `capital`。</span><span class="sxs-lookup"><span data-stu-id="a20cc-143">The following example uses inference to create a tuple with three named elements, `state`, `stateName`, and `capital`.</span></span>

[!code-vb[Inferred tuple names](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/named-tuples/program.vb#2)]

<span data-ttu-id="a20cc-144">**其他編譯器參數**</span><span class="sxs-lookup"><span data-stu-id="a20cc-144">**Additional compiler switches**</span></span>  

<span data-ttu-id="a20cc-145">Visual Basic 命令列編譯器現在支援 [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) 和 [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) 編譯器選項，來控制參考組件的輸出。</span><span class="sxs-lookup"><span data-stu-id="a20cc-145">The Visual Basic command-line compiler now supports the [**-refout**](../reference/command-line-compiler/refout-compiler-option.md) and [**-refonly**](../reference/command-line-compiler/refonly-compiler-option.md) compiler options to control the output of reference assemblies.</span></span> <span data-ttu-id="a20cc-146">**-refout** 定義參考組件的輸出目錄，而 **-refonly** 指定編譯只會輸出參考組件。</span><span class="sxs-lookup"><span data-stu-id="a20cc-146">**-refout** defines the output directory of the reference assembly, and **-refonly** specifies that only a reference assembly is to be output by compilation.</span></span>

## <a name="visual-basic-2017"></a><span data-ttu-id="a20cc-147">Visual Basic 2017</span><span class="sxs-lookup"><span data-stu-id="a20cc-147">Visual Basic 2017</span></span>

[<span data-ttu-id="a20cc-148">**Tuple**</span><span class="sxs-lookup"><span data-stu-id="a20cc-148">**Tuples**</span></span>](../programming-guide/language-features/data-types/tuples.md)

<span data-ttu-id="a20cc-149">Tuple 是輕量的資料結構，最常用於從單一方法呼叫傳回多個值。</span><span class="sxs-lookup"><span data-stu-id="a20cc-149">Tuples are a lightweight data structure that most commonly is used to return multiple values from a single method call.</span></span> <span data-ttu-id="a20cc-150">通常要從方法傳回多個值，您必須執行下列其中一項︰</span><span class="sxs-lookup"><span data-stu-id="a20cc-150">Ordinarily, to return multiple values from a method, you have to do one of the following:</span></span>

- <span data-ttu-id="a20cc-151">定義自訂類型 (`Class` 或 `Structure`)。</span><span class="sxs-lookup"><span data-stu-id="a20cc-151">Define a custom type (a `Class` or a `Structure`).</span></span> <span data-ttu-id="a20cc-152">這是重量級解決方案。</span><span class="sxs-lookup"><span data-stu-id="a20cc-152">This is a heavyweight solution.</span></span>

- <span data-ttu-id="a20cc-153">除了從方法傳回值外，定義一或多個 `ByRef` 參數。</span><span class="sxs-lookup"><span data-stu-id="a20cc-153">Define one or more `ByRef` parameters, in addition to returning a value from the method.</span></span>
 
<span data-ttu-id="a20cc-154">Tuple 的 Visual Basic 支援可讓您快速定義 Tuple、選擇性地將語意名稱指派給它的值，並快速地擷取其值。</span><span class="sxs-lookup"><span data-stu-id="a20cc-154">Visual Basic's support for tuples lets you quickly define a tuple, optionally assign semantic names to its values, and quickly retrieve its values.</span></span> <span data-ttu-id="a20cc-155">下列範例會包裝對 <xref:System.Int32.TryParse%2A> 方法的呼叫，並傳回 Tuple。</span><span class="sxs-lookup"><span data-stu-id="a20cc-155">The following example wraps a call to the <xref:System.Int32.TryParse%2A> method and returns a tuple.</span></span>

[!code-vb[Tuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#2)]

<span data-ttu-id="a20cc-156">然後呼叫方法並使用類似下面的程式碼處理傳回的 Tuple。</span><span class="sxs-lookup"><span data-stu-id="a20cc-156">You can then call the method and handle the returned tuple with code like the following.</span></span>

[!code-vb[ReturnTuple](../../../samples/snippets/visualbasic/programming-guide/language-features/data-types/tuple-returns.vb#3)] 

<span data-ttu-id="a20cc-157">**二進位常值和數字分隔符號**</span><span class="sxs-lookup"><span data-stu-id="a20cc-157">**Binary literals and digit separators**</span></span>

<span data-ttu-id="a20cc-158">您可以使用前置詞 `&B` 或 `&b` 來定義二進位常值。</span><span class="sxs-lookup"><span data-stu-id="a20cc-158">You can define a binary literal by using the prefix `&B` or `&b`.</span></span> <span data-ttu-id="a20cc-159">此外，還可以使用底線字元 `_` 當作數字分隔符號，提升可讀性。</span><span class="sxs-lookup"><span data-stu-id="a20cc-159">In addition, you can use the underscore character, `_`, as a digit separator to enhance readability.</span></span> <span data-ttu-id="a20cc-160">下列範例會使用這兩種功能指派 `Byte` 值，並將它顯示為十進位、十六進位和二進位數字。</span><span class="sxs-lookup"><span data-stu-id="a20cc-160">The following example uses both features to assign a `Byte` value and to display it as a decimal, hexadecimal, and binary number.</span></span>

[!code-vb[Binary](../../../samples/snippets/visualbasic/getting-started/bin-example.vb#1)]

<span data-ttu-id="a20cc-161">如需詳細資訊，請參閱 [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments)、[Integer](../language-reference/data-types/integer-data-type.md#literal-assignments)、[Long](../language-reference/data-types/long-data-type.md#literal-assignments)、[Short](../language-reference/data-types/short-data-type.md#literal-assignments)、[SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments)、[UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments)、[ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments) 和 [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) 資料類型的＜常值指派＞一節。</span><span class="sxs-lookup"><span data-stu-id="a20cc-161">For more information, see the "Literal assignments" section of the [Byte](../language-reference/data-types/byte-data-type.md#literal-assignments), [Integer](../language-reference/data-types/integer-data-type.md#literal-assignments), [Long](../language-reference/data-types/long-data-type.md#literal-assignments), [Short](../language-reference/data-types/short-data-type.md#literal-assignments), [SByte](../language-reference/data-types/sbyte-data-type.md#literal-assignments), [UInteger](../language-reference/data-types/uinteger-data-type.md#literal-assignments), [ULong](../language-reference/data-types/ulong-data-type.md#literal-assignments), and [UShort](../language-reference/data-types/ushort-data-type.md#literal-assignments) data types.</span></span>

<span data-ttu-id="a20cc-162">**C# 參考傳回值的支援**</span><span class="sxs-lookup"><span data-stu-id="a20cc-162">**Support for C# reference return values**</span></span>

<span data-ttu-id="a20cc-163">從 C# 7.0 開始，C# 支援參考傳回值。</span><span class="sxs-lookup"><span data-stu-id="a20cc-163">Starting with C# 7.0, C# supports reference return values.</span></span> <span data-ttu-id="a20cc-164">也就是說，當呼叫方法收到參考傳回的值時，它可以變更參考的值。</span><span class="sxs-lookup"><span data-stu-id="a20cc-164">That is, when the calling method receives a value returned by reference, it can change the value of the reference.</span></span> <span data-ttu-id="a20cc-165">Visual Basic 不允許您撰寫使用參考傳回值的方法，但允許您使用和修改參考傳回值。</span><span class="sxs-lookup"><span data-stu-id="a20cc-165">Visual Basic does not allow you to author methods with reference return values, but it does allow you to consume and modify the reference return values.</span></span>

<span data-ttu-id="a20cc-166">例如，以 C# 撰寫的下列 `Sentence` 類別包含 `FindNext` 方法，它可以在句子中尋找以指定子字串開頭的下一個文字。</span><span class="sxs-lookup"><span data-stu-id="a20cc-166">For example, the following `Sentence` class written in C# includes a `FindNext` method that finds the next word in a sentence that begins with a specified substring.</span></span> <span data-ttu-id="a20cc-167">字串會以參考傳回值傳回，而參考所傳遞至方法的 `Boolean` 變數會指出搜尋是否成功。</span><span class="sxs-lookup"><span data-stu-id="a20cc-167">The string is returned as a reference return value, and a `Boolean` variable passed by reference to the method indicates whether the search was successful.</span></span> <span data-ttu-id="a20cc-168">這表示，呼叫端不只可以讀取傳回值，還可以修改它，再將修改結果反映在 `Sentence` 類別中。</span><span class="sxs-lookup"><span data-stu-id="a20cc-168">This means that the caller can not only read the returned value; he or she can also modify it, and that modification is reflected in the `Sentence` class.</span></span>

[!code-csharp[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-returns.cs)]

<span data-ttu-id="a20cc-169">在最簡單的格式中，您可以使用類似下列的程式碼，修改句子中找到的字。</span><span class="sxs-lookup"><span data-stu-id="a20cc-169">In its simplest form, you can modify the word found in the sentence by using code like the following.</span></span> <span data-ttu-id="a20cc-170">請注意，您不是將值指派給方法，而是指派給方法傳回的運算式，也就是參考傳回值。</span><span class="sxs-lookup"><span data-stu-id="a20cc-170">Note that you are not assigning a value to the method, but rather to the expression that the method returns, which is the reference return value.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#1)]

<span data-ttu-id="a20cc-171">但此程式碼有個問題，亦即如果找不到相符的項目，方法會傳回第一個字。</span><span class="sxs-lookup"><span data-stu-id="a20cc-171">A problem with this code, though, is that if a match is not found, the method returns the first word.</span></span> <span data-ttu-id="a20cc-172">因為範例不會檢查 `Boolean` 引數的值來判斷是否找到相符項目，所以如果找不到相符的項目，就會修改第一個字。</span><span class="sxs-lookup"><span data-stu-id="a20cc-172">Since the example does not examine the value of the `Boolean` argument to determine whether a match is found, it modifies the first word if there is no match.</span></span> <span data-ttu-id="a20cc-173">如果找不到相符的項目，下列範例會用本身來取代第一個字，藉此更正這個問題。</span><span class="sxs-lookup"><span data-stu-id="a20cc-173">The following example corrects this by replacing the first word with itself if there is no match.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return.vb#2)]

<span data-ttu-id="a20cc-174">更好的解決方案是使用參考所傳遞之參考傳回值對象的協助程式方法。</span><span class="sxs-lookup"><span data-stu-id="a20cc-174">A better solution is to use a helper method to which the reference return value is passed by reference.</span></span> <span data-ttu-id="a20cc-175">協助程式方法可以修改參考所傳遞給它的引數。</span><span class="sxs-lookup"><span data-stu-id="a20cc-175">The helper method can then modify the argument passed to it by reference.</span></span> <span data-ttu-id="a20cc-176">下列範例正是如此。</span><span class="sxs-lookup"><span data-stu-id="a20cc-176">The following example does that.</span></span>

[!code-vb[Ref-Return](../../../samples/snippets/visualbasic/getting-started/ref-return-helper.vb#1)]

<span data-ttu-id="a20cc-177">如需詳細資訊，請參閱[參考傳回值](../programming-guide/language-features/procedures/ref-return-values.md)。</span><span class="sxs-lookup"><span data-stu-id="a20cc-177">For more information, see [Reference Return Values](../programming-guide/language-features/procedures/ref-return-values.md).</span></span>

## <a name="visual-basic-14"></a><span data-ttu-id="a20cc-178">Visual Basic 14</span><span class="sxs-lookup"><span data-stu-id="a20cc-178">Visual Basic 14</span></span>

[<span data-ttu-id="a20cc-179">Nameof</span><span class="sxs-lookup"><span data-stu-id="a20cc-179">Nameof</span></span>](../../csharp/language-reference/keywords/nameof.md)  
 <span data-ttu-id="a20cc-180">您可以取得用於錯誤訊息之類型或成員的未限定字串名稱，而不需要對字串進行硬式編碼。</span><span class="sxs-lookup"><span data-stu-id="a20cc-180">You can get the unqualified string name of a type or member for use in an error message without hard coding a string.</span></span>  <span data-ttu-id="a20cc-181">這可讓您的程式碼在重構時保持正確。</span><span class="sxs-lookup"><span data-stu-id="a20cc-181">This allows your code to remain correct when refactoring.</span></span>  <span data-ttu-id="a20cc-182">這項功能也可用來連接模型檢視控制器 MVC 連結，以及引發屬性已變更事件。</span><span class="sxs-lookup"><span data-stu-id="a20cc-182">This feature is also useful for hooking up model-view-controller MVC links and firing property changed events.</span></span>  
  
[<span data-ttu-id="a20cc-183">字串內插補點</span><span class="sxs-lookup"><span data-stu-id="a20cc-183">String Interpolation</span></span>](../../visual-basic/programming-guide/language-features/strings/interpolated-strings.md)  
 <span data-ttu-id="a20cc-184">您可以使用字串插值運算式來建構字串。</span><span class="sxs-lookup"><span data-stu-id="a20cc-184">You can use string interpolation expressions to construct strings.</span></span>  <span data-ttu-id="a20cc-185">字串插值運算式類似包含運算式的範本字串。</span><span class="sxs-lookup"><span data-stu-id="a20cc-185">An interpolated string expression looks like a template string that contains expressions.</span></span>  <span data-ttu-id="a20cc-186">對於引數而言，字串插值比[複合格式](../../standard/base-types/composite-format.md)更容易了解。</span><span class="sxs-lookup"><span data-stu-id="a20cc-186">An interpolated string is easier to understand with respect to arguments than [Composite Formatting](../../standard/base-types/composite-format.md).</span></span>  
  
[<span data-ttu-id="a20cc-187">Null 條件式成員存取和索引</span><span class="sxs-lookup"><span data-stu-id="a20cc-187">Null-conditional Member Access and Indexing</span></span>](../../csharp/language-reference/operators/null-conditional-operators.md)  
<span data-ttu-id="a20cc-188">您可以在執行成員存取 (`?.`) 或對 (`?[]`) 作業編製索引之前，透過非常精簡的語法來測試是否為 Null。</span><span class="sxs-lookup"><span data-stu-id="a20cc-188">You can test for null in a very light syntactic way before performing a member access (`?.`) or index (`?[]`) operation.</span></span>  <span data-ttu-id="a20cc-189">這些運算子可協助您撰寫較少的程式碼來處理 Null 檢查，特別是遞減至資料結構。</span><span class="sxs-lookup"><span data-stu-id="a20cc-189">These operators help you write less code to handle null checks, especially for descending into data structures.</span></span>  <span data-ttu-id="a20cc-190">如果左運算元或物件參考為 Null，則作業會傳回 Null。</span><span class="sxs-lookup"><span data-stu-id="a20cc-190">If the left operand or object reference is null, the operations returns null.</span></span>  
  
[<span data-ttu-id="a20cc-191">多行字串常值</span><span class="sxs-lookup"><span data-stu-id="a20cc-191">Multi-line String Literals</span></span>](../../visual-basic/programming-guide/language-features/strings/string-basics.md)  
 <span data-ttu-id="a20cc-192">字串常值可包含新行字元序列。</span><span class="sxs-lookup"><span data-stu-id="a20cc-192">String literals can contain newline sequences.</span></span>  <span data-ttu-id="a20cc-193">您不再需要使用 `<xml><![CDATA[...text with newlines...]]></xml>.Value` 的舊解決方法</span><span class="sxs-lookup"><span data-stu-id="a20cc-193">You no longer need the old work around of using `<xml><![CDATA[...text with newlines...]]></xml>.Value`</span></span>  
  
<span data-ttu-id="a20cc-194">註解</span><span class="sxs-lookup"><span data-stu-id="a20cc-194">Comments</span></span>  
<span data-ttu-id="a20cc-195">您可以將註解放到隱含行接續符號之後、初始設定式運算式之內和 LINQ 運算式詞彙之間。</span><span class="sxs-lookup"><span data-stu-id="a20cc-195">You can put comments after implicit line continuations, inside initializer expressions, and amongst LINQ expression terms.</span></span>  
  
 <span data-ttu-id="a20cc-196">更聰明的完整名稱解析</span><span class="sxs-lookup"><span data-stu-id="a20cc-196">Smarter Fully-qualified Name Resolution</span></span>  
 <span data-ttu-id="a20cc-197">以程式碼 `Threading.Thread.Sleep(1000)` 為例，Visual Basic 之前會查詢命名空間 "Threading"，發現它在 System.Threading 和 System.Windows.Threading 之間模稜兩可，然後回報錯誤。</span><span class="sxs-lookup"><span data-stu-id="a20cc-197">Given code such as `Threading.Thread.Sleep(1000)`, Visual Basic used to look up the namespace "Threading", discover it was ambiguous between System.Threading and System.Windows.Threading, and then report an error.</span></span>  <span data-ttu-id="a20cc-198">Visual Basic 現在會同時考慮這兩種可能的命名空間。</span><span class="sxs-lookup"><span data-stu-id="a20cc-198">Visual Basic now considers both possible namespaces together.</span></span>  <span data-ttu-id="a20cc-199">如果您顯示完成清單，Visual Studio 編輯器會在完成清單中列出這兩種類型的成員。</span><span class="sxs-lookup"><span data-stu-id="a20cc-199">If you show the completion list, the Visual Studio editor lists members from both types in the completion list.</span></span>  
  
 <span data-ttu-id="a20cc-200">以年起始的日期常值</span><span class="sxs-lookup"><span data-stu-id="a20cc-200">Year-first Date Literals</span></span>  
 <span data-ttu-id="a20cc-201">您可以有 yyyy-mm-dd 格式的日期常值 (`#2015-03-17 16:10 PM#`)。</span><span class="sxs-lookup"><span data-stu-id="a20cc-201">You can have date literals in yyyy-mm-dd format, `#2015-03-17 16:10 PM#`.</span></span>  
  
 <span data-ttu-id="a20cc-202">唯讀介面屬性</span><span class="sxs-lookup"><span data-stu-id="a20cc-202">Readonly Interface Properties</span></span>  
 <span data-ttu-id="a20cc-203">您可以使用讀寫屬性來實作唯讀介面屬性。</span><span class="sxs-lookup"><span data-stu-id="a20cc-203">You can implement readonly interface properties using a readwrite property.</span></span>  <span data-ttu-id="a20cc-204">這個介面可確保提供基本功能，並且不會防止實作類別允許設定屬性。</span><span class="sxs-lookup"><span data-stu-id="a20cc-204">The interface guarantees minimum functionality, and it does not stop an implementing class from allowing the property to be set.</span></span>  
  
 [<span data-ttu-id="a20cc-205">TypeOf \<expr> IsNot \<類型></span><span class="sxs-lookup"><span data-stu-id="a20cc-205">TypeOf \<expr> IsNot \<type></span></span>](../../visual-basic/language-reference/operators/typeof-operator.md)  
 <span data-ttu-id="a20cc-206">為了增加程式碼的可讀性，您現在可以搭配使用 `TypeOf` 和 `IsNot`。</span><span class="sxs-lookup"><span data-stu-id="a20cc-206">For more readability of your code, you can now use `TypeOf` with `IsNot`.</span></span>  
  
 [<span data-ttu-id="a20cc-207">#Disable Warning \<識別碼> 和 #Enable Warning \<識別碼></span><span class="sxs-lookup"><span data-stu-id="a20cc-207">#Disable Warning \<ID> and #Enable Warning \<ID></span></span>](../../visual-basic/language-reference/directives/directives.md)  
 <span data-ttu-id="a20cc-208">您可以停用及啟用原始程式檔中區域的特定警告。</span><span class="sxs-lookup"><span data-stu-id="a20cc-208">You can disable and enable specific warnings for regions within a source file.</span></span>  
  
 <span data-ttu-id="a20cc-209">XML 文件註解增強功能</span><span class="sxs-lookup"><span data-stu-id="a20cc-209">XML Doc-comment Improvements</span></span>  
 <span data-ttu-id="a20cc-210">撰寫文件註解時，您會取得智慧型編輯器，以及驗證參數名稱、適當處理 `crefs` (泛型、運算子等)、色彩標示和重構的建置支援。</span><span class="sxs-lookup"><span data-stu-id="a20cc-210">When writing doc comments, you get smart editor and build support for validating parameter names, proper handling of `crefs` (generics, operators, etc.), colorizing, and refactoring.</span></span>  
  
 [<span data-ttu-id="a20cc-211">部分模組和介面定義</span><span class="sxs-lookup"><span data-stu-id="a20cc-211">Partial Module and Interface Definitions</span></span>](../../visual-basic/language-reference/modifiers/partial.md)  
 <span data-ttu-id="a20cc-212">除了類別和結構之外，您還可以宣告部分模組和介面。</span><span class="sxs-lookup"><span data-stu-id="a20cc-212">In addition to classes and structs, you can declare partial modules and interfaces.</span></span>  
  
 [<span data-ttu-id="a20cc-213">方法主體內的 #Region 指示詞</span><span class="sxs-lookup"><span data-stu-id="a20cc-213">#Region Directives inside Method Bodies</span></span>](../../visual-basic/language-reference/directives/region-directive.md)  
 <span data-ttu-id="a20cc-214">您可以將 #Region…#End Region 分隔符號放到檔案的任何位置及函式內，甚至是橫跨不同的函式主體。</span><span class="sxs-lookup"><span data-stu-id="a20cc-214">You can put #Region…#End Region delimiters anywhere in a file, inside functions, and even spanning across function bodies.</span></span>  
  
 [<span data-ttu-id="a20cc-215">Overrides 定義隱含為 Overloads</span><span class="sxs-lookup"><span data-stu-id="a20cc-215">Overrides Definitions are Implicitly Overloads</span></span>](../../visual-basic/language-reference/modifiers/overrides.md)  
 <span data-ttu-id="a20cc-216">如果您將 `Overrides` 修飾詞加入定義，編譯器會隱含加入 `Overloads`，讓您可以在一般情況下輸入較少的程式碼。</span><span class="sxs-lookup"><span data-stu-id="a20cc-216">If you add the `Overrides` modifier to a definition, the compiler implicitly adds `Overloads` so that you can type less code in common cases.</span></span>  
  
 <span data-ttu-id="a20cc-217">屬性引數允許 CObj</span><span class="sxs-lookup"><span data-stu-id="a20cc-217">CObj Allowed in Attributes Arguments</span></span>  
 <span data-ttu-id="a20cc-218">編譯器之前會提供錯誤，指出 CObj(…) 用於屬性建構時不是常數。</span><span class="sxs-lookup"><span data-stu-id="a20cc-218">The compiler used to give an error that CObj(…) was not a constant when used in attribute constructions.</span></span>  
  
 <span data-ttu-id="a20cc-219">從不同的介面宣告及使用模稜兩可的方法</span><span class="sxs-lookup"><span data-stu-id="a20cc-219">Declaring and Consuming Ambiguous Methods from Different Interfaces</span></span>  
 <span data-ttu-id="a20cc-220">之前，下列程式碼會產生錯誤，使您無法宣告 `IMock` 或呼叫 `GetDetails` (如果已在 C# 中宣告這些項目)：</span><span class="sxs-lookup"><span data-stu-id="a20cc-220">Previously the following code yielded errors that prevented you from declaring `IMock` or from calling `GetDetails` (if these had been declared in C#):</span></span>  
  
```vb  
Interface ICustomer  
  Sub GetDetails(x As Integer)  
End Interface  
  
Interface ITime  
  Sub GetDetails(x As String)  
End Interface  
  
Interface IMock : Inherits ICustomer, ITime  
  Overloads Sub GetDetails(x As Char)  
End Interface  
  
Interface IMock2 : Inherits ICustomer, ITime  
End Interface  
```  
  
 <span data-ttu-id="a20cc-221">現在，編譯器會使用一般多載解析規則來選擇要呼叫的最適合 `GetDetails`，而且您可以在 Visual Basic 中宣告介面關聯性 (如範例所示)。</span><span class="sxs-lookup"><span data-stu-id="a20cc-221">Now the compiler will use normal overload resolution rules to choose the most appropriate `GetDetails` to call, and you can declare interface relationships in Visual Basic like those shown in the sample.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a20cc-222">另請參閱</span><span class="sxs-lookup"><span data-stu-id="a20cc-222">See also</span></span>  
 [<span data-ttu-id="a20cc-223">Visual Studio 2017 的新功能</span><span class="sxs-lookup"><span data-stu-id="a20cc-223">What's New in Visual Studio 2017</span></span>](/visualstudio/ide/whats-new-in-visual-studio)
