---
title: 將 WPF 應用移到 .NET 核心 3.0
description: 瞭解如何將 Windows 演示文稿基礎 (WPF) 應用遷移到 .NET Core 3.0。
author: mjrousos
ms.date: 09/12/2019
ms.author: mikerou
ms.openlocfilehash: f52005e7c8a6312b8c4e09a950f1f635af1894e4
ms.sourcegitcommit: cdf5084648bf5e77970cbfeaa23f1cab3e6e234e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/01/2020
ms.locfileid: "82071308"
---
# <a name="migrating-wpf-apps-to-net-core"></a><span data-ttu-id="f22a2-103">將 WPF 應用移到 .NET 核心</span><span class="sxs-lookup"><span data-stu-id="f22a2-103">Migrating WPF apps to .NET Core</span></span>

<span data-ttu-id="f22a2-104">本文介紹將 Windows 演示文稿基礎 (WPF) 應用從 .NET 框架遷移到 .NET Core 3.0 所需的步驟。</span><span class="sxs-lookup"><span data-stu-id="f22a2-104">This article covers the steps necessary to migrate a Windows Presentation Foundation (WPF) app from .NET Framework to .NET Core 3.0.</span></span> <span data-ttu-id="f22a2-105">如果您手頭沒有 WPF 應用,但希望嘗試此過程,則可以使用[GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader)上可用的**Bean Trader**範例套用 。</span><span class="sxs-lookup"><span data-stu-id="f22a2-105">If you don't have a WPF app on hand to port, but would like to try out the process, you can use the **Bean Trader** sample app available on [GitHub](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader).</span></span> <span data-ttu-id="f22a2-106">原始應用程式(目標 .NET 框架 4.7.2)可在 NetFx_BeanTraderClient 資料夾中使用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-106">The original app (targeting .NET Framework 4.7.2) is available in the NetFx\BeanTraderClient folder.</span></span> <span data-ttu-id="f22a2-107">首先,我們將解釋移植應用程式所需的步驟,然後介紹適用於**Bean Trader**示例的特定更改。</span><span class="sxs-lookup"><span data-stu-id="f22a2-107">First we'll explain the steps necessary to port apps in general, and then we'll walk through the specific changes that apply to the **Bean Trader** sample.</span></span>

[!INCLUDE [desktop guide under construction](../../../includes/desktop-guide-preview-note.md)]

<span data-ttu-id="f22a2-108">要遷移到 .NET 核心,必須首先:</span><span class="sxs-lookup"><span data-stu-id="f22a2-108">To migrate to .NET Core, you must first:</span></span>

01. <span data-ttu-id="f22a2-109">瞭解並更新 NuGet 相依:</span><span class="sxs-lookup"><span data-stu-id="f22a2-109">Understand and update NuGet dependencies:</span></span>

    01. <span data-ttu-id="f22a2-110">升級 NuGet 依賴`<PackageReference>`項以 使用格式。</span><span class="sxs-lookup"><span data-stu-id="f22a2-110">Upgrade NuGet dependencies to use the `<PackageReference>` format.</span></span>
    01. <span data-ttu-id="f22a2-111">查看 .NET 核心或 .NET 標準相容性的頂級 NuGet 依賴項。</span><span class="sxs-lookup"><span data-stu-id="f22a2-111">Review top-level NuGet dependencies for .NET Core or .NET Standard compatibility.</span></span>
    01. <span data-ttu-id="f22a2-112">將 NuGet 包升級到較新版本。</span><span class="sxs-lookup"><span data-stu-id="f22a2-112">Upgrade NuGet packages to newer versions.</span></span>
    01. <span data-ttu-id="f22a2-113">使用[.NET 可移植性分析器](../../standard/analyzers/portability-analyzer.md)瞭解 .NET 依賴項。</span><span class="sxs-lookup"><span data-stu-id="f22a2-113">Use the [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) to understand .NET dependencies.</span></span>

01. <span data-ttu-id="f22a2-114">將專案檔案移到新的 SDK 樣式格式:</span><span class="sxs-lookup"><span data-stu-id="f22a2-114">Migrate the project file to the new SDK-style format:</span></span>

    01. <span data-ttu-id="f22a2-115">選擇是同時定位 .NET 核心和 .NET 框架,還是僅定位 .NET 核心。</span><span class="sxs-lookup"><span data-stu-id="f22a2-115">Choose whether to target both .NET Core and .NET Framework, or only .NET Core.</span></span>
    01. <span data-ttu-id="f22a2-116">將相關的專案檔屬性和項複製到新專案檔。</span><span class="sxs-lookup"><span data-stu-id="f22a2-116">Copy relevant project file properties and items to the new project file.</span></span>

01. <span data-ttu-id="f22a2-117">修復產生問題:</span><span class="sxs-lookup"><span data-stu-id="f22a2-117">Fix build issues:</span></span>

    01. <span data-ttu-id="f22a2-118">添加對[Microsoft.Windows.相容性](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/)包的引用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-118">Add a reference to the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility/) package.</span></span>
    01. <span data-ttu-id="f22a2-119">查找並修復 API 級別差異。</span><span class="sxs-lookup"><span data-stu-id="f22a2-119">Find and fix API-level differences.</span></span>
    01. <span data-ttu-id="f22a2-120">刪除`appSettings``connectionStrings`或以外的*應用.config*部分。</span><span class="sxs-lookup"><span data-stu-id="f22a2-120">Remove *app.config* sections other than `appSettings` or `connectionStrings`.</span></span>
    01. <span data-ttu-id="f22a2-121">如有必要,重新生成生成的代碼。</span><span class="sxs-lookup"><span data-stu-id="f22a2-121">Regenerate generated code, if necessary.</span></span>

01. <span data-ttu-id="f22a2-122">執行時測試:</span><span class="sxs-lookup"><span data-stu-id="f22a2-122">Runtime testing:</span></span>

    01. <span data-ttu-id="f22a2-123">確認移植的應用按預期工作。</span><span class="sxs-lookup"><span data-stu-id="f22a2-123">Confirm the ported app works as expected.</span></span>
    01. <span data-ttu-id="f22a2-124">注意<xref:System.NotSupportedException>例外情況。</span><span class="sxs-lookup"><span data-stu-id="f22a2-124">Beware of <xref:System.NotSupportedException> exceptions.</span></span>

## <a name="about-the-sample"></a><span data-ttu-id="f22a2-125">關於範例</span><span class="sxs-lookup"><span data-stu-id="f22a2-125">About the sample</span></span>

<span data-ttu-id="f22a2-126">本文引用[Bean Trader 範例應用](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader),因為它使用各種依賴項,類似於現實世界的 WPF 應用可能具有的依賴項。</span><span class="sxs-lookup"><span data-stu-id="f22a2-126">This article references the [Bean Trader sample app](https://github.com/dotnet/windows-desktop/tree/master/Samples/BeanTrader) because it uses a variety of dependencies similar to those that real-world WPF apps might have.</span></span> <span data-ttu-id="f22a2-127">該應用程式並不大,但在複雜性方面,它意味著從"你好世界"中邁出一步。</span><span class="sxs-lookup"><span data-stu-id="f22a2-127">The app isn't large, but is meant to be a step up from 'Hello World' in terms of complexity.</span></span> <span data-ttu-id="f22a2-128">該應用程式演示了使用者在移植實際應用時可能會遇到的一些問題。</span><span class="sxs-lookup"><span data-stu-id="f22a2-128">The app demonstrates some issues users may encounter while porting real apps.</span></span> <span data-ttu-id="f22a2-129">該應用程式與 WCF 服務通訊,因此要正常執行,您還需要運行 BeanTraderServer 專案(在同一 GitHub 儲存庫中可用),並確保 BeanTraderClient 配置指向正確的終結點。</span><span class="sxs-lookup"><span data-stu-id="f22a2-129">The app communicates with a WCF service, so for it to run properly, you'll also need to run the BeanTraderServer project (available in the same GitHub repository) and make sure the BeanTraderClient configuration points to the correct endpoint.</span></span> <span data-ttu-id="f22a2-130">(預設情況下,該範例假定伺服器在的同一台電腦上運行,*http://localhost:8090*如果您在本地啟動 BeanTraderServer,則為 true。</span><span class="sxs-lookup"><span data-stu-id="f22a2-130">(By default, the sample assumes the server is running on the same machine at *http://localhost:8090*, which will be true if you launch BeanTraderServer locally.)</span></span>

<span data-ttu-id="f22a2-131">請記住,此示例應用旨在演示 .NET Core 移植挑戰和解決方案。</span><span class="sxs-lookup"><span data-stu-id="f22a2-131">Keep in mind that this sample app is meant to demonstrate .NET Core porting challenges and solutions.</span></span> <span data-ttu-id="f22a2-132">它不是要演示 WPF 最佳實踐。</span><span class="sxs-lookup"><span data-stu-id="f22a2-132">It's not meant to demonstrate WPF best practices.</span></span> <span data-ttu-id="f22a2-133">事實上,它故意包括一些反模式,以確保你在移植時至少遇到幾個有趣的挑戰。</span><span class="sxs-lookup"><span data-stu-id="f22a2-133">In fact, it deliberately includes some anti-patterns to make sure you come across at least a couple of interesting challenges while porting.</span></span>

## <a name="getting-ready"></a><span data-ttu-id="f22a2-134">準備就緒</span><span class="sxs-lookup"><span data-stu-id="f22a2-134">Getting ready</span></span>

<span data-ttu-id="f22a2-135">將 .NET Framework 應用遷移到 .NET Core 的主要挑戰是其依賴項可能以不同的方式工作,或者根本不工作。</span><span class="sxs-lookup"><span data-stu-id="f22a2-135">The primary challenge of migrating a .NET Framework app to .NET Core is that its dependencies may work differently or not at all.</span></span> <span data-ttu-id="f22a2-136">遷移比過去容易得多;許多 NuGet 套件現在都針對 .NET 標準。</span><span class="sxs-lookup"><span data-stu-id="f22a2-136">Migration is much easier than it used to be; many NuGet packages now target .NET Standard.</span></span> <span data-ttu-id="f22a2-137">從 .NET Core 2.0 開始,.NET 框架和 .NET 核心曲面區域變得相似。</span><span class="sxs-lookup"><span data-stu-id="f22a2-137">Starting with .NET Core 2.0, the .NET Framework and .NET Core surface areas have become similar.</span></span> <span data-ttu-id="f22a2-138">即便如此,仍然存在一些差異(在 NuGet 包和可用的 .NET API 中支援方面)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-138">Even so, some differences (both in support from NuGet packages and in available .NET APIs) remain.</span></span> <span data-ttu-id="f22a2-139">遷移的第一步是查看應用的依賴項,並確保引用的格式易於遷移到 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="f22a2-139">The first step in migrating is to review the app's dependencies and make sure references are in a format that's easily migrated to .NET Core.</span></span>

### <a name="upgrade-to-packagereference-nuget-references"></a><span data-ttu-id="f22a2-140">升級到`<PackageReference>`NuGet 引用</span><span class="sxs-lookup"><span data-stu-id="f22a2-140">Upgrade to `<PackageReference>` NuGet references</span></span>

<span data-ttu-id="f22a2-141">較舊的 .NET 框架專案通常在*包*中列出其 NuGet 依賴項。</span><span class="sxs-lookup"><span data-stu-id="f22a2-141">Older .NET Framework projects typically list their NuGet dependencies in a *packages.config* file.</span></span> <span data-ttu-id="f22a2-142">新的 SDK 樣式的專案檔案格式將[`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files)NuGet 套件作為 csproj 檔本身中的元素引用,而不是在單獨的設定檔中。</span><span class="sxs-lookup"><span data-stu-id="f22a2-142">The new SDK-style project file format references NuGet packages as [`<PackageReference>`](/nuget/consume-packages/package-references-in-project-files) elements in the csproj file itself rather than in a separate config file.</span></span>

<span data-ttu-id="f22a2-143">移轉時,使用`<PackageReference>`-style 引用有兩個優點:</span><span class="sxs-lookup"><span data-stu-id="f22a2-143">When migrating, there are two advantages to using `<PackageReference>`-style references:</span></span>

- <span data-ttu-id="f22a2-144">這是新的 .NET Core 專案檔所需的 NuGet 引用樣式。</span><span class="sxs-lookup"><span data-stu-id="f22a2-144">This is the style of NuGet reference that is required for the new .NET Core project file.</span></span> <span data-ttu-id="f22a2-145">如果您已在使用`<PackageReference>`,則可以將這些專案檔元素直接複製並粘貼到新專案中。</span><span class="sxs-lookup"><span data-stu-id="f22a2-145">If you're already using `<PackageReference>`, those project file elements can be copied and pasted directly into the new project.</span></span>
- <span data-ttu-id="f22a2-146">與包.config 檔`<PackageReference>`不同 ,元素僅引用專案直接依賴的頂級依賴項。</span><span class="sxs-lookup"><span data-stu-id="f22a2-146">Unlike a packages.config file, `<PackageReference>` elements only refer to the top-level dependencies that your project depends on directly.</span></span> <span data-ttu-id="f22a2-147">所有其他傳遞 NuGet 包將在還原時確定,並記錄在自動生成的 obj_project.assets.json 檔中。</span><span class="sxs-lookup"><span data-stu-id="f22a2-147">All other transitive NuGet packages will be determined at restore time and recorded in the autogenerated obj\project.assets.json file.</span></span> <span data-ttu-id="f22a2-148">這樣可以更輕鬆地確定專案具有哪些依賴項,這在確定必要的依賴項是否適用於 .NET Core 上非常有用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-148">This makes it much easier to determine what dependencies your project has, which is useful when determining whether the necessary dependencies will work on .NET Core or not.</span></span>

<span data-ttu-id="f22a2-149">將 .NET Framework 應用遷移到 .NET Core 的第`<PackageReference>`一步是更新它以 使用 NuGet 引用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-149">The first step to migrating a .NET Framework app to .NET Core is to update it to use `<PackageReference>` NuGet references.</span></span> <span data-ttu-id="f22a2-150">視覺工作室使這一點變得簡單。</span><span class="sxs-lookup"><span data-stu-id="f22a2-150">Visual Studio makes this simple.</span></span> <span data-ttu-id="f22a2-151">只需右鍵單擊 Visual Studio**的解決方案資源管理器**中的*包.config*檔,然後選擇 **「遷移包.config 到包參考**」。</span><span class="sxs-lookup"><span data-stu-id="f22a2-151">Just right-click the project's *packages.config* file in Visual Studio's **Solution Explorer**, and then select **Migrate packages.config to PackageReference**.</span></span>

![升級到包參考](./media/convert-project-from-net-framework/package-reference-migration.png)

<span data-ttu-id="f22a2-153">將顯示一個對話框,顯示計算的頂級 NuGet 依賴項,並詢問應將哪些其他 NuGet 包提升到頂級。</span><span class="sxs-lookup"><span data-stu-id="f22a2-153">A dialog appears showing calculated top-level NuGet dependencies and asking which other NuGet packages should be promoted to top-level.</span></span> <span data-ttu-id="f22a2-154">這些其他包都不需要是 Bean Trader 範例的頂級,因此您可以取消選中所有這些框。</span><span class="sxs-lookup"><span data-stu-id="f22a2-154">None of these other packages need to be top-level for the Bean Trader sample, so you can uncheck all of those boxes.</span></span> <span data-ttu-id="f22a2-155">然後,按下 **「確定」** 並刪除*包.config*檔`<PackageReference>`,並將元素添加到專案檔中。</span><span class="sxs-lookup"><span data-stu-id="f22a2-155">Then, click **Ok** and the *packages.config* file is removed and `<PackageReference>` elements are added to the project file.</span></span>

<span data-ttu-id="f22a2-156">`<PackageReference>`-樣式引用不會將 NuGet 套件本地儲存在套件資料夾中。</span><span class="sxs-lookup"><span data-stu-id="f22a2-156">`<PackageReference>`-style references don't store NuGet packages locally in a packages folder.</span></span> <span data-ttu-id="f22a2-157">相反,它們作為優化存儲在全域。</span><span class="sxs-lookup"><span data-stu-id="f22a2-157">Instead, they're stored globally as an optimization.</span></span> <span data-ttu-id="f22a2-158">移轉完成後,編輯 csproj 檔並刪除參考`<Analyzer>`以前來自的分析器的任何元素 *。\包*目錄。</span><span class="sxs-lookup"><span data-stu-id="f22a2-158">After the migration completes, edit the csproj file and remove any `<Analyzer>` elements referring to the analyzers that previously came from the *..\packages* directory.</span></span> <span data-ttu-id="f22a2-159">別擔心,由於您仍然具有 NuGet 包引用,因此分析器將包含在專案中。</span><span class="sxs-lookup"><span data-stu-id="f22a2-159">Don't worry; since you still have the NuGet package references, the analyzers will be included in the project.</span></span> <span data-ttu-id="f22a2-160">你只需要清理舊包。 `<Analyzer>`</span><span class="sxs-lookup"><span data-stu-id="f22a2-160">You just need to clean up the old packages.config-style `<Analyzer>` elements.</span></span>

### <a name="review-nuget-packages"></a><span data-ttu-id="f22a2-161">檢視 NuGet 套件</span><span class="sxs-lookup"><span data-stu-id="f22a2-161">Review NuGet packages</span></span>

<span data-ttu-id="f22a2-162">現在,您可以看到項目所依賴的頂級 NuGet 包,您可以查看這些包是否在 .NET Core 上可用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-162">Now that you can see the top-level NuGet packages that the project depends on, you can review whether those packages are available on .NET Core.</span></span> <span data-ttu-id="f22a2-163">您可以通過查看包對[nuget.org](https://www.nuget.org/)的依賴項來確定包是否支援 .NET Core。社區創建的[fuget.org](https://www.fuget.org/)網站在包信息頁面頂部醒目地顯示此資訊。</span><span class="sxs-lookup"><span data-stu-id="f22a2-163">You can determine whether a package supports .NET Core by looking at its dependencies on [nuget.org](https://www.nuget.org/). The community-created [fuget.org](https://www.fuget.org/) site shows this information prominently at the top of the package information page.</span></span>

<span data-ttu-id="f22a2-164">當定位 .NET Core 3.0 時,任何針對 .NET Core 或 .NET 標準包都應工作(因為 .NET Core 實現了 .NET 標準表面積)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-164">When targeting .NET Core 3.0, any packages targeting .NET Core or .NET Standard should work (since .NET Core implements the .NET Standard surface area).</span></span> <span data-ttu-id="f22a2-165">在某些情況下,所使用的包的特定版本不會針對 .NET Core 或 .NET 標準,但較新版本將面向.</span><span class="sxs-lookup"><span data-stu-id="f22a2-165">In some cases, the specific version of a package that's used won't target .NET Core or .NET Standard, but newer versions will.</span></span> <span data-ttu-id="f22a2-166">在這種情況下,應考慮升級到最新版本的包。</span><span class="sxs-lookup"><span data-stu-id="f22a2-166">In this case, you should consider upgrading to the latest version of the package.</span></span>

<span data-ttu-id="f22a2-167">您也可以使用針對 .NET 框架的包,但這會帶來一些風險。</span><span class="sxs-lookup"><span data-stu-id="f22a2-167">You can use packages targeting .NET Framework, as well, but that introduces some risk.</span></span> <span data-ttu-id="f22a2-168">.NET Core 到 .NET 框架依賴項是允許的,因為 .NET Core 和 .NET 框架曲面區域足夠相似,因此此類依賴項*通常*工作。</span><span class="sxs-lookup"><span data-stu-id="f22a2-168">.NET Core to .NET Framework dependencies are allowed because .NET Core and .NET Framework surface areas are similar enough that such dependencies *often* work.</span></span> <span data-ttu-id="f22a2-169">但是,如果包嘗試使用 .NET Core 中不存在的 .NET API,則會遇到運行時異常。</span><span class="sxs-lookup"><span data-stu-id="f22a2-169">However, if the package tries to use a .NET API that isn't present in .NET Core, you'll encounter a runtime exception.</span></span> <span data-ttu-id="f22a2-170">因此,您應該僅在沒有其他選項可用時引用 .NET Framework 包,並瞭解這樣做會帶來測試負擔。</span><span class="sxs-lookup"><span data-stu-id="f22a2-170">Because of that, you should only reference .NET Framework packages when no other options are available and understand that doing so imposes a test burden.</span></span>

<span data-ttu-id="f22a2-171">如果引用的包不針對 .NET Core 或 .NET 標準,則必須考慮其他備選方案:</span><span class="sxs-lookup"><span data-stu-id="f22a2-171">If there are packages referenced that don't target .NET Core or .NET Standard, you'll have to think about other alternatives:</span></span>

- <span data-ttu-id="f22a2-172">是否有其他類似的軟體包可以代替使用?</span><span class="sxs-lookup"><span data-stu-id="f22a2-172">Are there other similar packages that can be used instead?</span></span> <span data-ttu-id="f22a2-173">有時 NuGet 作者發佈單獨的」。核心的庫版本專門針對 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="f22a2-173">Sometimes NuGet authors publish separate '.Core' versions of their libraries specifically targeting .NET Core.</span></span> <span data-ttu-id="f22a2-174">企業庫包是社區發佈的一個示例」。NetCore"替代方案。</span><span class="sxs-lookup"><span data-stu-id="f22a2-174">Enterprise Library packages are an example of the community publishing ".NetCore" alternatives.</span></span> <span data-ttu-id="f22a2-175">在其他情況下,對於 .NET標準,可用於特定服務的較新的 SDK(有時具有不同的包名)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-175">In other cases, newer SDKs for a particular service (sometimes with different package names) are available for .NET Standard.</span></span> <span data-ttu-id="f22a2-176">如果沒有可用的替代方案,則可以繼續使用 .NET Framework 目標包,同時請記住,在 .NET Core 上運行後,需要對其進行徹底測試。</span><span class="sxs-lookup"><span data-stu-id="f22a2-176">If no alternatives are available, you can proceed using the .NET Framework-targeted packages, bearing in mind that you'll need to test them thoroughly once running on .NET Core.</span></span>

<span data-ttu-id="f22a2-177">Bean 交易者範例具有以下頂級 NuGet 相依:</span><span class="sxs-lookup"><span data-stu-id="f22a2-177">The Bean Trader sample has the following top-level NuGet dependencies:</span></span>

- [<span data-ttu-id="f22a2-178">**城堡.溫莎,版本 4.1.1**</span><span class="sxs-lookup"><span data-stu-id="f22a2-178">**Castle.Windsor, version 4.1.1**</span></span>](https://www.castleproject.org/projects/windsor/)  

  <span data-ttu-id="f22a2-179">此包以 .NET 標準 1.6 為目標,因此適用於 .NET 核心。</span><span class="sxs-lookup"><span data-stu-id="f22a2-179">This package targets .NET Standard 1.6, so it works on .NET Core.</span></span>

- [<span data-ttu-id="f22a2-180">**微軟.代碼分析.FxCopAnalyzers,版本2.6.3**</span><span class="sxs-lookup"><span data-stu-id="f22a2-180">**Microsoft.CodeAnalysis.FxCopAnalyzers, version 2.6.3**</span></span>](https://www.nuget.org/packages/Microsoft.CodeAnalysis.FxCopAnalyzers/2.6.3)  
  <span data-ttu-id="f22a2-181">這是一個元包,因此它支援哪些平臺並不立即明顯,但[文檔](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers)表明其最新版本 (2.9.2) 將同時適用於 .NET 框架和 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="f22a2-181">This is a meta-package, so it's not immediately obvious which platforms it supports, but [documentation](https://github.com/dotnet/roslyn-analyzers#microsoftcodeanalysisfxcopanalyzers) indicates that its newest version (2.9.2) will work for both .NET Framework and .NET Core.</span></span>

- [<span data-ttu-id="f22a2-182">**Nito.AsyncEx,版本 4.0.1**</span><span class="sxs-lookup"><span data-stu-id="f22a2-182">**Nito.AsyncEx, version 4.0.1**</span></span>](https://www.nuget.org/packages/Nito.AsyncEx/4.0.1)  

  <span data-ttu-id="f22a2-183">此包不針對 .NET Core,但較新的 5.0 版本支援.</span><span class="sxs-lookup"><span data-stu-id="f22a2-183">This package doesn't target .NET Core, but the newer 5.0 version does.</span></span> <span data-ttu-id="f22a2-184">遷移時很常見,因為許多 NuGet 包最近添加了 .NET 標準支援,但較舊的專案版本將僅針對 .NET 框架。</span><span class="sxs-lookup"><span data-stu-id="f22a2-184">This is common when migrating because many NuGet packages have added .NET Standard support recently, but older project versions will only target .NET Framework.</span></span> <span data-ttu-id="f22a2-185">如果版本差異只是一個較小的版本差異,則通常很容易升級到較新版本。</span><span class="sxs-lookup"><span data-stu-id="f22a2-185">If the version difference is only a minor version difference, it's often easy to upgrade to the newer version.</span></span> <span data-ttu-id="f22a2-186">由於這是一個重大版本更改,因此需要謹慎升級,因為包中可能會有重大更改。</span><span class="sxs-lookup"><span data-stu-id="f22a2-186">Because this is a major version change, you need to be cautious upgrading since there could be breaking changes in the package.</span></span> <span data-ttu-id="f22a2-187">不過,有一條前進的道路,這很好。</span><span class="sxs-lookup"><span data-stu-id="f22a2-187">There is a path forward, though, which is good.</span></span>

- [<span data-ttu-id="f22a2-188">**MahApps.Metro,版本 1.6.5**</span><span class="sxs-lookup"><span data-stu-id="f22a2-188">**MahApps.Metro, version 1.6.5**</span></span>](https://www.nuget.org/packages/MahApps.Metro/1.6.5)  

  <span data-ttu-id="f22a2-189">此包也不針對 .NET Core,但有較新的預發行版本 (2.0-alpha)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-189">This package also doesn't target .NET Core, but has a newer pre-release (2.0-alpha) that does.</span></span> <span data-ttu-id="f22a2-190">同樣,你必須留意重大的變化,但較新的軟體包是令人鼓舞的。</span><span class="sxs-lookup"><span data-stu-id="f22a2-190">Again, you have to look out for breaking changes, but the newer package is encouraging.</span></span>

<span data-ttu-id="f22a2-191">Bean Trader 範例的 NuGet 依賴項都針對 .NET 標準/.NET Core,或者具有較新版本,因此這裡不太可能存在任何阻塞問題。</span><span class="sxs-lookup"><span data-stu-id="f22a2-191">The Bean Trader sample's NuGet dependencies all either target .NET Standard/.NET Core or have newer versions that do, so there are unlikely to be any blocking issues here.</span></span>

### <a name="upgrade-nuget-packages"></a><span data-ttu-id="f22a2-192">升級 NuGet 套件</span><span class="sxs-lookup"><span data-stu-id="f22a2-192">Upgrade NuGet packages</span></span>

<span data-ttu-id="f22a2-193">如果可能,最好升級僅針對 .NET Core 或 .NET 標準的任何包的版本,此時更新版本(專案仍以 .NET Framework 為目標),以便及早發現和解決任何重大更改。</span><span class="sxs-lookup"><span data-stu-id="f22a2-193">If possible, it would be good to upgrade the versions of any packages that only target .NET Core or .NET Standard with more recent versions at this point (with the project still targeting .NET Framework) to discover and address any breaking changes early.</span></span>

<span data-ttu-id="f22a2-194">如果您不希望對應用的現有 .NET Framework 版本進行任何實質性更改,則可以等到您有針對 .NET Core 的新專案檔。</span><span class="sxs-lookup"><span data-stu-id="f22a2-194">If you would rather not make any material changes to the existing .NET Framework version of the app, this can wait until you have a new project file targeting .NET Core.</span></span> <span data-ttu-id="f22a2-195">但是,提前將 NuGet 包升級到 .NET Core 相容版本,一旦創建新的專案檔並減少應用 .NET Framework 和 .NET Core 版本之間的差異,遷移過程就變得更加容易。</span><span class="sxs-lookup"><span data-stu-id="f22a2-195">However, upgrading the NuGet packages to .NET Core-compatible versions ahead of time makes the migration process even easier once you create the new project file and reduces the number of differences between the .NET Framework and .NET Core versions of the app.</span></span>

<span data-ttu-id="f22a2-196">使用 Bean Trader 範例,所有必要的升級都可以輕鬆進行(使用 Visual Studio 的 NuGet 軟體包管理器),但有一個例外:從**MahApps.Metro 1.6.5**升級到**2.0**揭示了與主題和重音管理 API 相關的重大更改。</span><span class="sxs-lookup"><span data-stu-id="f22a2-196">With the Bean Trader sample, all of the necessary upgrades can be made easily (using Visual Studio's NuGet package manager) with one exception: upgrading from **MahApps.Metro 1.6.5** to **2.0** reveals breaking changes related to theme and accent management APIs.</span></span>

<span data-ttu-id="f22a2-197">理想情況下,應用將更新以使用包的較新版本(因為這更有可能適用於 .NET Core)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-197">Ideally, the app would be updated to use the newer version of the package (since that is more likely to work on .NET Core).</span></span> <span data-ttu-id="f22a2-198">然而,在某些情況下,這可能不可行。</span><span class="sxs-lookup"><span data-stu-id="f22a2-198">In some cases, however, that may not be feasible.</span></span> <span data-ttu-id="f22a2-199">在這些情況下,不要升級**MahApps.Metro,** 因為必要的更改是非瑣碎的,本教程側重於遷移到 .NET Core 3,而不是**MahApps.Metro 2。**</span><span class="sxs-lookup"><span data-stu-id="f22a2-199">In these cases, don't upgrade **MahApps.Metro** because the necessary changes are non-trivial and this tutorial focuses on migrating to .NET Core 3, not to **MahApps.Metro 2.**</span></span> <span data-ttu-id="f22a2-200">此外,這是一個低風險 .NET 框架依賴項,因為 Bean Trader 應用程式只行使**MahApps.Metro 的**一小部分。</span><span class="sxs-lookup"><span data-stu-id="f22a2-200">Also, this is a low-risk .NET Framework dependency because the Bean Trader app only exercises a small part of **MahApps.Metro**.</span></span> <span data-ttu-id="f22a2-201">當然,它將需要測試,以確保遷移完成後一切工作。</span><span class="sxs-lookup"><span data-stu-id="f22a2-201">It will, of course, require testing to make sure everything's working once the migration is complete.</span></span> <span data-ttu-id="f22a2-202">如果這是一個真實的場景,最好提交一個問題來跟蹤工作移動到**MahApps.Metro**版本2.0,因為不做遷移現在留下一些技術債務。</span><span class="sxs-lookup"><span data-stu-id="f22a2-202">If this were a real-world scenario, it would be good to file an issue to track the work to move to **MahApps.Metro** version 2.0 since not doing the migration now leaves behind some technical debt.</span></span>

<span data-ttu-id="f22a2-203">將 NuGet 套件更新到最新版本後,「Bean `<PackageReference>` Trader」範例的專案檔中的專案組應如下所示。</span><span class="sxs-lookup"><span data-stu-id="f22a2-203">Once the NuGet packages are updated to recent versions, the `<PackageReference>` item group in the Bean Trader sample's project file should look like this.</span></span>

```xml
<ItemGroup>
  <PackageReference Include="Castle.Windsor">
    <Version>4.1.1</Version>
  </PackageReference>
  <PackageReference Include="MahApps.Metro">
    <Version>1.6.5</Version>
  </PackageReference>
  <PackageReference Include="Microsoft.CodeAnalysis.FxCopAnalyzers">
    <Version>2.9.2</Version>
  </PackageReference>
  <PackageReference Include="Nito.AsyncEx">
    <Version>5.0.0</Version>
  </PackageReference>
</ItemGroup>
```

### <a name="net-framework-portability-analysis"></a><span data-ttu-id="f22a2-204">.NET 框架可移植性分析</span><span class="sxs-lookup"><span data-stu-id="f22a2-204">.NET Framework portability analysis</span></span>

<span data-ttu-id="f22a2-205">瞭解專案的 NuGet 依賴項的狀態後,需要考慮的下一件事是 .NET Framework API 依賴項。</span><span class="sxs-lookup"><span data-stu-id="f22a2-205">Once you understand the state of your project's NuGet dependencies, the next thing to consider is .NET Framework API dependencies.</span></span> <span data-ttu-id="f22a2-206">[.NET 可移植性分析器](../../standard/analyzers/portability-analyzer.md)工具可用於瞭解專案使用的 .NET API 在其他 .NET 平臺上可用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-206">The [.NET Portability Analyzer](../../standard/analyzers/portability-analyzer.md) tool is useful for understanding which of the .NET APIs your project uses are available on other .NET platforms.</span></span>

<span data-ttu-id="f22a2-207">該工具作為[Visual Studio 外掛程式](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer),[一個命令列工具](https://github.com/Microsoft/dotnet-apiport/releases),或包裝在一[個簡單的 GUI,](https://github.com/Microsoft/dotnet-apiport-ui)這簡化了它的選項。</span><span class="sxs-lookup"><span data-stu-id="f22a2-207">The tool comes as a [Visual Studio plugin](https://marketplace.visualstudio.com/items?itemName=ConnieYau.NETPortabilityAnalyzer), a [command-line tool](https://github.com/Microsoft/dotnet-apiport/releases), or wrapped in a [simple GUI](https://github.com/Microsoft/dotnet-apiport-ui), which simplifies its options.</span></span> <span data-ttu-id="f22a2-208">您可以閱讀有關使用 .NET 可移植性分析器 (API 連接埠) 在[將桌面應用移植到 .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/)部落格文章中的 GUI 的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="f22a2-208">You can read more about using the .NET Portability Analyzer (API Port) using the GUI in the [Porting desktop apps to .NET Core](https://devblogs.microsoft.com/dotnet/porting-desktop-apps-to-net-core/) blog post.</span></span> <span data-ttu-id="f22a2-209">如果希望使用命令行,則必要的步驟是:</span><span class="sxs-lookup"><span data-stu-id="f22a2-209">If you prefer to use the command line, the necessary steps are:</span></span>

1. <span data-ttu-id="f22a2-210">如果您還沒有[.NET 可移植性分析器](https://github.com/Microsoft/dotnet-apiport/releases),請下載它。</span><span class="sxs-lookup"><span data-stu-id="f22a2-210">Download the [.NET Portability Analyzer](https://github.com/Microsoft/dotnet-apiport/releases) if you don't already have it.</span></span>
1. <span data-ttu-id="f22a2-211">確保成功移植 .NET Framework 應用(無論在遷移之前,這是一個好主意)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-211">Make sure the .NET Framework app to be ported builds successfully (this is a good idea prior to migration regardless).</span></span>
1. <span data-ttu-id="f22a2-212">使用這樣的命令列運行 API 連接埠。</span><span class="sxs-lookup"><span data-stu-id="f22a2-212">Run API Port with a command line like this.</span></span>

    ```console
    ApiPort.exe analyze -f <PathToBeanTraderBinaries> -r html -r excel -t ".NET Core"
    ```

    <span data-ttu-id="f22a2-213">參數`-f`指定包含要分析的二進位檔案的路徑。</span><span class="sxs-lookup"><span data-stu-id="f22a2-213">The `-f` argument specifies the path containing the binaries to analyze.</span></span> <span data-ttu-id="f22a2-214">參數`-r`指定所需的輸出檔格式。</span><span class="sxs-lookup"><span data-stu-id="f22a2-214">The `-r` argument specifies which output file format you want.</span></span> <span data-ttu-id="f22a2-215">參數`-t`指定要針對哪個 .NET 平臺分析 API 使用方式。</span><span class="sxs-lookup"><span data-stu-id="f22a2-215">The `-t` argument specifies which .NET platform to analyze API usage against.</span></span> <span data-ttu-id="f22a2-216">在這種情況下,您需要 .NET 核心。</span><span class="sxs-lookup"><span data-stu-id="f22a2-216">In this case, you want .NET Core.</span></span>

<span data-ttu-id="f22a2-217">打開 HTML 報表時,第一部分將列出所有分析的二進位檔案,以及他們使用的 .NET API 的百分比在目標平臺上可用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-217">When you open the HTML report, the first section will list all of the analyzed binaries and what percentage of the .NET APIs they use are available on the targeted platform.</span></span> <span data-ttu-id="f22a2-218">這個百分比本身沒有意義。</span><span class="sxs-lookup"><span data-stu-id="f22a2-218">The percentage is not meaningful by itself.</span></span> <span data-ttu-id="f22a2-219">更有用的是查看缺少的特定 API。</span><span class="sxs-lookup"><span data-stu-id="f22a2-219">What's more useful is to see the specific APIs that are missing.</span></span> <span data-ttu-id="f22a2-220">為此,請選擇程式集名稱或向下滾動到各個程式集的報表。</span><span class="sxs-lookup"><span data-stu-id="f22a2-220">To do that, either select an assembly name or scroll down to the reports for individual assemblies.</span></span>

<span data-ttu-id="f22a2-221">關注您擁有的原始碼的程式集。</span><span class="sxs-lookup"><span data-stu-id="f22a2-221">Focus on the assemblies that you own the source code for.</span></span> <span data-ttu-id="f22a2-222">例如,在 Bean Trader ApiPort 報告中,列出了許多二進位檔,但大多數都屬於 NuGet 包。</span><span class="sxs-lookup"><span data-stu-id="f22a2-222">In the Bean Trader ApiPort report, for example, there are many binaries listed, but most of them belong to NuGet packages.</span></span> <span data-ttu-id="f22a2-223">`Castle.Windsor`顯示它依賴於 .NET Core 中缺少的某些 System.Web API。</span><span class="sxs-lookup"><span data-stu-id="f22a2-223">`Castle.Windsor` shows that it depends on some System.Web APIs that are missing in .NET Core.</span></span> <span data-ttu-id="f22a2-224">這不是問題,因為您以前已驗證支援`Castle.Windsor`.NET Core。</span><span class="sxs-lookup"><span data-stu-id="f22a2-224">This isn't a concern because you previously verified that `Castle.Windsor` supports .NET Core.</span></span> <span data-ttu-id="f22a2-225">NuGet 套件具有不同的二進位檔案用於不同的 .NET 平臺是很常見的,因此,只要包也`Castle.Windsor`針對 .NET 標準或 .NET Core(它這樣做),.NET 框架版本是否使用 System.Web API 都無關緊要。</span><span class="sxs-lookup"><span data-stu-id="f22a2-225">It is common for NuGet packages to have different binaries for use with different .NET platforms, so whether the .NET Framework version of `Castle.Windsor` uses System.Web APIs or not is irrelevant as long as the package also targets .NET Standard or .NET Core (which it does).</span></span>

<span data-ttu-id="f22a2-226">使用 Bean Trader 表示例時,您需要考慮的唯一二進位檔案是**BeanTraderClient,** 報告顯示`System.ServiceModel.ClientBase<T>.Close`僅缺少兩`System.ServiceModel.ClientBase<T>.Open`個 .NET API: 和 。</span><span class="sxs-lookup"><span data-stu-id="f22a2-226">With the Bean Trader sample, the only binary that you need to consider is **BeanTraderClient** and the report shows that only two .NET APIs are missing: `System.ServiceModel.ClientBase<T>.Close` and `System.ServiceModel.ClientBase<T>.Open`.</span></span>

![豆交易用戶端可移植性報告](./media/convert-project-from-net-framework/portability-report.png)

<span data-ttu-id="f22a2-228">這些不太可能阻止問題,因為 WCF 用戶端 API(大部分)在 .NET Core 上受支援,因此必須為這些中央 API 提供替代方案。</span><span class="sxs-lookup"><span data-stu-id="f22a2-228">These are unlikely to be blocking issues because WCF Client APIs are (mostly) supported on .NET Core, so there must be alternatives available for these central APIs.</span></span> <span data-ttu-id="f22a2-229">事實上,查看`System.ServiceModel`.NET 核心表面積<https://apisof.net>(使用 ),您會看到 .NET Core 中有異步替代方案。</span><span class="sxs-lookup"><span data-stu-id="f22a2-229">In fact, looking at `System.ServiceModel`'s .NET Core surface area (using <https://apisof.net>), you see that there are async alternatives in .NET Core instead.</span></span>

<span data-ttu-id="f22a2-230">基於此報告和以前的 NuGet 依賴項分析,似乎不應存在將 Bean Trader 範例遷移到 .NET Core 的大問題。</span><span class="sxs-lookup"><span data-stu-id="f22a2-230">Based on this report and the previous NuGet dependency analysis, it looks like there should be no major issues migrating the Bean Trader sample to .NET Core.</span></span> <span data-ttu-id="f22a2-231">您已準備好下一步,在此步驟中,您將實際開始遷移。</span><span class="sxs-lookup"><span data-stu-id="f22a2-231">You're ready for the next step in which you'll actually start the migration.</span></span>

## <a name="migrating-the-project-file"></a><span data-ttu-id="f22a2-232">移轉專案檔</span><span class="sxs-lookup"><span data-stu-id="f22a2-232">Migrating the project file</span></span>

<span data-ttu-id="f22a2-233">如果你的應用沒有使用新的[SDK 風格的專案檔案格式](../../core/tools/csproj.md),則需要一個新的專案檔來定位 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="f22a2-233">If your app isn't using the new [SDK-style project file format](../../core/tools/csproj.md), you'll need a new project file to target .NET Core.</span></span> <span data-ttu-id="f22a2-234">您可以替換現有的 csproj 檔,或者,如果您希望保持現有專案保持其當前狀態不變,則可以添加針對 .NET Core 的新 csproj 檔。</span><span class="sxs-lookup"><span data-stu-id="f22a2-234">You can replace the existing csproj file or, if you prefer to keep the existing project untouched in its current state, you can add a new csproj file targeting .NET Core.</span></span> <span data-ttu-id="f22a2-235">您可以使用具有[多目標的](../../standard/library-guidance/cross-platform-targeting.md)單個 SDK 樣式專案檔`<TargetFrameworks>`(指定多個目標)為 .NET 框架和 .NET Core 構建應用版本。</span><span class="sxs-lookup"><span data-stu-id="f22a2-235">You can build versions of the app for .NET Framework and .NET Core with a single SDK-style project file with [multi-targeting](../../standard/library-guidance/cross-platform-targeting.md) (specifying multiple `<TargetFrameworks>` targets).</span></span>

<span data-ttu-id="f22a2-236">要建立新的專案檔,可以在 Visual Studio 中建立新的 WPF 專案,或者`dotnet new wpf`使用暫存目錄中的命令生成專案檔,然後將其複製/重命名到正確的位置。</span><span class="sxs-lookup"><span data-stu-id="f22a2-236">To create the new project file, you can create a new WPF project in Visual Studio or use the `dotnet new wpf` command in a temporary directory to generate the project file and then copy/rename it to the correct location.</span></span> <span data-ttu-id="f22a2-237">還有一個社區創建的工具[,CsprojToVs2017,](https://github.com/hvanbakel/CsprojToVs2017)它可以自動執行一些專案檔遷移。</span><span class="sxs-lookup"><span data-stu-id="f22a2-237">There is also a community-created tool, [CsprojToVs2017](https://github.com/hvanbakel/CsprojToVs2017), that can automate some of the project file migration.</span></span> <span data-ttu-id="f22a2-238">該工具很有用,但仍需要人工查看結果,以確保遷移的所有詳細資訊都正確無誤。</span><span class="sxs-lookup"><span data-stu-id="f22a2-238">The tool is helpful but still needs a human to review the results to make sure all the details of the migration are correct.</span></span> <span data-ttu-id="f22a2-239">此工具無法將最好處理的特定區域是從包遷移 NuGet 套件 *。*</span><span class="sxs-lookup"><span data-stu-id="f22a2-239">One particular area that the tool doesn't handle optimally is migrating NuGet packages from *packages.config* files.</span></span> <span data-ttu-id="f22a2-240">如果該工具在仍使用*包.config*檔案引用 NuGet 套件的專案檔上運行,它將`<PackageReference>`自動遷移到 元素,但`<PackageReference>`會為所有包添加*all*元素,而不僅僅是頂級 包的元素。</span><span class="sxs-lookup"><span data-stu-id="f22a2-240">If the tool runs on a project file that still uses a *packages.config* file to reference NuGet packages, it will migrate to `<PackageReference>` elements automatically, but will add `<PackageReference>` elements for *all* of the packages instead of just top-level ones.</span></span> <span data-ttu-id="f22a2-241">如果您已經遷移到`<PackageReference>`了使用 Visual Studio 的元素(如本示例中所做的那樣),則該工具可以説明完成轉換的其餘部分。</span><span class="sxs-lookup"><span data-stu-id="f22a2-241">If you have already migrated to`<PackageReference>` elements with Visual Studio (as you've done in this sample), then the tool can help with the rest of the conversion.</span></span> <span data-ttu-id="f22a2-242">像斯科特·漢塞爾曼[在他的博客文章中建議遷移csproj檔](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx),手工移植是教育性的,如果你只有幾個專案移植,將提供更好的結果。</span><span class="sxs-lookup"><span data-stu-id="f22a2-242">Like Scott Hanselman recommends in [his blog post on migrating csproj files](https://www.hanselman.com/blog/UpgradingAnExistingNETProjectFilesToTheLeanNewCSPROJFormatFromNETCore.aspx), porting by hand is educational and will give better results if you only have a few projects to port.</span></span> <span data-ttu-id="f22a2-243">但是,如果您移植了幾十個或數百個專案檔,那麼像 [CprojToVs2017] 這樣的工具可能是一個説明。</span><span class="sxs-lookup"><span data-stu-id="f22a2-243">But if you are porting dozens or hundreds of project files, then a tool like [CsprojToVs2017] can be a help.</span></span>

<span data-ttu-id="f22a2-244">要為 Bean Trader 範例建立新的項目`dotnet new wpf`檔,請執行暫存目錄中,並將產生的 *.csproj*檔案移動到*BeanTraderClient*資料夾中,並將其重新命名為**BeanTraderClient.Core.csproj**。</span><span class="sxs-lookup"><span data-stu-id="f22a2-244">To create a new project file for the Bean Trader sample, run `dotnet new wpf` in a temporary directory and move the generated *.csproj* file into the *BeanTraderClient* folder and rename it **BeanTraderClient.Core.csproj**.</span></span>

<span data-ttu-id="f22a2-245">由於新的項目檔格式自動包括 C# 檔 *、resx*檔和 XAML 檔,它在其目錄中或在其目錄下找到,因此專案檔已幾乎完成!</span><span class="sxs-lookup"><span data-stu-id="f22a2-245">Because the new project file format automatically includes C# files, *resx* files, and XAML files that it finds in or under its directory, the project file is already almost complete!</span></span> <span data-ttu-id="f22a2-246">要完成移轉,請並排打開新舊專案檔,並查看舊專案檔以查看是否需要遷移其中包含的任何資訊。</span><span class="sxs-lookup"><span data-stu-id="f22a2-246">To finish the migration, open the old and new project files side-by-side and look through the old one to see if any information it contains needs to be migrated.</span></span> <span data-ttu-id="f22a2-247">在「豆交易」示例案例中,應將以下專案複製到新專案:</span><span class="sxs-lookup"><span data-stu-id="f22a2-247">In the Bean Trader sample case, the following items should be copied to the new project:</span></span>

- <span data-ttu-id="f22a2-248">全部`<RootNamespace>`應`<AssemblyName>`複製`<ApplicationIcon>`和屬性。</span><span class="sxs-lookup"><span data-stu-id="f22a2-248">The `<RootNamespace>`, `<AssemblyName>`, and `<ApplicationIcon>` properties should all be copied.</span></span>

- <span data-ttu-id="f22a2-249">您還需要向新專案檔添加`<GenerateAssemblyInfo>false</GenerateAssemblyInfo>`屬性,因為 Bean Trader 範例在 AssemblyInfo.cs 檔中包含`[AssemblyTitle]`程式集級屬性(如 )。"屬性"。</span><span class="sxs-lookup"><span data-stu-id="f22a2-249">You also need to add a `<GenerateAssemblyInfo>false</GenerateAssemblyInfo>` property to the new project file since the Bean Trader sample includes assembly-level attributes (like `[AssemblyTitle]`) in an AssemblyInfo.cs file.</span></span> <span data-ttu-id="f22a2-250">默認情況下,新的 SDK 樣式專案將根據 csproj 檔中的屬性自動生成這些屬性。</span><span class="sxs-lookup"><span data-stu-id="f22a2-250">By default, new SDK-style projects will autogenerate these attributes based on properties in the csproj file.</span></span> <span data-ttu-id="f22a2-251">由於在這種情況下不希望這種情況發生(自動產生的屬性將與AssemblyInfo.cs的屬性衝突),因此使用關閉自動產生的屬性`<GenerateAssemblyInfo>`。</span><span class="sxs-lookup"><span data-stu-id="f22a2-251">Because you don't want that to happen in this case (the autogenerated attributes would conflict with those from AssemblyInfo.cs), you disable the autogenerated attributes with `<GenerateAssemblyInfo>`.</span></span>

- <span data-ttu-id="f22a2-252">儘管*resx*檔自動作為嵌入資源包含`<Resource>`在內 ,但其他專案(如圖像)則不包括在內。</span><span class="sxs-lookup"><span data-stu-id="f22a2-252">Although *resx* files are automatically included as embedded resources, other `<Resource>` items like images are not.</span></span> <span data-ttu-id="f22a2-253">因此,`<Resource>`複製嵌入影像和圖示檔案的元素。</span><span class="sxs-lookup"><span data-stu-id="f22a2-253">So, copy the `<Resource>` elements for embedding image and icon files.</span></span> <span data-ttu-id="f22a2-254">您可以使用新項目檔案格式對 globing 模式的支援來簡化對單行的 png`<Resource Include="**\*.png" />`引用: 。</span><span class="sxs-lookup"><span data-stu-id="f22a2-254">You can simplify the png references to a single line by using the new project file format's support for globbing patterns: `<Resource Include="**\*.png" />`.</span></span>

- <span data-ttu-id="f22a2-255">同樣,`<None>`專案會自動包含,但默認情況下不會將其複製到輸出目錄。</span><span class="sxs-lookup"><span data-stu-id="f22a2-255">Similarly, `<None>` items are included automatically, but they aren't copied to the output directory, by default.</span></span> <span data-ttu-id="f22a2-256">由於 Bean Trader`<None>`專案 包含*複製到*輸出目錄(使用`PreserveNewest`行為)的專案,因此您需要更新`<None>`該檔自動填充的項,如下所示。</span><span class="sxs-lookup"><span data-stu-id="f22a2-256">Because the Bean Trader project includes a `<None>` item that *is* copied to the output directory (using `PreserveNewest` behaviors), you need to update the automatically populated `<None>` item for that file, like this.</span></span>

  ```xml
  <None Update="BeanTrader.pfx">
    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </None>
  ```

- <span data-ttu-id="f22a2-257">Bean Trader 範例包括 XAML 檔 (Default.Accent.xaml) 作為`Content`(`Page`而不是作為 ),因為在此檔案中定義的主題和重音在執行時從檔案的 XAML 載入,而不是嵌入到應用本身中。</span><span class="sxs-lookup"><span data-stu-id="f22a2-257">The Bean Trader sample includes a XAML file (Default.Accent.xaml) as `Content` (rather than as a `Page`) because themes and accents defined in this file are loaded from the file's XAML at runtime, rather than being embedded in the app itself.</span></span> <span data-ttu-id="f22a2-258">但是,新項目系統會自動將此檔作為`<Page>`,因為它是 XAML 檔。</span><span class="sxs-lookup"><span data-stu-id="f22a2-258">The new project system automatically includes this file as a `<Page>`, however, since it's a XAML file.</span></span> <span data-ttu-id="f22a2-259">因此,您需要同時刪除 XAML 檔作為`<Page Remove="**\Default.Accent.xaml" />`頁面 ( ), 並將其添加為內容。</span><span class="sxs-lookup"><span data-stu-id="f22a2-259">So, you need to both remove the XAML file as a page (`<Page Remove="**\Default.Accent.xaml" />`) and add it as content.</span></span>

  ```xml
  <Content Include="Resources\Themes\Default.Accent.xaml">
      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
  </Content>
  ```

- <span data-ttu-id="f22a2-260">最後,通過複製`<ItemGroup>`所有`<PackageReference>`元素來添加 NuGet 引用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-260">Finally, add NuGet references by copying the `<ItemGroup>` with all the `<PackageReference>` elements.</span></span> <span data-ttu-id="f22a2-261">如果您以前沒有將 NuGet 包升級到 .NET Core 相容版本,則現在可以執行此操作,因為包引用位於 .NET Core 特定的專案中。</span><span class="sxs-lookup"><span data-stu-id="f22a2-261">If you hadn't previously upgraded the NuGet packages to .NET Core-compatible versions, you could do that now that the package references are in a .NET Core-specific project.</span></span>

<span data-ttu-id="f22a2-262">此時,應該可以將新專案添加到 BeanTrader 解決方案並在 Visual Studio 中打開它。</span><span class="sxs-lookup"><span data-stu-id="f22a2-262">At this point, it should be possible to add the new project to the BeanTrader solution and open it in Visual Studio.</span></span> <span data-ttu-id="f22a2-263">專案在**解決方案資源管理器**中應看起來正確,`dotnet restore BeanTraderClient.Core.csproj`並應成功還原包(與 MahApps.Metro 版本相關的兩個預期警告,您使用的定位目標 .NET Framework)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-263">The project should look correct in **Solution Explorer**, and `dotnet restore BeanTraderClient.Core.csproj` should successfully restore packages (with two expected warnings related to the MahApps.Metro version you're using targeting .NET Framework).</span></span>

<span data-ttu-id="f22a2-264">儘管可以同時保留兩個專案檔(如果要保持舊專案完全按照現在的身份構建,甚至可能是可取的),但它使遷移過程複雜化(這兩個專案將嘗試使用相同的 bin 和 obj 資料夾),通常沒有必要。</span><span class="sxs-lookup"><span data-stu-id="f22a2-264">Although it's possible to keep both project files side-by-side (and may even be desirable if you want to keep building the old project exactly as it was), it complicates the migration process (the two projects will try to use the same bin and obj folders) and usually isn't necessary.</span></span> <span data-ttu-id="f22a2-265">如果要同時為 .NET Core 和 .NET 框架`<TargetFramework>netcoreapp3.0</TargetFramework>``<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>`目標生成,則可以改為替換新專案檔中的屬性。</span><span class="sxs-lookup"><span data-stu-id="f22a2-265">If you want to build for both .NET Core and .NET Framework targets, you can replace the `<TargetFramework>netcoreapp3.0</TargetFramework>` property in the new project file with `<TargetFrameworks>netcoreapp3.0;net472</TargetFrameworks>` instead.</span></span> <span data-ttu-id="f22a2-266">對於 Bean Trader 範例,請刪除舊專案檔(BeanTraderClient.csproj),因為它不再需要。</span><span class="sxs-lookup"><span data-stu-id="f22a2-266">For the Bean Trader sample, delete the old project file (BeanTraderClient.csproj) since it's no longer needed.</span></span> <span data-ttu-id="f22a2-267">如果您希望保留這兩個專案檔,請確保將它們構建到不同的輸出和中間輸出路徑。</span><span class="sxs-lookup"><span data-stu-id="f22a2-267">If you prefer to keep both project files, be sure to have them build to different output and intermediate output paths.</span></span>

## <a name="fix-build-issues"></a><span data-ttu-id="f22a2-268">修復產生問題</span><span class="sxs-lookup"><span data-stu-id="f22a2-268">Fix build issues</span></span>

<span data-ttu-id="f22a2-269">移植過程的第三步是生成專案。</span><span class="sxs-lookup"><span data-stu-id="f22a2-269">The third step of the porting process is getting the project to build.</span></span> <span data-ttu-id="f22a2-270">一旦專案檔轉換為 SDK 樣式的專案,某些應用將成功生成。</span><span class="sxs-lookup"><span data-stu-id="f22a2-270">Some apps will already build successfully once the project file is converted to an SDK-style project.</span></span> <span data-ttu-id="f22a2-271">如果你的應用如此,恭喜你!</span><span class="sxs-lookup"><span data-stu-id="f22a2-271">If that's the case for your app, congratulations!</span></span> <span data-ttu-id="f22a2-272">您可以繼續執行步驟 4。</span><span class="sxs-lookup"><span data-stu-id="f22a2-272">You can go on to Step 4.</span></span> <span data-ttu-id="f22a2-273">其他應用將需要一些更新,以使它們為 .NET Core 構建。</span><span class="sxs-lookup"><span data-stu-id="f22a2-273">Other apps will need some updates to get them building for .NET Core.</span></span> <span data-ttu-id="f22a2-274">如果您嘗試現在`dotnet build`運行 Bean Trader 範例專案(例如,或在 Visual Studio 中建譯),將有許多錯誤,但很快就會修復它們。</span><span class="sxs-lookup"><span data-stu-id="f22a2-274">If you try to run `dotnet build` on the Bean Trader sample project now, for example, (or build it in Visual Studio), there will be many errors, but you'll get them fixed quickly.</span></span>

### <a name="systemservicemodel-references-and-microsoftwindowscompatibility"></a><span data-ttu-id="f22a2-275">系統.服務模型引用和微軟.Windows.相容性</span><span class="sxs-lookup"><span data-stu-id="f22a2-275">System.ServiceModel references and Microsoft.Windows.Compatibility</span></span>

<span data-ttu-id="f22a2-276">常見的錯誤來源是缺少可用於 .NET Core 但未自動包含在 .NET Core 應用元包中的 API 的引用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-276">A common source of errors is missing references for APIs that are available for .NET Core but not automatically included in the .NET Core app metapackage.</span></span> <span data-ttu-id="f22a2-277">為此,應引用該`Microsoft.Windows.Compatibility`包。</span><span class="sxs-lookup"><span data-stu-id="f22a2-277">To address this, you should reference the `Microsoft.Windows.Compatibility` package.</span></span> <span data-ttu-id="f22a2-278">相容性包包括 Windows 桌面應用中常見的廣泛 API 集,例如 WCF 用戶端、目錄服務、註冊表、配置、ACL API 等。</span><span class="sxs-lookup"><span data-stu-id="f22a2-278">The compatibility package includes a broad set of APIs that are common in Windows desktop apps, such as WCF client, directory services, registry, configuration, ACLs APIs, and more.</span></span>

<span data-ttu-id="f22a2-279">使用 Bean Trader 範例,大多數生成錯誤<xref:System.ServiceModel>是由於缺少 類型造成的。</span><span class="sxs-lookup"><span data-stu-id="f22a2-279">With the Bean Trader sample, the majority of the build errors are due to missing <xref:System.ServiceModel> types.</span></span> <span data-ttu-id="f22a2-280">這些可以通過引用必要的 WCF NuGet 套件來解決。</span><span class="sxs-lookup"><span data-stu-id="f22a2-280">These could be addressed by referencing the necessary WCF NuGet packages.</span></span> <span data-ttu-id="f22a2-281">但是,WCF 用戶端 API 是`Microsoft.Windows.Compatibility`包中存在的一部分,因此引用相容性包是一個更好的解決方案(因為它還解決了與 API 相關的任何問題以及相容性包提供的 WCF 問題的解決方案)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-281">WCF client APIs are among those present in the `Microsoft.Windows.Compatibility` package, though, so referencing the compatibility package is an even better solution (since it also addresses any issues related to APIs as well as solutions to the WCF issues that the compatibility package makes available).</span></span> <span data-ttu-id="f22a2-282">在大多數`Microsoft.Windows.Compatibility`.NET Core 3.0 WPF 和 WinForms 移植方案中,該包都很有説明。</span><span class="sxs-lookup"><span data-stu-id="f22a2-282">The `Microsoft.Windows.Compatibility` package helps in most .NET Core 3.0 WPF and WinForms porting scenarios.</span></span> <span data-ttu-id="f22a2-283">將 NuGet 引用`Microsoft.Windows.Compatibility`新增到 後,僅保留一個產生錯誤!</span><span class="sxs-lookup"><span data-stu-id="f22a2-283">After adding the NuGet reference to `Microsoft.Windows.Compatibility`, only one build error remains!</span></span>

### <a name="cleaning-up-unused-files"></a><span data-ttu-id="f22a2-284">清除未使用的檔案</span><span class="sxs-lookup"><span data-stu-id="f22a2-284">Cleaning up unused files</span></span>

<span data-ttu-id="f22a2-285">出現一種類型的遷移問題通常與以前未包含在生成中的新 SDK 樣式項目(自動包含*所有*來源)的 C# 和 XAML 檔有關。</span><span class="sxs-lookup"><span data-stu-id="f22a2-285">One type of migration issue that comes up often relates to C# and XAML files that weren't previously included in the build getting picked up by the new SDK-style projects that include *all* source automatically.</span></span>

<span data-ttu-id="f22a2-286">您在 Bean Trader 範例看到的下一個生成錯誤是指*OldUnusedViewModel.cs*中的一個錯誤介面實現。</span><span class="sxs-lookup"><span data-stu-id="f22a2-286">The next build error you see in the Bean Trader sample refers to a bad interface implementation in *OldUnusedViewModel.cs*.</span></span> <span data-ttu-id="f22a2-287">檔名是提示,但在檢查時,您會發現此源檔不正確。</span><span class="sxs-lookup"><span data-stu-id="f22a2-287">The file name is a hint, but on inspection, you'll find that this source file is incorrect.</span></span> <span data-ttu-id="f22a2-288">它以前沒有引起問題,因為它未包含在原始的 .NET 框架專案中。</span><span class="sxs-lookup"><span data-stu-id="f22a2-288">It didn't cause issues previously because it wasn't included in the original .NET Framework project.</span></span> <span data-ttu-id="f22a2-289">磁碟上存在但未包含在舊*csproj*中的源文件現在會自動包含。</span><span class="sxs-lookup"><span data-stu-id="f22a2-289">Source files that were present on disk but not included in the old *csproj* are included automatically now.</span></span>

<span data-ttu-id="f22a2-290">對於這樣的一次性問題,很容易與以前的*csproj*進行比較,以確認該檔不需要`<Compile Remove="" />`,然後 要麼它,要麼,如果源檔不再需要任何地方,請將其刪除。</span><span class="sxs-lookup"><span data-stu-id="f22a2-290">For one-off issues like this, it's easy to compare to the previous *csproj* to confirm that the file isn't needed, and then either `<Compile Remove="" />` it or, if the source file isn't needed anywhere anymore, delete it.</span></span> <span data-ttu-id="f22a2-291">在這種情況下,只需刪除*OldUnusedViewModel.cs*是安全的。</span><span class="sxs-lookup"><span data-stu-id="f22a2-291">In this case, it's safe to just delete *OldUnusedViewModel.cs*.</span></span>

<span data-ttu-id="f22a2-292">如果有許多需要以這種方式排除的源檔,則可以通過在專案檔中`<EnableDefaultCompileItems>`將 屬性設置為 false 來禁用自動包含 C# 檔。</span><span class="sxs-lookup"><span data-stu-id="f22a2-292">If you have many source files that would need to be excluded this way, you can disable auto-inclusion of C# files by setting the `<EnableDefaultCompileItems>` property to false in the project file.</span></span> <span data-ttu-id="f22a2-293">然後,您可以將專案從`<Compile Include>`舊專案檔複製到新專案檔,以便僅生成要包括的源。</span><span class="sxs-lookup"><span data-stu-id="f22a2-293">Then, you can copy `<Compile Include>` items from the old project file to the new one in order to only build sources you intended to include.</span></span> <span data-ttu-id="f22a2-294">同樣,`<EnableDefaultPageItems>`可用於關閉 XAML 頁面的自動`<EnableDefaultItems>`包含,並且可以使用單個屬性控制這兩個頁面。</span><span class="sxs-lookup"><span data-stu-id="f22a2-294">Similarly, `<EnableDefaultPageItems>` can be used to turn off auto-inclusion of XAML pages and `<EnableDefaultItems>` can control both with a single property.</span></span>

### <a name="a-brief-aside-on-multi-pass-compilers"></a><span data-ttu-id="f22a2-295">多通道編譯器的簡短旁加</span><span class="sxs-lookup"><span data-stu-id="f22a2-295">A brief aside on multi-pass compilers</span></span>

<span data-ttu-id="f22a2-296">從 Bean Trader 範例中刪除違規檔後,您可以重新生成,並將得到四個錯誤。</span><span class="sxs-lookup"><span data-stu-id="f22a2-296">After removing the offending file from the Bean Trader sample, you can re-build and will get four errors.</span></span> <span data-ttu-id="f22a2-297">你以前沒有嗎?</span><span class="sxs-lookup"><span data-stu-id="f22a2-297">Didn't you have one before?</span></span> <span data-ttu-id="f22a2-298">為什麼錯誤數會上升?</span><span class="sxs-lookup"><span data-stu-id="f22a2-298">Why did the number of errors go up?</span></span> <span data-ttu-id="f22a2-299">C# 編譯器是[多通道編譯器](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-299">The C# compiler is a [multi-pass compiler](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes).</span></span> <span data-ttu-id="f22a2-300">這意味著它遍遍每個源檔兩次。</span><span class="sxs-lookup"><span data-stu-id="f22a2-300">This means that it goes through each source file twice.</span></span> <span data-ttu-id="f22a2-301">首先,編譯器只查看每個源檔中的元數據和聲明,並標識任何聲明級問題。</span><span class="sxs-lookup"><span data-stu-id="f22a2-301">First, the compiler just looks at metadata and declarations in each source file and identifies any declaration-level problems.</span></span> <span data-ttu-id="f22a2-302">這些是您修復的錯誤。</span><span class="sxs-lookup"><span data-stu-id="f22a2-302">Those are the errors you've fixed.</span></span> <span data-ttu-id="f22a2-303">然後,它再次通過代碼將 C# 源構建到 IL;這些是你現在看到的第二組錯誤。</span><span class="sxs-lookup"><span data-stu-id="f22a2-303">Then it goes through the code again to build the C# source into IL; those are the second set of errors that you're seeing now.</span></span>

> [!NOTE]
> <span data-ttu-id="f22a2-304">C# 編譯器[執行的不僅僅是兩個傳遞](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes),但最終結果是,對於像這樣的大型代碼更改的編譯器錯誤往往以兩個波表示。</span><span class="sxs-lookup"><span data-stu-id="f22a2-304">The C# compiler does [more than just two passes](https://docs.microsoft.com/archive/blogs/ericlippert/how-many-passes), but the end result is that compiler errors for large code changes like this tend to come in two waves.</span></span>

### <a name="third-party-dependency-fixes-castlewindsor"></a><span data-ttu-id="f22a2-305">第三方依賴項修復(城堡.溫莎)</span><span class="sxs-lookup"><span data-stu-id="f22a2-305">Third-party dependency fixes (Castle.Windsor)</span></span>

<span data-ttu-id="f22a2-306">某些遷移方案中出現的另一類問題是依賴項 .NET Framework 和 .NET Core 版本之間的 API 差異。</span><span class="sxs-lookup"><span data-stu-id="f22a2-306">Another class of issue that comes up in some migration scenarios is API differences between .NET Framework and .NET Core versions of dependencies.</span></span> <span data-ttu-id="f22a2-307">即使 NuGet 套件同時面向 .NET 框架和 .NET 標準或 .NET Core,也可能有不同的函式庫可用於不同的 .NET 目標。</span><span class="sxs-lookup"><span data-stu-id="f22a2-307">Even if a NuGet package targets both .NET Framework and .NET Standard or .NET Core, there may be different libraries for use with different .NET targets.</span></span> <span data-ttu-id="f22a2-308">這允許包支援許多不同的 .NET 平臺,這可能需要不同的實現。</span><span class="sxs-lookup"><span data-stu-id="f22a2-308">This allows the packages to support many different .NET platforms, which may require different implementations.</span></span> <span data-ttu-id="f22a2-309">這也意味著,當針對不同的 .NET 平臺時,庫中可能存在較小的 API 差異。</span><span class="sxs-lookup"><span data-stu-id="f22a2-309">It also means that there may be small API differences in the libraries when targeting different .NET platforms.</span></span>

<span data-ttu-id="f22a2-310">您將在「豆交易」範例中看到的下一組錯誤與`Castle.Windsor`API 相關。</span><span class="sxs-lookup"><span data-stu-id="f22a2-310">The next set of errors you'll see in the Bean Trader sample are related to `Castle.Windsor` APIs.</span></span> <span data-ttu-id="f22a2-311">.NET 核心 Bean Trader`Castle.Windsor`專案使用與 .NET Framework 目標專案 (4.1.1) 相同的版本,但這兩個平臺的實現略有不同。</span><span class="sxs-lookup"><span data-stu-id="f22a2-311">The .NET Core Bean Trader project uses the same version of `Castle.Windsor` as the .NET Framework-targeted project (4.1.1), but the implementations for those two platforms are slightly different.</span></span>

<span data-ttu-id="f22a2-312">在這種情況下,您將看到需要修復的以下問題:</span><span class="sxs-lookup"><span data-stu-id="f22a2-312">In this case, you see the following issues that need to be fixed:</span></span>

1. <span data-ttu-id="f22a2-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly`不在 .NET 核心上可用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-313">`Castle.MicroKernel.Registration.Classes.FromThisAssembly` isn't available on .NET Core.</span></span> <span data-ttu-id="f22a2-314">但是,有類似的`Classes.FromAssemblyContaining`API 可用,因此我們可以將調`Classes.FromThisAssembly()`用 的兩個`Classes.FromAssemblyContaining(t)`用途替換`t`為調用 ,其中發出調用的類型在哪裡。</span><span class="sxs-lookup"><span data-stu-id="f22a2-314">There is, however, the similar API `Classes.FromAssemblyContaining` available, so we can replace both uses of `Classes.FromThisAssembly()` with calls to `Classes.FromAssemblyContaining(t)`, where `t` is the type making the call.</span></span>
1. <span data-ttu-id="f22a2-315">同樣,在*Bootstrapper.cs*`Castle.Windsor.Installer.FromAssembly`中。這在 .NET 核心上不可用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-315">Similarly, in *Bootstrapper.cs*, `Castle.Windsor.Installer.FromAssembly`.This is unavailable on .NET Core.</span></span> <span data-ttu-id="f22a2-316">相反,該呼叫可以取代為`FromAssembly.Containing(typeof(Bootstrapper))`。</span><span class="sxs-lookup"><span data-stu-id="f22a2-316">Instead, that call can be replaced with `FromAssembly.Containing(typeof(Bootstrapper))`.</span></span>

### <a name="updating-wcf-client-usage"></a><span data-ttu-id="f22a2-317">更新 WCF 用戶端使用方式</span><span class="sxs-lookup"><span data-stu-id="f22a2-317">Updating WCF client usage</span></span>

<span data-ttu-id="f22a2-318">修復了`Castle.Windsor`差異后,.NET Core Bean Trader 專案中最後`BeanTraderServiceClient`剩餘的生成錯誤`DuplexClientBase`是`Open`(派生自 )沒有方法。</span><span class="sxs-lookup"><span data-stu-id="f22a2-318">Having fixed the `Castle.Windsor` differences, the last remaining build error in the .NET Core Bean Trader project is that `BeanTraderServiceClient` (which derives from `DuplexClientBase`) doesn't have an `Open` method.</span></span> <span data-ttu-id="f22a2-319">這並不奇怪,因為這是在此遷移過程開始時由 .NET 可移植性分析器突出顯示的 API。</span><span class="sxs-lookup"><span data-stu-id="f22a2-319">This isn't surprising since this is an API that was highlighted by the .NET Portability Analyzer at the beginning of this migration process.</span></span> <span data-ttu-id="f22a2-320">不過,`BeanTraderServiceClient`讓我們注意到一個更大的問題。</span><span class="sxs-lookup"><span data-stu-id="f22a2-320">Looking at `BeanTraderServiceClient` draws our attention to a larger issue, though.</span></span> <span data-ttu-id="f22a2-321">此 WCF 用戶端由[Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)工具自動生成。</span><span class="sxs-lookup"><span data-stu-id="f22a2-321">This WCF client was autogenerated by the [Svcutil.exe](../../framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) tool.</span></span>

<span data-ttu-id="f22a2-322">**Svcutil 生成的 WCF 用戶端用於 .NET 框架。**</span><span class="sxs-lookup"><span data-stu-id="f22a2-322">**WCF clients generated by Svcutil are meant for use on .NET Framework.**</span></span>

<span data-ttu-id="f22a2-323">使用 svcutil 生成的 WCF 用戶端的解決方案需要重新生成 .NET 標準相容的用戶端,以便與 .NET Core 一起使用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-323">Solutions that use svcutil-generated WCF clients will need to regenerate .NET Standard-compatible clients for use with .NET Core.</span></span> <span data-ttu-id="f22a2-324">舊用戶端無法工作的主要原因之一是,它們依賴於應用配置來定義 WCF 綁定和終結點。</span><span class="sxs-lookup"><span data-stu-id="f22a2-324">One of the main reasons the old clients won't work is that they depend on app configuration for defining WCF bindings and endpoints.</span></span> <span data-ttu-id="f22a2-325">由於 .NET 標準 WCF API 可以跨平臺工作(其中 System.配置 API 不可用),因此 .NET 核心和 .NET 標準方案的 WCF 用戶端必須以程式設計方式定義綁定和終結點,而不是在配置中定義綁定和終結點。</span><span class="sxs-lookup"><span data-stu-id="f22a2-325">Because .NET Standard WCF APIs can work cross-platform (where System.Configuration APIs aren't available), WCF clients for .NET Core and .NET Standard scenarios must define bindings and endpoints programmatically instead of in configuration.</span></span>

<span data-ttu-id="f22a2-326">事實上,任何 WCF 用戶端使用`<system.serviceModel>`依賴於 app.config 部分(無論是使用 Svcutil 還是手動創建的)都需要更改為在 .NET Core 上工作。</span><span class="sxs-lookup"><span data-stu-id="f22a2-326">In fact, any WCF client usage that depends on the `<system.serviceModel>` app.config section (whether created with Svcutil or manually) will need to be changed to work on .NET Core.</span></span>

<span data-ttu-id="f22a2-327">有兩種方法可以自動產生與 .NET 標準相容的 WCF 用戶端:</span><span class="sxs-lookup"><span data-stu-id="f22a2-327">There are two ways to automatically generate .NET Standard-compatible WCF clients:</span></span>

- <span data-ttu-id="f22a2-328">該工具`dotnet-svcutil`是一個 .NET 工具,以類似於 Svcutil 以前的工作方式的方式生成 WCF 用戶端。</span><span class="sxs-lookup"><span data-stu-id="f22a2-328">The `dotnet-svcutil` tool is a .NET tool that generates WCF clients in a way that is similar to how Svcutil worked previously.</span></span>
- <span data-ttu-id="f22a2-329">Visual Studio 可以使用其連接服務功能的[WCF Web 服務參考](../../core/additional-tools/wcf-web-service-reference-guide.md)選項生成 WCF 用戶端。</span><span class="sxs-lookup"><span data-stu-id="f22a2-329">Visual Studio can generate WCF clients using the [WCF Web Service Reference](../../core/additional-tools/wcf-web-service-reference-guide.md) option of its Connected Services feature.</span></span>

<span data-ttu-id="f22a2-330">兩種方法都有效。</span><span class="sxs-lookup"><span data-stu-id="f22a2-330">Either approach works well.</span></span> <span data-ttu-id="f22a2-331">或者,當然,您可以自己編寫 WCF 客戶端代碼。</span><span class="sxs-lookup"><span data-stu-id="f22a2-331">Alternatively, of course, you could write the WCF client code yourself.</span></span> <span data-ttu-id="f22a2-332">對於此示例,我選擇使用可視化工作室連接服務功能。</span><span class="sxs-lookup"><span data-stu-id="f22a2-332">For this sample, I chose to use the Visual Studio Connected Service feature.</span></span> <span data-ttu-id="f22a2-333">為此,請右鍵單擊 Visual Studio 解決方案資源管理員中的*BeanTraderClient.Core*專案,然後選擇「**添加** > **連接服務**」 。</span><span class="sxs-lookup"><span data-stu-id="f22a2-333">To do that, right-click on the *BeanTraderClient.Core* project in Visual Studio's solution explorer and select **Add** > **Connected Service**.</span></span> <span data-ttu-id="f22a2-334">接下來,選擇 WCF Web 服務參考提供程式。</span><span class="sxs-lookup"><span data-stu-id="f22a2-334">Next, choose the WCF Web Service Reference Provider.</span></span> <span data-ttu-id="f22a2-335">這將彈出一個對話框,您可以在其中指定後端 Bean Trader Web`localhost:8080`服務的位址( 如果您在本地端執行伺服器)和生成類型的命名空間應使用(例如**BeanTrader.Service)。**</span><span class="sxs-lookup"><span data-stu-id="f22a2-335">This will bring up a dialog where you can specify the address of the backend Bean Trader web service (`localhost:8080` if you are running the server locally) and the namespace that generated types should use (**BeanTrader.Service**, for example).</span></span>

![WCF Web 服務參考連線的服務對話框](./media/convert-project-from-net-framework/connected-service-dialog.png)

<span data-ttu-id="f22a2-337">選擇 **"完成"** 按鈕後,將添加新的"已連接服務"節點,並在該節點下添加一個Reference.cs檔,其中包含用於存取 Bean Trader 服務的新 .NET 標準 WCF 用戶端。</span><span class="sxs-lookup"><span data-stu-id="f22a2-337">After you select the **Finish** button, a new Connected Services node is added to the project and a Reference.cs file is added under that node containing the new .NET Standard WCF client for accessing the Bean Trader service.</span></span> <span data-ttu-id="f22a2-338">如果查看該檔中的`GetEndpointAddress``GetBindingForEndpoint`或 方法,您將看到綁定和終結點現在以程式設計方式生成(而不是透過應用配置)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-338">If you look at the `GetEndpointAddress` or `GetBindingForEndpoint` methods in that file, you'll see that bindings and endpoints are now generated programmatically (instead of via app config).</span></span> <span data-ttu-id="f22a2-339">"添加已連接服務"功能還可能添加對專案檔中某些 System.ServiceModel 包的引用,因為所有必需的 WCF 包都通過 Microsoft.Windows.相容性包含在內,因此不需要這些引用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-339">The 'Add Connected Services' feature may also add references to some System.ServiceModel packages in the project file, which aren't needed since all necessary WCF packages are included via Microsoft.Windows.Compatibility.</span></span> <span data-ttu-id="f22a2-340">檢查 csproj 以查看是否添加了任何額外的 System.ServiceModel`<PackageReference>`專案,如果是,請刪除它們。</span><span class="sxs-lookup"><span data-stu-id="f22a2-340">Check the csproj to see if any extra System.ServiceModel `<PackageReference>` items have been added, and if so, remove them.</span></span>

<span data-ttu-id="f22a2-341">我們的項目現在有新的WCF用戶端類(*在Reference.cs),* 但它也有舊的(在BeanTrader.cs)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-341">Our project has new WCF client classes now (in *Reference.cs*), but it also still has the old ones (in BeanTrader.cs).</span></span> <span data-ttu-id="f22a2-342">此時有兩個選項:</span><span class="sxs-lookup"><span data-stu-id="f22a2-342">There are two options at this point:</span></span>

- <span data-ttu-id="f22a2-343">如果希望能夠構建原始的 .NET Framework 專案(以及新的 .NET Core 目標`<Compile Remove="BeanTrader.cs" />`專案),則可以使用 .NET Core 專案的 csproj 檔中的專案,以便應用程式的 .NET 框架和 .NET Core 版本使用不同的 WCF 用戶端。</span><span class="sxs-lookup"><span data-stu-id="f22a2-343">If you want to be able to build the original .NET Framework project (alongside the new .NET Core-targeted one), you can use a `<Compile Remove="BeanTrader.cs" />` item in the .NET Core project's csproj file so that the .NET Framework and .NET Core versions of the app use different WCF clients.</span></span> <span data-ttu-id="f22a2-344">這樣做的好處是使現有的 .NET Framework 專案保持不變,但缺點是使用生成的 WCF 用戶端的代碼可能需要在 .NET Core 案例中與 .NET 框架專案`#if`中的代碼略有不同,因此您可能需要使用 指令有條件地編譯某些 WCF 用戶端使用方式(例如創建用戶端),以便在為 .NET Core 構建時採用單向方式工作,在為 .NET 框架構建時,可能需要另一種方式。</span><span class="sxs-lookup"><span data-stu-id="f22a2-344">This has the advantage of leaving the existing .NET Framework project unchanged, but has the disadvantage that code using the generated WCF clients may need to be slightly different in the .NET Core case than it was in the .NET Framework project, so you'll likely need to use `#if` directives to conditionally compile some WCF client usage (creating clients, for example) to work one way when built for .NET Core and another way when built for .NET Framework.</span></span>

- <span data-ttu-id="f22a2-345">另一方面,如果現有的 .NET Framework 專案中的某些代碼改動是可以接受的,則可以同時刪除*BeanTrader.cs。*</span><span class="sxs-lookup"><span data-stu-id="f22a2-345">If, on the other hand, some code churn in the existing .NET Framework project is acceptable, you can remove *BeanTrader.cs* all together.</span></span> <span data-ttu-id="f22a2-346">由於新的 WCF 用戶端是為 .NET 標準構建的,因此它將同時在 .NET Core 和 .NET 框架方案中工作。</span><span class="sxs-lookup"><span data-stu-id="f22a2-346">Because the new WCF client is built for .NET Standard, it will work in both .NET Core and .NET Framework scenarios.</span></span> <span data-ttu-id="f22a2-347">如果要為 .NET 框架構建 .NET 框架(通過多目標或具有兩個 csproj 檔案),則可以對兩個目標使用此新的*Reference.cs*檔。</span><span class="sxs-lookup"><span data-stu-id="f22a2-347">If you are building for .NET Framework in addition to .NET Core (either by multi-targeting or by having two csproj files), you can use this new *Reference.cs* file for both targets.</span></span> <span data-ttu-id="f22a2-348">此方法的優點是,代碼不需要分叉來支援兩個不同的 WCF 用戶端;相同的代碼將在任何地方使用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-348">This approach has the advantage that the code won't need to bifurcate to support two different WCF clients; the same code will be used everywhere.</span></span> <span data-ttu-id="f22a2-349">缺點是它涉及更改 (大概穩定) .NET 框架專案。</span><span class="sxs-lookup"><span data-stu-id="f22a2-349">The drawback is that it involves changing the (presumably stable) .NET Framework project.</span></span>

<span data-ttu-id="f22a2-350">在 Bean Trader 範例中,如果原始專案使遷移更容易,則可以對原始專案進行少量更改,因此請按照以下步驟協調 WCF 用戶端使用方式:</span><span class="sxs-lookup"><span data-stu-id="f22a2-350">In the case of the Bean Trader sample, you can make small changes to the original project if it makes migration easier, so follow these steps to reconcile WCF client usage:</span></span>

01. <span data-ttu-id="f22a2-351">使用解決方案資源管理員中的「添加現有專案」上下文選單將新的Reference.cs檔添加到 .NET 框架*BeanTraderClient.csproj*專案中。</span><span class="sxs-lookup"><span data-stu-id="f22a2-351">Add the new Reference.cs file to the .NET Framework *BeanTraderClient.csproj* project using the 'Add existing item' context menu from the solution explorer.</span></span> <span data-ttu-id="f22a2-352">請務必添加"作為連結",以便兩個專案使用相同的檔(而不是複製 C# 檔案)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-352">Be sure to add 'as link' so that the same file is used by both projects (as opposed to copying the C# file).</span></span> <span data-ttu-id="f22a2-353">如果要使用單個 csproj(使用多目標)為 .NET Core 和 .NET 框架構建,則此步驟是不必要的。</span><span class="sxs-lookup"><span data-stu-id="f22a2-353">If you are building for both .NET Core and .NET Framework with a single csproj (using multi-targeting) then this step isn't necessary.</span></span>

01. <span data-ttu-id="f22a2-354">刪除*BeanTrader.cs*BeanTrader.cs 。</span><span class="sxs-lookup"><span data-stu-id="f22a2-354">Delete *BeanTrader.cs*.</span></span>

01. <span data-ttu-id="f22a2-355">新的 WCF 用戶端與舊用戶端類似,但生成的代碼中的多個命名空間不同。</span><span class="sxs-lookup"><span data-stu-id="f22a2-355">The new WCF client is similar to the old one, but a number of namespaces in the generated code are different.</span></span> <span data-ttu-id="f22a2-356">因此,有必要更新專案,以便 WCF 用戶端類型從 BeanTrader.Service.Service(或您選擇的任何命名空間名稱)而不是 BeanTrader.Model 或沒有命名空間使用。</span><span class="sxs-lookup"><span data-stu-id="f22a2-356">Because of this, it is necessary to update the project so that WCF client types are used from BeanTrader.Service (or whatever namespace name you chose) instead of BeanTrader.Model or without a namespace.</span></span> <span data-ttu-id="f22a2-357">構建*BeanTraderClient.Core.csproj*將有助於確定需要進行更改的位置。</span><span class="sxs-lookup"><span data-stu-id="f22a2-357">Building *BeanTraderClient.Core.csproj* will help to identify where these changes need to be made.</span></span> <span data-ttu-id="f22a2-358">在 C# 和 XAML 源檔中都需要修復。</span><span class="sxs-lookup"><span data-stu-id="f22a2-358">Fixes will be needed both in C# and in XAML source files.</span></span>

01. <span data-ttu-id="f22a2-359">最後,您將發現*BeanTraderServiceClientFactory.cs*存在錯誤,因為`BeanTraderServiceClient`類型的可用構造函數已更改。</span><span class="sxs-lookup"><span data-stu-id="f22a2-359">Finally, you'll discover that there is an error in *BeanTraderServiceClientFactory.cs* because the available constructors for the `BeanTraderServiceClient` type have changed.</span></span> <span data-ttu-id="f22a2-360">它曾經可以提供一個`InstanceContext`參數(這是`CallbackHandler``Castle.Windsor`使用 IoC 容器創建的)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-360">It used to be possible to supply an `InstanceContext` argument (which was created using a `CallbackHandler` from the `Castle.Windsor` IoC container).</span></span> <span data-ttu-id="f22a2-361">新的構造函數創建新`CallbackHandler`的 s。</span><span class="sxs-lookup"><span data-stu-id="f22a2-361">The new constructors create new `CallbackHandler`s.</span></span> <span data-ttu-id="f22a2-362">但是,在基類型中`BeanTraderServiceClient`,構造函數與所需內容相匹配。</span><span class="sxs-lookup"><span data-stu-id="f22a2-362">There are, however, constructors in `BeanTraderServiceClient`'s base type that match what you want.</span></span> <span data-ttu-id="f22a2-363">由於自動生成的 WCF 用戶端代碼都存在於部分類中,因此可以輕鬆地擴展它。</span><span class="sxs-lookup"><span data-stu-id="f22a2-363">Since the autogenerated WCF client code all exists in partial classes, you can easily extend it.</span></span> <span data-ttu-id="f22a2-364">為此,請創建一個名為*BeanTraderServiceClient.cs*的新檔案,然後創建具有相同名稱的部分類(使用 BeanTrader.Service 命名空間)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-364">To do this, create a new file called *BeanTraderServiceClient.cs* and then create a partial class with that same name (using the BeanTrader.Service namespace).</span></span> <span data-ttu-id="f22a2-365">然後,將一個構造函數添加到部分類型,如下所示。</span><span class="sxs-lookup"><span data-stu-id="f22a2-365">Then, add one constructor to the partial type as shown here.</span></span>

    ```csharp
    public BeanTraderServiceClient(System.ServiceModel.InstanceContext callbackInstance) :
        base(callbackInstance, EndpointConfiguration.NetTcpBinding_BeanTraderService)
            { }
    ```

<span data-ttu-id="f22a2-366">進行這些更改後,Bean Trader 範例現在將使用新的 .NET 標準相容的 WCF 用戶端,您可以TradingService.cs改為更改`Open`呼叫*TradingService.cs*`await OpenAsync`的最後修復方法。</span><span class="sxs-lookup"><span data-stu-id="f22a2-366">With those changes made, the Bean Trader sample will now be using a new .NET Standard-compatible WCF client and you can make the final fix of changing the `Open` call in *TradingService.cs* to use `await OpenAsync` instead.</span></span>

<span data-ttu-id="f22a2-367">隨著 WCF 問題的解決,Bean Trader 示例的 .NET 核心版本現在構建乾淨!</span><span class="sxs-lookup"><span data-stu-id="f22a2-367">With the WCF issues addressed, the .NET Core version of the Bean Trader sample now builds cleanly!</span></span>

## <a name="runtime-testing"></a><span data-ttu-id="f22a2-368">執行時測試</span><span class="sxs-lookup"><span data-stu-id="f22a2-368">Runtime testing</span></span>

<span data-ttu-id="f22a2-369">很容易忘記,一旦項目針對 .NET Core 乾淨地構建,遷移工作就不會完成。</span><span class="sxs-lookup"><span data-stu-id="f22a2-369">It's easy to forget that migration work isn't done as soon as the project builds cleanly against .NET Core.</span></span> <span data-ttu-id="f22a2-370">留出時間測試移植的應用程式也很重要。</span><span class="sxs-lookup"><span data-stu-id="f22a2-370">It's important to leave time for testing the ported app, too.</span></span> <span data-ttu-id="f22a2-371">成功生成內容後,請確保應用按預期運行並工作,尤其是在使用針對 .NET Framework 的任何包時。</span><span class="sxs-lookup"><span data-stu-id="f22a2-371">Once things build successfully, make sure the app runs and works as expected, especially if you are using any packages targeting .NET Framework.</span></span>

<span data-ttu-id="f22a2-372">讓我們嘗試啟動移植的豆交易應用程式,看看會發生什麼。</span><span class="sxs-lookup"><span data-stu-id="f22a2-372">Let's try launching the ported Bean Trader app and see what happens.</span></span> <span data-ttu-id="f22a2-373">除了以下例外情況外,應用在失敗之前不會走得太遠。</span><span class="sxs-lookup"><span data-stu-id="f22a2-373">The app doesn't get far before failing with the following exception.</span></span>

```output
System.Configuration.ConfigurationErrorsException: 'Configuration system failed to initialize'

Inner Exception
ConfigurationErrorsException: Unrecognized configuration section system.serviceModel.
```

<span data-ttu-id="f22a2-374">當然,這是有道理的。</span><span class="sxs-lookup"><span data-stu-id="f22a2-374">This makes sense, of course.</span></span> <span data-ttu-id="f22a2-375">請記住,WCF 不再使用應用配置,因此需要刪除 app.config 檔的舊系統.serviceModel 部分。</span><span class="sxs-lookup"><span data-stu-id="f22a2-375">Remember that WCF no longer uses app configuration, so the old system.serviceModel section of the app.config file needs to be removed.</span></span> <span data-ttu-id="f22a2-376">更新後的 WCF 用戶端在其代碼中包含所有相同的資訊,因此不再需要配置部分。</span><span class="sxs-lookup"><span data-stu-id="f22a2-376">The updated WCF client includes all of the same information in its code, so the config section isn't needed anymore.</span></span> <span data-ttu-id="f22a2-377">如果希望 WCF 終結點在 app.config 中可配置,則可以將其添加為應用設置,並更新 WCF 用戶端代碼以從配置中檢索 WCF 服務終結點。</span><span class="sxs-lookup"><span data-stu-id="f22a2-377">If you wanted the WCF endpoint to be configurable in app.config, you could add it as an app setting and update the WCF client code to retrieve the WCF service endpoint from configuration.</span></span>

<span data-ttu-id="f22a2-378">刪除*app.config*的 system.serviceModel 部分後,應用啟動,但在使用者登錄時失敗,但另一個例外。</span><span class="sxs-lookup"><span data-stu-id="f22a2-378">After removing the system.serviceModel section of *app.config*, the app launches but fails with another exception when a user signs in.</span></span>

```output
System.PlatformNotSupportedException: 'Operation is not supported on this platform.'
```

<span data-ttu-id="f22a2-379">不支援的 API`Func<T>.BeginInvoke`是 。</span><span class="sxs-lookup"><span data-stu-id="f22a2-379">The unsupported API is `Func<T>.BeginInvoke`.</span></span> <span data-ttu-id="f22a2-380">如[dotnet/corefx_5940](https://github.com/dotnet/corefx/issues/5940)中所述,.NET Core 不支援`BeginInvoke`委託`EndInvoke`類型和方法,因為存在基礎的遠端處理依賴關係。</span><span class="sxs-lookup"><span data-stu-id="f22a2-380">As explained in [dotnet/corefx#5940](https://github.com/dotnet/corefx/issues/5940), .NET Core doesn't support the `BeginInvoke` and `EndInvoke` methods on delegate types due to underlying remoting dependencies.</span></span> <span data-ttu-id="f22a2-381">此問題及其修復程式在遷移委託中進行了更詳細的解釋[。 BeginInvoke 呼叫 .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/)部落`BeginInvoke``EndInvoke`格文章,但要`Task.Run`點是, 呼叫應取代為 (或異步替代,如果可能)。</span><span class="sxs-lookup"><span data-stu-id="f22a2-381">This issue and its fix are explained in more detail in the [Migrating Delegate.BeginInvoke Calls for .NET Core](https://devblogs.microsoft.com/dotnet/migrating-delegate-begininvoke-calls-for-net-core/) blog post, but the gist is that `BeginInvoke` and `EndInvoke` calls should be replaced with `Task.Run` (or async alternatives, if possible).</span></span> <span data-ttu-id="f22a2-382">在此處應用常規解決方案,`BeginInvoke`呼叫可以取代為`Invoke``Task.Run`由啟動的呼叫。</span><span class="sxs-lookup"><span data-stu-id="f22a2-382">Applying the general solution here, the `BeginInvoke` call can be replaced with an `Invoke` call launched by `Task.Run`.</span></span>

```csharp
Task.Run(() =>
{
    return userInfoRetriever.Invoke();
}).ContinueWith(result =>
{
    // BeginInvoke's callback is replaced with ContinueWith
    var task = result.ConfigureAwait(false);
    CurrentTrader = task.GetAwaiter().GetResult();
}, TaskScheduler.Default);
```

<span data-ttu-id="f22a2-383">刪除`BeginInvoke`使用後,豆交易者應用程式在 .NET 核心上成功運行!</span><span class="sxs-lookup"><span data-stu-id="f22a2-383">After removing the `BeginInvoke` usage, the Bean Trader app runs successfully on .NET Core!</span></span>

![在 .NET 核心上執行的豆交易者](./media/convert-project-from-net-framework/running-on-core.png)

<span data-ttu-id="f22a2-385">所有應用都不同,因此將您自己的應用遷移到 .NET Core 所需的特定步驟會有所不同。</span><span class="sxs-lookup"><span data-stu-id="f22a2-385">All apps are different, so the specific steps needed to migrate your own apps to .NET Core will vary.</span></span> <span data-ttu-id="f22a2-386">但希望 Bean Trader 範例演示了常規工作流和可以預期的問題類型。</span><span class="sxs-lookup"><span data-stu-id="f22a2-386">But hopefully the Bean Trader sample demonstrates the general workflow and the types of issues that can be expected.</span></span> <span data-ttu-id="f22a2-387">而且,儘管本文的長度,豆交易者樣本中所需的實際更改,使其在 .NET Core 上工作相當有限。</span><span class="sxs-lookup"><span data-stu-id="f22a2-387">And, despite this article's length, the actual changes needed in the Bean Trader sample to make it work on .NET Core were fairly limited.</span></span> <span data-ttu-id="f22a2-388">許多應用以同樣方式遷移到 .NET Core;需要有限甚至無需更改代碼。</span><span class="sxs-lookup"><span data-stu-id="f22a2-388">Many apps migrate to .NET Core in this same way; with limited or even no code changes needed.</span></span>
