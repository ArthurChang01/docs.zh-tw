---
title: 定義可搭配 .NET XAML 服務使用的自訂類型
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: ff7e4229450e801a6d618c5141efde8cdcbef03d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/12/2020
ms.locfileid: "82071854"
---
# <a name="define-custom-types-for-use-with-net-xaml-services"></a><span data-ttu-id="12fea-102">定義為 .NET XAML 服務的自訂類型</span><span class="sxs-lookup"><span data-stu-id="12fea-102">Define custom types for use with .NET XAML Services</span></span>

<span data-ttu-id="12fea-103">當您定義業務物件或對特定框架不依賴的類型時,您可以遵循 XAML 的某些最佳做法。</span><span class="sxs-lookup"><span data-stu-id="12fea-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="12fea-104">如果您遵循這些實踐,.NET XAML 服務及其 XAML 讀取器和 XAML 編寫器可以發現您類型的 XAML 特徵,並使用 XAML 類型系統在 XAML 節點流中為其提供適當的表示形式。</span><span class="sxs-lookup"><span data-stu-id="12fea-104">If you follow these practices, .NET XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="12fea-105">本主題介紹類型定義、成員定義和類型或成員的 CLR 歸因的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="12fea-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>

## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="12fea-106">XAML 的建構函式模式和類型定義</span><span class="sxs-lookup"><span data-stu-id="12fea-106">Constructor Patterns and Type Definitions for XAML</span></span>

<span data-ttu-id="12fea-107">要在 XAML 中實體化為物件元素,自訂類必須滿足以下要求:</span><span class="sxs-lookup"><span data-stu-id="12fea-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>

- <span data-ttu-id="12fea-108">自定義類必須是公共的,並且必須公開無參數的公共構造函數。</span><span class="sxs-lookup"><span data-stu-id="12fea-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="12fea-109">(如需結構相關附註，請參閱下節)。</span><span class="sxs-lookup"><span data-stu-id="12fea-109">(See following section for notes regarding structures.)</span></span>

- <span data-ttu-id="12fea-110">自定義類不能是嵌套類。</span><span class="sxs-lookup"><span data-stu-id="12fea-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="12fea-111">全名路徑中的額外"點"使類命名空間劃分不明確,並干擾其他 XAML 功能(如附加屬性)。</span><span class="sxs-lookup"><span data-stu-id="12fea-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>
<span data-ttu-id="12fea-112">如果物件可以實例化為物件元素,則創建的物件可以填充將對象作為其基礎類型的任何屬性的屬性元素形式。</span><span class="sxs-lookup"><span data-stu-id="12fea-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>

<span data-ttu-id="12fea-113">如果啟用值轉換器,仍可以為不符合這些標準的類型提供物件值。</span><span class="sxs-lookup"><span data-stu-id="12fea-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="12fea-114">有關詳細資訊,請參閱[XAML 的類型轉換器和標記延伸](type-converters-and-markup-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="12fea-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

### <a name="structures"></a><span data-ttu-id="12fea-115">結構</span><span class="sxs-lookup"><span data-stu-id="12fea-115">Structures</span></span>

<span data-ttu-id="12fea-116">結構始終能夠在 XAML 中透過 CLR 定義構造。</span><span class="sxs-lookup"><span data-stu-id="12fea-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="12fea-117">這是因為 CLR 編譯器隱式為結構創建了無參數構造函數。</span><span class="sxs-lookup"><span data-stu-id="12fea-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="12fea-118">此建構函數將所有屬性值初始化到其預設值。</span><span class="sxs-lookup"><span data-stu-id="12fea-118">This constructor initializes all property values to their defaults.</span></span>

<span data-ttu-id="12fea-119">在某些情況下,結構的預設構造行為是不需要的。</span><span class="sxs-lookup"><span data-stu-id="12fea-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="12fea-120">這可能是因為結構旨在填充值,並在概念上作為聯合進行函數。</span><span class="sxs-lookup"><span data-stu-id="12fea-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="12fea-121">作為聯合,包含的值可能具有互斥的解釋,因此,其屬性都不是可設置的。</span><span class="sxs-lookup"><span data-stu-id="12fea-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="12fea-122">WPF 字彙中這種結構的範例是<xref:System.Windows.GridLength>。</span><span class="sxs-lookup"><span data-stu-id="12fea-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="12fea-123">此類結構應實現類型轉換器,以便透過使用創建結構值的不同解釋或模式的字串約定,以屬性形式表示值。</span><span class="sxs-lookup"><span data-stu-id="12fea-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="12fea-124">結構還應通過非參數構造函數公開代碼構造的類似行為。</span><span class="sxs-lookup"><span data-stu-id="12fea-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>

### <a name="interfaces"></a><span data-ttu-id="12fea-125">介面</span><span class="sxs-lookup"><span data-stu-id="12fea-125">Interfaces</span></span>

<span data-ttu-id="12fea-126">介面可用作成員的基礎類型。</span><span class="sxs-lookup"><span data-stu-id="12fea-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="12fea-127">XAML 類型系統檢查可分配清單,並期望作為值提供的物件可以分配給介面。</span><span class="sxs-lookup"><span data-stu-id="12fea-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="12fea-128">只要相關的可分配類型支援 XAML 建構要求,則對於介面必須作為 XAML 類型呈現的概念是沒有概念的。</span><span class="sxs-lookup"><span data-stu-id="12fea-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>

### <a name="factory-methods"></a><span data-ttu-id="12fea-129">工廠方法</span><span class="sxs-lookup"><span data-stu-id="12fea-129">Factory Methods</span></span>

<span data-ttu-id="12fea-130">工廠方法是 XAML 2009 功能。</span><span class="sxs-lookup"><span data-stu-id="12fea-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="12fea-131">它們修改了 XAML 原則,即物件必須具有無參數構造函數。</span><span class="sxs-lookup"><span data-stu-id="12fea-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="12fea-132">本文沒有記錄工廠方法。</span><span class="sxs-lookup"><span data-stu-id="12fea-132">Factory methods are not documented in this article.</span></span> <span data-ttu-id="12fea-133">請參考[x:工廠方法指令](xfactorymethod-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="12fea-133">See [x:FactoryMethod Directive](xfactorymethod-directive.md).</span></span>

## <a name="enumerations"></a><span data-ttu-id="12fea-134">列舉</span><span class="sxs-lookup"><span data-stu-id="12fea-134">Enumerations</span></span>

<span data-ttu-id="12fea-135">枚舉具有 XAML 本機類型轉換行為。</span><span class="sxs-lookup"><span data-stu-id="12fea-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="12fea-136">根據基礎枚舉類型解析 XAML 中指定的枚舉常量名稱,並將枚舉值返回給 XAML 物件編寫器。</span><span class="sxs-lookup"><span data-stu-id="12fea-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>

<span data-ttu-id="12fea-137">XAML<xref:System.FlagsAttribute>支援 應用的枚舉標記樣式用法。</span><span class="sxs-lookup"><span data-stu-id="12fea-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="12fea-138">有關詳細資訊,請參閱[XAML 語法詳細資訊](../../framework/wpf/advanced/xaml-syntax-in-detail.md)。</span><span class="sxs-lookup"><span data-stu-id="12fea-138">For more information, see [XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="12fea-139">[(XAML 語法詳細](../../framework/wpf/advanced/xaml-syntax-in-detail.md)為 WPF 受眾編寫,但該主題中的大多數資訊與不特定於特定實現框架的 XAML 相關。</span><span class="sxs-lookup"><span data-stu-id="12fea-139">([XAML Syntax In Detail](../../framework/wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>

## <a name="member-definitions"></a><span data-ttu-id="12fea-140">成員定義</span><span class="sxs-lookup"><span data-stu-id="12fea-140">Member Definitions</span></span>

<span data-ttu-id="12fea-141">類型可以為 XAML 使用定義成員。</span><span class="sxs-lookup"><span data-stu-id="12fea-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="12fea-142">類型可以定義 XAML 可用的成員,即使該特定類型不可用於 XAML。</span><span class="sxs-lookup"><span data-stu-id="12fea-142">It's possible for types to define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="12fea-143">這是可能的,因為CLR繼承。</span><span class="sxs-lookup"><span data-stu-id="12fea-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="12fea-144">只要繼承該成員的某些類型支援 XAML 使用作為類型,並且該成員支援其基礎類型的 XAML 用法或具有本機 XAML 語法可用,該成員即可用於 XAML。</span><span class="sxs-lookup"><span data-stu-id="12fea-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>

### <a name="properties"></a><span data-ttu-id="12fea-145">屬性</span><span class="sxs-lookup"><span data-stu-id="12fea-145">Properties</span></span>

<span data-ttu-id="12fea-146">如果使用典型的`get`CLR 和訪問`set`模式以及 語言適當的關鍵字將屬性定義為公共 CLR 屬性,則 XAML 類型系統可以將該屬性<xref:System.Xaml.XamlMember>報告為成員<xref:System.Xaml.XamlMember.IsReadPublic%2A>,<xref:System.Xaml.XamlMember.IsWritePublic%2A>並提供有關 屬性(如和 )等屬性的適當資訊。</span><span class="sxs-lookup"><span data-stu-id="12fea-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>

<span data-ttu-id="12fea-147">特定屬性可以透過<xref:System.ComponentModel.TypeConverterAttribute>應用 啟用文本語法來啟用文本語法。</span><span class="sxs-lookup"><span data-stu-id="12fea-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="12fea-148">有關詳細資訊,請參閱[XAML 的類型轉換器和標記延伸](type-converters-and-markup-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="12fea-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="12fea-149">在沒有文字語法或本機 XAML 轉換的情況下,在沒有進一步間接(如標記擴展用法)的情況下,屬性的<xref:System.Xaml.XamlMember.TargetType%2A>類型( 在 XAML 類型系統中)必須能夠將實例視為 CLR 類型,將實例返回到 XAML 物件編寫器。</span><span class="sxs-lookup"><span data-stu-id="12fea-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>

<span data-ttu-id="12fea-150">如果使用 XAML 2009,則如果未滿足以前的注意事項,可以使用[x:參考標記擴展](xreference-markup-extension.md)提供值;但是,這更多的是使用問題,而不是類型定義問題。</span><span class="sxs-lookup"><span data-stu-id="12fea-150">If using XAML 2009, [x:Reference Markup Extension](xreference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>

### <a name="events"></a><span data-ttu-id="12fea-151">事件</span><span class="sxs-lookup"><span data-stu-id="12fea-151">Events</span></span>

<span data-ttu-id="12fea-152">如果將事件定義為公共 CLR 事件,XAML 類型系統可以將事件<xref:System.Xaml.XamlMember.IsEvent%2A>報告為具有`true`的成員。</span><span class="sxs-lookup"><span data-stu-id="12fea-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="12fea-153">連接事件處理程式不在 .NET XAML 服務功能範圍內;因此,在 .NET XAML 服務功能範圍內,則對事件處理程序進行佈線。線路留給特定的框架和實現。</span><span class="sxs-lookup"><span data-stu-id="12fea-153">Wiring the event handlers is not within the scope of .NET XAML Services capabilities; wiring is left to specific frameworks and implementations.</span></span>

### <a name="methods"></a><span data-ttu-id="12fea-154">方法</span><span class="sxs-lookup"><span data-stu-id="12fea-154">Methods</span></span>

<span data-ttu-id="12fea-155">方法的內聯代碼不是預設的 XAML 功能。</span><span class="sxs-lookup"><span data-stu-id="12fea-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="12fea-156">在大多數情況下,您不會直接引用 XAML 中的方法成員,並且方法在 XAML 中的角色只是為特定的 XAML 模式提供支援。</span><span class="sxs-lookup"><span data-stu-id="12fea-156">In most cases, you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="12fea-157">[x:工廠方法指令](xfactorymethod-directive.md)是一個例外。</span><span class="sxs-lookup"><span data-stu-id="12fea-157">[x:FactoryMethod Directive](xfactorymethod-directive.md) is an exception.</span></span>

### <a name="fields"></a><span data-ttu-id="12fea-158">欄位</span><span class="sxs-lookup"><span data-stu-id="12fea-158">Fields</span></span>

<span data-ttu-id="12fea-159">CLR 設計指南阻止非靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="12fea-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="12fea-160">對於靜態欄位,只能通過[x:靜態標記擴展](xstatic-markup-extension.md)訪問靜態欄位值。在這種情況下,您沒有在 CLR 定義中執行任何特殊操作來公開[x:靜態](xstatic-markup-extension.md)用法的欄位。</span><span class="sxs-lookup"><span data-stu-id="12fea-160">For static fields, you can access static field values only through [x:Static Markup Extension](xstatic-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](xstatic-markup-extension.md) usages.</span></span>

## <a name="attachable-members"></a><span data-ttu-id="12fea-161">可附加成員</span><span class="sxs-lookup"><span data-stu-id="12fea-161">Attachable Members</span></span>

<span data-ttu-id="12fea-162">可附加成員通過定義類型上的訪問器方法模式向 XAML 公開。</span><span class="sxs-lookup"><span data-stu-id="12fea-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="12fea-163">定義類型本身不需要 XAML 作為物件可用。</span><span class="sxs-lookup"><span data-stu-id="12fea-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="12fea-164">實際上,一種常見模式是聲明服務類,其作用是擁有可附加成員並實現相關行為,但不提供其他函數,如 UI 表示形式。</span><span class="sxs-lookup"><span data-stu-id="12fea-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="12fea-165">對於以下部分,占位符*屬性名稱*表示可附加成員的名稱。</span><span class="sxs-lookup"><span data-stu-id="12fea-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="12fea-166">該名稱必須在[XamlName 語法](xamlname-grammar.md)中有效。</span><span class="sxs-lookup"><span data-stu-id="12fea-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>

<span data-ttu-id="12fea-167">小心這些模式和類型的其他方法之間的名稱衝突。</span><span class="sxs-lookup"><span data-stu-id="12fea-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="12fea-168">如果存在與其中一種模式匹配的成員,則 XAML 處理器可以將其解釋為可附加成員使用路徑,即使這不是您的意圖。</span><span class="sxs-lookup"><span data-stu-id="12fea-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>

#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="12fea-169">取得屬性名稱存取器</span><span class="sxs-lookup"><span data-stu-id="12fea-169">The GetPropertyName Accessor</span></span>

<span data-ttu-id="12fea-170">存取器的`GetPropertyName`簽章 必須為:</span><span class="sxs-lookup"><span data-stu-id="12fea-170">The signature for the `GetPropertyName` accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="12fea-171">`target` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="12fea-171">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="12fea-172">您可以使用它來限定可附加成員的使用範圍;預期範圍以外的用法將引發無效強制轉換異常,然後由 XAML 分析錯誤顯示。</span><span class="sxs-lookup"><span data-stu-id="12fea-172">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="12fea-173">參數名稱`target`不是要求,但在大多數實現中按`target`約定 命名。</span><span class="sxs-lookup"><span data-stu-id="12fea-173">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>

- <span data-ttu-id="12fea-174">傳回值可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="12fea-174">The return value can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="12fea-175">要支援<xref:System.ComponentModel.TypeConverter>啟用的文本語法,以便附加成員的屬性使用,請應用<xref:System.ComponentModel.TypeConverterAttribute>`GetPropertyName`於訪問器。</span><span class="sxs-lookup"><span data-stu-id="12fea-175">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `GetPropertyName` accessor.</span></span> <span data-ttu-id="12fea-176">申請`get`,`set`而不是 可能看起來不直觀;但是,此約定可以支援可序列化的唯讀可附加成員的概念,這在設計器方案中很有用。</span><span class="sxs-lookup"><span data-stu-id="12fea-176">Applying to the `get` instead of the `set` may seem non-intuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>

#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="12fea-177">設定屬性名稱存取器</span><span class="sxs-lookup"><span data-stu-id="12fea-177">The SetPropertyName Accessor</span></span>

<span data-ttu-id="12fea-178">存取器的`SetPropertyName`簽章 必須為:</span><span class="sxs-lookup"><span data-stu-id="12fea-178">The signature for the `SetPropertyName` accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="12fea-179">該`target`物件可以指定為實現中更具體的類型,其邏輯和後果與上一節所述相同。</span><span class="sxs-lookup"><span data-stu-id="12fea-179">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>

- <span data-ttu-id="12fea-180">`value` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="12fea-180">The `value` object can be specified as a more specific type in your implementation.</span></span>

<span data-ttu-id="12fea-181">請記住,此方法的值是來自 XAML 用法的輸入,通常以屬性形式提供。</span><span class="sxs-lookup"><span data-stu-id="12fea-181">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="12fea-182">從屬性表單中,必須支援文字語法的值轉換器,並且對`GetPropertyName`s 訪問器的屬性。</span><span class="sxs-lookup"><span data-stu-id="12fea-182">From attribute form there must be value converter support for a text syntax, and you attribute on the `GetPropertyName`s accessor.</span></span>

### <a name="attachable-member-stores"></a><span data-ttu-id="12fea-183">可附加會員商店</span><span class="sxs-lookup"><span data-stu-id="12fea-183">Attachable Member Stores</span></span>

<span data-ttu-id="12fea-184">訪問器方法通常不足以提供將可附加成員值放入物件圖形的方法,或從物件圖中檢索值並正確序列化它們。</span><span class="sxs-lookup"><span data-stu-id="12fea-184">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="12fea-185">要提供此功能,`target`以前存取器簽名中的物件必須能夠儲存值。</span><span class="sxs-lookup"><span data-stu-id="12fea-185">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="12fea-186">儲存機制應符合可附加成員原則,即成員可附加到可附加成員不在成員清單中的目標。</span><span class="sxs-lookup"><span data-stu-id="12fea-186">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="12fea-187">.NET XAML 服務通過<xref:System.Xaml.IAttachedPropertyStore><xref:System.Xaml.AttachablePropertyServices>API 和 為可附加成員存儲提供了一種實現技術。</span><span class="sxs-lookup"><span data-stu-id="12fea-187">.NET XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="12fea-188"><xref:System.Xaml.IAttachedPropertyStore>XAML 編寫器用於發現存儲實現,並且應在訪問`target`器的類型上實現。</span><span class="sxs-lookup"><span data-stu-id="12fea-188"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="12fea-189">靜態<xref:System.Xaml.AttachablePropertyServices>API 在訪問器的正文中使用,並<xref:System.Xaml.AttachableMemberIdentifier>透過其引用可連接成員。</span><span class="sxs-lookup"><span data-stu-id="12fea-189">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>

## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="12fea-190">與 XAML 相關的 CLR 屬性</span><span class="sxs-lookup"><span data-stu-id="12fea-190">XAML-Related CLR Attributes</span></span>

<span data-ttu-id="12fea-191">正確配置類型、成員和程式集對於向 .NET XAML 服務報告 XAML 類型系統資訊非常重要。</span><span class="sxs-lookup"><span data-stu-id="12fea-191">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET XAML Services.</span></span> <span data-ttu-id="12fea-192">如果適用以下任一情況,報告 XAML 類型系統資訊是相關的:</span><span class="sxs-lookup"><span data-stu-id="12fea-192">Reporting XAML type system information is relevant if either of the following situations apply:</span></span>

- <span data-ttu-id="12fea-193">您希望類型與直接基於 .NET XAML 服務 XAML 服務讀取器和 XAML 寫入器的 XAML 系統一起使用。</span><span class="sxs-lookup"><span data-stu-id="12fea-193">You intend your types for use with XAML systems that are directly based on .NET XAML Services XAML readers and XAML writers.</span></span>
- <span data-ttu-id="12fea-194">您定義或使用基於這些 XAML 讀取器和 XAML 編寫器的 XAML 利用框架。</span><span class="sxs-lookup"><span data-stu-id="12fea-194">You define or use a XAML-utilizing framework that's based on those XAML readers and XAML writers.</span></span>

<span data-ttu-id="12fea-195">有關與自訂類型的 XAML 支援相關的每個 XAML 相關屬性的清單,請參閱[自訂類型和函式庫的 XAML 相關 CLR 屬性](clr-attributes-with-custom-types-and-libraries.md)。</span><span class="sxs-lookup"><span data-stu-id="12fea-195">For a listing of each XAML-related attribute that's relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](clr-attributes-with-custom-types-and-libraries.md).</span></span>

## <a name="usage"></a><span data-ttu-id="12fea-196">使用量</span><span class="sxs-lookup"><span data-stu-id="12fea-196">Usage</span></span>

<span data-ttu-id="12fea-197">自訂類型的使用要求標記作者必須映射包含自訂類型的程式集和 CLR 命名空間的前置碼。</span><span class="sxs-lookup"><span data-stu-id="12fea-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="12fea-198">本主題中未記錄此過程。</span><span class="sxs-lookup"><span data-stu-id="12fea-198">This procedure is not documented in this topic.</span></span>

## <a name="access-level"></a><span data-ttu-id="12fea-199">存取層級</span><span class="sxs-lookup"><span data-stu-id="12fea-199">Access Level</span></span>

<span data-ttu-id="12fea-200">XAML 提供了一種載入和實例化`internal`具有 存取等級的類型的方法。</span><span class="sxs-lookup"><span data-stu-id="12fea-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="12fea-201">提供此功能,以便用戶代碼可以定義自己的類型,然後從也是同一用戶代碼作用域的標記實例化這些類。</span><span class="sxs-lookup"><span data-stu-id="12fea-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>

<span data-ttu-id="12fea-202">WPF 的一個範例是,每當用戶代碼<xref:System.Windows.Controls.UserControl>定義旨在重構 UI 行為的方法時,而不是作為任何可能的擴展機制的一部分,這些擴展機制可能`public`通過聲明具有 訪問級別的支援類來暗示。</span><span class="sxs-lookup"><span data-stu-id="12fea-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="12fea-203">如果支援<xref:System.Windows.Controls.UserControl>程式碼編譯到`internal`引用 XAML 類型的同一程式集中,則可以透過權限宣告此類 。</span><span class="sxs-lookup"><span data-stu-id="12fea-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>

<span data-ttu-id="12fea-204">對於在完全信任下載入 XAML<xref:System.Xaml.XamlObjectWriter>並使用的應用程式,始終`internal`啟用具有 訪問級別的載入類。</span><span class="sxs-lookup"><span data-stu-id="12fea-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>

<span data-ttu-id="12fea-205">對於在部分信任下載入 XAML 的應用程式,<xref:System.Xaml.Permissions.XamlAccessLevel>可以使用 API 來控制存取等級特徵。</span><span class="sxs-lookup"><span data-stu-id="12fea-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="12fea-206">此外,延遲機制(如 WPF 範本系統)必須能夠傳播任何訪問級別許可權,並將其保留為最終的運行時評估;這通過傳遞資訊在<xref:System.Xaml.Permissions.XamlAccessLevel>內部處理。</span><span class="sxs-lookup"><span data-stu-id="12fea-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>

### <a name="wpf-implementation"></a><span data-ttu-id="12fea-207">WPF 實施</span><span class="sxs-lookup"><span data-stu-id="12fea-207">WPF Implementation</span></span>

<span data-ttu-id="12fea-208">WPF XAML 使用部分信任訪問模型,其中如果BAML在部分信任下載入<xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A>,則訪問僅限於作為BAML源的程式集。</span><span class="sxs-lookup"><span data-stu-id="12fea-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="12fea-209">對於延遲,WPF 用<xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType>作 傳遞訪問級別資訊的機制。</span><span class="sxs-lookup"><span data-stu-id="12fea-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>

<span data-ttu-id="12fea-210">在 WPF XAML 術語中,*內部類型*是由同一程式集定義的類型,該程式集還包括引用 XAML。</span><span class="sxs-lookup"><span data-stu-id="12fea-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="12fea-211">此類類型可以透過 XAML 命名空間映射,該命名空間有意省略映射的程式`xmlns:local="clr-namespace:WPFApplication1"`集部分, 例如 。</span><span class="sxs-lookup"><span data-stu-id="12fea-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span> <span data-ttu-id="12fea-212">如果 BAML 引用內部類型,`internal`並且該 類型具有訪問級別`GeneratedInternalTypeHelper`,這將為程式集生成一個類。</span><span class="sxs-lookup"><span data-stu-id="12fea-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="12fea-213">如果要避免`GeneratedInternalTypeHelper`,則必須`public`使用 訪問級別,或者必須將相關類考慮到單獨的程式集中,並使該程式集與程式集相關。</span><span class="sxs-lookup"><span data-stu-id="12fea-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>

## <a name="see-also"></a><span data-ttu-id="12fea-214">另請參閱</span><span class="sxs-lookup"><span data-stu-id="12fea-214">See also</span></span>

- [<span data-ttu-id="12fea-215">自訂類型和程式庫的 XAML 相關 CLR 屬性</span><span class="sxs-lookup"><span data-stu-id="12fea-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](clr-attributes-with-custom-types-and-libraries.md)
- [<span data-ttu-id="12fea-216">XAML 服務</span><span class="sxs-lookup"><span data-stu-id="12fea-216">XAML Services</span></span>](../../../api/index.md)
