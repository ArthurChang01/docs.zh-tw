---
title: x:Name 指示詞
ms.date: 03/30/2017
f1_keywords:
- x:Name
- xName
- Name
helpviewer_keywords:
- x:Name attribute [XAML Services]
- XAML [XAML Services], x:Name attribute
- Name attribute in XAML [XAML Services]
ms.assetid: b7e61222-e8cf-48d2-acd0-6df3b7685d48
ms.openlocfilehash: 9f812a49a3217a563be1bd7f1d999b641c28463d
ms.sourcegitcommit: c2d9718996402993cf31541f11e95531bc68bad0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/27/2020
ms.locfileid: "82071448"
---
# <a name="xname-directive"></a><span data-ttu-id="0c641-102">x:Name 指示詞</span><span class="sxs-lookup"><span data-stu-id="0c641-102">x:Name Directive</span></span>

<span data-ttu-id="0c641-103">唯一識別 XAML 定義的元素在 XAML 命名範圍中。</span><span class="sxs-lookup"><span data-stu-id="0c641-103">Uniquely identifies XAML-defined elements in a XAML namescope.</span></span> <span data-ttu-id="0c641-104">當框架提供 API 或實現在執行時存取 XAML 創建的物件圖的行為時,XAML 命名範圍及其唯一性模型可以應用於實例化物件。</span><span class="sxs-lookup"><span data-stu-id="0c641-104">XAML namescopes and their uniqueness models can be applied to the instantiated objects, when frameworks provide APIs or implement behaviors that access the XAML-created object graph at run time.</span></span>

## <a name="xaml-attribute-usage"></a><span data-ttu-id="0c641-105">XAML Attribute Usage</span><span class="sxs-lookup"><span data-stu-id="0c641-105">XAML Attribute Usage</span></span>

```xaml
<object x:Name="XAMLNameValue".../>
```

## <a name="xaml-values"></a><span data-ttu-id="0c641-106">XAML 值</span><span class="sxs-lookup"><span data-stu-id="0c641-106">XAML Values</span></span>

|||
|-|-|
|`XAMLNameValue`|<span data-ttu-id="0c641-107">符合[XamlName 語法](xamlname-grammar.md)限制的字串。</span><span class="sxs-lookup"><span data-stu-id="0c641-107">A string that conforms to the restrictions of the [XamlName Grammar](xamlname-grammar.md).</span></span>|

## <a name="remarks"></a><span data-ttu-id="0c641-108">備註</span><span class="sxs-lookup"><span data-stu-id="0c641-108">Remarks</span></span>

<span data-ttu-id="0c641-109">應用於`x:Name`框架的備份程式設計模型後,名稱等效於保存物件引用的變數或構造函數返回的實例。</span><span class="sxs-lookup"><span data-stu-id="0c641-109">After `x:Name` is applied to a framework's backing programming model, the name is equivalent to the variable that holds an object reference or an instance as returned by a constructor.</span></span>

<span data-ttu-id="0c641-110">`x:Name`指令用法的值必須在 XAML 名稱範圍內是唯一的。</span><span class="sxs-lookup"><span data-stu-id="0c641-110">The value of an `x:Name` directive usage must be unique within a XAML namescope.</span></span> <span data-ttu-id="0c641-111">預設情況下,當 .NET XAML 服務 API 使用時,主 XAML 命名範圍在單個 XAML 生產的 XAML 根元素中定義,並包含該 XAML 生產中包含的元素。</span><span class="sxs-lookup"><span data-stu-id="0c641-111">By default when used by .NET XAML Services API, the primary XAML namescope is defined at the XAML root element of a single XAML production, and encompasses the elements that are contained in that XAML production.</span></span> <span data-ttu-id="0c641-112">框架可以定義單個 XAML 生產中可能發生的其他離散 XAML 命名範圍,以解決特定方案。</span><span class="sxs-lookup"><span data-stu-id="0c641-112">Additional discrete XAML namescopes that might occur within a single XAML production can be defined by frameworks to address specific scenarios.</span></span> <span data-ttu-id="0c641-113">例如,在 WPF 中,新的 XAML 命名範圍由在 XAML 生產上定義的任何範本定義和創建。</span><span class="sxs-lookup"><span data-stu-id="0c641-113">For example, in WPF, new XAML namescopes are defined and created by any template that is also defined on that XAML production.</span></span> <span data-ttu-id="0c641-114">有關 XAML 名稱範圍的詳細資訊(為 WPF 編寫,但與許多 XAML 名稱範圍概念相關),請參閱[WPF XAML 名稱範圍](../../framework/wpf/advanced/wpf-xaml-namescopes.md)。</span><span class="sxs-lookup"><span data-stu-id="0c641-114">For more information about XAML namescopes (written for WPF but relevant for many XAML namescope concepts), see [WPF XAML Namescopes](../../framework/wpf/advanced/wpf-xaml-namescopes.md).</span></span>

<span data-ttu-id="0c641-115">通常,`x:Name`不應應用於也`x:Key`使用 的情況。</span><span class="sxs-lookup"><span data-stu-id="0c641-115">In general, `x:Name` should not be applied in situations that also use `x:Key`.</span></span> <span data-ttu-id="0c641-116">由特定現有框架實現的 XAML`x:Key``x:Name`在和 之間引入了替換概念,但這不是建議的做法。</span><span class="sxs-lookup"><span data-stu-id="0c641-116">XAML implementations by specific existing frameworks have introduced substitution concepts between `x:Key` and `x:Name`, but that is not a recommended practice.</span></span> <span data-ttu-id="0c641-117">.NET XAML 服務在處理名稱/金鑰資訊(<xref:System.Windows.Markup.INameScope><xref:System.Windows.Markup.DictionaryKeyPropertyAttribute>如 或 ) 時不支援此類替換概念。</span><span class="sxs-lookup"><span data-stu-id="0c641-117">.NET XAML Services does not support such substitution concepts when handling name/key information such as <xref:System.Windows.Markup.INameScope> or <xref:System.Windows.Markup.DictionaryKeyPropertyAttribute>.</span></span>

<span data-ttu-id="0c641-118">允許`x:Name`性規則以及名稱唯一性實施可能由特定的實現框架定義。</span><span class="sxs-lookup"><span data-stu-id="0c641-118">Rules for permittance of `x:Name` as well as the name uniqueness enforcement are potentially defined by specific implementing frameworks.</span></span> <span data-ttu-id="0c641-119">但是,要與 .NET XAML 服務一起使用,XAML 命名範圍的唯一性的框架定義應<xref:System.Windows.Markup.INameScope>與本文檔中的資訊定義一致,並且應該使用有關資訊應用位置的相同規則。</span><span class="sxs-lookup"><span data-stu-id="0c641-119">However, to be usable with .NET XAML Services, the framework definitions of XAML namescope uniqueness should be consistent with the definition of <xref:System.Windows.Markup.INameScope> information in this documentation, and should use the same rules regarding where the information is applied.</span></span> <span data-ttu-id="0c641-120">例如,[!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)]實現將各種標記元素劃分為單獨<xref:System.Windows.NameScope>的 範圍,例如資源字典、由頁面級 XAML 創建的邏輯樹、範本和其他延遲內容,然後在每個 XAML 命名範圍內強制實施 XAML 名稱唯一性。</span><span class="sxs-lookup"><span data-stu-id="0c641-120">For example, the [!INCLUDE[TLA#tla_winclient](../../../includes/tlasharptla-winclient-md.md)] implementation divides various markup elements into separate <xref:System.Windows.NameScope> ranges, such as resource dictionaries, the logical tree created by the page-level XAML, templates, and other deferred content, and then enforces XAML name uniqueness within each of those XAML namescopes.</span></span>

<span data-ttu-id="0c641-121">對於使用 .NET XAML 服務 XAML 物件編寫`x:Name`器的自定義類型 ,可以建立或更改映射到類型的屬性。</span><span class="sxs-lookup"><span data-stu-id="0c641-121">For custom types that use .NET XAML Services XAML object writers, a property that maps to `x:Name` on a type can be established or changed.</span></span> <span data-ttu-id="0c641-122">通過引用要使用類型定義代碼<xref:System.Windows.Markup.RuntimeNamePropertyAttribute>中映射的屬性的名稱來定義此行為。</span><span class="sxs-lookup"><span data-stu-id="0c641-122">You define this behavior by referencing the name of the property to map with the <xref:System.Windows.Markup.RuntimeNamePropertyAttribute> in the type definition code.</span></span>  <span data-ttu-id="0c641-123"><xref:System.Windows.Markup.RuntimeNamePropertyAttribute>是類型級屬性。</span><span class="sxs-lookup"><span data-stu-id="0c641-123"><xref:System.Windows.Markup.RuntimeNamePropertyAttribute> is a type-level attribute.</span></span>

<span data-ttu-id="0c641-124">Using.NET XAML 服務,<xref:System.Windows.Markup.INameScope>可以通過實現 介面以框架中立的方式定義 XAML 命名範圍支援的備份邏輯。</span><span class="sxs-lookup"><span data-stu-id="0c641-124">Using.NET XAML Services, the backing logic for XAML namescope support can be defined in a framework-neutral way by implementing the <xref:System.Windows.Markup.INameScope> interface.</span></span>

## <a name="wpf-usage-notes"></a><span data-ttu-id="0c641-125">WPF 使用注意事項</span><span class="sxs-lookup"><span data-stu-id="0c641-125">WPF Usage Notes</span></span>

<span data-ttu-id="0c641-126">在使用 XAML、[!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)]部分類和代碼後面的應用程式的標準生成配置下`x:Name`,指定將成為在標記編譯生成任務[!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)]處理時 在基礎代碼中創建的欄位的名稱,並且該欄位包含對物件的引用。</span><span class="sxs-lookup"><span data-stu-id="0c641-126">Under the standard build configuration for a [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] application that uses XAML, partial classes, and code-behind, the specified `x:Name` becomes the name of a field that is created in the underlying code when [!INCLUDE[TLA2#tla_xaml](../../../includes/tla2sharptla-xaml-md.md)] is processed by a markup compilation build task, and that field holds a reference to the object.</span></span> <span data-ttu-id="0c641-127">預設情況下,創建的欄位是內部欄位。</span><span class="sxs-lookup"><span data-stu-id="0c641-127">By default, the created field is internal.</span></span> <span data-ttu-id="0c641-128">您可以通過指定[x:欄位修改器屬性](xfieldmodifier-directive.md)來更改欄位訪問。</span><span class="sxs-lookup"><span data-stu-id="0c641-128">You can change field access by specifying the [x:FieldModifier attribute](xfieldmodifier-directive.md).</span></span> <span data-ttu-id="0c641-129">在 WPF 和 Silverlight 中,序列是標記編譯定義和命名部分類中的欄位,但該值最初為空。</span><span class="sxs-lookup"><span data-stu-id="0c641-129">In WPF and Silverlight, the sequence is that the markup compile defines and names the field in a partial class, but the value is initially empty.</span></span> <span data-ttu-id="0c641-130">然後,從類構造函數`InitializeComponent`中調用名為 生成的方法。</span><span class="sxs-lookup"><span data-stu-id="0c641-130">Then, a generated method named `InitializeComponent` is called from within the class constructor.</span></span> <span data-ttu-id="0c641-131">`InitializeComponent`由`FindName`使用部分類 XAML 定義部分`x:Name`中存在的每個 值作為輸入字串的調用組成。</span><span class="sxs-lookup"><span data-stu-id="0c641-131">`InitializeComponent` consists of `FindName` calls using each of the `x:Name` values that exist in the XAML-defined part of the partial class as input strings.</span></span> <span data-ttu-id="0c641-132">然後,返回值分配給類似命名的欄位引用,以使用從 XAML 分析創建的物件填充欄位值。</span><span class="sxs-lookup"><span data-stu-id="0c641-132">The return values are then assigned to the like-named field reference to fill the field values with objects that were created from XAML parsing.</span></span> <span data-ttu-id="0c641-133">執行`InitializeComponent`後 ,可以`x:Name`直接使用 / 欄位名稱引用執行時物件圖,而不必在需要`FindName`引用 XAML 定義的物件時顯式調用。</span><span class="sxs-lookup"><span data-stu-id="0c641-133">The execution of `InitializeComponent` make it possible to reference the run time object graph using the `x:Name` / field name directly, rather than having to call `FindName` explicitly any time you need a reference to a XAML-defined object.</span></span>

<span data-ttu-id="0c641-134">對於使用`Page`Microsoft Visual Basic 目標並包含包含生成操作的 XAML 檔的 WPF`WithEvents`應用程式,在編`x:Name`譯過程中將關鍵字`Handles`添加到具有的所有元素,以支援 事件處理程式委託的語法。</span><span class="sxs-lookup"><span data-stu-id="0c641-134">For a WPF application that uses the Microsoft Visual Basic targets and includes XAML files with `Page` build action, a separate reference property is created during compilation that adds the `WithEvents` keyword to all elements that have an `x:Name`, to support `Handles` syntax for event handler delegates.</span></span> <span data-ttu-id="0c641-135">此屬性始終是公共的。</span><span class="sxs-lookup"><span data-stu-id="0c641-135">This property is always public.</span></span> <span data-ttu-id="0c641-136">如需詳細資訊，請參閱 [Visual Basic 和 WPF 事件處理](../../framework/wpf/advanced/visual-basic-and-wpf-event-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="0c641-136">For more information, see [Visual Basic and WPF Event Handling](../../framework/wpf/advanced/visual-basic-and-wpf-event-handling.md).</span></span>

<span data-ttu-id="0c641-137">`x:Name`WPF XAML 處理器在載入時使用該名稱註冊到 XAML 命名範圍中,即使對於頁面未透過生成操作進行標記編譯的情況也是如此(例如,資源字典的鬆散 XAML)。</span><span class="sxs-lookup"><span data-stu-id="0c641-137">`x:Name` is used by the WPF XAML processor to register a name into a XAML namescope at load time, even for cases where the page is not markup-compiled by build actions (for example, loose XAML of a resource dictionary).</span></span> <span data-ttu-id="0c641-138">此行為的原因是綁定可能需要`x:Name`<xref:System.Windows.Data.Binding.ElementName%2A>。</span><span class="sxs-lookup"><span data-stu-id="0c641-138">One reason for this behavior is because the `x:Name` is potentially needed for <xref:System.Windows.Data.Binding.ElementName%2A> binding.</span></span> <span data-ttu-id="0c641-139">有關詳細資訊,請參閱[資料繫結此概述](../data/data-binding-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="0c641-139">For details, see [Data Binding Overview](../data/data-binding-overview.md).</span></span>

<span data-ttu-id="0c641-140">如前所述,(`x:Name``Name`或 )不應應用於`x:Key`也使用 的情況。</span><span class="sxs-lookup"><span data-stu-id="0c641-140">As mentioned previously, `x:Name` (or `Name`) should not be applied in situations that also use `x:Key`.</span></span> <span data-ttu-id="0c641-141">具有特殊[!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.ResourceDictionary>行為,將自身定義為 XAML 命名範圍,但傳回<xref:System.Windows.Markup.INameScope>API 的未實現或 null 值,作為強制執行此行為的一種方式。</span><span class="sxs-lookup"><span data-stu-id="0c641-141">The [!INCLUDE[TLA2#tla_winclient](../../../includes/tla2sharptla-winclient-md.md)] <xref:System.Windows.ResourceDictionary> has a special behavior of defining itself as a XAML namescope but returning Not Implemented or null values for <xref:System.Windows.Markup.INameScope> APIs as a way to enforce this behavior.</span></span> <span data-ttu-id="0c641-142">如果 WPF XAML 解析`Name`器`x:Name`遇到<xref:System.Windows.ResourceDictionary>或在 XAML 定義中,則名稱不會添加到任何 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="0c641-142">If the WPF XAML parser encounters `Name` or `x:Name` in a XAML-defined <xref:System.Windows.ResourceDictionary>, the name is not added to any XAML namescope.</span></span> <span data-ttu-id="0c641-143">嘗試從任何 XAML 名稱範圍查找該名稱`FindName`和方法 將不會返回有效結果。</span><span class="sxs-lookup"><span data-stu-id="0c641-143">Attempting to find that name from any XAML namescope and the `FindName` methods will not return valid results.</span></span>

### <a name="xname-and-name"></a><span data-ttu-id="0c641-144">x:名稱與名稱</span><span class="sxs-lookup"><span data-stu-id="0c641-144">x:Name and Name</span></span>

<span data-ttu-id="0c641-145">許多 WPF`x:Name`應用程式方案 可以避免對屬性的任何使用,`Name`因為在預設的 XAML 命名空間中指定的依賴項屬性適用於幾個<xref:System.Windows.FrameworkElement>重要<xref:System.Windows.FrameworkContentElement>基類,如和滿足此相同的用途。</span><span class="sxs-lookup"><span data-stu-id="0c641-145">Many WPF application scenarios can avoid any use of the `x:Name` attribute, because the `Name` dependency property as specified in the default XAML namespace for several of the important base classes such as <xref:System.Windows.FrameworkElement> and <xref:System.Windows.FrameworkContentElement> satisfies this same purpose.</span></span> <span data-ttu-id="0c641-146">仍有一些常見的 XAML 和 WPF 方案,其中`Name`代碼訪問框架級別 上沒有屬性的元素非常重要。</span><span class="sxs-lookup"><span data-stu-id="0c641-146">There are still some common XAML and WPF scenarios where code access to an element with no `Name` property at the framework level is important.</span></span> <span data-ttu-id="0c641-147">例如,某些動畫和情節提要支援類不支援`Name`屬性,但它們通常需要在代碼中引用才能控制動畫。</span><span class="sxs-lookup"><span data-stu-id="0c641-147">For example, certain animation and storyboard support classes do not support a `Name` property, but they often need to be referenced in code in order to control the animation.</span></span> <span data-ttu-id="0c641-148">如果以後打算`x:Name`從代碼中引用它們,則應在時間線上指定為屬性,並在 XAML 中創建的轉換中指定屬性。</span><span class="sxs-lookup"><span data-stu-id="0c641-148">You should specify `x:Name` as an attribute on timelines and transforms that are created in XAML, if you intend to reference them from code later.</span></span>

<span data-ttu-id="0c641-149">如果在<xref:System.Windows.FrameworkElement.Name%2A>類上作為屬性可用<xref:System.Windows.FrameworkElement.Name%2A>`x:Name`, 並且可以作為屬性互換使用,但如果在同一元素上指定兩者,則會產生解析異常。</span><span class="sxs-lookup"><span data-stu-id="0c641-149">If <xref:System.Windows.FrameworkElement.Name%2A> is available as a property on the class, <xref:System.Windows.FrameworkElement.Name%2A> and `x:Name` can be used interchangeably as attributes, but a parse exception will result if both are specified on the same element.</span></span> <span data-ttu-id="0c641-150">如果編譯了 XAML,則異常將在標記編譯上發生,否則將在載入時發生。</span><span class="sxs-lookup"><span data-stu-id="0c641-150">If the XAML is markup compiled, the exception will occur on the markup compile, otherwise it occurs on load.</span></span>

<span data-ttu-id="0c641-151"><xref:System.Windows.FrameworkElement.Name%2A>可以使用 XAML 屬性語法與 在<xref:System.Windows.DependencyObject.SetValue%2A>代碼中使用 。但是請注意,在已<xref:System.Windows.FrameworkElement.Name%2A>載入 XAML 的大多數情況下,在代碼中設置屬性不會在 XAML 命名範圍內創建具有代表性的欄位引用。</span><span class="sxs-lookup"><span data-stu-id="0c641-151"><xref:System.Windows.FrameworkElement.Name%2A> can be set using XAML attribute syntax, and in code using <xref:System.Windows.DependencyObject.SetValue%2A>; note however that setting the <xref:System.Windows.FrameworkElement.Name%2A> property in code does not create the representative field reference within the XAML namescope in most circumstances where the XAML is already loaded.</span></span> <span data-ttu-id="0c641-152">不要嘗試在代碼中設置<xref:System.Windows.FrameworkElement.Name%2A>,而是根據<xref:System.Windows.NameScope>相應的 名稱範圍使用代碼中的方法。</span><span class="sxs-lookup"><span data-stu-id="0c641-152">Instead of attempting to set <xref:System.Windows.FrameworkElement.Name%2A> in code, use <xref:System.Windows.NameScope> methods from code, against the appropriate namescope.</span></span>

<span data-ttu-id="0c641-153"><xref:System.Windows.FrameworkElement.Name%2A>也可以使用包含內部文本的屬性元素語法進行設置,但這種情況並不常見。</span><span class="sxs-lookup"><span data-stu-id="0c641-153"><xref:System.Windows.FrameworkElement.Name%2A> can also be set using property element syntax with inner text, but that is uncommon.</span></span> <span data-ttu-id="0c641-154">相反,`x:Name`無法在 XAML 屬性元素語法中設定<xref:System.Windows.DependencyObject.SetValue%2A>,也不能在程式碼中使用 。它只能使用物件的屬性語法進行設置,因為它是指令。</span><span class="sxs-lookup"><span data-stu-id="0c641-154">In contrast, `x:Name` cannot be set in XAML property element syntax, or in code using <xref:System.Windows.DependencyObject.SetValue%2A>; it can only be set using attribute syntax on objects because it is a directive.</span></span>

## <a name="silverlight-usage-notes"></a><span data-ttu-id="0c641-155">銀光使用說明</span><span class="sxs-lookup"><span data-stu-id="0c641-155">Silverlight Usage Notes</span></span>

<span data-ttu-id="0c641-156">`x:Name`銀光單獨記錄。</span><span class="sxs-lookup"><span data-stu-id="0c641-156">`x:Name` for Silverlight is documented separately.</span></span> <span data-ttu-id="0c641-157">有關詳細資訊,請參閱[XAML 命名空間 (x:)語言功能(銀光)](https://docs.microsoft.com/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc188995(v=vs.95)).</span><span class="sxs-lookup"><span data-stu-id="0c641-157">For more information, see [XAML Namespace (x:) Language Features (Silverlight)](https://docs.microsoft.com/previous-versions/windows/silverlight/dotnet-windows-silverlight/cc188995(v=vs.95)).</span></span>

## <a name="see-also"></a><span data-ttu-id="0c641-158">另請參閱</span><span class="sxs-lookup"><span data-stu-id="0c641-158">See also</span></span>

- <xref:System.Windows.FrameworkElement.Name%2A?displayProperty=nameWithType>
- <xref:System.Windows.FrameworkContentElement.Name%2A?displayProperty=nameWithType>
- [<span data-ttu-id="0c641-159">WPF 中的樹狀結構</span><span class="sxs-lookup"><span data-stu-id="0c641-159">Trees in WPF</span></span>](../../framework/wpf/advanced/trees-in-wpf.md)
