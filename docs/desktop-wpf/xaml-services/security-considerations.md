---
title: XAML 安全性考量
ms.date: 03/30/2017
helpviewer_keywords:
- security [XAML Services], .NET XAML services
- XAML security [XAML Services]
ms.assetid: 544296d4-f38e-4498-af49-c9f4dad28964
ms.openlocfilehash: 1864910b339c74e3033fb4d6d8baebffada1a4f8
ms.sourcegitcommit: c2d9718996402993cf31541f11e95531bc68bad0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/27/2020
ms.locfileid: "82071686"
---
# <a name="xaml-security-considerations"></a><span data-ttu-id="72fe4-102">XAML 安全注意事項</span><span class="sxs-lookup"><span data-stu-id="72fe4-102">XAML security considerations</span></span>

<span data-ttu-id="72fe4-103">本文介紹了在使用 XAML 和 .NET XAML 服務 API 時應用程式中安全性的最佳做法。</span><span class="sxs-lookup"><span data-stu-id="72fe4-103">This article describes best practices for security in applications when you use XAML and .NET XAML Services API.</span></span>

## <a name="untrusted-xaml-in-applications"></a><span data-ttu-id="72fe4-104">應用程式中的不受信任的 XAML</span><span class="sxs-lookup"><span data-stu-id="72fe4-104">Untrusted XAML in Applications</span></span>

<span data-ttu-id="72fe4-105">在最一般意義上,不受信任的 XAML 是應用程式未具體包含或發出的任何 XAML 源。</span><span class="sxs-lookup"><span data-stu-id="72fe4-105">In the most general sense, untrusted XAML is any XAML source that your application did not specifically include or emit.</span></span>

<span data-ttu-id="72fe4-106">編譯到受信任和簽名程式集中的`resx`-類型資源或存儲為 -類型的 XAML 本質上不受信任。</span><span class="sxs-lookup"><span data-stu-id="72fe4-106">XAML that is compiled into or stored as a `resx`-type resource within a trusted and signed assembly is not inherently untrusted.</span></span> <span data-ttu-id="72fe4-107">您可以像信任整個程式集一樣信任 XAML。</span><span class="sxs-lookup"><span data-stu-id="72fe4-107">You can trust the XAML as much as you trust the assembly as a whole.</span></span> <span data-ttu-id="72fe4-108">在大多數情況下,您只關心鬆散的 XAML 的信任方面,這是從流或其他 I/O 載入的 XAML 源。</span><span class="sxs-lookup"><span data-stu-id="72fe4-108">In most cases, you are only concerned with the trust aspects of loose XAML, which is a XAML source that you load from a stream or other I/O.</span></span> <span data-ttu-id="72fe4-109">鬆散 XAML 不是具有部署和打包基礎結構的應用程式模型的特定元件或功能。</span><span class="sxs-lookup"><span data-stu-id="72fe4-109">Loose XAML is not a specific component or feature of an application model with a deployment and packaging infrastructure.</span></span> <span data-ttu-id="72fe4-110">但是,程式集可能實現涉及載入鬆散 XAML 的行為。</span><span class="sxs-lookup"><span data-stu-id="72fe4-110">However, an assembly might implement a behavior that involves loading loose XAML.</span></span>

<span data-ttu-id="72fe4-111">對於不受信任的 XAML,通常應該將其視為不受信任的代碼。</span><span class="sxs-lookup"><span data-stu-id="72fe4-111">For untrusted XAML, you should treat it generally the same as if it were untrusted code.</span></span> <span data-ttu-id="72fe4-112">使用沙箱或其他隱喻來防止可能不受信任的 XAML 訪問受信任的代碼。</span><span class="sxs-lookup"><span data-stu-id="72fe4-112">Use sandboxing or other metaphors to prevent possibly untrusted XAML from accessing your trusted code.</span></span>

<span data-ttu-id="72fe4-113">XAML 功能的性質使 XAML 有權構造物件並設置其屬性。</span><span class="sxs-lookup"><span data-stu-id="72fe4-113">The nature of XAML capabilities gives the XAML the right to construct objects and set their properties.</span></span> <span data-ttu-id="72fe4-114">這些功能還包括存取類型轉換器、映射和存取應用程式域中的程式集,使用標記`x:Code`擴展、塊等。</span><span class="sxs-lookup"><span data-stu-id="72fe4-114">These capabilities also include accessing type converters, mapping and accessing assemblies in the application domain, using markup extensions, `x:Code` blocks, and so on.</span></span>

<span data-ttu-id="72fe4-115">除了語言級功能外,XAML 還用於許多技術的 UI 定義。</span><span class="sxs-lookup"><span data-stu-id="72fe4-115">In addition to its language-level capabilities, XAML is used for UI definition in many technologies.</span></span> <span data-ttu-id="72fe4-116">載入不受信任的 XAML 可能意味著載入惡意欺騙 UI。</span><span class="sxs-lookup"><span data-stu-id="72fe4-116">Loading untrusted XAML might mean loading a malicious spoofing UI.</span></span>

## <a name="sharing-context-between-readers-and-writers"></a><span data-ttu-id="72fe4-117">讀者與作者之間分享上下文</span><span class="sxs-lookup"><span data-stu-id="72fe4-117">Sharing Context Between Readers and Writers</span></span>

<span data-ttu-id="72fe4-118">.NET XAML 服務架構結構適用於 XAML 讀取器和 XAML 編寫器,通常需要將 XAML 讀取器共用給 XAML 編寫器或共用 XAML 架構上下文。</span><span class="sxs-lookup"><span data-stu-id="72fe4-118">.NET XAML Services architecture for XAML readers and XAML writers often requires sharing a XAML reader to a XAML writer, or a shared XAML schema context.</span></span> <span data-ttu-id="72fe4-119">如果要編寫 XAML 節點迴圈邏輯或提供自訂保存路徑,則可能需要共用物件或上下文。</span><span class="sxs-lookup"><span data-stu-id="72fe4-119">Sharing objects or contexts might be required if you are writing XAML node loop logic, or providing a custom save path.</span></span> <span data-ttu-id="72fe4-120">不要在受信任的代碼和不受信任的代碼之間共用 XAML 讀取器實例、非預設 XAML 架構上下文或 XAML 讀取器/寫入器類的設置。</span><span class="sxs-lookup"><span data-stu-id="72fe4-120">Don't share XAML reader instances, nondefault XAML schema context, or settings for XAML reader/writer classes between trusted and untrusted code.</span></span>

<span data-ttu-id="72fe4-121">大多數涉及基於 CLR 的類型備份的 XAML 物件寫入的方案和操作都只能使用預設的 XAML 架構上下文。</span><span class="sxs-lookup"><span data-stu-id="72fe4-121">Most scenarios and operations involving XAML object writing for a CLR-based type backing can just use default XAML schema context.</span></span> <span data-ttu-id="72fe4-122">預設 XAML 架構上下文沒有明確包含可能危及完全信任的設置。</span><span class="sxs-lookup"><span data-stu-id="72fe4-122">The default XAML schema context does not explicitly include settings that could compromise full trust.</span></span> <span data-ttu-id="72fe4-123">因此,在受信任的和不受信任的 XAML 讀取器/寫入器元件之間共用上下文是安全的。</span><span class="sxs-lookup"><span data-stu-id="72fe4-123">It is thus safe to share context between trusted and untrusted XAML reader/writer components.</span></span> <span data-ttu-id="72fe4-124">但是,如果您這樣做,最好還是將這些讀者和作者保存在單獨的<xref:System.AppDomain>作用域中,其中一個專門打算/沙箱用於部分信任。</span><span class="sxs-lookup"><span data-stu-id="72fe4-124">However, if you do this, it is still a best practice to keep such readers and writers in separate <xref:System.AppDomain> scopes, with one of them specifically intended/sandboxed for partial trust.</span></span>

## <a name="xaml-namespaces-and-assembly-trust"></a><span data-ttu-id="72fe4-125">XAML 命名空間與程式集信任</span><span class="sxs-lookup"><span data-stu-id="72fe4-125">XAML Namespaces and Assembly Trust</span></span>

<span data-ttu-id="72fe4-126">XAML 如何將自定義 XAML 命名空間映射解釋為程式集的基本限定語法和定義不會區分載入到應用程式域中的受信任程式集和不受信任的程式集。</span><span class="sxs-lookup"><span data-stu-id="72fe4-126">The basic unqualified syntax and definition for how XAML interprets a custom XAML namespace mapping to an assembly does not distinguish between a trusted and untrusted assembly as loaded into the application domain.</span></span> <span data-ttu-id="72fe4-127">因此,從技術上講,不受信任的程式集可以欺騙受信任的程式集的預期 XAML 命名空間映射並捕獲 XAML 源聲明的物件和屬性資訊。</span><span class="sxs-lookup"><span data-stu-id="72fe4-127">Thus, it is technically possible for an untrusted assembly to spoof a trusted assembly's intended XAML namespace mapping and capture a XAML source's declared object and property information.</span></span> <span data-ttu-id="72fe4-128">如果您有安全要求以避免這種情況,則應使用以下技術之一進行預期的 XAML 命名空間映射:</span><span class="sxs-lookup"><span data-stu-id="72fe4-128">If you have security requirements to avoid this situation, your intended XAML namespace mapping should be made using one of the following techniques:</span></span>

- <span data-ttu-id="72fe4-129">在應用程式的 XAML 進行的任何 XAML 命名空間映射中使用具有強名稱的完全限定程式集名稱。</span><span class="sxs-lookup"><span data-stu-id="72fe4-129">Use a fully qualified assembly name with strong name in any XAML namespace mapping made by your application's XAML.</span></span>

- <span data-ttu-id="72fe4-130">通過建構特定於 XAML 讀取器和<xref:System.Xaml.XamlSchemaContext>XAML 物件編寫器的程式集映射,將程式集映射限制為一組固定的引用程式集。</span><span class="sxs-lookup"><span data-stu-id="72fe4-130">Restrict assembly mapping to a fixed set of reference assemblies, by constructing a specific <xref:System.Xaml.XamlSchemaContext> for your XAML readers and XAML object writers.</span></span> <span data-ttu-id="72fe4-131">請參閱＜<xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.Reflection.Assembly%7D%29>＞。</span><span class="sxs-lookup"><span data-stu-id="72fe4-131">See <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.Reflection.Assembly%7D%29>.</span></span>

## <a name="xaml-type-mapping-and-type-system-access"></a><span data-ttu-id="72fe4-132">XAML 類型映射與類型系統存取</span><span class="sxs-lookup"><span data-stu-id="72fe4-132">XAML Type Mapping and Type System Access</span></span>

<span data-ttu-id="72fe4-133">XAML 支援其自己的類型系統,在許多方面,該系統是CLR如何實現基本CLR類型系統的對等體。</span><span class="sxs-lookup"><span data-stu-id="72fe4-133">XAML supports its own type system, which in many ways is a peer to how CLR implements the basic CLR type system.</span></span> <span data-ttu-id="72fe4-134">但是,對於類型感知的某些方面,如果您根據類型資訊對類型做出信任決策,則應服從 CLR 支援類型中的類型資訊。</span><span class="sxs-lookup"><span data-stu-id="72fe4-134">However, for certain aspects of type awareness where you are making trust decisions about a type based on its type information, you should defer to the type information in the CLR backing types.</span></span> <span data-ttu-id="72fe4-135">這是因為 XAML 類型系統的一些特定報告功能作為虛擬方法處於打開狀態,因此並不完全受原始 .NET XAML 服務實現的控制。</span><span class="sxs-lookup"><span data-stu-id="72fe4-135">This is because some of the specific reporting capabilities of the XAML type system are left open as virtual methods and are therefore, not fully under the control of the original .NET XAML Services implementations.</span></span> <span data-ttu-id="72fe4-136">存在這些擴展點是因為 XAML 類型系統是可擴展的,以匹配 XAML 本身的可擴充性及其可能的替代類型對應策略與預設 CLR 支援的實現和預設 XAML 架構上下文。</span><span class="sxs-lookup"><span data-stu-id="72fe4-136">These extensibility points exist because the XAML type system is extensible, to match the extensibility of XAML itself and its possible alternative type-mapping strategies versus the default CLR-backed implementation and default XAML schema context.</span></span> <span data-ttu-id="72fe4-137">有關詳細資訊,請參閱<xref:System.Xaml.XamlType>有關<xref:System.Xaml.XamlMember>和的幾種屬性的特定註釋。</span><span class="sxs-lookup"><span data-stu-id="72fe4-137">For more information, see the specific notes on several of the properties of <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>.</span></span>

## <a name="see-also"></a><span data-ttu-id="72fe4-138">另請參閱</span><span class="sxs-lookup"><span data-stu-id="72fe4-138">See also</span></span>

- <xref:System.Xaml.Permissions.XamlAccessLevel>
