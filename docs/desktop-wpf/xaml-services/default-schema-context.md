---
title: 預設 XAML 結構描述內容和 WPF XAML 結構描述內容
ms.date: 03/30/2017
ms.assetid: 04e06a15-09b3-4210-9bdf-9a64c2eccb83
ms.openlocfilehash: 2e92372de61230a98a02282cc28fc3f479cd94eb
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/12/2020
ms.locfileid: "82071861"
---
# <a name="default-xaml-schema-context-and-wpf-xaml-schema-context"></a><span data-ttu-id="a5869-102">預設 XAML 結構描述內容和 WPF XAML 結構描述內容</span><span class="sxs-lookup"><span data-stu-id="a5869-102">Default XAML Schema Context and WPF XAML Schema Context</span></span>
<span data-ttu-id="a5869-103">XAML 架構上下文是一個概念實體,它限定了使用特定 XAML 詞彙表的 XAML 生產如何與物件寫入行為進行交互,包括類型映射解析方式、程式集的載入方式、如何解釋某些讀取器和編寫器設置。</span><span class="sxs-lookup"><span data-stu-id="a5869-103">A XAML schema context is a conceptual entity that qualifies how a XAML production that uses a particular XAML vocabulary interacts with the object writing behavior, including how type mapping resolves, how assemblies are loaded, how certain reader and writer settings are interpreted.</span></span> <span data-ttu-id="a5869-104">本主題介紹 .NET XAML 服務的功能和基於 CLR 類型系統的關聯的預設 XAML 架構上下文。</span><span class="sxs-lookup"><span data-stu-id="a5869-104">This topic describes the features of .NET XAML Services and the associated default XAML schema context, which is based on the CLR type system.</span></span> <span data-ttu-id="a5869-105">本主題還介紹用於 WPF 的 XAML 架構上下文。</span><span class="sxs-lookup"><span data-stu-id="a5869-105">This topic also describes the XAML schema context that is used for WPF.</span></span>

## <a name="default-xaml-schema-context"></a><span data-ttu-id="a5869-106">預設 XAML 架構內容</span><span class="sxs-lookup"><span data-stu-id="a5869-106">Default XAML Schema Context</span></span>

<span data-ttu-id="a5869-107">.NET XAML 服務既實現並使用預設的 XAML 架構上下文。</span><span class="sxs-lookup"><span data-stu-id="a5869-107">.NET XAML Services both implements and uses a default XAML schema context.</span></span> <span data-ttu-id="a5869-108">預設 XAML 架構上下文行為並不<xref:System.Xaml.XamlSchemaContext>總是在 類的 API 中完全可見。</span><span class="sxs-lookup"><span data-stu-id="a5869-108">The default XAML schema context behavior is not always fully visible in the API of the <xref:System.Xaml.XamlSchemaContext> class.</span></span> <span data-ttu-id="a5869-109">但是,在許多情況下,預設 XAML 架構上下文影響的行為可以透過 XAML 類型系統的<xref:System.Xaml.XamlMember>常見 API(如或的成員<xref:System.Xaml.XamlType>或 或透過使用預設 XAML 架構上下文的 XAML 讀取器和 XAML 寫入器上公開的 API 來觀察)。</span><span class="sxs-lookup"><span data-stu-id="a5869-109">However, in many cases the behavior that the default XAML schema context influences is observable through common API of the XAML type system, such as members of <xref:System.Xaml.XamlMember> or <xref:System.Xaml.XamlType>, or through APIs exposed on XAML readers and XAML writers that are using the default XAML schema context.</span></span>

<span data-ttu-id="a5869-110">可以透過呼叫式函數<xref:System.Xaml.XamlSchemaContext>建立封裝預設行為<xref:System.Xaml.XamlSchemaContext>的 。</span><span class="sxs-lookup"><span data-stu-id="a5869-110">You can create a <xref:System.Xaml.XamlSchemaContext> that encapsulates the default behavior by calling the <xref:System.Xaml.XamlSchemaContext> constructor.</span></span> <span data-ttu-id="a5869-111">這顯式創建預設的 XAML 架構上下文。</span><span class="sxs-lookup"><span data-stu-id="a5869-111">This explicitly creates the default XAML schema context.</span></span> <span data-ttu-id="a5869-112">如果使用不顯式採用<xref:System.Xaml.XamlSchemaContext>輸入參數的 API 初始化 XAML 讀取器或 XAML 編寫器,則隱式創建相同的預設 XAML 架構上下文。</span><span class="sxs-lookup"><span data-stu-id="a5869-112">The same default XAML schema context is created implicitly, if you initialize a XAML reader or XAML writer using APIs that do not explicitly take a <xref:System.Xaml.XamlSchemaContext> input parameter.</span></span>

<span data-ttu-id="a5869-113">預設 XAML 架構上下文依賴於 CLR 反射的類型映射行為。</span><span class="sxs-lookup"><span data-stu-id="a5869-113">The default XAML schema context relies on CLR reflection for its type mapping behavior.</span></span> <span data-ttu-id="a5869-114">這包括檢查定義的 CLR<xref:System.Type><xref:System.Reflection.PropertyInfo>和<xref:System.Reflection.MethodInfo>相關 或 。</span><span class="sxs-lookup"><span data-stu-id="a5869-114">This includes examining the defining CLR <xref:System.Type>, and related <xref:System.Reflection.PropertyInfo> or <xref:System.Reflection.MethodInfo>.</span></span> <span data-ttu-id="a5869-115">此外,使用類型或成員的 CLR 歸因來填寫使用 CLR 支援類型的 XAML 類型或 XAML 成員資訊的詳細資訊。</span><span class="sxs-lookup"><span data-stu-id="a5869-115">Also, CLR attribution on types or members is used in order to fill in the specifics for XAML type or XAML member information that uses the CLR backing type.</span></span> <span data-ttu-id="a5869-116">預設 XAML 架構上下文不需要類型系統擴展技術`Invoker`(如模式),因為 CLR 類型系統提供了必要的資訊。</span><span class="sxs-lookup"><span data-stu-id="a5869-116">The default XAML schema context does not require type system extension techniques such as the `Invoker` pattern, because the necessary information is available from the CLR type system.</span></span>

<span data-ttu-id="a5869-117">對於程式集載入邏輯,預設 XAML 架構上下文主要依賴於 XAML 命名空間映射中提供的任何程式集值。</span><span class="sxs-lookup"><span data-stu-id="a5869-117">For assembly loading logic, the default XAML schema context relies mainly on any assembly values provided in XAML namespace mappings.</span></span> <span data-ttu-id="a5869-118">此外,<xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A>還可以提示要載入的程式集,用於載入內部類型等方案。</span><span class="sxs-lookup"><span data-stu-id="a5869-118">Also, <xref:System.Xaml.XamlReaderSettings.LocalAssembly%2A> can hint an assembly to load, for scenarios such as loading internal types.</span></span>

## <a name="wpf-xaml-schema-context"></a><span data-ttu-id="a5869-119">WPF XAML 架構內容</span><span class="sxs-lookup"><span data-stu-id="a5869-119">WPF XAML Schema Context</span></span>

<span data-ttu-id="a5869-120">本主題將介紹 WPF XAML 架構上下文,因為 WPF 實現提供了通過實現非預設 XAML 架構上下文可以引入的功能類型的有趣說明。</span><span class="sxs-lookup"><span data-stu-id="a5869-120">The WPF XAML schema context is described in this topic because the WPF implementation provides an interesting illustration of the kinds of features that can be introduced by implementing a non-default XAML schema context.</span></span> <span data-ttu-id="a5869-121">此外,解決 WPF XAML 的 WPF 文檔中沒有過多討論 XAML 架構上下文概念;僅當與討論預設 XAML 架構上下文的工作原理集成時,XAML 架構上下文啟用的行為可能完全可以理解。</span><span class="sxs-lookup"><span data-stu-id="a5869-121">Also, the XAML schema context concept is not discussed very much in the WPF documentation that addresses WPF XAML; the behavior that the XAML schema context enables might only be fully understandable if integrated with a discussion of how the default XAML schema context works.</span></span> <span data-ttu-id="a5869-122">WPF XAML 架構上下文實現以下行為。</span><span class="sxs-lookup"><span data-stu-id="a5869-122">The WPF XAML schema context implements the following behavior.</span></span>

<span data-ttu-id="a5869-123">**尋找覆寫:** WPF 具有一些適用於 XAML 的內容模型,其中有<xref:System.Windows.Markup.ContentPropertyAttribute>XAML 內容 屬性,這些屬性在不被歸因的情況下起作用。</span><span class="sxs-lookup"><span data-stu-id="a5869-123">**Lookup overrides:** WPF has a few content models for XAML where there are XAML content properties that function without being <xref:System.Windows.Markup.ContentPropertyAttribute> attributed.</span></span> <span data-ttu-id="a5869-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A>覆蓋 WPF 實現此行為。</span><span class="sxs-lookup"><span data-stu-id="a5869-124"><xref:System.Xaml.XamlType.LookupContentProperty%2A> overrides for WPF implement this behavior.</span></span>

<span data-ttu-id="a5869-125">**WPF 表示式的延遲:** WPF 具有多個運算式類,這些運算式類將值延遲到運行時上下文可用。</span><span class="sxs-lookup"><span data-stu-id="a5869-125">**Deferral for WPF expressions:** WPF features several expression classes that defer a value until a runtime context is available.</span></span> <span data-ttu-id="a5869-126">此外,範本擴展是依賴於延遲技術的運行時行為。</span><span class="sxs-lookup"><span data-stu-id="a5869-126">Also, template expansion is a runtime behavior that relies on deferral techniques.</span></span>

<span data-ttu-id="a5869-127">**類型系統搜尋最佳化:** WPF 具有廣泛的 XAML 詞彙表和物件模型,包括繼承到數百個 WPF 定義的類的基類成員定義。</span><span class="sxs-lookup"><span data-stu-id="a5869-127">**Type system lookup optimizations:** WPF has an extensive XAML vocabulary and object model, including base class member definitions that inherit to literally hundreds of WPF-defined classes.</span></span> <span data-ttu-id="a5869-128">此外,WPF 本身分佈在多個程式集中。</span><span class="sxs-lookup"><span data-stu-id="a5869-128">Also, WPF itself is spread across several assemblies.</span></span> <span data-ttu-id="a5869-129">WPF 使用查找表和其他技術優化其類型查找。</span><span class="sxs-lookup"><span data-stu-id="a5869-129">WPF optimizes its type lookup using lookup tables and other techniques.</span></span> <span data-ttu-id="a5869-130">這提供了與預設 XAML 架構上下文及其基於 CLR 的類型查找的性能改進。</span><span class="sxs-lookup"><span data-stu-id="a5869-130">This provides performance improvements over the default XAML schema context and its CLR-based type lookup.</span></span> <span data-ttu-id="a5869-131">在查找表中不存在類型的情況下,行為使用類似於預設 XAML 架構上下文的 XAML 架構上下文技術。</span><span class="sxs-lookup"><span data-stu-id="a5869-131">In cases where types do not exist in a lookup table, the behavior uses XAML schema context techniques that are similar to the default XAML schema context.</span></span>

<span data-ttu-id="a5869-132">**XamlType 和 Xaml 成員延伸:** WPF 擴展具有依賴項屬性的屬性概念,以及具有路由事件的事件概念。</span><span class="sxs-lookup"><span data-stu-id="a5869-132">**XamlType and XamlMember extension:** WPF extends property concepts with dependency properties, and event concepts with routed events.</span></span> <span data-ttu-id="a5869-133">為了給這些概念提供 XAML 處理操作的更大可見性,WPF<xref:System.Xaml.XamlType><xref:System.Xaml.XamlMember>擴展和,並添加報告依賴項屬性和路由事件特徵的內部屬性。</span><span class="sxs-lookup"><span data-stu-id="a5869-133">To give these concepts greater visibility for XAML processing operations, WPF extends <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>, and adds internal properties that report dependency property and routed event characteristics.</span></span>

### <a name="accessing-the-wpf-xaml-schema-context"></a><span data-ttu-id="a5869-134">存取 WPF XAML 架構內容</span><span class="sxs-lookup"><span data-stu-id="a5869-134">Accessing the WPF XAML Schema Context</span></span>

<span data-ttu-id="a5869-135">如果您使用的是基於<xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType>WPF<xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType>或的 XAML 技術,則 WPF XAML 架構上下文已在這些 XAML 讀取器和 XAML 編寫器實現上使用。</span><span class="sxs-lookup"><span data-stu-id="a5869-135">If you are using XAML techniques that are based on the WPF <xref:System.Windows.Markup.XamlReader?displayProperty=nameWithType> or <xref:System.Windows.Markup.XamlWriter?displayProperty=nameWithType>, the WPF XAML schema context is already in use on those XAML reader and XAML writer implementations.</span></span>

<span data-ttu-id="a5869-136">如果使用其他未使用 WPF XAML 架構上下文初始化的 XAML 讀取器或 XAML 編<xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType>寫器實現,則可以從 獲取工作 WPF XAML 架構上下文。</span><span class="sxs-lookup"><span data-stu-id="a5869-136">If you are using other XAML reader or XAML writer implementations that do not initialize with the WPF XAML schema context, you may be able to get a working WPF XAML schema context from <xref:System.Windows.Markup.XamlReader.GetWpfSchemaContext%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="a5869-137">然後,可以將此值用作使用的其他 API 的<xref:System.Xaml.XamlSchemaContext>初始化 。</span><span class="sxs-lookup"><span data-stu-id="a5869-137">You can then use this value as initialization for other API that use a <xref:System.Xaml.XamlSchemaContext>.</span></span> <span data-ttu-id="a5869-138">例如,您可以調用<xref:System.Xaml.XamlXmlReader.%23ctor%2A>初始化並傳遞 WPF XAML 架構上下文。</span><span class="sxs-lookup"><span data-stu-id="a5869-138">For example, you could call <xref:System.Xaml.XamlXmlReader.%23ctor%2A> for initialization and pass the WPF XAML schema context.</span></span> <span data-ttu-id="a5869-139">或者,您可以將 WPF XAML 架構上下文用於 XAML 類型系統操作。</span><span class="sxs-lookup"><span data-stu-id="a5869-139">Or you could use the WPF XAML schema context for XAML type system operations.</span></span> <span data-ttu-id="a5869-140">這可能包含<xref:System.Xaml.XamlType>或<xref:System.Xaml.XamlMember>的建構初始化或呼叫<xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a5869-140">This might include construction initialization of a <xref:System.Xaml.XamlType> or <xref:System.Xaml.XamlMember>, or calling <xref:System.Xaml.XamlSchemaContext.GetXamlType%2A?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="a5869-141">請注意,如果從純 XAML 節點流的角度來看訪問 WPF XAML 的某些方面,則某些 WPF 框架功能可能尚未執行。</span><span class="sxs-lookup"><span data-stu-id="a5869-141">Note that if you access certain aspects of WPF XAML from a pure XAML node stream perspectives, some of the WPF framework capabilities may not have acted yet.</span></span> <span data-ttu-id="a5869-142">例如,尚未應用控制件的 WPF 範本。</span><span class="sxs-lookup"><span data-stu-id="a5869-142">For example, WPF templates for controls are not yet applied.</span></span> <span data-ttu-id="a5869-143">因此,如果您訪問在運行時可能使用完整可視化樹填充的屬性,則可能只看到引用範本的屬性值。</span><span class="sxs-lookup"><span data-stu-id="a5869-143">Thus if you access a property that at run time might be populated with a full visual tree, you might only see a property value that references a template.</span></span> <span data-ttu-id="a5869-144">如果從非運行時情況提供,則為 WPF 標記擴展提供的服務上下文也可能不準確,並且在嘗試寫入物件圖時可能會導致異常。</span><span class="sxs-lookup"><span data-stu-id="a5869-144">The service context provided for WPF markup extensions might also not be accurate if provided from a non-runtime situation, and can result in exceptions when attempting to write an object graph.</span></span>

## <a name="xaml-and-assembly-loading"></a><span data-ttu-id="a5869-145">XAML 和裝配載</span><span class="sxs-lookup"><span data-stu-id="a5869-145">XAML and Assembly Loading</span></span>

<span data-ttu-id="a5869-146">XAML 和 .NET XAML 服務的程式集載入與CLR定義的概<xref:System.AppDomain>念整合在一起。</span><span class="sxs-lookup"><span data-stu-id="a5869-146">Assembly loading for XAML and .NET XAML Services integrates with the CLR-defined concept of <xref:System.AppDomain>.</span></span> <span data-ttu-id="a5869-147">XAML 架構上下文根據<xref:System.AppDomain>使用 和其他因素解釋如何在運行時或設計時載入程式集或查找類型。</span><span class="sxs-lookup"><span data-stu-id="a5869-147">A XAML schema context interprets how to either load assemblies or find types at run time or design time, based on the use of <xref:System.AppDomain> and other factors.</span></span> <span data-ttu-id="a5869-148">邏輯略有不同,具體取決於 XAML 對於 XAML 讀取器是鬆散的 XAML,XAML 是否由`XamlBuildTask`編譯為 DLL,還是由 WPF 生成的`PresentationBuildTask`BAML。</span><span class="sxs-lookup"><span data-stu-id="a5869-148">The logic is slightly different depending on whether the XAML is loose XAML for a XAML reader, is XAML compiled into a DLL by `XamlBuildTask`, or is BAML generated by WPF's `PresentationBuildTask`.</span></span>

<span data-ttu-id="a5869-149">WPF 的 XAML 架構上下文與 WPF<xref:System.AppDomain>應用程式模型整合,而 WPF 應用程式模型又使用 WPF 實現詳細資訊的其他因素。</span><span class="sxs-lookup"><span data-stu-id="a5869-149">The XAML schema context for WPF integrates with the WPF application model, which in turn uses <xref:System.AppDomain> as well as other factors that are WPF implementation details.</span></span>

#### <a name="xaml-reader-input-loose-xaml"></a><span data-ttu-id="a5869-150">XAML讀卡機輸入(鬆散 XAML)</span><span class="sxs-lookup"><span data-stu-id="a5869-150">XAML reader input (loose XAML)</span></span>

01. <span data-ttu-id="a5869-151">XAML 架構上下文遍<xref:System.AppDomain>達 應用程式,查找與名稱的所有方面匹配的已載入程式集,從最近載入的程式集開始。</span><span class="sxs-lookup"><span data-stu-id="a5869-151">The XAML schema context iterates through the <xref:System.AppDomain> of the application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="a5869-152">如果找到匹配項,則該程式集用於解析。</span><span class="sxs-lookup"><span data-stu-id="a5869-152">If a match is found, that assembly is used for resolution.</span></span>

02. <span data-ttu-id="a5869-153">否則,基於 CLR <xref:System.Reflection.Assembly> API 的以下技術之一用於載入程式集:</span><span class="sxs-lookup"><span data-stu-id="a5869-153">Otherwise, one of the following techniques based on CLR <xref:System.Reflection.Assembly> API are used to load an assembly:</span></span>

    - <span data-ttu-id="a5869-154">如果名稱在映射中限定,則調用<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>限定名稱。</span><span class="sxs-lookup"><span data-stu-id="a5869-154">If the name is qualified in the mapping, call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>

    - <span data-ttu-id="a5869-155">如果上一步驟失敗,請使用短名稱(如果存在公開金鑰) 呼叫<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a5869-155">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

    - <span data-ttu-id="a5869-156">如果名稱在映射中為非限定,請<xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>呼叫 。</span><span class="sxs-lookup"><span data-stu-id="a5869-156">If the name is unqualified in the mapping, call <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType>.</span></span>

#### <a name="xamlbuildtask"></a><span data-ttu-id="a5869-157">XamlBuildTask</span><span class="sxs-lookup"><span data-stu-id="a5869-157">XamlBuildTask</span></span>

<span data-ttu-id="a5869-158">`XamlBuildTask`用於 Windows 通信基礎 (WCF) 和 Windows 工作流基礎。</span><span class="sxs-lookup"><span data-stu-id="a5869-158">`XamlBuildTask` is used for Windows Communication Foundation (WCF) and Windows Workflow Foundation.</span></span>

<span data-ttu-id="a5869-159">請注意,通過的`XamlBuildTask`程式集引用始終完全限定。</span><span class="sxs-lookup"><span data-stu-id="a5869-159">Note that assembly references through `XamlBuildTask` are always fully qualified.</span></span>

1. <span data-ttu-id="a5869-160">呼叫<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>修飾名。</span><span class="sxs-lookup"><span data-stu-id="a5869-160">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>

2. <span data-ttu-id="a5869-161">如果上一步驟失敗,請使用短名稱(如果存在公開金鑰) 呼叫<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a5869-161">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

#### <a name="baml-presentationbuildtask"></a><span data-ttu-id="a5869-162">BAML (示範編譯工作)</span><span class="sxs-lookup"><span data-stu-id="a5869-162">BAML (PresentationBuildTask)</span></span>

<span data-ttu-id="a5869-163">BAML 的程式集載入有兩個方面:載入包含 BAML 作為元件的初始程式集,以及為 BAML 生產引用的任何類型的類型載入類型支援程式集。</span><span class="sxs-lookup"><span data-stu-id="a5869-163">There are two aspects to assembly-loading for BAML: loading the initial assembly that contains the BAML as a component, and loading the type-backing assemblies for any types referenced by the BAML production.</span></span>

##### <a name="assembly-load-for-initial-markup"></a><span data-ttu-id="a5869-164">初始標記的載入負載:</span><span class="sxs-lookup"><span data-stu-id="a5869-164">Assembly load for initial markup:</span></span>

<span data-ttu-id="a5869-165">對程式集的引用始終不限定以載入標記。</span><span class="sxs-lookup"><span data-stu-id="a5869-165">The reference to the assembly to load the markup from is always unqualified.</span></span>

1. <span data-ttu-id="a5869-166">WPF XAML 架構上下文遍達 WPF<xref:System.AppDomain>應用程式的, 尋找與名稱的所有方面符合的已載入程式集,從最近載入的程式集開始。</span><span class="sxs-lookup"><span data-stu-id="a5869-166">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="a5869-167">如果找到匹配項,則該程式集用於解析。</span><span class="sxs-lookup"><span data-stu-id="a5869-167">If a match is found, that assembly is used for resolution.</span></span>

2. <span data-ttu-id="a5869-168">如果上一步驟失敗,請使用短名稱(如果存在公開金鑰) 呼叫<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="a5869-168">If the previous step fails, use the short name (and public key token if present) to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

##### <a name="assembly-references-by-baml-types"></a><span data-ttu-id="a5869-169">依 BAML 類型進行的程式集引用:</span><span class="sxs-lookup"><span data-stu-id="a5869-169">Assembly references by BAML types:</span></span>

<span data-ttu-id="a5869-170">作為生成任務的輸出,BAML 生產中使用的類型的程式集引用始終完全限定。</span><span class="sxs-lookup"><span data-stu-id="a5869-170">Assembly references for types used in the BAML production are always fully qualified, as an output of the build task.</span></span>

01. <span data-ttu-id="a5869-171">WPF XAML 架構上下文遍達 WPF<xref:System.AppDomain>應用程式的, 尋找與名稱的所有方面符合的已載入程式集,從最近載入的程式集開始。</span><span class="sxs-lookup"><span data-stu-id="a5869-171">The WPF XAML schema context iterates through the <xref:System.AppDomain> of the WPF application, looking for an already-loaded assembly that matches all aspects of the name, starting from the most recently loaded assembly.</span></span> <span data-ttu-id="a5869-172">如果找到匹配項,則該程式集用於解析。</span><span class="sxs-lookup"><span data-stu-id="a5869-172">If a match is found, that assembly is used for resolution.</span></span>

02. <span data-ttu-id="a5869-173">否則,使用以下技術之一載入程式集:</span><span class="sxs-lookup"><span data-stu-id="a5869-173">Otherwise, one of the following techniques is used to load an assembly:</span></span>

    - <span data-ttu-id="a5869-174">呼叫<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>修飾名。</span><span class="sxs-lookup"><span data-stu-id="a5869-174">Call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType> on the qualified name.</span></span>
  
    - <span data-ttu-id="a5869-175">如果短名稱 + 公開金鑰與從 BAML 載入的程式集匹配,請使用該程式集。</span><span class="sxs-lookup"><span data-stu-id="a5869-175">If a short name + public key token combination match the assembly that the BAML was loaded from, use that assembly.</span></span>

    - <span data-ttu-id="a5869-176">使用短名稱 + 公開金<xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>鑰的權碼呼叫 。</span><span class="sxs-lookup"><span data-stu-id="a5869-176">Use short name + public key token to call <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="a5869-177">另請參閱</span><span class="sxs-lookup"><span data-stu-id="a5869-177">See also</span></span>

- [<span data-ttu-id="a5869-178">認識 XAML 節點資料流結構和概念</span><span class="sxs-lookup"><span data-stu-id="a5869-178">Understanding XAML Node Stream Structures and Concepts</span></span>](understanding-xaml-node-stream-structures-and-concepts.md)
