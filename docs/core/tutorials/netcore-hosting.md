---
title: 撰寫自訂 .NET Core 執行階段主機
description: 了解如何從原生程式碼裝載 .NET Core 執行階段，以支援需要控制 .NET Core 執行階段運作方式的進階案例。
author: mjrousos
ms.author: mairaw
ms.date: 02/03/2017
ms.custom: seodec18
ms.openlocfilehash: 7e30536a27408c529743ef623aa1bb837c327f96
ms.sourcegitcommit: ccd8c36b0d74d99291d41aceb14cf98d74dc9d2b
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/10/2018
ms.locfileid: "53146941"
---
# <a name="write-a-custom-net-core-host-to-control-the-net-runtime-from-your-native-code"></a><span data-ttu-id="64021-103">撰寫自訂 .NET Core 主機以從原生程式碼控制 .NET 執行階段</span><span class="sxs-lookup"><span data-stu-id="64021-103">Write a custom .NET Core host to control the .NET runtime from your native code</span></span>

<span data-ttu-id="64021-104">如同所有 Managed 程式碼，.NET Core 應用程式是由主機執行。</span><span class="sxs-lookup"><span data-stu-id="64021-104">Like all managed code, .NET Core applications are executed by a host.</span></span> <span data-ttu-id="64021-105">該主機會負責啟動執行階段 (包括 JIT 和記憶體回收行程等元件)、建立 AppDomain 及叫用 Managed 進入點。</span><span class="sxs-lookup"><span data-stu-id="64021-105">The host is responsible for starting the runtime (including components like the JIT and garbage collector), creating AppDomains, and invoking managed entry points.</span></span>

<span data-ttu-id="64021-106">裝載 .NET Core 執行階段是進階案例，在大多數情況下，由於 .NET Core 建置程序會提供預設主機來執行 .NET Core 應用程式，因此 .NET Core 開發人員不需要擔心裝載相關事宜。</span><span class="sxs-lookup"><span data-stu-id="64021-106">Hosting the .NET Core runtime is an advanced scenario and, in most cases, .NET Core developers don't need to worry about hosting because .NET Core build processes provide a default host to run .NET Core applications.</span></span> <span data-ttu-id="64021-107">不過在某些特殊情況下，明確裝載 .NET Core 執行階段可能會很有用，像是用來叫用原生處理序中的 Managed 程式碼，或是用來增加對執行階段運作方式的更多控制。</span><span class="sxs-lookup"><span data-stu-id="64021-107">In some specialized circumstances, though, it can be useful to explicitly host the .NET Core runtime, either as a means of invoking managed code in a native process or in order to gain more control over how the runtime works.</span></span>

<span data-ttu-id="64021-108">本文概述從機器碼啟動 .NET Core 執行階段、建立初始應用程式定義域 (<xref:System.AppDomain>) 及在其中執行 Managed 程式碼的必要步驟。</span><span class="sxs-lookup"><span data-stu-id="64021-108">This article gives an overview of the steps necessary to start the .NET Core runtime from native code, create an initial application domain (<xref:System.AppDomain>), and execute managed code in it.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="64021-109">必要條件</span><span class="sxs-lookup"><span data-stu-id="64021-109">Prerequisites</span></span>

<span data-ttu-id="64021-110">由於主機是原生應用程式，因此本教學課程將說明如何建構 C++ 應用程式以裝載 .NET Core。</span><span class="sxs-lookup"><span data-stu-id="64021-110">Because hosts are native applications, this tutorial will cover constructing a C++ application to host .NET Core.</span></span> <span data-ttu-id="64021-111">您將需要 C++ 開發環境 (例如 [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs) 所提供的環境)。</span><span class="sxs-lookup"><span data-stu-id="64021-111">You will need a C++ development environment (such as that provided by [Visual Studio](https://aka.ms/vsdownload?utm_source=mscom&utm_campaign=msdocs)).</span></span>

<span data-ttu-id="64021-112">您也需要一個簡單的 .NET Core 應用程式來測試主機，因此您必須安裝 [.NET Core SDK](https://www.microsoft.com/net/core) 並[建置一個小型的.NET Core 測試應用程式](../../core/tutorials/with-visual-studio.md) (例如 'Hello World' 應用程式)。</span><span class="sxs-lookup"><span data-stu-id="64021-112">You will also want a simple .NET Core application to test the host with, so you should install the [.NET Core SDK](https://www.microsoft.com/net/core) and [build a small .NET Core test app](../../core/tutorials/with-visual-studio.md) (such as a 'Hello World' app).</span></span> <span data-ttu-id="64021-113">由新的 .NET Core 主控台專案範本建立的 'Hello World' 應用程式就已足夠。</span><span class="sxs-lookup"><span data-stu-id="64021-113">The 'Hello World' app created by the new .NET Core console project template is sufficient.</span></span>

<span data-ttu-id="64021-114">本教學課程及其相關範例會建置 Windows 主機；請參閱本文結尾有關裝載於 UNIX 的注意事項。</span><span class="sxs-lookup"><span data-stu-id="64021-114">This tutorial and its associated sample build a Windows host; see the notes at the end of this article about hosting on Unix.</span></span>

## <a name="creating-the-host"></a><span data-ttu-id="64021-115">建立主機</span><span class="sxs-lookup"><span data-stu-id="64021-115">Creating the host</span></span>

<span data-ttu-id="64021-116">dotnet/samples GitHub 存放庫中提供示範本文所述步驟的[範例主機](https://github.com/dotnet/samples/tree/master/core/hosting)。</span><span class="sxs-lookup"><span data-stu-id="64021-116">A [sample host](https://github.com/dotnet/samples/tree/master/core/hosting) demonstrating the steps outlined in this article is available in the dotnet/samples GitHub repository.</span></span> <span data-ttu-id="64021-117">範例 *host.cpp* 檔案中的註解清楚地將本教學課程中的編號步驟關聯到範例中的執行位置。</span><span class="sxs-lookup"><span data-stu-id="64021-117">Comments in the sample's *host.cpp* file clearly associate the numbered steps from this tutorial with where they're performed in the sample.</span></span> <span data-ttu-id="64021-118">如需下載指示，請參閱[範例和教學課程](../../samples-and-tutorials/index.md#viewing-and-downloading-samples)。</span><span class="sxs-lookup"><span data-stu-id="64021-118">For download instructions, see [Samples and Tutorials](../../samples-and-tutorials/index.md#viewing-and-downloading-samples).</span></span>

<span data-ttu-id="64021-119">請記住，範例主機是為了用於學習，因此錯誤檢查較不嚴謹，並設計成可讀性比效率更重要。</span><span class="sxs-lookup"><span data-stu-id="64021-119">Keep in mind that the sample host is meant to be used for learning purposes, so it is light on error checking and is designed to emphasize readability over efficiency.</span></span> <span data-ttu-id="64021-120">如需更多真實世界主機範例，請參閱 [dotnet/coreclr](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts) 存放庫。</span><span class="sxs-lookup"><span data-stu-id="64021-120">More real-world host samples are available in the [dotnet/coreclr](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts) repository.</span></span> <span data-ttu-id="64021-121">特別是 [CoreRun 主機](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/corerun)，這是適合在讀完較簡單範例之後進行研究的一般用途主機。</span><span class="sxs-lookup"><span data-stu-id="64021-121">The [CoreRun host](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts/corerun), in particular, is a good general-purpose host to study after reading through the simpler sample.</span></span>

### <a name="a-note-about-mscoreeh"></a><span data-ttu-id="64021-122">mscoree.h 的相關注意事項</span><span class="sxs-lookup"><span data-stu-id="64021-122">A note about mscoree.h</span></span>
<span data-ttu-id="64021-123">主要的 .NET Core 裝載介面 (`ICLRRuntimeHost2`) 定義於 [MSCOREE.IDL](https://github.com/dotnet/coreclr/blob/master/src/inc/MSCOREE.IDL)。</span><span class="sxs-lookup"><span data-stu-id="64021-123">The primary .NET Core hosting interface (`ICLRRuntimeHost2`) is defined in [MSCOREE.IDL](https://github.com/dotnet/coreclr/blob/master/src/inc/MSCOREE.IDL).</span></span> <span data-ttu-id="64021-124">您的主機必須參考此檔案的標頭版本 (mscoree.h)，該檔案會在建置 [.NET Core 執行階段](https://github.com/dotnet/coreclr/)時透過 MIDL 產生。</span><span class="sxs-lookup"><span data-stu-id="64021-124">A header version of this file (mscoree.h), which your host will need to reference, is produced via MIDL when the [.NET Core runtime](https://github.com/dotnet/coreclr/) is built.</span></span> <span data-ttu-id="64021-125">如果不想建置 .NET Core 執行階段，mscoree.h 也會當作 dotnet/coreclr 存放庫中[預先建立的標頭](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc)使用。</span><span class="sxs-lookup"><span data-stu-id="64021-125">If you do not want to build the .NET Core runtime, mscoree.h is also available as a [pre-built header](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc) in the dotnet/coreclr repository.</span></span> <span data-ttu-id="64021-126">您可以在 GitHub 存放庫中找到[建置 .NET Core 執行階段的指示](https://github.com/dotnet/coreclr#building-the-repository)。</span><span class="sxs-lookup"><span data-stu-id="64021-126">[Instructions on building the .NET Core runtime](https://github.com/dotnet/coreclr#building-the-repository) can be found in its GitHub repository.</span></span> 

### <a name="step-1---identify-the-managed-entry-point"></a><span data-ttu-id="64021-127">步驟 1 - 識別 Managed 進入點</span><span class="sxs-lookup"><span data-stu-id="64021-127">Step 1 - Identify the managed entry point</span></span>
<span data-ttu-id="64021-128">參考必要的標頭 (例如 [mscoree.h](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc/mscoree.h) 和 stdio.h) 之後，.NET Core 主機必須先找出所要使用的 Managed 進入點。</span><span class="sxs-lookup"><span data-stu-id="64021-128">After referencing necessary headers ([mscoree.h](https://github.com/dotnet/coreclr/tree/master/src/pal/prebuilt/inc/mscoree.h) and stdio.h, for example), one of the first things a .NET Core host must do is locate the managed entry point it will be using.</span></span> <span data-ttu-id="64021-129">在我們的範例主機中，只要將第一個命令列引數傳遞至主機作為 Managed 二進位檔 (將執行其 `main` 方法) 的路徑，即可完成此作業。</span><span class="sxs-lookup"><span data-stu-id="64021-129">In our sample host, this is done by just taking the first command line argument to our host as the path to a managed binary whose `main` method will be executed.</span></span>

[!code-cpp[NetCoreHost#1](../../../samples/core/hosting/host.cpp#1)]

### <a name="step-2---find-and-load-coreclrdll"></a><span data-ttu-id="64021-130">步驟 2 - 找到並載入 CoreCLR.dll</span><span class="sxs-lookup"><span data-stu-id="64021-130">Step 2 - Find and load CoreCLR.dll</span></span>
<span data-ttu-id="64021-131">.NET Core 執行階段 API 位於 *CoreCLR.dll* (Windows 上)。</span><span class="sxs-lookup"><span data-stu-id="64021-131">The .NET Core runtime APIs are in *CoreCLR.dll* (on Windows).</span></span> <span data-ttu-id="64021-132">若要取得我們的裝載介面 (`ICLRRuntimeHost2`)，您必須找到並載入 *CoreCLR.dll*。</span><span class="sxs-lookup"><span data-stu-id="64021-132">To get our hosting interface (`ICLRRuntimeHost2`), it's necessary to find and load *CoreCLR.dll*.</span></span> <span data-ttu-id="64021-133">主機會定義尋找 *CoreCLR.dll* 的方式慣例。</span><span class="sxs-lookup"><span data-stu-id="64021-133">It is up to the host to define a convention for how it will locate *CoreCLR.dll*.</span></span> <span data-ttu-id="64021-134">某些主機預期此檔案會出現在已知的全機器位置 (例如 %programfiles%\dotnet\shared\Microsoft.NETCore.App\1.1.0)。</span><span class="sxs-lookup"><span data-stu-id="64021-134">Some hosts expect the file to be present in a well-known machine-wide location (such as %programfiles%\dotnet\shared\Microsoft.NETCore.App\1.1.0).</span></span> <span data-ttu-id="64021-135">其他主機則預期會從主機本身或所要裝載之應用程式旁的位置載入 *CoreCLR.dll*。</span><span class="sxs-lookup"><span data-stu-id="64021-135">Others expect that *CoreCLR.dll* will be loaded from a location next to either the host itself or the app to be hosted.</span></span> <span data-ttu-id="64021-136">不過，其他主機還是可以參考環境變數以尋找程式庫。</span><span class="sxs-lookup"><span data-stu-id="64021-136">Still others might consult an environment variable to find the library.</span></span>

<span data-ttu-id="64021-137">在 Linux 或 Mac 上，Core 執行階段程式庫分別是 *libcoreclr.so* 或 *libcoreclr.dylib*。</span><span class="sxs-lookup"><span data-stu-id="64021-137">On Linux or Mac, the core runtime library is *libcoreclr.so* or *libcoreclr.dylib*, respectively.</span></span>

<span data-ttu-id="64021-138">我們的範例主機會在一些常見的位置中探查 *CoreCLR.dll*。</span><span class="sxs-lookup"><span data-stu-id="64021-138">Our sample host probes a few common locations for *CoreCLR.dll*.</span></span> <span data-ttu-id="64021-139">找到後，必須透過 `LoadLibrary` (若是 Linux/Mac 則為 `dlopen`) 載入。</span><span class="sxs-lookup"><span data-stu-id="64021-139">Once found, it must be loaded via `LoadLibrary` (or `dlopen` on Linux/Mac).</span></span>

[!code-cpp[NetCoreHost#2](../../../samples/core/hosting/host.cpp#2)]

### <a name="step-3---get-an-iclrruntimehost2-instance"></a><span data-ttu-id="64021-140">步驟 3 - 取得 ICLRRuntimeHost2 執行個體</span><span class="sxs-lookup"><span data-stu-id="64021-140">Step 3 - Get an ICLRRuntimeHost2 Instance</span></span>
<span data-ttu-id="64021-141">若要擷取 `ICLRRuntimeHost2` 裝載介面，請在 `GetCLRRuntimeHost` 上呼叫 `GetProcAddress` (若是 Linux/Mac 則為 `dlsym`)，然後叫用該函式。</span><span class="sxs-lookup"><span data-stu-id="64021-141">The `ICLRRuntimeHost2` hosting interface is retrieved by calling `GetProcAddress` (or `dlsym` on Linux/Mac) on `GetCLRRuntimeHost`, and then invoking that function.</span></span> 

[!code-cpp[NetCoreHost#3](../../../samples/core/hosting/host.cpp#3)]

### <a name="step-4---setting-startup-flags-and-starting-the-runtime"></a><span data-ttu-id="64021-142">步驟 4 - 設定啟動旗標並啟動執行階段</span><span class="sxs-lookup"><span data-stu-id="64021-142">Step 4 - Setting startup flags and starting the runtime</span></span>
<span data-ttu-id="64021-143">準備好 `ICLRRuntimeHost2` 之後，現在可以指定全執行階段啟動旗標並啟動執行階段。</span><span class="sxs-lookup"><span data-stu-id="64021-143">With an `ICLRRuntimeHost2` in-hand, we can now specify runtime-wide startup flags and start the runtime.</span></span> <span data-ttu-id="64021-144">啟動旗標會決定所要使用的記憶體回收行程 (GC) (並行或伺服器)，而不論使用的是單一 AppDomain 或多個 AppDomain；它也會決定 (為了以定義域中性方式載入組件) 所要使用的載入器最佳化原則。</span><span class="sxs-lookup"><span data-stu-id="64021-144">Startup flags will determine which garbage collector (GC) to use (concurrent or server), whether we will use a single AppDomain or multiple AppDomains, and what loader optimization policy to use (for domain-neutral loading of assemblies).</span></span>

[!code-cpp[NetCoreHost#4](../../../samples/core/hosting/host.cpp#4)]

<span data-ttu-id="64021-145">呼叫 `Start` 函式以啟動執行階段。</span><span class="sxs-lookup"><span data-stu-id="64021-145">The runtime is started with a call to the `Start` function.</span></span>

```C++
hr = runtimeHost->Start();
```

### <a name="step-5---preparing-appdomain-settings"></a><span data-ttu-id="64021-146">步驟 5 - 準備 AppDomain 設定</span><span class="sxs-lookup"><span data-stu-id="64021-146">Step 5 - Preparing AppDomain settings</span></span>
<span data-ttu-id="64021-147">啟動執行階段之後，我們想要設定 AppDomain。</span><span class="sxs-lookup"><span data-stu-id="64021-147">Once the runtime is started, we will want to set up an AppDomain.</span></span> <span data-ttu-id="64021-148">不過，建立 .NET AppDomain 時必須指定一些選項，因此必須先準備這些選項。</span><span class="sxs-lookup"><span data-stu-id="64021-148">There are a number of options that must be specified when creating a .NET AppDomain, however, so it's necessary to prepare those first.</span></span>

<span data-ttu-id="64021-149">AppDomain 旗標會指定與安全性和 Interop 相關的 AppDomain 行為。</span><span class="sxs-lookup"><span data-stu-id="64021-149">AppDomain flags specify AppDomain behaviors related to security and interop.</span></span> <span data-ttu-id="64021-150">舊版的 Silverlight 主機使用這些設定來沙箱化使用者程式碼，但最新式的 .NET Core 主機則會以完全信任的方式來執行使用者程式碼並啟用 Interop。</span><span class="sxs-lookup"><span data-stu-id="64021-150">Older Silverlight hosts used these settings to sandbox user code, but most modern .NET Core hosts run user code as full trust and enable interop.</span></span>

[!code-cpp[NetCoreHost#5](../../../samples/core/hosting/host.cpp#5)]

<span data-ttu-id="64021-151">決定要使用的 AppDomain 旗標之後，必須定義 AppDomain 屬性。</span><span class="sxs-lookup"><span data-stu-id="64021-151">After deciding which AppDomain flags to use, AppDomain properties must be defined.</span></span> <span data-ttu-id="64021-152">這些屬性是字串的索引鍵/值組。</span><span class="sxs-lookup"><span data-stu-id="64021-152">The properties are key/value pairs of strings.</span></span> <span data-ttu-id="64021-153">許多屬性與 AppDomain 載入組件的方式相關。</span><span class="sxs-lookup"><span data-stu-id="64021-153">Many of the properties relate to how the AppDomain will load assemblies.</span></span>

<span data-ttu-id="64021-154">常見的 AppDomain 屬性包括：</span><span class="sxs-lookup"><span data-stu-id="64021-154">Common AppDomain properties include:</span></span>

* <span data-ttu-id="64021-155">`TRUSTED_PLATFORM_ASSEMBLIES`：這是 AppDomain 應設定載入優先權並授與完全信任 (即使是部分信任的定義域) 的組件路徑清單 (在 Windows 上會以 ';' 分隔，而在 Unix 上則以 ':' 分隔)。</span><span class="sxs-lookup"><span data-stu-id="64021-155">`TRUSTED_PLATFORM_ASSEMBLIES` This is a list of assembly paths (delimited by ';' on Windows and ':' on Unix) which the AppDomain should prioritize loading and give full trust to (even in partially-trusted domains).</span></span> <span data-ttu-id="64021-156">此清單可用來包含 'Framework' 組件及其他信任的模組，類似於 .NET Framework 案例中的 GAC。</span><span class="sxs-lookup"><span data-stu-id="64021-156">This list is meant to contain 'Framework' assemblies and other trusted modules, similar to the GAC in .NET Framework scenarios.</span></span> <span data-ttu-id="64021-157">某些主機會將任何程式庫放在此清單中的 *coreclr.dll* 旁，其他主機則會有針對其用途列出信任組件的硬式編碼資訊清單。</span><span class="sxs-lookup"><span data-stu-id="64021-157">Some hosts will put any library next to *coreclr.dll* on this list, others have hard-coded manifests listing trusted assemblies for their purposes.</span></span>
* <span data-ttu-id="64021-158">`APP_PATHS`：這是在信賴平台組件 (TPA) 清單中找不到組件時，要在其中探查組件的路徑清單。</span><span class="sxs-lookup"><span data-stu-id="64021-158">`APP_PATHS` This is a list of paths to probe in for an assembly if it can't be found in the trusted platform assemblies (TPA) list.</span></span> <span data-ttu-id="64021-159">這些路徑會是使用者組件所在的位置。</span><span class="sxs-lookup"><span data-stu-id="64021-159">These paths are meant to be the locations where users' assemblies can be found.</span></span> <span data-ttu-id="64021-160">在沙箱化 AppDomain 中，從這些路徑載入的組件只會被授與部分信任。</span><span class="sxs-lookup"><span data-stu-id="64021-160">In a sandboxed AppDomain, assemblies loaded from these paths will only be granted partial trust.</span></span> <span data-ttu-id="64021-161">常見的 APP_PATH 路徑包括載入目標應用程式的來源路徑，或使用者資產已知存留的其他位置。</span><span class="sxs-lookup"><span data-stu-id="64021-161">Common APP_PATH paths include the path the target app was loaded from or other locations where user assets are known to live.</span></span>
*  <span data-ttu-id="64021-162">`APP_NI_PATHS`：此清單與 APP_PATHS 非常類似，不同之處在於其用途是作為探查原生影像的路徑。</span><span class="sxs-lookup"><span data-stu-id="64021-162">`APP_NI_PATHS` This list is very similar to APP_PATHS except that it's meant to be paths that will be probed for native images.</span></span>
*  <span data-ttu-id="64021-163">`NATIVE_DLL_SEARCH_DIRECTORIES`：此屬性是想要透過 p/invoke 呼叫原生 DLL 時，載入器應探查的路徑清單。</span><span class="sxs-lookup"><span data-stu-id="64021-163">`NATIVE_DLL_SEARCH_DIRECTORIES` This property is a list of paths the loader should probe when looking for native DLLs called via p/invoke.</span></span>
*  <span data-ttu-id="64021-164">`PLATFORM_RESOURCE_ROOTS`：此清單包含要在其中探查資源附屬組件的路徑 (位於文化特性專屬子目錄中)。</span><span class="sxs-lookup"><span data-stu-id="64021-164">`PLATFORM_RESOURCE_ROOTS` This list includes paths to probe in for resource satellite assemblies (in culture-specific sub-directories).</span></span>

<span data-ttu-id="64021-165">在我們的[簡單範例主機](https://github.com/dotnet/samples/tree/master/core/hosting)中，這些屬性會設定如下：</span><span class="sxs-lookup"><span data-stu-id="64021-165">In our [simple sample host](https://github.com/dotnet/samples/tree/master/core/hosting), these properties are set up as follows:</span></span>

[!code-cpp[NetCoreHost#6](../../../samples/core/hosting/host.cpp#6)]

### <a name="step-6---create-the-appdomain"></a><span data-ttu-id="64021-166">步驟 6 - 建立 AppDomain</span><span class="sxs-lookup"><span data-stu-id="64021-166">Step 6 - Create the AppDomain</span></span>
<span data-ttu-id="64021-167">準備好所有 AppDomain 旗標和屬性之後，即可使用 `ICLRRuntimeHost2::CreateAppDomainWithManager` 來設定 AppDomain。</span><span class="sxs-lookup"><span data-stu-id="64021-167">Once all AppDomain flags and properties are prepared, `ICLRRuntimeHost2::CreateAppDomainWithManager` can be used to set up the AppDomain.</span></span> <span data-ttu-id="64021-168">此函式會選擇性地接受完整組件名稱和類型名稱，以用作定義域的 AppDomain 管理員。</span><span class="sxs-lookup"><span data-stu-id="64021-168">This function optionally takes a fully qualified assembly name and type name to use as the domain's AppDomain manager.</span></span> <span data-ttu-id="64021-169">AppDomain 管理員可讓主機控制 AppDomain 行為的某些層面，並可在主機不想直接叫用使用者程式碼時，提供進入點以啟動 Managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="64021-169">An AppDomain manager can allow a host to control some aspects of AppDomain behavior and may provide entry points for launching managed code if the host doesn't intend to invoke user code directly.</span></span>   

[!code-cpp[NetCoreHost#7](../../../samples/core/hosting/host.cpp#7)]

### <a name="step-7---run-managed-code"></a><span data-ttu-id="64021-170">步驟 7 - 執行 Managed 程式碼！</span><span class="sxs-lookup"><span data-stu-id="64021-170">Step 7 - Run managed code!</span></span>
<span data-ttu-id="64021-171">在 AppDomain 啟動並執行之後，主機現在可以開始執行 Managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="64021-171">With an AppDomain up and running, the host can now start executing managed code.</span></span> <span data-ttu-id="64021-172">最簡單的做法是使用 `ICLRRuntimeHost2::ExecuteAssembly` 叫用 Managed 組件的進入點方法。</span><span class="sxs-lookup"><span data-stu-id="64021-172">The easiest way to do this is to use `ICLRRuntimeHost2::ExecuteAssembly` to invoke a managed assembly's entry point method.</span></span> <span data-ttu-id="64021-173">請注意，此函式僅適用於單一定義域案例。</span><span class="sxs-lookup"><span data-stu-id="64021-173">Note that this function only works in single-domain scenarios.</span></span>

[!code-cpp[NetCoreHost#8](../../../samples/core/hosting/host.cpp#8)]

<span data-ttu-id="64021-174">如果 `ExecuteAssembly` 不符合您的主機需求，另一個選擇是使用 `CreateDelegate` 建立靜態 Managed 方法的函式指標。</span><span class="sxs-lookup"><span data-stu-id="64021-174">Another option, if `ExecuteAssembly` doesn't meet your host's needs, is to use `CreateDelegate` to create a function pointer to a static managed method.</span></span> <span data-ttu-id="64021-175">雖然此做法要求主機必須知道所呼叫的方法簽章 (以便建立函式指標類型)，但允許主機彈性地叫用組件進入點以外的程式碼。</span><span class="sxs-lookup"><span data-stu-id="64021-175">This requires the host to know the signature of the method it is calling into (in order to create the function pointer type) but allows hosts the flexibility to invoke code other than an assembly's entry point.</span></span>

```C++
void *pfnDelegate = NULL;
hr = runtimeHost->CreateDelegate(
  domainId,
  L"HW, Version=1.0.0.0, Culture=neutral",  // Target managed assembly
  L"ConsoleApplication.Program",            // Target managed type
  L"Main",                                  // Target entry point (static method)
  (INT_PTR*)&pfnDelegate);

((MainMethodFp*)pfnDelegate)(NULL);
```

### <a name="step-8---clean-up"></a><span data-ttu-id="64021-176">步驟 8 - 清除</span><span class="sxs-lookup"><span data-stu-id="64021-176">Step 8 - Clean up</span></span>
<span data-ttu-id="64021-177">最後，主機應該藉由卸載 AppDomain、停止執行階段並釋放 `ICLRRuntimeHost2` 參考來清除自身。</span><span class="sxs-lookup"><span data-stu-id="64021-177">Finally, the host should clean up after itself by unloading AppDomains, stopping the runtime, and releasing the `ICLRRuntimeHost2` reference.</span></span>

[!code-cpp[NetCoreHost#9](../../../samples/core/hosting/host.cpp#9)]

## <a name="about-hosting-net-core-on-unix"></a><span data-ttu-id="64021-178">關於在 Unix 上裝載 .NET Core</span><span class="sxs-lookup"><span data-stu-id="64021-178">About Hosting .NET Core on Unix</span></span>
<span data-ttu-id="64021-179">.NET Core 是在 Windows、Linux 和 Mac 作業系統上執行的跨平台產品。</span><span class="sxs-lookup"><span data-stu-id="64021-179">.NET Core is a cross-platform product, running on Windows, Linux, and Mac operating systems.</span></span> <span data-ttu-id="64021-180">不過如同原生應用程式，不同平台的主機之間會有一些差異。</span><span class="sxs-lookup"><span data-stu-id="64021-180">As native applications, though, hosts for different platforms will have some differences between them.</span></span> <span data-ttu-id="64021-181">上述使用 `ICLRRuntimeHost2` 啟動執行階段、建立 AppDomain 及執行 Managed 程式碼的程序，在任何支援的作業系統上都應該正常運作。</span><span class="sxs-lookup"><span data-stu-id="64021-181">The process described above of using `ICLRRuntimeHost2` to start the runtime, create an AppDomain, and execute managed code, should work on any supported operating system.</span></span> <span data-ttu-id="64021-182">不過，由於 mscoree 提出許多 Win32 假設，因此定義於 mscoree.h 的介面可能很難搭配 Unix 平台使用。</span><span class="sxs-lookup"><span data-stu-id="64021-182">However, the interfaces defined in mscoree.h can be cumbersome to work with on Unix platforms since mscoree makes many Win32 assumptions.</span></span>

<span data-ttu-id="64021-183">為了讓 Unix 平台上的裝載作業更容易，[coreclrhost.h](https://github.com/dotnet/coreclr/blob/master/src/coreclr/hosts/inc/coreclrhost.h) 中提供由多個非平台相關的裝載 API 包裝函式組成的集合。</span><span class="sxs-lookup"><span data-stu-id="64021-183">To make hosting on Unix platforms easier, a set of more platform-neutral hosting API wrappers are available in [coreclrhost.h](https://github.com/dotnet/coreclr/blob/master/src/coreclr/hosts/inc/coreclrhost.h).</span></span>

<span data-ttu-id="64021-184">您可以在 [UnixCoreRun 主機](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts)中查看使用 coreclrhost.h (而不是直接使用 mscoree.h) 的範例。</span><span class="sxs-lookup"><span data-stu-id="64021-184">An example of using coreclrhost.h (instead of mscoree.h directly) can be seen in the [UnixCoreRun host](https://github.com/dotnet/coreclr/tree/master/src/coreclr/hosts).</span></span> <span data-ttu-id="64021-185">從 coreclrhost.h 使用 API 裝載執行階段的步驟，類似於使用 mscoree.h 時的步驟：</span><span class="sxs-lookup"><span data-stu-id="64021-185">The steps to use the APIs from coreclrhost.h to host the runtime are similar to the steps when using mscoree.h:</span></span>

1. <span data-ttu-id="64021-186">識別要執行的 Managed 程式碼 (例如從命令列參數)。</span><span class="sxs-lookup"><span data-stu-id="64021-186">Identify the managed code to execute (from command line parameters, for example).</span></span> 
2. <span data-ttu-id="64021-187">載入 CoreCLR 程式庫。</span><span class="sxs-lookup"><span data-stu-id="64021-187">Load the CoreCLR library.</span></span>
    1. `dlopen("./libcoreclr.so", RTLD_NOW | RTLD_LOCAL);` 
3. <span data-ttu-id="64021-188">使用 `dlsym` 取得 CoreCLR 之 `coreclr_initialize`、`coreclr_create_delegate`、`coreclr_execute_assembly` 和 `coreclr_shutdown` 的函式指標</span><span class="sxs-lookup"><span data-stu-id="64021-188">Get function pointers to CoreCLR's `coreclr_initialize`, `coreclr_create_delegate`, `coreclr_execute_assembly`, and `coreclr_shutdown` functions using `dlsym`</span></span>
    1. `coreclr_initialize_ptr coreclr_initialize = (coreclr_initialize_ptr)dlsym(coreclrLib, "coreclr_initialize");`
4. <span data-ttu-id="64021-189">設定 AppDomain 屬性 (例如 TPA 清單)。</span><span class="sxs-lookup"><span data-stu-id="64021-189">Set up AppDomain properties (such as the TPA list).</span></span> <span data-ttu-id="64021-190">這會與上述 mscoree 工作流程的步驟 5 相同。</span><span class="sxs-lookup"><span data-stu-id="64021-190">This is the same as step 5 from the mscoree workflow, above.</span></span>
5. <span data-ttu-id="64021-191">使用 `coreclr_initialize` 啟動執行階段並建立 AppDomain。</span><span class="sxs-lookup"><span data-stu-id="64021-191">Use `coreclr_initialize` to start the runtime and create an AppDomain.</span></span> <span data-ttu-id="64021-192">這也會建立將在未來裝載呼叫中使用的 `hostHandle` 指標。</span><span class="sxs-lookup"><span data-stu-id="64021-192">This will also create a `hostHandle` pointer that will be used in future hosting calls.</span></span>
    1. <span data-ttu-id="64021-193">請注意，此函式會執行上一個工作流程之步驟 4 和 6 的角色。</span><span class="sxs-lookup"><span data-stu-id="64021-193">Note that this function performs the roles of both steps 4 and 6 from the previous workflow.</span></span> 
6. <span data-ttu-id="64021-194">使用 `coreclr_execute_assembly` 或 `coreclr_create_delegate` 執行 Managed 程式碼。</span><span class="sxs-lookup"><span data-stu-id="64021-194">Use either `coreclr_execute_assembly` or `coreclr_create_delegate` to execute managed code.</span></span> <span data-ttu-id="64021-195">這些函式類似於上一個工作流程的步驟 7 中 mscoree 的 `ExecuteAssembly` 和 `CreateDelegate` 函式。</span><span class="sxs-lookup"><span data-stu-id="64021-195">These functions are analogous to mscoree's `ExecuteAssembly` and `CreateDelegate` functions from step 7 of the previous workflow.</span></span>
7. <span data-ttu-id="64021-196">使用 `coreclr_shutdown` 卸載 AppDomain 並關閉執行階段。</span><span class="sxs-lookup"><span data-stu-id="64021-196">Use `coreclr_shutdown` to unload the AppDomain and shut down the runtime.</span></span> 

## <a name="conclusion"></a><span data-ttu-id="64021-197">結論</span><span class="sxs-lookup"><span data-stu-id="64021-197">Conclusion</span></span>
<span data-ttu-id="64021-198">建立主機之後，您可以藉由從命令列執行主機，並傳遞主機預期的任何引數 (例如所要執行的 Managed 應用程式)，來進行測試。</span><span class="sxs-lookup"><span data-stu-id="64021-198">Once your host is built, it can be tested by running it from the command line and passing any arguments (like the managed app to run) the host expects.</span></span> <span data-ttu-id="64021-199">指定主機要執行的 .NET Core 應用程式時，請務必使用 `dotnet build` 所產生的 .dll。</span><span class="sxs-lookup"><span data-stu-id="64021-199">When specifying the .NET Core app for the host to run, be sure to use the .dll that is produced by `dotnet build`.</span></span> <span data-ttu-id="64021-200">針對獨立性應用程式執行 `dotnet publish` 所產生的可執行檔，其實就是預設 .NET Core 主機 (因此應用程式可在主要情況下從命令列直接啟動)；使用者程式碼會編譯成同名的 DLL。</span><span class="sxs-lookup"><span data-stu-id="64021-200">Executables produced by `dotnet publish` for self-contained applications are actually the default .NET Core host (so that the app can be launched directly from the command line in mainline scenarios); user code is compiled into a dll of the same name.</span></span> 

<span data-ttu-id="64021-201">如果一開始未正常運作，請再確認一次主機預期的位置中有 *coreclr.dll*、所有必要的 Framework 程式庫都在 TPA 清單中，而且 CoreCLR 的位元 (32 或 64 位元) 符合主機的建立方式。</span><span class="sxs-lookup"><span data-stu-id="64021-201">If things don't work initially, double-check that *coreclr.dll* is available in the location expected by the host, that all necessary Framework libraries are in the TPA list, and that CoreCLR's bitness (32- or 64-bit) matches how the host was built.</span></span>

<span data-ttu-id="64021-202">裝載 .NET Core 執行階段是進階案例，許多開發人員並不需要，但對於需要從原生處理序啟動 Managed 程式碼的人員，或需要更能掌控 .NET Core 執行階段行為的人員而言，這項作業可能很實用。</span><span class="sxs-lookup"><span data-stu-id="64021-202">Hosting the .NET Core runtime is an advanced scenario that many developers won't require, but for those who need to launch managed code from a native process, or who need more control over the .NET Core runtime's behavior, it can be very useful.</span></span> <span data-ttu-id="64021-203">由於 .NET Core 能夠與本身並存執行，因此您甚至可以建立主機，以初始化並啟動多個版本的 .NET Core 執行階段，並在相同處理序的這些執行階段上執行應用程式。</span><span class="sxs-lookup"><span data-stu-id="64021-203">Because .NET Core is able to run side-by-side with itself, it's even possible to create hosts which initialize and start multiple versions of the .NET Core runtime and execute apps on all of them in the same process.</span></span> 
