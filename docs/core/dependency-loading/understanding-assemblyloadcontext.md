---
title: 瞭解程式集載入上下文 - .NET 核心
description: 瞭解 .NET Core 中程式集 LoadCoNtext 的目的和行為的關鍵概念。
ms.date: 08/09/2019
author: sdmaclea
ms.author: stmaclea
ms.openlocfilehash: 8a73a432bf8cc72cced77cf6c62a785b72032913
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/14/2020
ms.locfileid: "72291257"
---
# <a name="understanding-systemruntimeloaderassemblyloadcontext"></a><span data-ttu-id="3a9a3-103">瞭解系統.運行時.載入程式.程式集載入上下文</span><span class="sxs-lookup"><span data-stu-id="3a9a3-103">Understanding System.Runtime.Loader.AssemblyLoadContext</span></span>

<span data-ttu-id="3a9a3-104">類<xref:System.Runtime.Loader.AssemblyLoadContext>對 .NET Core 是唯一的。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-104">The <xref:System.Runtime.Loader.AssemblyLoadContext> class is unique to .NET Core.</span></span> <span data-ttu-id="3a9a3-105">本文嘗試用概念資訊<xref:System.Runtime.Loader.AssemblyLoadContext>補充 API 文檔。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-105">This article attempts to supplement the <xref:System.Runtime.Loader.AssemblyLoadContext> API documentation with conceptual information.</span></span>

<span data-ttu-id="3a9a3-106">本文與實現動態載入的開發人員相關，尤其是動態載入框架開發人員。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-106">This article is relevant to developers implementing dynamic loading, especially dynamic loading framework developers.</span></span>

## <a name="what-is-the-assemblyloadcontext"></a><span data-ttu-id="3a9a3-107">什麼是程式集載入上下文？</span><span class="sxs-lookup"><span data-stu-id="3a9a3-107">What is the AssemblyLoadContext?</span></span>

<span data-ttu-id="3a9a3-108">每個 .NET 核心應用程式隱<xref:System.Runtime.Loader.AssemblyLoadContext>式使用 。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-108">Every .NET Core application implicitly uses the <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span>
<span data-ttu-id="3a9a3-109">它是用於查找和載入依賴項的運行時提供程式。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-109">It's the runtime's provider for locating and loading dependencies.</span></span> <span data-ttu-id="3a9a3-110">每當載入依賴項時，都會<xref:System.Runtime.Loader.AssemblyLoadContext>調用實例來查找它。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-110">Whenever a dependency is loaded, an <xref:System.Runtime.Loader.AssemblyLoadContext> instance is invoked to locate it.</span></span>

- <span data-ttu-id="3a9a3-111">它提供定位、載入和緩存託管程式集和其他依賴項的服務。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-111">It provides a service of locating, loading, and caching managed assemblies and other dependencies.</span></span>

- <span data-ttu-id="3a9a3-112">為了支援動態代碼載入和卸載，它為在其自己的<xref:System.Runtime.Loader.AssemblyLoadContext>實例中載入代碼及其依賴項創建了一個隔離上下文。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-112">To support dynamic code loading and unloading, it creates an isolated context for loading code and its dependencies in their own <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span>

## <a name="when-do-you-need-multiple-assemblyloadcontext-instances"></a><span data-ttu-id="3a9a3-113">何時需要多個程式集載入上下文實例？</span><span class="sxs-lookup"><span data-stu-id="3a9a3-113">When do you need multiple AssemblyLoadContext instances?</span></span>

<span data-ttu-id="3a9a3-114">單個<xref:System.Runtime.Loader.AssemblyLoadContext>實例僅限於僅載入每個簡單程式集名稱的一個版本<xref:System.Reflection.Assembly><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-114">A single <xref:System.Runtime.Loader.AssemblyLoadContext> instance is limited to loading exactly one version of an <xref:System.Reflection.Assembly> per simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="3a9a3-115">動態載入代碼模組時，此限制可能會成為問題。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-115">This restriction can become a problem when loading code modules dynamically.</span></span> <span data-ttu-id="3a9a3-116">每個模組都是獨立編譯的，可能依賴于 不同的<xref:System.Reflection.Assembly>版本。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-116">Each module is independently compiled and may depend on different versions of an <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="3a9a3-117">當不同的模組依賴于常用庫的不同版本時，通常會出現此問題。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-117">This problem commonly occurs when different modules depend on different versions of a commonly used library.</span></span>

<span data-ttu-id="3a9a3-118">為了支援動態載入代碼，API<xref:System.Runtime.Loader.AssemblyLoadContext>提供在同一應用程式中載入 衝突版本的<xref:System.Reflection.Assembly>。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-118">To support dynamically loading code, the <xref:System.Runtime.Loader.AssemblyLoadContext> API provides for loading conflicting versions of an <xref:System.Reflection.Assembly> in the same application.</span></span> <span data-ttu-id="3a9a3-119">每個<xref:System.Runtime.Loader.AssemblyLoadContext>實例都提供一個唯一<xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>的字典，<xref:System.Reflection.Assembly>將每個實例映射到一個特定實例。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-119">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance provides a unique dictionary mapping each <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> to a specific <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="3a9a3-120">它還提供了一種方便的機制，用於分組與代碼模組相關的依賴項，以便以後卸載。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-120">It also provides a convenient mechanism for grouping dependencies related to a code module for later unload.</span></span>

## <a name="what-is-special-about-the-assemblyloadcontextdefault-instance"></a><span data-ttu-id="3a9a3-121">程式集載入上下文.預設實例有哪些特別內容？</span><span class="sxs-lookup"><span data-stu-id="3a9a3-121">What is special about the AssemblyLoadContext.Default instance?</span></span>

<span data-ttu-id="3a9a3-122"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>實例由啟動時運行時自動填滿。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-122">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance is automatically populated by the runtime at startup.</span></span>  <span data-ttu-id="3a9a3-123">它使用[預設探測](default-probing.md)來查找和查找所有靜態依賴項。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-123">It uses [default probing](default-probing.md) to locate and find all static dependencies.</span></span>

<span data-ttu-id="3a9a3-124">它解決了最常見的依賴項載入方案。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-124">It solves the most common dependency loading scenarios.</span></span>

## <a name="how-does-assemblyloadcontext-support-dynamic-dependencies"></a><span data-ttu-id="3a9a3-125">程式集載入上下文如何支援動態依賴項？</span><span class="sxs-lookup"><span data-stu-id="3a9a3-125">How does AssemblyLoadContext support dynamic dependencies?</span></span>

<span data-ttu-id="3a9a3-126"><xref:System.Runtime.Loader.AssemblyLoadContext>具有可以重寫的各種事件和虛擬函數。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-126"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span>

<span data-ttu-id="3a9a3-127">實例<xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>僅支援重寫事件。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-127">The <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> instance only supports overriding the events.</span></span>

<span data-ttu-id="3a9a3-128">文章[託管程式集載入演算法](loading-managed.md)、[附屬程式集載入演算法](loading-resources.md)和非[託管（本機）庫載入演算法](loading-unmanaged.md)是指所有可用的事件和虛擬函數。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-128">The articles [Managed assembly loading algorithm](loading-managed.md), [Satellite assembly loading algorithm](loading-resources.md), and [Unmanaged (native) library loading algorithm](loading-unmanaged.md) refer to all the available events and virtual functions.</span></span>  <span data-ttu-id="3a9a3-129">這些文章顯示了每個事件和函數在載入演算法中的相對位置。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-129">The articles show each event and function's relative position in the loading algorithms.</span></span> <span data-ttu-id="3a9a3-130">本文不會重現該資訊。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-130">This article doesn't reproduce that information.</span></span>

<span data-ttu-id="3a9a3-131">本節介紹相關事件和職能的一般原則。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-131">This section covers the general principles for the relevant events and functions.</span></span>

- <span data-ttu-id="3a9a3-132">**可重複**。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-132">**Be repeatable**.</span></span> <span data-ttu-id="3a9a3-133">對特定依賴項的查詢必須始終產生相同的回應。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-133">A query for a specific dependency must always result in the same response.</span></span> <span data-ttu-id="3a9a3-134">必須返回相同的載入的依賴項實例。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-134">The same loaded dependency instance must be returned.</span></span> <span data-ttu-id="3a9a3-135">此要求對於快取一致性至關重要。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-135">This requirement is fundamental  for cache consistency.</span></span> <span data-ttu-id="3a9a3-136">對於託管程式集，我們創建了緩存<xref:System.Reflection.Assembly>。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-136">For managed assemblies in particular, we're creating a <xref:System.Reflection.Assembly> cache.</span></span> <span data-ttu-id="3a9a3-137">緩存鍵是一個簡單的程式集名稱<xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-137">The cache key is a simple assembly name, <xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="3a9a3-138">**通常不扔**。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-138">**Typically don't throw**.</span></span>  <span data-ttu-id="3a9a3-139">當找不到請求的依賴項時，預計`null`這些函數返回而不是引發。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-139">It's expected that these functions return `null` rather than throw when unable to find the requested dependency.</span></span> <span data-ttu-id="3a9a3-140">引發將過早結束搜索，並將異常傳播到調用方。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-140">Throwing will prematurely end the search and be propagate an exception to the caller.</span></span> <span data-ttu-id="3a9a3-141">投擲應限於意外錯誤，如損壞的程式集或記憶體不足條件。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-141">Throwing should be restricted to unexpected errors like a corrupted assembly or an out of memory condition.</span></span>
- <span data-ttu-id="3a9a3-142">**避免遞迴**。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-142">**Avoid recursion**.</span></span> <span data-ttu-id="3a9a3-143">請注意，這些函數和處理常式實現了用於查找依賴項的載入規則。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-143">Be aware that these functions and handlers implement the loading rules for locating dependencies.</span></span> <span data-ttu-id="3a9a3-144">您的實現不應調用觸發遞迴的 API。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-144">Your implementation shouldn't call APIs that trigger recursion.</span></span> <span data-ttu-id="3a9a3-145">代碼通常應調用需要特定路徑或記憶體傳址參數的**AssemblyLoadCoNtext**載入函數。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-145">Your code should typically call **AssemblyLoadContext** load functions that require a specific path or memory reference argument.</span></span>
- <span data-ttu-id="3a9a3-146">**載入到正確的程式集載入上下文**。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-146">**Load into the correct AssemblyLoadContext**.</span></span> <span data-ttu-id="3a9a3-147">選擇載入依賴項的位置是特定于應用程式的。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-147">The choice of where to load dependencies is application-specific.</span></span>  <span data-ttu-id="3a9a3-148">選擇由這些事件和函數實現。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-148">The choice is implemented by these events and functions.</span></span> <span data-ttu-id="3a9a3-149">當代碼調用**AssemblyLoadCoNtext**逐路徑載入函數時，在您希望載入代碼的實例上調用它們。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-149">When your code calls **AssemblyLoadContext** load-by-path functions call them on the instance where you want the code loaded.</span></span> <span data-ttu-id="3a9a3-150">某個時候返回`null`並讓<xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>控制碼載入可能是最簡單的選項。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-150">Sometime returning `null` and letting the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> handle the load may be the simplest option.</span></span>
- <span data-ttu-id="3a9a3-151">**注意執行緒爭用**。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-151">**Be aware of thread races**.</span></span> <span data-ttu-id="3a9a3-152">載入可以由多個執行緒觸發。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-152">Loading can be triggered by multiple threads.</span></span> <span data-ttu-id="3a9a3-153">AssemblyLoadCoNtext 通過原子方式將程式集添加到其緩存來處理執行緒爭用。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-153">The AssemblyLoadContext handles thread races by atomically adding assemblies to its cache.</span></span> <span data-ttu-id="3a9a3-154">種族失敗者的實例被丟棄。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-154">The race loser's instance is discarded.</span></span> <span data-ttu-id="3a9a3-155">在實現邏輯中，不要添加無法正確處理多個執行緒的額外邏輯。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-155">In your implementation logic, don't add extra logic that doesn't handle multiple threads properly.</span></span>

## <a name="how-are-dynamic-dependencies-isolated"></a><span data-ttu-id="3a9a3-156">如何隔離動態依賴關係？</span><span class="sxs-lookup"><span data-stu-id="3a9a3-156">How are dynamic dependencies isolated?</span></span>

<span data-ttu-id="3a9a3-157">每個<xref:System.Runtime.Loader.AssemblyLoadContext>實例表示<xref:System.Reflection.Assembly>實例和<xref:System.Type>定義的唯一範圍。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-157">Each <xref:System.Runtime.Loader.AssemblyLoadContext> instance represents a unique scope for <xref:System.Reflection.Assembly> instances and <xref:System.Type> definitions.</span></span>

<span data-ttu-id="3a9a3-158">這些依賴項之間沒有二進位隔離。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-158">There's no binary isolation between these dependencies.</span></span> <span data-ttu-id="3a9a3-159">他們只是通過沒有按名字找到對方而孤立。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-159">They're only isolated by not finding each other by name.</span></span>

<span data-ttu-id="3a9a3-160">在每個<xref:System.Runtime.Loader.AssemblyLoadContext>：</span><span class="sxs-lookup"><span data-stu-id="3a9a3-160">In each <xref:System.Runtime.Loader.AssemblyLoadContext>:</span></span>

- <span data-ttu-id="3a9a3-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType>可以引用其他<xref:System.Reflection.Assembly>實例。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-161"><xref:System.Reflection.AssemblyName.Name?displayProperty=nameWithType> may refer to a different <xref:System.Reflection.Assembly> instance.</span></span>
- <span data-ttu-id="3a9a3-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType>可能為同一類型`name`返回不同類型的實例。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-162"><xref:System.Type.GetType%2A?displayProperty=nameWithType> may return a different type instance for the same type `name`.</span></span>

## <a name="how-are-dependencies-shared"></a><span data-ttu-id="3a9a3-163">如何共用依賴項？</span><span class="sxs-lookup"><span data-stu-id="3a9a3-163">How are dependencies shared?</span></span>

<span data-ttu-id="3a9a3-164">依賴項可以很容易地在實例之間<xref:System.Runtime.Loader.AssemblyLoadContext>共用。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-164">Dependencies can easily be shared between <xref:System.Runtime.Loader.AssemblyLoadContext> instances.</span></span> <span data-ttu-id="3a9a3-165">一般模型是一個<xref:System.Runtime.Loader.AssemblyLoadContext>載入依賴項。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-165">The general model is for one <xref:System.Runtime.Loader.AssemblyLoadContext> to load a dependency.</span></span>  <span data-ttu-id="3a9a3-166">另一個通過使用對載入的程式集的引用共用依賴項。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-166">The other shares the dependency by using a reference to the loaded assembly.</span></span>

<span data-ttu-id="3a9a3-167">運行時程式集需要此共用。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-167">This sharing is required of the runtime assemblies.</span></span> <span data-ttu-id="3a9a3-168">這些程式集只能載入到 中<xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-168">These assemblies can only be loaded into the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a9a3-169">對於 框架（如`ASP.NET`、`WPF`或`WinForms`）也是如此。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-169">The same is required for frameworks like `ASP.NET`, `WPF`, or `WinForms`.</span></span>

<span data-ttu-id="3a9a3-170">建議將共用依賴項載入到<xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>中。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-170">It's recommended that shared dependencies should be loaded into <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3a9a3-171">此共用是常見的設計模式。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-171">This sharing is the common design pattern.</span></span>

<span data-ttu-id="3a9a3-172">共用在自訂<xref:System.Runtime.Loader.AssemblyLoadContext>實例的編碼中實現。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-172">Sharing is implemented in the coding of the custom <xref:System.Runtime.Loader.AssemblyLoadContext> instance.</span></span> <span data-ttu-id="3a9a3-173"><xref:System.Runtime.Loader.AssemblyLoadContext>具有可以重寫的各種事件和虛擬函數。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-173"><xref:System.Runtime.Loader.AssemblyLoadContext> has various events and virtual functions that can be overridden.</span></span> <span data-ttu-id="3a9a3-174">當這些函數中的任何一個返回對在另一<xref:System.Reflection.Assembly>個<xref:System.Runtime.Loader.AssemblyLoadContext>實例中載入的實例的引用時<xref:System.Reflection.Assembly>，該實例將共用。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-174">When any of these functions return a reference to an <xref:System.Reflection.Assembly> instance that was loaded in another <xref:System.Runtime.Loader.AssemblyLoadContext> instance, the <xref:System.Reflection.Assembly> instance is shared.</span></span> <span data-ttu-id="3a9a3-175">標準負載演算法順從<xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>載入以簡化公共共用模式。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-175">The standard load algorithm defers to <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> for loading to simplify the common sharing pattern.</span></span>  <span data-ttu-id="3a9a3-176">請參閱[託管程式集載入演算法](loading-managed.md)。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-176">See [Managed assembly loading algorithm](loading-managed.md).</span></span>

## <a name="complications"></a><span data-ttu-id="3a9a3-177">複雜功能</span><span class="sxs-lookup"><span data-stu-id="3a9a3-177">Complications</span></span>

### <a name="type-conversion-issues"></a><span data-ttu-id="3a9a3-178">類型轉換問題</span><span class="sxs-lookup"><span data-stu-id="3a9a3-178">Type conversion issues</span></span>

<span data-ttu-id="3a9a3-179">當兩<xref:System.Runtime.Loader.AssemblyLoadContext>個實例包含具有相同`name`的類型定義時，它們不是同一類型。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-179">When two <xref:System.Runtime.Loader.AssemblyLoadContext> instances contain type definitions with the same `name`, they're not the same type.</span></span> <span data-ttu-id="3a9a3-180">它們是同一類型，只有當它們來自同一<xref:System.Reflection.Assembly>個實例時。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-180">They're the same type if and only if they come from the same <xref:System.Reflection.Assembly> instance.</span></span>

<span data-ttu-id="3a9a3-181">使問題複雜化的是，有關這些不匹配類型的異常消息可能會令人困惑。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-181">To complicate matters, exception messages about these mismatched types can be confusing.</span></span> <span data-ttu-id="3a9a3-182">這些類型在異常消息中由其簡單類型名稱引用。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-182">The types are referred to in the exception messages by their simple type names.</span></span> <span data-ttu-id="3a9a3-183">在這種情況下，常見的異常消息是這樣的形式：</span><span class="sxs-lookup"><span data-stu-id="3a9a3-183">The common exception message in this case would be of the form:</span></span>

> <span data-ttu-id="3a9a3-184">類型"隔離類型"的物件不能轉換為類型"隔離類型"。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-184">Object of type 'IsolatedType' cannot be converted to type 'IsolatedType'.</span></span>

### <a name="debugging-type-conversion-issues"></a><span data-ttu-id="3a9a3-185">調試類型轉換問題</span><span class="sxs-lookup"><span data-stu-id="3a9a3-185">Debugging type conversion issues</span></span>

<span data-ttu-id="3a9a3-186">給定一對不匹配的類型，還必須瞭解：</span><span class="sxs-lookup"><span data-stu-id="3a9a3-186">Given a pair of mismatched types it's important to also know:</span></span>

- <span data-ttu-id="3a9a3-187">每種類型的<xref:System.Type.Assembly?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="3a9a3-187">Each type's <xref:System.Type.Assembly?displayProperty=nameWithType></span></span>
- <span data-ttu-id="3a9a3-188">每個類型的<xref:System.Runtime.Loader.AssemblyLoadContext>的 ，可通過 函數<xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType>獲得。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-188">Each type's <xref:System.Runtime.Loader.AssemblyLoadContext>, which can be obtained via the <xref:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)?displayProperty=nameWithType> function.</span></span>

<span data-ttu-id="3a9a3-189">給定兩個`a`物件`b`和 ，在調試器中評估以下內容將很有説明：</span><span class="sxs-lookup"><span data-stu-id="3a9a3-189">Given two objects `a` and `b`, evaluating the following in the debugger will be helpful:</span></span>

```csharp
// In debugger look at each assembly's instance, Location, and FullName
a.GetType().Assembly
b.GetType().Assembly
// In debugger look at each AssemblyLoadContext's instance and name
System.Runtime.AssemblyLoadContext.GetLoadContext(a.GetType().Assembly)
System.Runtime.AssemblyLoadContext.GetLoadContext(b.GetType().Assembly)
```

### <a name="resolving-type-conversion-issues"></a><span data-ttu-id="3a9a3-190">解決類型轉換問題</span><span class="sxs-lookup"><span data-stu-id="3a9a3-190">Resolving type conversion issues</span></span>

<span data-ttu-id="3a9a3-191">有兩種設計模式可用於解決這些類型的轉換問題。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-191">There are two design patterns for solving these type conversion issues.</span></span>

1. <span data-ttu-id="3a9a3-192">使用公共共用類型。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-192">Use common shared types.</span></span> <span data-ttu-id="3a9a3-193">此共用類型可以是基元運行時類型，也可以涉及在共用組件中創建新的共用類型。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-193">This shared type can either be a primitive runtime type, or it can involve creating a new shared type in a shared assembly.</span></span>  <span data-ttu-id="3a9a3-194">通常，共用類型是在應用程式程式集中定義的[介面](../../csharp/language-reference/keywords/interface.md)。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-194">Often the shared type is an [interface](../../csharp/language-reference/keywords/interface.md) defined in an application assembly.</span></span> <span data-ttu-id="3a9a3-195">另請參閱：[如何共用依賴項？](#how-are-dependencies-shared)</span><span class="sxs-lookup"><span data-stu-id="3a9a3-195">See also: [How are dependencies shared?](#how-are-dependencies-shared).</span></span>

2. <span data-ttu-id="3a9a3-196">使用封送技術從一種類型轉換為另一種類型。</span><span class="sxs-lookup"><span data-stu-id="3a9a3-196">Use marshaling techniques to convert from one type to another.</span></span>
