---
title: 認識 XAML 節點資料流結構和概念
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: d6b2975b8e0338b121d00f5ec7f4ffb69d32ab6a
ms.sourcegitcommit: 093571de904fc7979e85ef3c048547d0accb1d8a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/06/2019
ms.locfileid: "70400741"
---
# <a name="understanding-xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="5ea97-102">認識 XAML 節點資料流結構和概念</span><span class="sxs-lookup"><span data-stu-id="5ea97-102">Understanding XAML Node Stream Structures and Concepts</span></span>

<span data-ttu-id="5ea97-103">XAML 讀取器和 XAML 寫入器在 .NET Framework XAML 服務中實作，根據 XAML 節點資料流的設計概念。</span><span class="sxs-lookup"><span data-stu-id="5ea97-103">XAML readers and XAML writers as implemented in .NET Framework XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="5ea97-104">XAML 節點資料流是一組 XAML 節點的概念化。</span><span class="sxs-lookup"><span data-stu-id="5ea97-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="5ea97-105">在此概念化中，XAML 處理器會逐步查核 XAML 中的節點關聯性結構，一次一個 XAML。</span><span class="sxs-lookup"><span data-stu-id="5ea97-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="5ea97-106">在任何時候，只能有一個目前的記錄或目前的位置存在於開啟的 XAML 節點資料流中，而應用程式開發介面的許多層面只會報告從該位置取得的資訊。</span><span class="sxs-lookup"><span data-stu-id="5ea97-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="5ea97-107">XAML 節點資料流中的目前節點可以描述成物件、成員或值。</span><span class="sxs-lookup"><span data-stu-id="5ea97-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="5ea97-108">若將 XAML 視為 XAML 節點資料流，XAML 讀取器可以與 XAML 寫入器進行通訊，並可讓程式在有關 XAML 的載入路徑或儲存路徑作業期間，檢視、變更 XAML 節點資料流的內容，或與其互動。</span><span class="sxs-lookup"><span data-stu-id="5ea97-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="5ea97-109">XAML 讀取器和寫入器應用程式開發介面的設計和 XAML 節點資料流概念，類似先前相關讀取器和寫入器的設計和概念，例如 [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] ，以及 <xref:System.Xml.XmlReader> 和 <xref:System.Xml.XmlWriter> 類別。</span><span class="sxs-lookup"><span data-stu-id="5ea97-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the [!INCLUDE[TLA#tla_xmldom](../../../includes/tlasharptla-xmldom-md.md)] and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="5ea97-110">本主題討論 XAML 節點資料流概念，並說明如何撰寫在 XAML 節點層級與 XAML 表示法互動的常式。</span><span class="sxs-lookup"><span data-stu-id="5ea97-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>

<a name="loading_into_a_xaml_reader"></a>

## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="5ea97-111">正在將 XAML 載入 XAML 讀取器</span><span class="sxs-lookup"><span data-stu-id="5ea97-111">Loading XAML into a XAML Reader</span></span>

<span data-ttu-id="5ea97-112">基底 <xref:System.Xaml.XamlReader> 類別不會宣告用來將初始 XAML 載入 XAML 讀取器中的特定技術。</span><span class="sxs-lookup"><span data-stu-id="5ea97-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="5ea97-113">反而是衍生的類別會宣告並實作載入技術，包括其用於 XAML 之輸入來源的一般特性和條件約束。</span><span class="sxs-lookup"><span data-stu-id="5ea97-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="5ea97-114">例如， <xref:System.Xaml.XamlObjectReader> 會讀取物件圖形，從代表根或基底之單一物件的輸入來源開始。</span><span class="sxs-lookup"><span data-stu-id="5ea97-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="5ea97-115">然後 <xref:System.Xaml.XamlObjectReader> 會從物件圖形產生 XAML 節點資料流。</span><span class="sxs-lookup"><span data-stu-id="5ea97-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>

<span data-ttu-id="5ea97-116">最著名的 .NET Framework XAML 服務定義 <xref:System.Xaml.XamlReader> 子類別是 <xref:System.Xaml.XamlXmlReader>。</span><span class="sxs-lookup"><span data-stu-id="5ea97-116">The most prominent .NET Framework XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="5ea97-117"><xref:System.Xaml.XamlXmlReader> 會載入初始的 XAML，其方法是直接透過資料流或檔案路徑，或間接透過相關的讀取器類別 (例如 <xref:System.IO.TextReader>)，來載入文字檔案。</span><span class="sxs-lookup"><span data-stu-id="5ea97-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="5ea97-118"><xref:System.Xaml.XamlReader> 載入之後，即可視為包含 XAML 輸入來源的全部內容。</span><span class="sxs-lookup"><span data-stu-id="5ea97-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="5ea97-119">不過，因為有設計 <xref:System.Xaml.XamlReader> 基底應用程式開發介面，所以讀取器是在與 XAML 的單一節點互動。</span><span class="sxs-lookup"><span data-stu-id="5ea97-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="5ea97-120">第一次載入時，您遇到的第一個節點會是 XAML 的根目錄及其開始物件。</span><span class="sxs-lookup"><span data-stu-id="5ea97-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>

### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="5ea97-121">XAML 節點資料流概念</span><span class="sxs-lookup"><span data-stu-id="5ea97-121">The XAML Node Stream Concept</span></span>

<span data-ttu-id="5ea97-122">如果您通常較為熟悉以 DOM、樹狀目錄象徵物或查詢式手法來存取 XML 架構的技術，下面的方法將有助於將 XAML 節點資料流概念化。</span><span class="sxs-lookup"><span data-stu-id="5ea97-122">If you are generally more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="5ea97-123">假設載入的 XAML 是 DOM 或樹狀結構，其中每個可能的節點都是全部展開，然後以線性方式呈現。</span><span class="sxs-lookup"><span data-stu-id="5ea97-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="5ea97-124">當您在節點中向前推進時，您可能會在 DOM 的相關層級中來回「進」、「出」，但 XAML 節點資料流不會明確地保留追蹤，因為這些層級概念與節點資料流無關。</span><span class="sxs-lookup"><span data-stu-id="5ea97-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="5ea97-125">節點資料流具有「目前」位置，但除非您自己已經將資料流的其他部分儲存成參考，否則，除了目前的節點位置以外，您將看不見節點資料流的所有其他層面。</span><span class="sxs-lookup"><span data-stu-id="5ea97-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>

<span data-ttu-id="5ea97-126">XAML 節點資料流概念有一個值得注意的優點，如果您通過了整個節點資料流，則可確定您已處理整個的 XAML 表示；不需要擔心用來處理資訊的查詢、DOM 作業或某些其他非線性方法遺漏了完整 XAML 表示的某些部分。</span><span class="sxs-lookup"><span data-stu-id="5ea97-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="5ea97-127">基於這個理由，XAML 節點資料流表示適合用來連接 XAML 讀取器和 XAML 寫入器，也適合用來提供一個系統，讓您可以在其中插入您自己處理序，以在 XAML 處理作業的讀取和寫入階段之間運作。</span><span class="sxs-lookup"><span data-stu-id="5ea97-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="5ea97-128">在許多情況下，相對於可能出現在原始程式文字、二進位或物件圖形中的排列方式，XAML 讀取器會將 XAML 節點資料流中的節點排列順序謹慎地最佳化，或是重新排列。</span><span class="sxs-lookup"><span data-stu-id="5ea97-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="5ea97-129">此行為是為了強制執行 XAML 處理架構，如此一來，XAML 寫入器就永遠不會在節點資料流中其必須「返回」的位置。</span><span class="sxs-lookup"><span data-stu-id="5ea97-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="5ea97-130">在理想的情況下，所有 XAML 寫入作業都應該能夠依據結構描述內容以及節點資料流的目前位置來運作。</span><span class="sxs-lookup"><span data-stu-id="5ea97-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>

<a name="a_basic_reading_node_loop"></a>

## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="5ea97-131">基本讀取節點迴圈</span><span class="sxs-lookup"><span data-stu-id="5ea97-131">A Basic Reading Node Loop</span></span>

<span data-ttu-id="5ea97-132">用來檢查 XAML 節點資料流的基本讀取節點迴圈包含下列概念。</span><span class="sxs-lookup"><span data-stu-id="5ea97-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="5ea97-133">基於本主題中討論的節點迴圈，假設您正在使用 <xref:System.Xaml.XamlXmlReader>來閱讀以文字為基礎、人類可讀的 XAML 檔案。</span><span class="sxs-lookup"><span data-stu-id="5ea97-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="5ea97-134">本節中的連結指向 <xref:System.Xaml.XamlXmlReader>所實作的特定 XAML 節點迴圈應用程式開發介面。</span><span class="sxs-lookup"><span data-stu-id="5ea97-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>

- <span data-ttu-id="5ea97-135">請確定您不是在 XAML 節點資料流結尾 (檢查 <xref:System.Xaml.XamlXmlReader.IsEof%2A>，或使用 <xref:System.Xaml.XamlXmlReader.Read%2A> 傳回值)。</span><span class="sxs-lookup"><span data-stu-id="5ea97-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="5ea97-136">如果您是在資料流結尾，那裡並沒有目前的節點，您應該要結束。</span><span class="sxs-lookup"><span data-stu-id="5ea97-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>

- <span data-ttu-id="5ea97-137">呼叫 <xref:System.Xaml.XamlXmlReader.NodeType%2A>，以檢查 XAML 節點資料流目前公開的節點類型為何。</span><span class="sxs-lookup"><span data-stu-id="5ea97-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>

- <span data-ttu-id="5ea97-138">如果您有直接連線的相關 XAML 物件寫入器，您通常會在這時候呼叫 <xref:System.Xaml.XamlWriter.WriteNode%2A> 。</span><span class="sxs-lookup"><span data-stu-id="5ea97-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>

- <span data-ttu-id="5ea97-139">根據被報告為目前節點或目前記錄的 <xref:System.Xaml.XamlNodeType> ，呼叫下列其中一項，以取得節點內容的相關資訊：</span><span class="sxs-lookup"><span data-stu-id="5ea97-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>

  - <span data-ttu-id="5ea97-140">針對 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 或 <xref:System.Xaml.XamlNodeType.StartMember> 的 <xref:System.Xaml.XamlNodeType.EndMember>，呼叫 <xref:System.Xaml.XamlXmlReader.Member%2A> ，以取得成員的 <xref:System.Xaml.XamlMember> 相關資訊。</span><span class="sxs-lookup"><span data-stu-id="5ea97-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="5ea97-141">請注意，成員可能是 <xref:System.Xaml.XamlDirective>，因此不一定會是上述物件的傳統類型定義成員。</span><span class="sxs-lookup"><span data-stu-id="5ea97-141">Note that the member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="5ea97-142">例如，套用至物件的 `x:Name` 似乎是 XAML 成員，其中 <xref:System.Xaml.XamlMember.IsDirective%2A> 為 true，而成員的 <xref:System.Xaml.XamlMember.Name%2A> 為 `Name`，還有其他屬性指出這個指示詞在 XAML 語言 XAML 命名空間之下。</span><span class="sxs-lookup"><span data-stu-id="5ea97-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>

  - <span data-ttu-id="5ea97-143">針對 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 或 <xref:System.Xaml.XamlNodeType.StartObject> 的 <xref:System.Xaml.XamlNodeType.EndObject>，呼叫 <xref:System.Xaml.XamlXmlReader.Type%2A> ，以取得物件的 <xref:System.Xaml.XamlType> 相關資訊。</span><span class="sxs-lookup"><span data-stu-id="5ea97-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>

  - <span data-ttu-id="5ea97-144">針對 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 的 <xref:System.Xaml.XamlNodeType.Value>，呼叫 <xref:System.Xaml.XamlXmlReader.Value%2A>。</span><span class="sxs-lookup"><span data-stu-id="5ea97-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="5ea97-145">唯有當節點對成員是某個值的最簡單運算式，或對物件是初始化文字時，該節點才會是一個值 (不過，您應該要注意類型轉換行為，本主題後續章節將會說明)。</span><span class="sxs-lookup"><span data-stu-id="5ea97-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>

  - <span data-ttu-id="5ea97-146">針對 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 的 <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>，呼叫 <xref:System.Xaml.XamlXmlReader.Namespace%2A> ，以取得命名空間節點的命名空間資訊。</span><span class="sxs-lookup"><span data-stu-id="5ea97-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>

- <span data-ttu-id="5ea97-147">呼叫 <xref:System.Xaml.XamlXmlReader.Read%2A> ，使 XAML 讀取器前進至 XAML 節點資料流中的下一個節點，然後再重複那些步驟。</span><span class="sxs-lookup"><span data-stu-id="5ea97-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>

<span data-ttu-id="5ea97-148">.NET Framework XAML 服務 XAML 讀取器提供的 XAML 節點資料流，永遠都會提供所有可能節點的完整、深層周遊。</span><span class="sxs-lookup"><span data-stu-id="5ea97-148">The XAML node stream provided by .NET Framework XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="5ea97-149">XAML 節點迴圈的一般流程控制技術，包括定義 `while (reader.Read())`內的主體，以及在節點迴圈中每個節點的 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 上切換。</span><span class="sxs-lookup"><span data-stu-id="5ea97-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>

<span data-ttu-id="5ea97-150">如果節點資料流位於檔案結尾，則目前節點為 null。</span><span class="sxs-lookup"><span data-stu-id="5ea97-150">If the node stream is at end of file, the current node is null.</span></span>

<span data-ttu-id="5ea97-151">使用讀取器和寫入器的最簡單迴圈，類似下列範例。</span><span class="sxs-lookup"><span data-stu-id="5ea97-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>

```csharp
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));
//where xamlStringToLoad is a string of well formed XAML
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);
while (xxr.Read()) {
  xow.WriteNode(xxr);
}
```

<span data-ttu-id="5ea97-152">這個載入路徑 XAML 節點迴圈的基本範例以透通方式連接 XAML 讀取器和 XAML 寫入器，所執行的動作和您使用 <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>來進行時並無不同。</span><span class="sxs-lookup"><span data-stu-id="5ea97-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="5ea97-153">但是這個基本結構到時會展開，以套用至您的讀取或寫入情節。</span><span class="sxs-lookup"><span data-stu-id="5ea97-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="5ea97-154">部分可能的情節如下：</span><span class="sxs-lookup"><span data-stu-id="5ea97-154">Some possible scenarios are as follows:</span></span>

- <span data-ttu-id="5ea97-155">在 <xref:System.Xaml.XamlXmlReader.NodeType%2A>上切換。</span><span class="sxs-lookup"><span data-stu-id="5ea97-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="5ea97-156">依據所讀取的節點類型，執行不同的動作。</span><span class="sxs-lookup"><span data-stu-id="5ea97-156">Perform different actions depending on which node type is being read.</span></span>

- <span data-ttu-id="5ea97-157">在所有案例中，都不要呼叫 <xref:System.Xaml.XamlWriter.WriteNode%2A> 。</span><span class="sxs-lookup"><span data-stu-id="5ea97-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="5ea97-158">只在某些 <xref:System.Xaml.XamlWriter.WriteNode%2A> 案例中，才呼叫 <xref:System.Xaml.XamlXmlReader.NodeType%2A> 。</span><span class="sxs-lookup"><span data-stu-id="5ea97-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>

- <span data-ttu-id="5ea97-159">特定節點類型內的邏輯，分析該節點的細節，並採取行動。</span><span class="sxs-lookup"><span data-stu-id="5ea97-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="5ea97-160">例如，您只能撰寫來自特定 XAML 命名空間的物件，然後卸除或延遲不是來自該 XAML 命名空間的任何物件。</span><span class="sxs-lookup"><span data-stu-id="5ea97-160">For example, you could write only objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="5ea97-161">或者，如果您的 XAML 系統不支援將任何 XAML 指示詞當做成員處理程序的一部分，您可以卸除或重新處理該 XAML 指示詞。</span><span class="sxs-lookup"><span data-stu-id="5ea97-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>

- <span data-ttu-id="5ea97-162">定義會覆寫 <xref:System.Xaml.XamlObjectWriter> 方法的自訂 `Write*` ，可能會執行略過 XAML 結構描述內容的類型對應。</span><span class="sxs-lookup"><span data-stu-id="5ea97-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>

- <span data-ttu-id="5ea97-163">建構 <xref:System.Xaml.XamlXmlReader> 來使用非預設 XAML 結構描述內容，以便讀取器和寫入器都能使用 XAML 行為中的自訂差異。</span><span class="sxs-lookup"><span data-stu-id="5ea97-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>

### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="5ea97-164">超越節點迴圈概念的 XAML 存取</span><span class="sxs-lookup"><span data-stu-id="5ea97-164">Accessing XAML Beyond the Node Loop Concept</span></span>

<span data-ttu-id="5ea97-165">除了 XAML 節點迴圈之外，還有其他處理 XAML 表示的可能方式。</span><span class="sxs-lookup"><span data-stu-id="5ea97-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="5ea97-166">例如，可能存在著可以讀取索引節點的 XAML 讀取器，或特別是直接以 `x:Name`、以 `x:Uid`或透過其他識別項存取節點的 XAML 讀取器。</span><span class="sxs-lookup"><span data-stu-id="5ea97-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="5ea97-167">.NET Framework XAML 服務沒有提供完整的實作，但會透過服務和支援類型來提供建議的模式。</span><span class="sxs-lookup"><span data-stu-id="5ea97-167">.NET Framework XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="5ea97-168">如需詳細資訊，請參閱 <xref:System.Xaml.IXamlIndexingReader> 與 <xref:System.Xaml.XamlNodeList>。</span><span class="sxs-lookup"><span data-stu-id="5ea97-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>

<a name="working_with_the_current_node"></a>

## <a name="working-with-the-current-node"></a><span data-ttu-id="5ea97-169">使用目前的節點</span><span class="sxs-lookup"><span data-stu-id="5ea97-169">Working with the Current Node</span></span>

<span data-ttu-id="5ea97-170">使用 XAML 節點迴圈的大部分情節不會只讀取節點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-170">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="5ea97-171">大部分情節都會處理目前的節點，並且一次一個，將每個節點傳遞至 <xref:System.Xaml.XamlWriter>的實作。</span><span class="sxs-lookup"><span data-stu-id="5ea97-171">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>

<span data-ttu-id="5ea97-172">一般載入路徑情節為 <xref:System.Xaml.XamlXmlReader> 產生 XAML 節點資料流；根據您的邏輯和 XAML 結構描述內容來處理 XAML 節點；將節點傳遞至 <xref:System.Xaml.XamlObjectWriter>。</span><span class="sxs-lookup"><span data-stu-id="5ea97-172">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="5ea97-173">然後您要將結果物件圖形整合至您的應用程式或架構中。</span><span class="sxs-lookup"><span data-stu-id="5ea97-173">You then integrate the resulting object graph into your application or framework.</span></span>

<span data-ttu-id="5ea97-174">一般儲存路徑情節為 <xref:System.Xaml.XamlObjectReader> 讀取物件圖形；處理個別 XAML 節點； <xref:System.Xaml.XamlXmlWriter> 將序列化結果輸出為 XAML 文字檔。</span><span class="sxs-lookup"><span data-stu-id="5ea97-174">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="5ea97-175">關鍵在於路徑和情節都是一次只能處理一個 XAML 節點，而 XAML 節點可以用 XAML 類型系統和 .Net Framework XAML 服務應用程式開發介面所定義的標準化方式來處理。</span><span class="sxs-lookup"><span data-stu-id="5ea97-175">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET Framework XAML Services APIs.</span></span>

### <a name="frames-and-scope"></a><span data-ttu-id="5ea97-176">框架和範圍</span><span class="sxs-lookup"><span data-stu-id="5ea97-176">Frames and Scope</span></span>

<span data-ttu-id="5ea97-177">XAML 節點迴圈會以線性方式處理 XAML 節點資料流。</span><span class="sxs-lookup"><span data-stu-id="5ea97-177">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="5ea97-178">節點資料流會周遊至物件中，以及包含其他物件的成員中等等。</span><span class="sxs-lookup"><span data-stu-id="5ea97-178">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="5ea97-179">實作框架和堆疊概念來追蹤 XAML 節點資料流內的範圍，通常會很有用。</span><span class="sxs-lookup"><span data-stu-id="5ea97-179">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="5ea97-180">特別是當您處於節點資料流中，並積極加以調整時，更是好用。</span><span class="sxs-lookup"><span data-stu-id="5ea97-180">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="5ea97-181">如果從 DOM 的觀點來看 XAML 節點結構，您實作為節點迴圈邏輯一部分的框架和堆疊支援，會隨著您深入該結構，計算 `StartObject` (或 `GetObject`) 和 `EndObject` 範圍。</span><span class="sxs-lookup"><span data-stu-id="5ea97-181">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>

<a name="traversing_and_entering_object_nodes"></a>

## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="5ea97-182">周遊及進入物件節點</span><span class="sxs-lookup"><span data-stu-id="5ea97-182">Traversing and Entering Object Nodes</span></span>

<span data-ttu-id="5ea97-183">當 XAML 讀取器開啟節點資料流時，其中的第一個節點，就是根物件的開始物件節點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-183">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="5ea97-184">根據定義，此物件一律為單一物件節點，沒有對等項目。</span><span class="sxs-lookup"><span data-stu-id="5ea97-184">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="5ea97-185">在任何真實世界的 XAML 範例中，根物件的定義為具有保存多個物件的一或多個屬性，而這些屬性具有成員節點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-185">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="5ea97-186">然後成員節點有一或多個物件節點，但也可能會在值節點中終止。</span><span class="sxs-lookup"><span data-stu-id="5ea97-186">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="5ea97-187">根物件通常會定義 XAML 名稱範圍，這些名稱範圍會藉由語法指派成 XAML 文字標記中的屬性，但會對應至 XAML 節點資料流表示中的 `Namescope` 節點類型。</span><span class="sxs-lookup"><span data-stu-id="5ea97-187">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>

<span data-ttu-id="5ea97-188">請考量下列 XAML 範例 (這是任意 XAML，不受 .NET Framework 中現有的類型支援)。</span><span class="sxs-lookup"><span data-stu-id="5ea97-188">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in the .NET Framework).</span></span> <span data-ttu-id="5ea97-189">假設在此物件模型中， `FavorCollection` 是 `List<T>` 的 `Favor`， `Balloon` 和 `NoiseMaker` 可指派給 `Favor`， `Balloon.Color` 屬性受 `Color` 物件支援 (方法類似 WPF 將色彩定義為已知的色彩名稱)，而 `Color` 支援屬性語法的類型轉換器。</span><span class="sxs-lookup"><span data-stu-id="5ea97-189">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>

|<span data-ttu-id="5ea97-190">XAML 標記</span><span class="sxs-lookup"><span data-stu-id="5ea97-190">XAML markup</span></span>|<span data-ttu-id="5ea97-191">產生的 XAML 節點資料流</span><span class="sxs-lookup"><span data-stu-id="5ea97-191">Resulting XAML node stream</span></span>|
|-----------------|--------------------------------|
|`<Party`|<span data-ttu-id="5ea97-192">`Namespace` 的 `Party`</span><span class="sxs-lookup"><span data-stu-id="5ea97-192">`Namespace` node for `Party`</span></span>|
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="5ea97-193">`StartObject` 的 `Party`</span><span class="sxs-lookup"><span data-stu-id="5ea97-193">`StartObject` node for `Party`</span></span>|
|`<Party.Favors>`|<span data-ttu-id="5ea97-194">`StartMember` 的 `Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="5ea97-194">`StartMember` node for `Party.Favors`</span></span>|
||<span data-ttu-id="5ea97-195">隱含`StartObject` 的 `FavorCollection`節點</span><span class="sxs-lookup"><span data-stu-id="5ea97-195">`StartObject` node for implicit `FavorCollection`</span></span>|
||<span data-ttu-id="5ea97-196">隱含`StartMember` 項目屬性的 `FavorCollection` 節點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-196">`StartMember` node for implicit `FavorCollection` items property.</span></span>|
|`<Balloon`|<span data-ttu-id="5ea97-197">`StartObject` 的 `Balloon`</span><span class="sxs-lookup"><span data-stu-id="5ea97-197">`StartObject` node for `Balloon`</span></span>|
|`Color="Red"`|<span data-ttu-id="5ea97-198">`StartMember` 的 `Color`</span><span class="sxs-lookup"><span data-stu-id="5ea97-198">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="5ea97-199">屬性值字串`Value` 的 `"Red"`節點</span><span class="sxs-lookup"><span data-stu-id="5ea97-199">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="5ea97-200">`EndMember` 的 `Color`</span><span class="sxs-lookup"><span data-stu-id="5ea97-200">`EndMember` for `Color`</span></span>|
|`HasHelium="True"`|<span data-ttu-id="5ea97-201">`StartMember` 的 `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="5ea97-201">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="5ea97-202">屬性值字串`Value` 的 `"True"`節點</span><span class="sxs-lookup"><span data-stu-id="5ea97-202">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="5ea97-203">`EndMember` 的 `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="5ea97-203">`EndMember` for `HasHelium`</span></span>|
|`>`|<span data-ttu-id="5ea97-204">`EndObject` 的 `Balloon`</span><span class="sxs-lookup"><span data-stu-id="5ea97-204">`EndObject` for `Balloon`</span></span>|
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="5ea97-205">`StartObject` 的 `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="5ea97-205">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="5ea97-206">`StartMember` 的 `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="5ea97-206">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="5ea97-207">初始值字串`Value` 的 `"Loudest"`節點</span><span class="sxs-lookup"><span data-stu-id="5ea97-207">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="5ea97-208">`EndMember` 的 `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="5ea97-208">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="5ea97-209">`EndObject` 的 `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="5ea97-209">`EndObject` for `NoiseMaker`</span></span>|
||<span data-ttu-id="5ea97-210">隱含`EndMember` 項目屬性的 `FavorCollection` 節點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-210">`EndMember` node for implicit `FavorCollection` items property.</span></span>|
||<span data-ttu-id="5ea97-211">隱含`EndObject` 的 `FavorCollection`節點</span><span class="sxs-lookup"><span data-stu-id="5ea97-211">`EndObject` node for implicit `FavorCollection`</span></span>|
|`</Party.Favors>`|<span data-ttu-id="5ea97-212">`EndMember` 的 `Favors`</span><span class="sxs-lookup"><span data-stu-id="5ea97-212">`EndMember` for `Favors`</span></span>|
|`</Party>`|<span data-ttu-id="5ea97-213">`EndObject` 的 `Party`</span><span class="sxs-lookup"><span data-stu-id="5ea97-213">`EndObject` for `Party`</span></span>|

<span data-ttu-id="5ea97-214">在 XAML 節點資料流中，您可以依賴下列行為：</span><span class="sxs-lookup"><span data-stu-id="5ea97-214">In the XAML node stream, you can rely on the following behavior:</span></span>

- <span data-ttu-id="5ea97-215">如果 `Namespace` 節點存在，會將它加入以 `StartObject` 宣告 XAML 命名空間之 `xmlns`前面的資料流。</span><span class="sxs-lookup"><span data-stu-id="5ea97-215">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="5ea97-216">再看一次包含 XAML 和範例節點資料流的上表。</span><span class="sxs-lookup"><span data-stu-id="5ea97-216">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="5ea97-217">注意 `StartObject` 和 `Namespace` 節點似乎調換的情形，以及其於文字標記中的宣告位置。</span><span class="sxs-lookup"><span data-stu-id="5ea97-217">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="5ea97-218">這是具有代表性的行為，其中命名空間節點一律出現在節點資料流中，套用該命名空間節點的節點前面。</span><span class="sxs-lookup"><span data-stu-id="5ea97-218">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="5ea97-219">這種設計的目的是，命名空間資訊對物件寫入器而言非常重要，在物件寫入器嘗試執行類型對應或者處理物件之前，必須先知道該資訊。</span><span class="sxs-lookup"><span data-stu-id="5ea97-219">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="5ea97-220">將 XAML 命名空間資訊放在資料流中其應用程式範圍的前面，要一律以其呈現的順序來處理節點資料流，就會比較容易。</span><span class="sxs-lookup"><span data-stu-id="5ea97-220">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>

- <span data-ttu-id="5ea97-221">基於上述考量，在真實世界的大部分標記案例中，從頭開始周遊節點時 (不是從根目錄的 `Namespace` )，您都會先讀取一或多個 `StartObject` 節點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-221">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>

- <span data-ttu-id="5ea97-222">`StartObject` 節點後面可以接 `StartMember`、 `Value`，或緊接著 `EndObject`。</span><span class="sxs-lookup"><span data-stu-id="5ea97-222">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="5ea97-223">它後面永遠不會緊接著另一個 `StartObject`。</span><span class="sxs-lookup"><span data-stu-id="5ea97-223">It is never followed immediately by another `StartObject`.</span></span>

- <span data-ttu-id="5ea97-224">`StartMember` 後面可以接 `StartObject`、 `Value`，或緊接著 `EndMember`。</span><span class="sxs-lookup"><span data-stu-id="5ea97-224">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="5ea97-225">如果成員中的值應該是來自父物件的現有值，而不是會具現化新值的 `GetObject`，則後面可以接 `StartObject` 。</span><span class="sxs-lookup"><span data-stu-id="5ea97-225">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="5ea97-226">它後面也可以接 `Namespace` 節點，這會套用到後續的 `StartObject`。</span><span class="sxs-lookup"><span data-stu-id="5ea97-226">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="5ea97-227">它後面永遠不會緊接著另一個 `StartMember`。</span><span class="sxs-lookup"><span data-stu-id="5ea97-227">It is never followed immediately by another `StartMember`.</span></span>

- <span data-ttu-id="5ea97-228">`Value` 節點代表該值本身；沒有 "EndValue"。</span><span class="sxs-lookup"><span data-stu-id="5ea97-228">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="5ea97-229">它後面只能接 `EndMember`。</span><span class="sxs-lookup"><span data-stu-id="5ea97-229">It can be followed only by an `EndMember`.</span></span>

  - <span data-ttu-id="5ea97-230">可能被建構使用之物件的 XAML 初始文字，不會產生「物件-值」結構。</span><span class="sxs-lookup"><span data-stu-id="5ea97-230">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="5ea97-231">而是會針對名為 `_Initialization` 的成員，建立專用成員節點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-231">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="5ea97-232">而該成員節點會包含初始值字串。</span><span class="sxs-lookup"><span data-stu-id="5ea97-232">and that member node contains the initialization value string.</span></span> <span data-ttu-id="5ea97-233">如果它存在的話， `_Initialization` 永遠是第一個 `StartMember`。</span><span class="sxs-lookup"><span data-stu-id="5ea97-233">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="5ea97-234">`_Initialization` 可能會限定在具有 XAML 語言的 XAML 名稱範圍的某些 XAML 服務表示中，以釐清 `_Initialization` 不支援類型中定義的屬性。</span><span class="sxs-lookup"><span data-stu-id="5ea97-234">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>

  - <span data-ttu-id="5ea97-235">「成員-值」組合代表該值的屬性設定。</span><span class="sxs-lookup"><span data-stu-id="5ea97-235">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="5ea97-236">可能最後會有值轉換器一起來處理這個值，而這個值是純文字字串。</span><span class="sxs-lookup"><span data-stu-id="5ea97-236">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="5ea97-237">不過，在 XAML 物件寫入器處理此節點資料流之前，不會評估這一點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-237">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="5ea97-238">XAML 物件寫入器擁有必要的 XAML 結構描述內容、類型系統對應，以及值轉換所需的其他支援。</span><span class="sxs-lookup"><span data-stu-id="5ea97-238">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>

- <span data-ttu-id="5ea97-239">`EndMember` 節點後面可以接著後續成員的 `StartMember` 節點，或是成員擁有者的 `EndObject` 節點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-239">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>

- <span data-ttu-id="5ea97-240">`EndObject` 節點後面可以接著 `EndMember` 節點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-240">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="5ea97-241">在集合的項目中，物件是對等的情況下，它後面可以接著 `StartObject` 節點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-241">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="5ea97-242">或者它後面可以接 `Namespace` 節點，這會套用到後續的 `StartObject`。</span><span class="sxs-lookup"><span data-stu-id="5ea97-242">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>

  - <span data-ttu-id="5ea97-243">針對關閉整個節點資料流這種特殊狀況，根目錄的 `EndObject` 的後面沒有接任何項目；讀取器現在是檔案結尾，而 <xref:System.Xaml.XamlReader.Read%2A> 會傳回 `false`。</span><span class="sxs-lookup"><span data-stu-id="5ea97-243">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>

<a name="value_converters_and_the_xaml_node_stream"></a>

## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="5ea97-244">值轉換器和 XAML 節點資料流</span><span class="sxs-lookup"><span data-stu-id="5ea97-244">Value Converters and the XAML Node Stream</span></span>

<span data-ttu-id="5ea97-245">值轉換器是下列項目的泛稱：標記延伸、類型轉換器 (包括值序列化程式)，或是透過 XAML 類型系統報告為值轉換器的另一個專用類別。</span><span class="sxs-lookup"><span data-stu-id="5ea97-245">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="5ea97-246">在 XAML 節點資料流中，類型轉換器的用法和標記延伸的用法有非常不同的表示方式。</span><span class="sxs-lookup"><span data-stu-id="5ea97-246">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>

### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="5ea97-247">XAML 節點資料流中的類型轉換器</span><span class="sxs-lookup"><span data-stu-id="5ea97-247">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="5ea97-248">最後會導致使用類型轉換器的屬性集，會在 XAML 節點資料流中報告為成員的值。</span><span class="sxs-lookup"><span data-stu-id="5ea97-248">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="5ea97-249">XAML 節點資料流不會嘗試產生類型轉換器執行個體物件，並將值傳遞給它。</span><span class="sxs-lookup"><span data-stu-id="5ea97-249">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="5ea97-250">使用類型轉換器的轉換實作時，需要叫用 XAML 結構描述內容，並將其用於類型對應。</span><span class="sxs-lookup"><span data-stu-id="5ea97-250">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="5ea97-251">即使是判斷應該使用哪一個類型轉換器類別來處理該值，都間接需要 XAML 結構描述內容。</span><span class="sxs-lookup"><span data-stu-id="5ea97-251">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="5ea97-252">當您使用預設 XAML 結構描述內容時，可從 XAML 類型系統取得該資訊。</span><span class="sxs-lookup"><span data-stu-id="5ea97-252">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="5ea97-253">如果您在連接至 XAML 寫入器之前，需要 XAML 節點資料流層級的類型轉換器類別資訊，您可以從所設定之成員的 <xref:System.Xaml.XamlMember> 資訊取得該資訊。</span><span class="sxs-lookup"><span data-stu-id="5ea97-253">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="5ea97-254">要不然，類型轉換器輸入應該會以純文字值，保留在 XAML 節點資料流中，直到執行完需要類型對應系統和 XAML 結構描述內容的其餘作業，例如 XAML 物件寫入器建立物件的作業。</span><span class="sxs-lookup"><span data-stu-id="5ea97-254">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>

<span data-ttu-id="5ea97-255">比方說，請考慮下列類別定義大綱及其 XAML 用法：</span><span class="sxs-lookup"><span data-stu-id="5ea97-255">For example, consider the following class definition outline and XAML usage for it:</span></span>

```csharp
public class BoardSizeConverter : TypeConverter {
  //converts from string to an int[2] by splitting on an "x" char
}
public class GameBoard {
  [TypeConverter(typeof(BoardSizeConverter))]
  public int[] BoardSize; //2x2 array, initialization not shown
}
```

```xaml
<GameBoard BoardSize="8x8"/>
```

<span data-ttu-id="5ea97-256">這種用法的 XAML 節點資料流文字表示，無法以下列方式表示：</span><span class="sxs-lookup"><span data-stu-id="5ea97-256">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>

<span data-ttu-id="5ea97-257">`StartObject` 搭配 <xref:System.Xaml.XamlType> 表示 `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="5ea97-257">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>

<span data-ttu-id="5ea97-258">`StartMember` 搭配 <xref:System.Xaml.XamlMember> 表示 `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="5ea97-258">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>

<span data-ttu-id="5ea97-259">`Value` 節點，包含文字字串 "`8x8`"</span><span class="sxs-lookup"><span data-stu-id="5ea97-259">`Value` node, with text string "`8x8`"</span></span>

<span data-ttu-id="5ea97-260">`EndMember` 符合 `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="5ea97-260">`EndMember` matches `BoardSize`</span></span>

<span data-ttu-id="5ea97-261">`EndObject` 符合 `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="5ea97-261">`EndObject` matches `GameBoard`</span></span>

<span data-ttu-id="5ea97-262">請注意，這個節點資料流中沒有類型轉換器執行個體。</span><span class="sxs-lookup"><span data-stu-id="5ea97-262">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="5ea97-263">但是您可以在 <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> 的 <xref:System.Xaml.XamlMember> 上呼叫 `BoardSize`，以取得類型轉換器資訊。</span><span class="sxs-lookup"><span data-stu-id="5ea97-263">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="5ea97-264">如果您有有效的 XAML 結構描述內容，您也可以從 <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>取得執行個體，以叫用轉換器方法。</span><span class="sxs-lookup"><span data-stu-id="5ea97-264">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>

### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="5ea97-265">XAML 節點資料流中的標記延伸</span><span class="sxs-lookup"><span data-stu-id="5ea97-265">Markup Extensions in the XAML Node Stream</span></span>

<span data-ttu-id="5ea97-266">標記延伸的使用會在 XAML 節點資料流中報告為成員中的物件節點，其中該物件代表標記延伸執行個體。</span><span class="sxs-lookup"><span data-stu-id="5ea97-266">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="5ea97-267">因此，在節點資料流表示中使用標記延伸，會比使用類型轉換器更明確地顯示，而且附帶更多資訊。</span><span class="sxs-lookup"><span data-stu-id="5ea97-267">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="5ea97-268"><xref:System.Xaml.XamlMember> 資訊不會告訴您有關標記延伸的任何資訊，因為該用法依情況而定，而且在每個可能的標記案例中各不相同；它不像使用類型轉換器的案例那樣是依每個類型或成員專用和隱含。</span><span class="sxs-lookup"><span data-stu-id="5ea97-268"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>

<span data-ttu-id="5ea97-269">即使是在 XAML 文字標記中，以屬性形式來使用標記延伸 (通常會這樣)，還是以標記延伸的節點資料流表示做為物件節點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-269">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="5ea97-270">使用明確物件項目表單的標記延伸用法會以相同的方式處理。</span><span class="sxs-lookup"><span data-stu-id="5ea97-270">Markup extension usages that used an explicit object element form are treated the same way.</span></span>

<span data-ttu-id="5ea97-271">在標記延伸物件節點中，可能會有該標記延伸的成員。</span><span class="sxs-lookup"><span data-stu-id="5ea97-271">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="5ea97-272">XAML 節點資料流表示會保留該標記延伸的使用，不論是位置參數用法或具有明確具名參數的用法。</span><span class="sxs-lookup"><span data-stu-id="5ea97-272">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>

<span data-ttu-id="5ea97-273">若為位置參數用法，XAML 節點資料流會包含 XAML 語言定義屬性 `_PositionalParameters` ，以記錄該用法。</span><span class="sxs-lookup"><span data-stu-id="5ea97-273">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="5ea97-274">這個屬性為泛型 <xref:System.Collections.Generic.List%601> ，具有 <xref:System.Object> 條件約束。</span><span class="sxs-lookup"><span data-stu-id="5ea97-274">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="5ea97-275">條件約束是物件，而不是字串，因為理論上位置參數用法可能會在其中包含巢狀標記延伸用法。</span><span class="sxs-lookup"><span data-stu-id="5ea97-275">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="5ea97-276">若要從該用法存取位置參數，您可以逐一查看清單，並將索引子用於個別清單值。</span><span class="sxs-lookup"><span data-stu-id="5ea97-276">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>

<span data-ttu-id="5ea97-277">若為具名參數用法，每個具名參數都會表示為節點資料流中該名稱的成員節點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-277">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="5ea97-278">成員值不一定是字串，因為可能會有巢狀標記延伸用法。</span><span class="sxs-lookup"><span data-stu-id="5ea97-278">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>

<span data-ttu-id="5ea97-279">尚未叫用來自標記延伸的`ProvideValue` 。</span><span class="sxs-lookup"><span data-stu-id="5ea97-279">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="5ea97-280">不過，如果您連接 XAML 讀取器和 XAML 寫入器，導致當您在節點資料流中檢查時，在標記延伸節點上叫用 `WriteEndObject` ，就會叫用它。</span><span class="sxs-lookup"><span data-stu-id="5ea97-280">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="5ea97-281">基於這個理由，您通常會需要有為了在載入路徑上形成物件圖形而使用的相同 XAML 結構描述內容。</span><span class="sxs-lookup"><span data-stu-id="5ea97-281">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="5ea97-282">否則，來自任何標記延伸的 `ProvideValue` 都可能在這裡擲回例外狀況，因為它沒有預期的服務可用。</span><span class="sxs-lookup"><span data-stu-id="5ea97-282">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>

<a name="xaml_and_xml_languagedefined_members_in_the_xaml_node_stream"></a>

## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="5ea97-283">XAML 節點資料流中的 XAML 和 XML 語言定義成員</span><span class="sxs-lookup"><span data-stu-id="5ea97-283">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>

<span data-ttu-id="5ea97-284">因為 XAML 讀取器的解譯和慣例，會將特定成員導入 XAML 節點資料流中，而不是透過明確的 <xref:System.Xaml.XamlMember> 查閱或建構。</span><span class="sxs-lookup"><span data-stu-id="5ea97-284">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="5ea97-285">這些成員通常是 XAML 指示詞。</span><span class="sxs-lookup"><span data-stu-id="5ea97-285">Often, these members are XAML directives.</span></span> <span data-ttu-id="5ea97-286">在某些情況下，它是讀取將指示詞導入 XAML 節點資料流中之 XAML 的動作。</span><span class="sxs-lookup"><span data-stu-id="5ea97-286">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="5ea97-287">換句話說，原始的輸入 XAML 文字並未明確指定 member 指示詞，但 XAML 讀取器會插入指示詞，以便滿足結構化 XAML 慣例，並在該資訊遺失之前，在 XAML 節點資料流程中報告資訊。</span><span class="sxs-lookup"><span data-stu-id="5ea97-287">In other words, the original input XAML text did not explicitly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>

<span data-ttu-id="5ea97-288">下列清單指出 XAML 讀取器應該要導入指示詞 XAML 成員節點的所有案例，以及如何在 .NET Framework XAML 服務實作中識別該成員節點。</span><span class="sxs-lookup"><span data-stu-id="5ea97-288">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in the .NET Framework XAML Services implementations.</span></span>

- <span data-ttu-id="5ea97-289">**物件節點的初始文字：** 這個成員節點的名稱是`_Initialization`，它代表 xaml 指示詞，而且它是在 xaml 語言 xaml 命名空間中定義的。</span><span class="sxs-lookup"><span data-stu-id="5ea97-289">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="5ea97-290">您可以從 <xref:System.Xaml.XamlLanguage.Initialization%2A>取得其靜態實體。</span><span class="sxs-lookup"><span data-stu-id="5ea97-290">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>

- <span data-ttu-id="5ea97-291">**標記延伸的位置參數：** 這個成員節點的名稱是`_PositionalParameters`，它是在 xaml 語言 xaml 命名空間中定義的。</span><span class="sxs-lookup"><span data-stu-id="5ea97-291">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="5ea97-292">它一律包含物件的泛型清單，每個物件都是位置參數，以 `,` 分隔符號字元預先分隔，和輸入 XAML 中所提供的一樣。</span><span class="sxs-lookup"><span data-stu-id="5ea97-292">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="5ea97-293">您可以從 <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>取得位置參數指示詞的靜態實體。</span><span class="sxs-lookup"><span data-stu-id="5ea97-293">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>

- <span data-ttu-id="5ea97-294">**未知的內容：** 這個成員節點的名稱是`_UnknownContent`。</span><span class="sxs-lookup"><span data-stu-id="5ea97-294">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="5ea97-295">嚴格來說，它是 <xref:System.Xaml.XamlDirective>，且其定義在 XAML 語言 XAML 命名空間中。</span><span class="sxs-lookup"><span data-stu-id="5ea97-295">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="5ea97-296">如果 XAML 物件項目包含來源 XAML 中的內容，但是在目前可用的 XAML 結構描述內容之下，無法判斷任何內容屬性，則會將這個指示詞當作 Sentinel 使用。</span><span class="sxs-lookup"><span data-stu-id="5ea97-296">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="5ea97-297">若要在 XAML 節點資料流中偵測此情況，您可以檢查是否有名為 `_UnknownContent`的成員。</span><span class="sxs-lookup"><span data-stu-id="5ea97-297">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="5ea97-298">如果在載入路徑 XAML 節點資料流中，沒有採取任何其他動作，當它遇到任何物件上的 <xref:System.Xaml.XamlObjectWriter> 成員，預設 `WriteEndObject` 就會在所嘗試的 `_UnknownContent` 上擲回。</span><span class="sxs-lookup"><span data-stu-id="5ea97-298">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="5ea97-299">預設 <xref:System.Xaml.XamlXmlWriter> 不會擲回，並且會將成員視為隱含。</span><span class="sxs-lookup"><span data-stu-id="5ea97-299">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="5ea97-300">您可以從 `_UnknownContent` 取得 <xref:System.Xaml.XamlLanguage.UnknownContent%2A>的靜態實體。</span><span class="sxs-lookup"><span data-stu-id="5ea97-300">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>

- <span data-ttu-id="5ea97-301">**集合的集合屬性：** 雖然用於 XAML 之集合類別的支援 CLR 類型，通常會有專用的命名屬性來保存集合專案，但是在支援類型解析之前，XAML 類型系統並不知道該屬性。</span><span class="sxs-lookup"><span data-stu-id="5ea97-301">**Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="5ea97-302">相反地，XAML 節點資料流會導入 `Items` 預留位置，做為集合 XAML 類型的成員。</span><span class="sxs-lookup"><span data-stu-id="5ea97-302">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="5ea97-303">在 .NET Framework XAML 服務實作中，這個指示詞/成員在節點資料流中的名稱為 `_Items`。</span><span class="sxs-lookup"><span data-stu-id="5ea97-303">In the .NET Framework XAML Services implementation the name of this directive / member in the node stream is `_Items`.</span></span> <span data-ttu-id="5ea97-304">這個指示詞的常數可以從 <xref:System.Xaml.XamlLanguage.Items%2A>取得。</span><span class="sxs-lookup"><span data-stu-id="5ea97-304">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>

    <span data-ttu-id="5ea97-305">請注意，XAML 節點資料流程可能會包含 Items 屬性，而這些專案不會根據支援型別解析和 XAML 架構內容來加以解析。</span><span class="sxs-lookup"><span data-stu-id="5ea97-305">Note that a XAML node stream might contain an Items property with items that turn out to not be parsable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="5ea97-306">例如，套用至物件的</span><span class="sxs-lookup"><span data-stu-id="5ea97-306">For example,</span></span>

- <span data-ttu-id="5ea97-307">**XML 定義的成員：** XML 定義`xml:base`的、 `lang` `base` `space`和成員會在 .NET Framework xaml 服務實作為中，報告為 xaml 指示詞，且名稱為、和。 `xml:space` `xml:lang`</span><span class="sxs-lookup"><span data-stu-id="5ea97-307">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in the .NET Framework XAML Services implementations.</span></span> <span data-ttu-id="5ea97-308">這些成員的命名空間是 XML 命名空間 `http://www.w3.org/XML/1998/namespace`。</span><span class="sxs-lookup"><span data-stu-id="5ea97-308">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="5ea97-309">您可以從 <xref:System.Xaml.XamlLanguage>取得每個成員的常數。</span><span class="sxs-lookup"><span data-stu-id="5ea97-309">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>

## <a name="node-order"></a><span data-ttu-id="5ea97-310">節點順序</span><span class="sxs-lookup"><span data-stu-id="5ea97-310">Node Order</span></span>

<span data-ttu-id="5ea97-311">在某些情況下， <xref:System.Xaml.XamlXmlReader> 會變更 XAML 節點資料流中的 XAML 節點順序，不同於在標記中檢視或當做 XML 處理時，所出現的節點順序。</span><span class="sxs-lookup"><span data-stu-id="5ea97-311">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="5ea97-312">這麼做是為了排列節點，讓 <xref:System.Xaml.XamlObjectWriter> 可以用僅限順向的方式來處理節點資料流。</span><span class="sxs-lookup"><span data-stu-id="5ea97-312">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="5ea97-313">在 .NET Framework XAML 服務中，XAML 讀取器會重新排列節點，而不會將這項工作留給 XAML 寫入器，如此可以讓節點資料流的 XAML 物件寫入器消費者獲得最佳化效能。</span><span class="sxs-lookup"><span data-stu-id="5ea97-313">In .NET Framework XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>

<span data-ttu-id="5ea97-314">某些指示詞的目的，是為了在從物件項目建立物件時，提供更多資訊。</span><span class="sxs-lookup"><span data-stu-id="5ea97-314">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="5ea97-315">這些指示詞為： `Initialization`、 `PositionalParameters`、 `TypeArguments`、 `FactoryMethod`、 `Arguments`。</span><span class="sxs-lookup"><span data-stu-id="5ea97-315">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="5ea97-316">.NET Framework XAML 服務 XAML 讀取器會嘗試將這些指示詞當做節點資料流中的第一個成員，接在物件的 `StartObject`後面，原因將會在下一節中說明。</span><span class="sxs-lookup"><span data-stu-id="5ea97-316">The .NET Framework XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>

### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="5ea97-317">XamlObjectWriter 行為和節點順序</span><span class="sxs-lookup"><span data-stu-id="5ea97-317">XamlObjectWriter Behavior and Node Order</span></span>

<span data-ttu-id="5ea97-318">`StartObject` 的 <xref:System.Xaml.XamlObjectWriter> 不一定是要 XAML 物件寫入器立即建構物件執行個體的信號。</span><span class="sxs-lookup"><span data-stu-id="5ea97-318">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="5ea97-319">XAML 包含數種語言功能，可讓您以額外的輸入來初始化物件，並不完全依賴叫用無參數的函式來產生初始物件，而且只會設定屬性。</span><span class="sxs-lookup"><span data-stu-id="5ea97-319">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a parameterless constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="5ea97-320">這些功能包括： <xref:System.Windows.Markup.XamlDeferLoadAttribute>、初始文字、 [x:TypeArguments](x-typearguments-directive.md)、標記延伸的位置參數、Factory 方法，以及相關聯的 [x:Arguments](x-arguments-directive.md) 節點 (XAML 2009)。</span><span class="sxs-lookup"><span data-stu-id="5ea97-320">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](x-typearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](x-arguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="5ea97-321">這些案例每個都會延遲實際的物件建構，而且因為節點資料流已重新排列，所以 XAML 物件寫入器可以依賴每當所遇到的開始成員不是特別用於該物件類型的建構指示詞時，就會實際建構執行個體的行為。</span><span class="sxs-lookup"><span data-stu-id="5ea97-321">Each of these cases delay the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>

### <a name="getobject"></a><span data-ttu-id="5ea97-322">GetObject</span><span class="sxs-lookup"><span data-stu-id="5ea97-322">GetObject</span></span>

<span data-ttu-id="5ea97-323">`GetObject` 表示 XAML 節點，其中，XAML 物件寫入器並不是要建構新的物件，而是應該要取得物件的包含屬性值。</span><span class="sxs-lookup"><span data-stu-id="5ea97-323">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="5ea97-324">在支援類型的物件模型中，當包含屬性是刻意唯讀時，在 XAML 節點資料流中遇到 `GetObject` 節點這種一般情況，會發生於集合物件或字典物件。</span><span class="sxs-lookup"><span data-stu-id="5ea97-324">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="5ea97-325">在此情節中，通常會由擁有者類型的初始化邏輯來建立及初始化集合或字典 (通常是空的)。</span><span class="sxs-lookup"><span data-stu-id="5ea97-325">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>

## <a name="see-also"></a><span data-ttu-id="5ea97-326">另請參閱</span><span class="sxs-lookup"><span data-stu-id="5ea97-326">See also</span></span>

- <xref:System.Xaml.XamlObjectReader>
- [<span data-ttu-id="5ea97-327">XAML Services</span><span class="sxs-lookup"><span data-stu-id="5ea97-327">XAML Services</span></span>](index.md)
- [<span data-ttu-id="5ea97-328">XAML 命名空間</span><span class="sxs-lookup"><span data-stu-id="5ea97-328">XAML Namespaces</span></span>](xaml-namespaces-for-net-framework-xaml-services.md)
