---
title: XAML 安全性考量
ms.date: 03/30/2017
helpviewer_keywords:
- security [XAML Services], .NET XAML services
- XAML security [XAML Services]
ms.assetid: 544296d4-f38e-4498-af49-c9f4dad28964
ms.openlocfilehash: ef47e7e370082a2050406710edcb62d0967df8ef
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/04/2018
ms.locfileid: "33562358"
---
# <a name="xaml-security-considerations"></a><span data-ttu-id="2c8b0-102">XAML 安全性考量</span><span class="sxs-lookup"><span data-stu-id="2c8b0-102">XAML Security Considerations</span></span>
<span data-ttu-id="2c8b0-103">本主題描述在應用程式中的安全性最佳作法，當您使用 XAML 和.NET Framework XAML 服務 API。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-103">This topic describes best practices for security in applications when you use XAML and .NET Framework XAML Services API.</span></span>  
  
## <a name="untrusted-xaml-in-applications"></a><span data-ttu-id="2c8b0-104">在應用程式中不受信任的 XAML</span><span class="sxs-lookup"><span data-stu-id="2c8b0-104">Untrusted XAML in Applications</span></span>  
 <span data-ttu-id="2c8b0-105">最常見的意義而言，不受信任的 XAML 是未特別包含您的應用程式或發出任何 XAML 來源。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-105">In the most general sense, untrusted XAML is any XAML source that your application did not specifically include or emit.</span></span>  
  
 <span data-ttu-id="2c8b0-106">編譯成或儲存為 XAML `resx`-類型受信任和簽署組件內的資源不是原本就是不受信任。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-106">XAML that is compiled into or stored as a `resx`-type resource within a trusted and signed assembly is not inherently untrusted.</span></span> <span data-ttu-id="2c8b0-107">如往常般信任整個組件中，您可以信任的 XAML。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-107">You can trust the XAML as much as you trust the assembly as a whole.</span></span> <span data-ttu-id="2c8b0-108">在大部分情況下，您才關心鬆散的 XAML，這是您從資料流或其他 I/O 載入 XAML 來源的信任層面。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-108">In most cases, you are only concerned with the trust aspects of loose XAML, which is a XAML source that you load from a stream or other I/O.</span></span> <span data-ttu-id="2c8b0-109">鬆散的 XAML 不是特定元件或功能的應用程式模型的部署與封裝基礎結構。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-109">Loose XAML is not a specific component or feature of an application model with a deployment and packaging infrastructure.</span></span> <span data-ttu-id="2c8b0-110">不過，組件可能會實作牽涉到載入鬆散 XAML 的行為。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-110">However, an assembly might implement a behavior that involves loading loose XAML.</span></span>  
  
 <span data-ttu-id="2c8b0-111">針對不受信任的 XAML，您應該將它視為通常相同它已不受信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-111">For untrusted XAML, you should treat it generally the same as if it were untrusted code.</span></span> <span data-ttu-id="2c8b0-112">若要防止存取您信任的程式碼可能不受信任的 XAML 使用沙箱或其他象徵物。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-112">Use sandboxing or other metaphors to prevent possibly untrusted XAML from accessing your trusted code.</span></span>  
  
 <span data-ttu-id="2c8b0-113">性質的 XAML 功能可讓 XAML 建構物件，並設定其屬性的權限。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-113">The nature of XAML capabilities gives the XAML the right to construct objects and set their properties.</span></span> <span data-ttu-id="2c8b0-114">這些功能也包括存取型別轉換子，對應及存取組件在應用程式網域中，使用標記延伸`x:Code`區塊，依此類推。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-114">These capabilities also include accessing type converters, mapping and accessing assemblies in the application domain, using markup extensions, `x:Code` blocks, and so on.</span></span>  
  
 <span data-ttu-id="2c8b0-115">除了其語言層級功能，XAML 用於 UI 定義許多技術中。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-115">In addition to its language-level capabilities, XAML is used for UI definition in many technologies.</span></span> <span data-ttu-id="2c8b0-116">載入未受信任的 XAML，可能表示載入惡意的詐騙 UI。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-116">Loading untrusted XAML might mean loading a malicious spoofing UI.</span></span>  
  
## <a name="sharing-context-between-readers-and-writers"></a><span data-ttu-id="2c8b0-117">共用讀取器與寫入器之間的內容</span><span class="sxs-lookup"><span data-stu-id="2c8b0-117">Sharing Context Between Readers and Writers</span></span>  
 <span data-ttu-id="2c8b0-118">.NET Framework XAML 服務 XAML 讀取器和 XAML 寫入器架構通常需要在共用的 XAML 寫入器，或共用的 XAML 結構描述內容的 XAML 讀取器。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-118">The .NET Framework XAML Services architecture for XAML readers and XAML writers often requires sharing a XAML reader to a XAML writer, or a shared XAML schema context.</span></span> <span data-ttu-id="2c8b0-119">共用的物件或內容可能需要當您要撰寫 XAML 節點迴圈邏輯，或提供自訂的儲存路徑。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-119">Sharing objects or contexts might be required if you are writing XAML node loop logic, or providing a custom save path.</span></span> <span data-ttu-id="2c8b0-120">您不應共用的 XAML 讀取器執行個體、 非預設 XAML 結構描述內容或設定受信任和未受信任的程式碼之間的 XAML 讀取器/寫入器類別。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-120">You should not share XAML reader instances, nondefault XAML schema context, or settings for XAML reader/writer classes between trusted and untrusted code.</span></span>  
  
 <span data-ttu-id="2c8b0-121">大部分的案例和牽涉到 XAML 物件寫入為以 CLR 為基礎的類型，支援的作業只可以使用的預設 XAML 結構描述內容。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-121">Most scenarios and operations involving XAML object writing for a CLR-based type backing can just use default XAML schema context.</span></span> <span data-ttu-id="2c8b0-122">預設 XAML 結構描述內容未明確包括可能會危及完全信任的設定。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-122">The default XAML schema context does not explicitly include settings that could compromise full trust.</span></span> <span data-ttu-id="2c8b0-123">因此，它可以安全地共用信任與不受信任的 XAML 讀取器/寫入器元件之間的內容。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-123">It is thus safe to share context between trusted and untrusted XAML reader/writer components.</span></span> <span data-ttu-id="2c8b0-124">不過，如果您這麼做時，它仍然是最佳做法是在不同保留這類的讀取器和寫入器<xref:System.AppDomain>範圍，其中特別預期/沙箱化部分信任。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-124">However, if you do this, it is still a best practice to keep such readers and writers in separate <xref:System.AppDomain> scopes, with one of them specifically intended/sandboxed for partial trust.</span></span>  
  
## <a name="xaml-namespaces-and-assembly-trust"></a><span data-ttu-id="2c8b0-125">XAML 命名空間和組件信任</span><span class="sxs-lookup"><span data-stu-id="2c8b0-125">XAML Namespaces and Assembly Trust</span></span>  
 <span data-ttu-id="2c8b0-126">基本不合格的語法和 XAML 如何解譯的組件的自訂 XAML 命名空間對應的定義不會區分受信任和未受信任組件載入至應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-126">The basic unqualified syntax and definition for how XAML interprets a custom XAML namespace mapping to an assembly does not distinguish between a trusted and untrusted assembly as loaded into the application domain.</span></span> <span data-ttu-id="2c8b0-127">因此，它技術上可能會偽造受信任組件的預期的 XAML 命名空間對應，並擷取宣告 XAML 來源的物件和屬性資訊的不受信任組件。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-127">Thus, it is technically possible for an untrusted assembly to spoof a trusted assembly's intended XAML namespace mapping and capture a XAML source's declared object and property information.</span></span> <span data-ttu-id="2c8b0-128">如果您有安全性需求，以避免這種情況，您預期的 XAML 命名空間對應應該可以使用下列技巧：</span><span class="sxs-lookup"><span data-stu-id="2c8b0-128">If you have security requirements to avoid this situation, your intended XAML namespace mapping should be made using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="2c8b0-129">使用應用程式的 XAML 所做的任何 XAML 命名空間對應中的強式名稱的完整組件名稱。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-129">Use a fully qualified assembly name with strong name in any XAML namespace mapping made by your application's XAML.</span></span>  
  
-   <span data-ttu-id="2c8b0-130">限制對應至一組固定的參考組件，建構特定的組件<xref:System.Xaml.XamlSchemaContext>XAML 讀取器和 XAML 物件寫入器。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-130">Restrict assembly mapping to a fixed set of reference assemblies, by constructing a specific <xref:System.Xaml.XamlSchemaContext> for your XAML readers and XAML object writers.</span></span> <span data-ttu-id="2c8b0-131">請參閱 <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.Reflection.Assembly%7D%29>。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-131">See <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.Reflection.Assembly%7D%29>.</span></span>  
  
## <a name="xaml-type-mapping-and-type-system-access"></a><span data-ttu-id="2c8b0-132">XAML 型別對應和類型系統存取</span><span class="sxs-lookup"><span data-stu-id="2c8b0-132">XAML Type Mapping and Type System Access</span></span>  
 <span data-ttu-id="2c8b0-133">XAML 支援它自己的型別系統，其中有許多方式等 CLR 實作基本的 CLR 型別系統的方式。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-133">XAML supports its own type system, which in many ways is a peer to how CLR implements the basic CLR type system.</span></span> <span data-ttu-id="2c8b0-134">不過，您會在此進行信任決策是根據其類型資訊的類型的類型感知的特定部分，您應該遵循在支援類型的 CLR 型別資訊。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-134">However, for certain aspects of type awareness where you are making trust decisions about a type based on its type information, you should defer to the type information in the CLR backing types.</span></span> <span data-ttu-id="2c8b0-135">這是因為某些特定 XAML 類型系統的報告功能會保持在開啟做為虛擬方法，因此，不完全控制原始的.NET Framework XAML 服務實作。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-135">This is because some of the specific reporting capabilities of the XAML type system are left open as virtual methods and are therefore, not fully under the control of the original .NET Framework XAML Services implementations.</span></span> <span data-ttu-id="2c8b0-136">這些擴充點存在，因為 XAML 類型系統可延伸，以符合 XAML 本身的擴充性和其可能的替代類型對應策略和預設 CLR 為基礎的實作及預設 XAML 結構描述內容。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-136">These extensibility points exist because the XAML type system is extensible, to match the extensibility of XAML itself and its possible alternative type-mapping strategies versus the default CLR-backed implementation and default XAML schema context.</span></span> <span data-ttu-id="2c8b0-137">如需詳細資訊，請參閱特定的備忘稿幾個屬性的<xref:System.Xaml.XamlType>和<xref:System.Xaml.XamlMember>。</span><span class="sxs-lookup"><span data-stu-id="2c8b0-137">For more information, see the specific notes on several of the properties of <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2c8b0-138">另請參閱</span><span class="sxs-lookup"><span data-stu-id="2c8b0-138">See Also</span></span>  
 <xref:System.Xaml.Permissions.XamlAccessLevel>
