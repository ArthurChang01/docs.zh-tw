---
title: XAML 安全性考量
ms.date: 03/30/2017
helpviewer_keywords:
- security [XAML Services], .NET XAML services
- XAML security [XAML Services]
ms.assetid: 544296d4-f38e-4498-af49-c9f4dad28964
ms.openlocfilehash: 124310497cc2a8e8a816ba90b2c68a16ed342ae6
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/22/2019
ms.locfileid: "59973439"
---
# <a name="xaml-security-considerations"></a><span data-ttu-id="5e482-102">XAML 安全性考量</span><span class="sxs-lookup"><span data-stu-id="5e482-102">XAML Security Considerations</span></span>
<span data-ttu-id="5e482-103">本主題描述在應用程式中的安全性最佳作法，當您使用 XAML 和.NET Framework XAML 服務 API。</span><span class="sxs-lookup"><span data-stu-id="5e482-103">This topic describes best practices for security in applications when you use XAML and .NET Framework XAML Services API.</span></span>  
  
## <a name="untrusted-xaml-in-applications"></a><span data-ttu-id="5e482-104">在應用程式中不受信任的 XAML</span><span class="sxs-lookup"><span data-stu-id="5e482-104">Untrusted XAML in Applications</span></span>  
 <span data-ttu-id="5e482-105">最常見的方面來說，不受信任的 XAML 是您的應用程式沒有不是明確地包含或發出任何 XAML 來源。</span><span class="sxs-lookup"><span data-stu-id="5e482-105">In the most general sense, untrusted XAML is any XAML source that your application did not specifically include or emit.</span></span>  
  
 <span data-ttu-id="5e482-106">編譯成或儲存為 XAML `resx`-信任和已簽署的組件中的型別資源不是原本就是不受信任。</span><span class="sxs-lookup"><span data-stu-id="5e482-106">XAML that is compiled into or stored as a `resx`-type resource within a trusted and signed assembly is not inherently untrusted.</span></span> <span data-ttu-id="5e482-107">如同您信任整個組件，您可以信任的 XAML。</span><span class="sxs-lookup"><span data-stu-id="5e482-107">You can trust the XAML as much as you trust the assembly as a whole.</span></span> <span data-ttu-id="5e482-108">在大部分情況下，您才關心鬆散的 XAML，這是您從資料流或其他 I/O 載入 XAML 來源的信任層面。</span><span class="sxs-lookup"><span data-stu-id="5e482-108">In most cases, you are only concerned with the trust aspects of loose XAML, which is a XAML source that you load from a stream or other I/O.</span></span> <span data-ttu-id="5e482-109">鬆散的 XAML 不是特定元件或功能的部署與封裝基礎結構的應用程式模型。</span><span class="sxs-lookup"><span data-stu-id="5e482-109">Loose XAML is not a specific component or feature of an application model with a deployment and packaging infrastructure.</span></span> <span data-ttu-id="5e482-110">不過，組件可能會實作包含載入鬆散 XAML 的行為。</span><span class="sxs-lookup"><span data-stu-id="5e482-110">However, an assembly might implement a behavior that involves loading loose XAML.</span></span>  
  
 <span data-ttu-id="5e482-111">針對未受信任的 XAML，您應該將它視為通常相同它已不受信任的程式碼。</span><span class="sxs-lookup"><span data-stu-id="5e482-111">For untrusted XAML, you should treat it generally the same as if it were untrusted code.</span></span> <span data-ttu-id="5e482-112">若要防止存取您信任的程式碼可能不受信任的 XAML 使用沙箱或其他的隱喻。</span><span class="sxs-lookup"><span data-stu-id="5e482-112">Use sandboxing or other metaphors to prevent possibly untrusted XAML from accessing your trusted code.</span></span>  
  
 <span data-ttu-id="5e482-113">XAML 功能的本質可讓 XAML 來建構物件，並設定其屬性。</span><span class="sxs-lookup"><span data-stu-id="5e482-113">The nature of XAML capabilities gives the XAML the right to construct objects and set their properties.</span></span> <span data-ttu-id="5e482-114">這些功能也包含存取型別轉換子，對應和存取組件在應用程式網域中，使用標記延伸`x:Code`區塊，依此類推。</span><span class="sxs-lookup"><span data-stu-id="5e482-114">These capabilities also include accessing type converters, mapping and accessing assemblies in the application domain, using markup extensions, `x:Code` blocks, and so on.</span></span>  
  
 <span data-ttu-id="5e482-115">除了其語言層級功能，XAML 用來在許多技術中的 UI 定義。</span><span class="sxs-lookup"><span data-stu-id="5e482-115">In addition to its language-level capabilities, XAML is used for UI definition in many technologies.</span></span> <span data-ttu-id="5e482-116">正在載入未受信任的 XAML，可能表示載入惡意的詐騙 UI。</span><span class="sxs-lookup"><span data-stu-id="5e482-116">Loading untrusted XAML might mean loading a malicious spoofing UI.</span></span>  
  
## <a name="sharing-context-between-readers-and-writers"></a><span data-ttu-id="5e482-117">共用讀取器和寫入器之間的內容</span><span class="sxs-lookup"><span data-stu-id="5e482-117">Sharing Context Between Readers and Writers</span></span>  
 <span data-ttu-id="5e482-118">XAML 讀取器和 XAML 寫入器的.NET Framework XAML 服務架構通常會需要共用是在 XAML 讀取器的 XAML 寫入器，或共用的 XAML 結構描述內容。</span><span class="sxs-lookup"><span data-stu-id="5e482-118">The .NET Framework XAML Services architecture for XAML readers and XAML writers often requires sharing a XAML reader to a XAML writer, or a shared XAML schema context.</span></span> <span data-ttu-id="5e482-119">共用的物件或內容可能是必要，如果您正在撰寫 XAML 節點迴圈邏輯，或提供自訂儲存路徑。</span><span class="sxs-lookup"><span data-stu-id="5e482-119">Sharing objects or contexts might be required if you are writing XAML node loop logic, or providing a custom save path.</span></span> <span data-ttu-id="5e482-120">您不應共用 XAML 讀取器執行個體、 非預設 XAML 結構描述內容或設定受信任和未受信任的程式碼之間的 XAML 讀取器/寫入器類別。</span><span class="sxs-lookup"><span data-stu-id="5e482-120">You should not share XAML reader instances, nondefault XAML schema context, or settings for XAML reader/writer classes between trusted and untrusted code.</span></span>  
  
 <span data-ttu-id="5e482-121">大部分的案例和涉及 XAML 物件寫入為以 CLR 為基礎的類型，支援的作業可以只使用預設 XAML 結構描述內容。</span><span class="sxs-lookup"><span data-stu-id="5e482-121">Most scenarios and operations involving XAML object writing for a CLR-based type backing can just use default XAML schema context.</span></span> <span data-ttu-id="5e482-122">預設 XAML 結構描述內容未明確包括可能會危害完全信任的設定。</span><span class="sxs-lookup"><span data-stu-id="5e482-122">The default XAML schema context does not explicitly include settings that could compromise full trust.</span></span> <span data-ttu-id="5e482-123">因此，它是安全地共用信任與不受信任的 XAML 讀取器/寫入器元件之間的內容。</span><span class="sxs-lookup"><span data-stu-id="5e482-123">It is thus safe to share context between trusted and untrusted XAML reader/writer components.</span></span> <span data-ttu-id="5e482-124">不過，如果您這麼做時，仍建議您保留在不同的這類的讀取器和寫入<xref:System.AppDomain>範圍，具有特別想要/沙箱化部分信任的其中一個。</span><span class="sxs-lookup"><span data-stu-id="5e482-124">However, if you do this, it is still a best practice to keep such readers and writers in separate <xref:System.AppDomain> scopes, with one of them specifically intended/sandboxed for partial trust.</span></span>  
  
## <a name="xaml-namespaces-and-assembly-trust"></a><span data-ttu-id="5e482-125">XAML 命名空間和組件的信任</span><span class="sxs-lookup"><span data-stu-id="5e482-125">XAML Namespaces and Assembly Trust</span></span>  
 <span data-ttu-id="5e482-126">基本不合格的語法與定義 XAML 如何解譯自訂的 XAML 命名空間對應至組件就不會區分之間受信任和未受信任的組件，以載入應用程式定義域中。</span><span class="sxs-lookup"><span data-stu-id="5e482-126">The basic unqualified syntax and definition for how XAML interprets a custom XAML namespace mapping to an assembly does not distinguish between a trusted and untrusted assembly as loaded into the application domain.</span></span> <span data-ttu-id="5e482-127">因此，就技術上來說可能不受信任的組件來證明其信任的組件的預定的 XAML 命名空間對應，並擷取 XAML 來源的宣告的物件和屬性資訊。</span><span class="sxs-lookup"><span data-stu-id="5e482-127">Thus, it is technically possible for an untrusted assembly to spoof a trusted assembly's intended XAML namespace mapping and capture a XAML source's declared object and property information.</span></span> <span data-ttu-id="5e482-128">如果您有安全性需求，以避免這種情況下，您想要的 XAML 命名空間對應應在使用其中一種下列技術：</span><span class="sxs-lookup"><span data-stu-id="5e482-128">If you have security requirements to avoid this situation, your intended XAML namespace mapping should be made using one of the following techniques:</span></span>  
  
-   <span data-ttu-id="5e482-129">使用您的應用程式的 XAML 所做的任何 XAML 命名空間對應中的強式名稱的完整組件名稱。</span><span class="sxs-lookup"><span data-stu-id="5e482-129">Use a fully qualified assembly name with strong name in any XAML namespace mapping made by your application's XAML.</span></span>  
  
-   <span data-ttu-id="5e482-130">限制對應至一組固定的參考組件，藉由建構特定的組件<xref:System.Xaml.XamlSchemaContext>您 XAML 讀取器和 XAML 物件寫入器。</span><span class="sxs-lookup"><span data-stu-id="5e482-130">Restrict assembly mapping to a fixed set of reference assemblies, by constructing a specific <xref:System.Xaml.XamlSchemaContext> for your XAML readers and XAML object writers.</span></span> <span data-ttu-id="5e482-131">請參閱 <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.Reflection.Assembly%7D%29>。</span><span class="sxs-lookup"><span data-stu-id="5e482-131">See <xref:System.Xaml.XamlSchemaContext.%23ctor%28System.Collections.Generic.IEnumerable%7BSystem.Reflection.Assembly%7D%29>.</span></span>  
  
## <a name="xaml-type-mapping-and-type-system-access"></a><span data-ttu-id="5e482-132">XAML 型別對應和型別系統的存取權</span><span class="sxs-lookup"><span data-stu-id="5e482-132">XAML Type Mapping and Type System Access</span></span>  
 <span data-ttu-id="5e482-133">XAML 支援它自己的型別系統，這在許多方面是 CLR 如何實作基本的 CLR 型別系統之對等。</span><span class="sxs-lookup"><span data-stu-id="5e482-133">XAML supports its own type system, which in many ways is a peer to how CLR implements the basic CLR type system.</span></span> <span data-ttu-id="5e482-134">不過，您會在其中進行信任決策，根據其類型資訊的型別相關的類型感知的特定部分，您應該延後至支援型別在 CLR 中的類型資訊。</span><span class="sxs-lookup"><span data-stu-id="5e482-134">However, for certain aspects of type awareness where you are making trust decisions about a type based on its type information, you should defer to the type information in the CLR backing types.</span></span> <span data-ttu-id="5e482-135">這是因為一些 XAML 類型系統的特定報告功能會保持在開啟為虛擬方法，因此，並不是完全在原始的.NET Framework XAML 服務實作的控制之下。</span><span class="sxs-lookup"><span data-stu-id="5e482-135">This is because some of the specific reporting capabilities of the XAML type system are left open as virtual methods and are therefore, not fully under the control of the original .NET Framework XAML Services implementations.</span></span> <span data-ttu-id="5e482-136">這些擴充點存在，因為 XAML 型別系統可延伸，以符合 XAML 本身的擴充性和其可能的替代類型對應策略與預設 XAML 結構描述內容與預設 CLR 為基礎的實作。</span><span class="sxs-lookup"><span data-stu-id="5e482-136">These extensibility points exist because the XAML type system is extensible, to match the extensibility of XAML itself and its possible alternative type-mapping strategies versus the default CLR-backed implementation and default XAML schema context.</span></span> <span data-ttu-id="5e482-137">詳細資訊，請參閱特定的附註，數個屬性上<xref:System.Xaml.XamlType>和<xref:System.Xaml.XamlMember>。</span><span class="sxs-lookup"><span data-stu-id="5e482-137">For more information, see the specific notes on several of the properties of <xref:System.Xaml.XamlType> and <xref:System.Xaml.XamlMember>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5e482-138">另請參閱</span><span class="sxs-lookup"><span data-stu-id="5e482-138">See also</span></span>

- <xref:System.Xaml.Permissions.XamlAccessLevel>
