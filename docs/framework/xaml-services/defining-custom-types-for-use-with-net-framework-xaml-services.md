---
title: 定義可搭配 .NET Framework XAML 服務使用的自訂類型
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: be9c0e26574a15279ce89af2c7862abaa8713360
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/18/2019
ms.locfileid: "59164433"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="dd4f2-102">定義可搭配 .NET Framework XAML 服務使用的自訂類型</span><span class="sxs-lookup"><span data-stu-id="dd4f2-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="dd4f2-103">當您定義了商務物件的自訂類型，或在特定架構上沒有相依性的類型時，但也有特定的 XAML，您可以遵循的最佳作法。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="dd4f2-104">如果您遵循這些作法時，.NET Framework XAML 服務及其 XAML 讀取器和 XAML 寫入器可以探索您類型的 XAML 特性，並提供適當的表示，使用 XAML 型別系統的 XAML 節點資料流中。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="dd4f2-105">本主題說明類型定義、 成員定義，以及 CLR 屬性的型別或成員的最佳作法。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="dd4f2-106">建構函式模式和 XAML 的類型定義</span><span class="sxs-lookup"><span data-stu-id="dd4f2-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="dd4f2-107">若要具現化為物件項目在 XAML 中，自訂類別必須符合下列需求：</span><span class="sxs-lookup"><span data-stu-id="dd4f2-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
-   <span data-ttu-id="dd4f2-108">自訂類別必須是公用，而且必須公開 （expose） 的預設 （無參數） 公用建構函式。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-108">The custom class must be public and must expose a default (parameterless) public constructor.</span></span> <span data-ttu-id="dd4f2-109">(如需結構相關附註，請參閱下節)。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-109">(See following section for notes regarding structures.)</span></span>  
  
-   <span data-ttu-id="dd4f2-110">自訂類別不能巢狀的類別。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="dd4f2-111">「 點 」 的完整名稱的路徑中的額外類別命名空間除法模稜兩可，並會干擾其他 XAML 功能，例如附加屬性。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="dd4f2-112">如果物件可以具現化為物件項目中，所建立的物件可以填入屬性項目表單的任何採用物件作為其基礎類型的屬性。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="dd4f2-113">您仍然可以提供物件的值類型不符合這些條件，如果您啟用的值轉換器。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="dd4f2-114">如需詳細資訊，請參閱 < [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="dd4f2-115">結構</span><span class="sxs-lookup"><span data-stu-id="dd4f2-115">Structures</span></span>  
 <span data-ttu-id="dd4f2-116">結構都可以建構在 XAML 中，CLR 定義。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="dd4f2-117">這是因為 CLR 編譯器隱含建立結構的預設建構函式。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-117">This is because a CLR compiler implicitly creates a default constructor for a structure.</span></span> <span data-ttu-id="dd4f2-118">這個建構函式會初始化為其預設值的所有屬性值。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="dd4f2-119">在某些情況下，您可能不想要的結構的預設建構行為。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="dd4f2-120">這可能是因為結構為了在概念上，為聯集填入值和函式。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="dd4f2-121">聯集，包含的值可能會有互斥解譯，並因此，其屬性都是可設定。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="dd4f2-122">舉例來說，這種結構中的 WPF 詞彙<xref:System.Windows.GridLength>。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="dd4f2-123">這類結構應該實作類型轉換器，可以使用建立的不同解譯或模式的結構值的字串慣例來以屬性形式表示的值。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="dd4f2-124">此結構也應該透過非預設建構函式進行程式碼建構來公開類似行為。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-124">The structure should also expose similar behavior for code construction through a non-default constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="dd4f2-125">介面</span><span class="sxs-lookup"><span data-stu-id="dd4f2-125">Interfaces</span></span>  
 <span data-ttu-id="dd4f2-126">介面可用來當做基礎類型的成員。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="dd4f2-127">XAML 類型系統會檢查指派的清單，並預期提供做為值的物件都可以指派給介面。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="dd4f2-128">沒有介面如何必須呈現為 XAML 型別，只要相關的可指派型別支援 XAML 建構需求的概念。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="dd4f2-129">Factory 方法</span><span class="sxs-lookup"><span data-stu-id="dd4f2-129">Factory Methods</span></span>  
 <span data-ttu-id="dd4f2-130">Factory 方法，是 XAML 2009 功能。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="dd4f2-131">它們修改的物件都必須有預設建構函式的 XAML 原則。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-131">They modify the XAML principle that objects must have default constructors.</span></span> <span data-ttu-id="dd4f2-132">本主題中未記載的 factory 方法。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="dd4f2-133">請參閱[X:factorymethod 指示詞](x-factorymethod-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-133">See [x:FactoryMethod Directive](x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="dd4f2-134">列舉</span><span class="sxs-lookup"><span data-stu-id="dd4f2-134">Enumerations</span></span>  
 <span data-ttu-id="dd4f2-135">列舉型別具有 XAML 原生型別轉換行為。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="dd4f2-136">在 XAML 中指定的列舉常數名稱對基礎的列舉型別，解決，而且傳回至 XAML 物件寫入器的列舉值。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="dd4f2-137">XAML 支援列舉型別與旗標式使用量<xref:System.FlagsAttribute>套用。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="dd4f2-138">如需詳細資訊，請參閱 < [XAML 語法詳細資料](../wpf/advanced/xaml-syntax-in-detail.md)。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-138">For more information, see [XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="dd4f2-139">([XAML 語法詳細資料](../wpf/advanced/xaml-syntax-in-detail.md)的撰寫對 WPF 的對象，但大部分的該主題中的資訊是關於並非專屬於特定的實作架構的 XAML。)</span><span class="sxs-lookup"><span data-stu-id="dd4f2-139">([XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="dd4f2-140">成員定義</span><span class="sxs-lookup"><span data-stu-id="dd4f2-140">Member Definitions</span></span>  
 <span data-ttu-id="dd4f2-141">類型可以定義 XAML 使用的成員。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="dd4f2-142">可以定義成員，即使該特定的型別不是使用 XAML 的 XAML 使用的類型。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="dd4f2-143">這可能是因為 CLR 繼承。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="dd4f2-144">只要繼承成員的型別支援 XAML 用法，做為類型，且該成員支援 XAML 用法，其基礎類型，或有可用的原生 XAML 語法，該成員是 XAML 可用。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="dd4f2-145">屬性</span><span class="sxs-lookup"><span data-stu-id="dd4f2-145">Properties</span></span>  
 <span data-ttu-id="dd4f2-146">如果您定義屬性為公用的 CLR 屬性，使用一般的 CLR`get`和`set`存取子模式和適當語言 keywording，XAML 類型系統可以報告提供包含適當資訊的成員為屬性<xref:System.Xaml.XamlMember>屬性，例如<xref:System.Xaml.XamlMember.IsReadPublic%2A>和<xref:System.Xaml.XamlMember.IsWritePublic%2A>。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="dd4f2-147">特定的屬性可以藉由套用可讓文字語法<xref:System.ComponentModel.TypeConverterAttribute>。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="dd4f2-148">如需詳細資訊，請參閱 < [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="dd4f2-149">沒有文字語法或原生 XAML 轉換，並進一步間接取值，例如標記延伸使用方式，屬性的型別不存在 (<xref:System.Xaml.XamlMember.TargetType%2A>中 XAML 類型系統) 必須能夠傳回給 XAML 物件寫入器的執行個體，藉由將 t為 CLR 型別 arget 型別。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="dd4f2-150">如果使用 XAML 2009 [X:reference 標記延伸](x-reference-markup-extension.md)可用來提供值，如果不符合先前的考量，不過，這是多個類型定義問題比使用問題。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-150">If using XAML 2009, [x:Reference Markup Extension](x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="dd4f2-151">事件</span><span class="sxs-lookup"><span data-stu-id="dd4f2-151">Events</span></span>  
 <span data-ttu-id="dd4f2-152">如果您定義為公用的 CLR 事件的事件，XAML 類型系統可以做為成員與報告事件<xref:System.Xaml.XamlMember.IsEvent%2A>做為`true`。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="dd4f2-153">傳入事件處理常式不是.NET Framework XAML 服務功能; 的範圍內這會保留給特定的架構和實作。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="dd4f2-154">方法</span><span class="sxs-lookup"><span data-stu-id="dd4f2-154">Methods</span></span>  
 <span data-ttu-id="dd4f2-155">方法的內嵌程式碼不是預設的 XAML 功能。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="dd4f2-156">在大部分情況下您不要直接參照方法成員的 XAML，和方法，在 XAML 中的角色只是為了特定 XAML 模式提供支援。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="dd4f2-157">[X:factorymethod 指示詞](x-factorymethod-directive.md)例外狀況。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-157">[x:FactoryMethod Directive](x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="dd4f2-158">欄位</span><span class="sxs-lookup"><span data-stu-id="dd4f2-158">Fields</span></span>  
 <span data-ttu-id="dd4f2-159">CLR 設計指導方針不鼓勵非靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="dd4f2-160">對於靜態欄位，您可以存取靜態欄位值只能透過[X:static 標記延伸](x-static-markup-extension.md); 在此情況下您在不進行任何 CLR 定義公開 （expose） 的欄位中的特殊[X:static](x-static-markup-extension.md)使用方式。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-160">For static fields, you can access static field values only through [x:Static Markup Extension](x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="dd4f2-161">可附加成員</span><span class="sxs-lookup"><span data-stu-id="dd4f2-161">Attachable Members</span></span>  
 <span data-ttu-id="dd4f2-162">可附加成員會公開至 XAML 中，透過定義的類型存取子方法模式。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="dd4f2-163">不需要定義的型別本身不會用作 XAML-物件。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="dd4f2-164">事實上，常見的模式是以宣告的服務類別，其角色為自己的可附加成員及實作相關的行為，但不提供任何其他功能，例如 UI 表示法。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="dd4f2-165">如下列章節中，將預留位置*PropertyName*代表您可附加成員的名稱。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="dd4f2-166">該名稱必須是有效[XamlName 文法](xamlname-grammar.md)。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="dd4f2-167">留意這些模式和類型的其他方法之間的名稱衝突。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="dd4f2-168">如果成員存在，並符合其中一個模式，它可以解譯為可附加成員用法路徑由 XAML 處理器即使這不是您的意圖。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="dd4f2-169">GetPropertyName 存取子</span><span class="sxs-lookup"><span data-stu-id="dd4f2-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="dd4f2-170">`Get`<屬性名稱> 存取子的簽章必須是︰</span><span class="sxs-lookup"><span data-stu-id="dd4f2-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="dd4f2-171">`public static object Get` <屬性名稱> `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="dd4f2-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="dd4f2-172">`target` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="dd4f2-173">您可以使用這個限定範圍的使用量，您可附加成員;您預期的範圍之外的使用方式，就會擲回無效轉換例外狀況，然後呈現由 XAML 剖析錯誤。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="dd4f2-174">參數名稱`target`並非必要，但名為`target`依照慣例，在大部分的實作。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
-   <span data-ttu-id="dd4f2-175">傳回值可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="dd4f2-176">若要支援<xref:System.ComponentModel.TypeConverter>套用的屬性使用方式的可附加成員，啟用的文字語法<xref:System.ComponentModel.TypeConverterAttribute>要`Get` *PropertyName*存取子。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="dd4f2-177">將套用至`get`而不是`set`似乎不被察覺; 不過，這個慣例可以支援這個概念的唯讀狀態可附加成員都是可序列化，這是在設計工具的情況下很有用。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="dd4f2-178">SetPropertyName 存取子</span><span class="sxs-lookup"><span data-stu-id="dd4f2-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="dd4f2-179">集合的簽章*PropertyName*存取子必須是：</span><span class="sxs-lookup"><span data-stu-id="dd4f2-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="dd4f2-180">`public static void Set` <屬性名稱> `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="dd4f2-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="dd4f2-181">`target`物件可以指定為在您實作中，使用相同的邏輯和結果的更特定類型，如上一節所述。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
-   <span data-ttu-id="dd4f2-182">`value` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="dd4f2-183">請記住，此方法的值來自 XAML 用法，通常是以屬性形式的輸入。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="dd4f2-184">從屬性形式必須是值轉換子支援文字語法中，而且您屬性`Get` *PropertyName*存取子。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="dd4f2-185">可附加成員存放區</span><span class="sxs-lookup"><span data-stu-id="dd4f2-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="dd4f2-186">存取子方法，還通常不足以提供可附加成員的值放入物件圖形，或以擷取物件圖形的值，並將其序列化到正確的方法。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="dd4f2-187">若要提供這項功能，`target`的上一個存取子的簽章中的物件必須能夠儲存的值。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="dd4f2-188">儲存機制應該與該成員是可附加至目標的可附加成員不在成員清單中的可附加成員原則一致。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="dd4f2-189">.NET framework XAML 服務提供的實作方法，針對可附加成員存放區透過 Api<xref:System.Xaml.IAttachedPropertyStore>和<xref:System.Xaml.AttachablePropertyServices>。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="dd4f2-190"><xref:System.Xaml.IAttachedPropertyStore> 可由 XAML 寫入器來探索存放區實作中，並應該是類型上實作`target`存取子。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="dd4f2-191">靜態<xref:System.Xaml.AttachablePropertyServices>Api 的存取子的主體內使用和的可附加成員是指其<xref:System.Xaml.AttachableMemberIdentifier>。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="dd4f2-192">XAML 相關 CLR 屬性</span><span class="sxs-lookup"><span data-stu-id="dd4f2-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="dd4f2-193">正確設定其屬性，您的型別、 成員和組件是以.NET Framework XAML 服務 XAML 類型系統資訊 報告的順序很重要。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="dd4f2-194">如果您想要您的型別，用於 XAML 系統直接根據.NET Framework XAML 服務 XAML 讀取器和 XAML 寫入器，或如果您要定義或使用這些 XAML 讀取器和 XAML 寫入器為基礎的 XAML 使用的架構，這是相關。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="dd4f2-195">如需相關的 XAML 支援，您的自訂類型的每個 XAML 相關屬性的清單，請參閱[XAML-Related CLR 屬性的自訂型別和程式庫](xaml-related-clr-attributes-for-custom-types-and-libraries.md)。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="dd4f2-196">使用量</span><span class="sxs-lookup"><span data-stu-id="dd4f2-196">Usage</span></span>  
 <span data-ttu-id="dd4f2-197">使用的自訂型別都需要標記作者必須對應包含自訂類型的組件和 CLR 命名空間的前置詞。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="dd4f2-198">本主題不會詳細說明此程序。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="dd4f2-199">存取層級</span><span class="sxs-lookup"><span data-stu-id="dd4f2-199">Access Level</span></span>  
 <span data-ttu-id="dd4f2-200">XAML 會提供一個方法來載入並具現化具有型別`internal`存取層級。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="dd4f2-201">這項功能被提供，讓使用者程式碼可以定義自己的類型，然後具現化這些類別也是相同的使用者程式碼範圍的一部分的標記。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="dd4f2-202">WPF 的範例是，每當使用者程式碼會定義<xref:System.Windows.Controls.UserControl>，用來重構 UI 行為，但不是可能會隱含宣告支援的類別與任何可能的延伸模組機制的一部分`public`存取層級。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="dd4f2-203">這類<xref:System.Windows.Controls.UserControl>可以使用宣告`internal`如果支援程式碼會編譯成相同的組件的參考為 XAML 型別存取。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="dd4f2-204">在完全信任下載入 XAML，並使用的應用程式<xref:System.Xaml.XamlObjectWriter>，載入類別`internal`一律啟用的存取層級。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="dd4f2-205">在部分信任環境中載入 XAML 的應用程式，您可以使用控制存取層級特性<xref:System.Xaml.Permissions.XamlAccessLevel>API。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="dd4f2-206">此外，延遲機制 （例如 WPF 範本系統） 必須要能夠傳播任何存取層級的權限，並保留供最終的執行的階段評估;這在內部處理傳遞<xref:System.Xaml.Permissions.XamlAccessLevel>資訊。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="dd4f2-207">WPF 實作</span><span class="sxs-lookup"><span data-stu-id="dd4f2-207">WPF Implementation</span></span>  
 <span data-ttu-id="dd4f2-208">WPF XAML 使用部分信任存取模型，如果 BAML 已載入在部分信任下，存取僅限於<xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A>BAML 來源組件。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="dd4f2-209">對於延遲，WPF 會使用<xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType>做為傳遞的存取層級資訊的機制。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="dd4f2-210">在 WPF XAML 術語*內部型別*是相同的組件也包含參考的 XAML 所定義的型別。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="dd4f2-211">這種類型可以對應 XAML 命名空間，刻意省略組件 = 部分的對應，比方說， `xmlns:local="clr-namespace:WPFApplication1"`。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="dd4f2-212">如果 BAML 參考內部的型別和型別具有`internal`存取層級，這會產生`GeneratedInternalTypeHelper`組件的類別。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="dd4f2-213">如果您想要避免`GeneratedInternalTypeHelper`，您必須使用`public`存取層級，或必須納入個別的組件相關的類別，並將該組件相依。</span><span class="sxs-lookup"><span data-stu-id="dd4f2-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="dd4f2-214">另請參閱</span><span class="sxs-lookup"><span data-stu-id="dd4f2-214">See also</span></span>

- [<span data-ttu-id="dd4f2-215">自訂類型和程式庫的 XAML 相關 CLR 屬性</span><span class="sxs-lookup"><span data-stu-id="dd4f2-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="dd4f2-216">XAML Services</span><span class="sxs-lookup"><span data-stu-id="dd4f2-216">XAML Services</span></span>](index.md)
