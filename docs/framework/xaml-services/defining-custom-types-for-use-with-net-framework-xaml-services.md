---
title: 定義可搭配 .NET Framework XAML 服務使用的自訂類型
ms.date: 03/30/2017
helpviewer_keywords:
- defining custom types [XAML Services]
ms.assetid: c2667cbd-2f46-4a7f-9dfc-53696e35e8e4
ms.openlocfilehash: 7437add6795c1bb7f8a59807ebfc51dc2d0f987f
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/12/2019
ms.locfileid: "73972013"
---
# <a name="defining-custom-types-for-use-with-net-framework-xaml-services"></a><span data-ttu-id="2780b-102">定義可搭配 .NET Framework XAML 服務使用的自訂類型</span><span class="sxs-lookup"><span data-stu-id="2780b-102">Defining Custom Types for Use with .NET Framework XAML Services</span></span>
<span data-ttu-id="2780b-103">當您定義的自訂類型為商務物件，或其類型與特定架構沒有相依性時，您可以遵循 XAML 的某些最佳作法。</span><span class="sxs-lookup"><span data-stu-id="2780b-103">When you define custom types that are business objects or are types that do not have a dependency on specific frameworks, there are certain best practices for XAML you can follow.</span></span> <span data-ttu-id="2780b-104">如果您遵循這些做法，.NET Framework XAML 服務及其 XAML 讀取器和 XAML 撰寫者可以探索型別的 XAML 特性，並使用 XAML 型別系統，在 XAML 節點資料流程中提供適當的標記法。</span><span class="sxs-lookup"><span data-stu-id="2780b-104">If you follow these practices, .NET Framework XAML Services and its XAML readers and XAML writers can discover the XAML characteristics of your type and give it appropriate representation in a XAML node stream using the XAML type system.</span></span> <span data-ttu-id="2780b-105">本主題描述類型定義、成員定義以及類型或成員之 CLR 的最大型別的最佳作法。</span><span class="sxs-lookup"><span data-stu-id="2780b-105">This topic describes best practices for type definitions, member definitions, and CLR attributing of types or members.</span></span>  
  
## <a name="constructor-patterns-and-type-definitions-for-xaml"></a><span data-ttu-id="2780b-106">XAML 的函數模式和類型定義</span><span class="sxs-lookup"><span data-stu-id="2780b-106">Constructor Patterns and Type Definitions for XAML</span></span>  
 <span data-ttu-id="2780b-107">若要在 XAML 中具現化為物件元素，自訂類別必須符合下列需求：</span><span class="sxs-lookup"><span data-stu-id="2780b-107">To be instantiated as an object element in XAML, a custom class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="2780b-108">自訂類別必須是公用的，而且必須公開無參數公用的函式。</span><span class="sxs-lookup"><span data-stu-id="2780b-108">The custom class must be public and must expose a parameterless public constructor.</span></span> <span data-ttu-id="2780b-109">(如需結構相關附註，請參閱下節)。</span><span class="sxs-lookup"><span data-stu-id="2780b-109">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="2780b-110">自訂類別不得為嵌套類別。</span><span class="sxs-lookup"><span data-stu-id="2780b-110">The custom class must not be a nested class.</span></span> <span data-ttu-id="2780b-111">在完整名稱路徑中的額外「點」會使類別命名空間相除不明確，並干擾其他 XAML 功能，例如附加屬性。</span><span class="sxs-lookup"><span data-stu-id="2780b-111">The extra "dot" in the full-name path makes the class-namespace division ambiguous, and interferes with other XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="2780b-112">如果物件可以具現化為物件專案，則所建立的物件可以填入任何屬性的屬性專案表單，這些屬性會將物件當做其基礎類型。</span><span class="sxs-lookup"><span data-stu-id="2780b-112">If an object can be instantiated as an object element, the created object can fill the property element form of any properties that take the object as their underlying type.</span></span>  
  
 <span data-ttu-id="2780b-113">如果您啟用值轉換器，仍然可以針對不符合這些準則的類型提供物件值。</span><span class="sxs-lookup"><span data-stu-id="2780b-113">You can still provide object values for types that do not meet these criteria, if you enable a value converter.</span></span> <span data-ttu-id="2780b-114">如需詳細資訊，請參閱[XAML 的類型轉換器和標記延伸](type-converters-and-markup-extensions-for-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="2780b-114">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
### <a name="structures"></a><span data-ttu-id="2780b-115">結構</span><span class="sxs-lookup"><span data-stu-id="2780b-115">Structures</span></span>  
 <span data-ttu-id="2780b-116">結構一律能夠在 XAML 中以 CLR 定義來進行構造。</span><span class="sxs-lookup"><span data-stu-id="2780b-116">Structures are always able to be constructed in XAML, by CLR definition.</span></span> <span data-ttu-id="2780b-117">這是因為 CLR 編譯器會隱含地建立結構的無參數的函式。</span><span class="sxs-lookup"><span data-stu-id="2780b-117">This is because a CLR compiler implicitly creates a parameterless constructor for a structure.</span></span> <span data-ttu-id="2780b-118">此函式會將所有屬性值初始化為其預設值。</span><span class="sxs-lookup"><span data-stu-id="2780b-118">This constructor initializes all property values to their defaults.</span></span>  
  
 <span data-ttu-id="2780b-119">在某些情況下，不需要結構的預設結構行為。</span><span class="sxs-lookup"><span data-stu-id="2780b-119">In some cases, the default construction behavior for a structure is not desirable.</span></span> <span data-ttu-id="2780b-120">這可能是因為結構是用來填滿值，並在概念上當做聯集來運作。</span><span class="sxs-lookup"><span data-stu-id="2780b-120">This might be because the structure is intended to fill values and function conceptually as a union.</span></span> <span data-ttu-id="2780b-121">做為聯集，包含的值可能會有互斥的解讀，因此無法設定其任何屬性。</span><span class="sxs-lookup"><span data-stu-id="2780b-121">As a union, the contained values might have mutually exclusive interpretations, and therefore, none of its properties are settable.</span></span> <span data-ttu-id="2780b-122">在 WPF 詞彙中，這類結構的範例是 <xref:System.Windows.GridLength>。</span><span class="sxs-lookup"><span data-stu-id="2780b-122">An example of such a structure in the WPF vocabulary is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="2780b-123">這類結構應該會執行類型轉換器，以便使用可建立結構值之不同解讀或模式的字串慣例，以屬性形式表示值。</span><span class="sxs-lookup"><span data-stu-id="2780b-123">Such structures should implement a type converter so that the values can be expressed in attribute form, by using string conventions that create the different interpretations or modes of the structure values.</span></span> <span data-ttu-id="2780b-124">結構也應該透過非無參數的函式來公開程式碼結構的類似行為。</span><span class="sxs-lookup"><span data-stu-id="2780b-124">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
### <a name="interfaces"></a><span data-ttu-id="2780b-125">介面</span><span class="sxs-lookup"><span data-stu-id="2780b-125">Interfaces</span></span>  
 <span data-ttu-id="2780b-126">介面可用來做為成員的基礎類型。</span><span class="sxs-lookup"><span data-stu-id="2780b-126">Interfaces can be used as underlying types of members.</span></span> <span data-ttu-id="2780b-127">XAML 型別系統會檢查可指派的清單，並預期當做值提供的物件可以指派給介面。</span><span class="sxs-lookup"><span data-stu-id="2780b-127">The XAML type system checks the assignable list and expects that the object that is provided as the value can be assigned to the interface.</span></span> <span data-ttu-id="2780b-128">只要相關的可指派型別支援 XAML 結構需求，就不能將介面呈現為 XAML 型別的概念。</span><span class="sxs-lookup"><span data-stu-id="2780b-128">There is no concept of how the interface must be presented as a XAML type as long as a relevant assignable type supports the XAML construction requirements.</span></span>  
  
### <a name="factory-methods"></a><span data-ttu-id="2780b-129">Factory 方法</span><span class="sxs-lookup"><span data-stu-id="2780b-129">Factory Methods</span></span>  
 <span data-ttu-id="2780b-130">Factory 方法是 XAML 2009 功能。</span><span class="sxs-lookup"><span data-stu-id="2780b-130">Factory methods are a XAML 2009 feature.</span></span> <span data-ttu-id="2780b-131">它們會修改物件必須具有無參數的構造函式的 XAML 原則。</span><span class="sxs-lookup"><span data-stu-id="2780b-131">They modify the XAML principle that objects must have parameterless constructors.</span></span> <span data-ttu-id="2780b-132">Factory 方法未記載于本主題中。</span><span class="sxs-lookup"><span data-stu-id="2780b-132">Factory methods are not documented in this topic.</span></span> <span data-ttu-id="2780b-133">請參閱[x:FactoryMethod](x-factorymethod-directive.md)指示詞。</span><span class="sxs-lookup"><span data-stu-id="2780b-133">See [x:FactoryMethod Directive](x-factorymethod-directive.md).</span></span>  
  
## <a name="enumerations"></a><span data-ttu-id="2780b-134">列舉</span><span class="sxs-lookup"><span data-stu-id="2780b-134">Enumerations</span></span>  
 <span data-ttu-id="2780b-135">列舉具有 XAML 原生類型轉換行為。</span><span class="sxs-lookup"><span data-stu-id="2780b-135">Enumerations have XAML native type conversion behavior.</span></span> <span data-ttu-id="2780b-136">XAML 中指定的列舉常數名稱會針對基礎列舉型別解析，並將列舉值傳回給 XAML 物件寫入器。</span><span class="sxs-lookup"><span data-stu-id="2780b-136">Enumeration constant names specified in XAML are resolved against the underlying enumeration type, and return the enumeration value to a XAML object writer.</span></span>  
  
 <span data-ttu-id="2780b-137">XAML 支援套用 <xref:System.FlagsAttribute> 之列舉的旗標樣式用法。</span><span class="sxs-lookup"><span data-stu-id="2780b-137">XAML supports a flags-style usage for enumerations with <xref:System.FlagsAttribute> applied.</span></span> <span data-ttu-id="2780b-138">如需詳細資訊，請參閱[XAML 語法詳細資料](../wpf/advanced/xaml-syntax-in-detail.md)。</span><span class="sxs-lookup"><span data-stu-id="2780b-138">For more information, see [XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md).</span></span> <span data-ttu-id="2780b-139">（[詳細說明 Xaml 語法](../wpf/advanced/xaml-syntax-in-detail.md)是針對 WPF 物件所撰寫，但該主題中的大部分資訊都與特定的執行架構無關的 xaml 有關）。</span><span class="sxs-lookup"><span data-stu-id="2780b-139">([XAML Syntax In Detail](../wpf/advanced/xaml-syntax-in-detail.md) is written for the WPF audience, but most of the information in that topic is relevant for XAML that is not specific to a particular implementing framework.)</span></span>  
  
## <a name="member-definitions"></a><span data-ttu-id="2780b-140">成員定義</span><span class="sxs-lookup"><span data-stu-id="2780b-140">Member Definitions</span></span>  
 <span data-ttu-id="2780b-141">類型可以定義 XAML 使用方式的成員。</span><span class="sxs-lookup"><span data-stu-id="2780b-141">Types can define members for XAML usage.</span></span> <span data-ttu-id="2780b-142">定義可使用 XAML 之成員的類型有可能，即使該特定類型不是 XAML 可用也一樣。</span><span class="sxs-lookup"><span data-stu-id="2780b-142">It is possible for types that define members that are XAML-usable even if that specific type is not XAML-usable.</span></span> <span data-ttu-id="2780b-143">這是可能的，因為 CLR 繼承。</span><span class="sxs-lookup"><span data-stu-id="2780b-143">This is possible because of CLR inheritance.</span></span> <span data-ttu-id="2780b-144">只要某些繼承成員的型別支援 XAML 使用方式做為型別，而且該成員支援其基礎型別的 XAML 用法，或有可用的原生 XAML 語法，該成員就能使用 XAML。</span><span class="sxs-lookup"><span data-stu-id="2780b-144">So long as some type that inherits the member supports XAML usage as a type, and the member supports XAML usage for its underlying type or has a native XAML syntax available, that member is XAML-usable.</span></span>  
  
### <a name="properties"></a><span data-ttu-id="2780b-145">內容</span><span class="sxs-lookup"><span data-stu-id="2780b-145">Properties</span></span>  
 <span data-ttu-id="2780b-146">如果您使用一般的 CLR `get` 將屬性定義為公用 CLR 屬性，並 `set` 存取子模式和語言適當的 keywording，則 XAML 類型系統可以使用提供給 <xref:System.Xaml.XamlMember> 屬性的適當資訊（例如 <xref:System.Xaml.XamlMember.IsReadPublic%2A> 和 <xref:System.Xaml.XamlMember.IsWritePublic%2A>），將屬性報告為成員。</span><span class="sxs-lookup"><span data-stu-id="2780b-146">If you define properties as a public CLR property using the typical CLR `get` and `set` accessor patterns and language-appropriate keywording, the XAML type system can report the property as a member with appropriate information provided for <xref:System.Xaml.XamlMember> properties, such as <xref:System.Xaml.XamlMember.IsReadPublic%2A> and <xref:System.Xaml.XamlMember.IsWritePublic%2A>.</span></span>  
  
 <span data-ttu-id="2780b-147">特定屬性可以藉由套用 <xref:System.ComponentModel.TypeConverterAttribute>來啟用文字語法。</span><span class="sxs-lookup"><span data-stu-id="2780b-147">Specific properties can enable a text syntax by applying <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="2780b-148">如需詳細資訊，請參閱[XAML 的類型轉換器和標記延伸](type-converters-and-markup-extensions-for-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="2780b-148">For more information, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions-for-xaml.md).</span></span>  
  
 <span data-ttu-id="2780b-149">如果沒有文字語法或原生 XAML 轉換，而且沒有進一步的間接取值（例如標記延伸使用方式），屬性的類型（在 XAML 類型系統中<xref:System.Xaml.XamlMember.TargetType%2A>）必須將目標型別視為 CLR 類型，才能將實例傳回 XAML 物件寫入器。</span><span class="sxs-lookup"><span data-stu-id="2780b-149">In the absence of a text syntax or native XAML conversion and in the absence of further indirection, such as a markup extension usage, the type of a property (<xref:System.Xaml.XamlMember.TargetType%2A> in the XAML type system) must be able to return an instance to a XAML object writer by treating the target type as a CLR type.</span></span>  
  
 <span data-ttu-id="2780b-150">如果使用 XAML 2009，如果不符合先前的考慮，則可以使用[X:Reference 標記延伸](x-reference-markup-extension.md)來提供值。不過，這比類型定義問題更有使用問題。</span><span class="sxs-lookup"><span data-stu-id="2780b-150">If using XAML 2009, [x:Reference Markup Extension](x-reference-markup-extension.md) can be used to provide values if the previous considerations are not met; however, that is more of a usage issue than a type definition issue.</span></span>  
  
### <a name="events"></a><span data-ttu-id="2780b-151">「事件」</span><span class="sxs-lookup"><span data-stu-id="2780b-151">Events</span></span>  
 <span data-ttu-id="2780b-152">如果您將事件定義為公用 CLR 事件，XAML 類型系統可以將附隨報告為成員，並將 <xref:System.Xaml.XamlMember.IsEvent%2A> 為 `true`。</span><span class="sxs-lookup"><span data-stu-id="2780b-152">If you define events as a public CLR event, the XAML type system can report the event as a member with <xref:System.Xaml.XamlMember.IsEvent%2A> as `true`.</span></span> <span data-ttu-id="2780b-153">連接事件處理常式不在 .NET Framework XAML 服務功能的範圍內;這會留給特定的架構和實現。</span><span class="sxs-lookup"><span data-stu-id="2780b-153">Wiring the event handlers is not within the scope of .NET Framework XAML Services capabilities; this is left to specific frameworks and implementations.</span></span>  
  
### <a name="methods"></a><span data-ttu-id="2780b-154">方法</span><span class="sxs-lookup"><span data-stu-id="2780b-154">Methods</span></span>  
 <span data-ttu-id="2780b-155">方法的內嵌程式碼不是預設的 XAML 功能。</span><span class="sxs-lookup"><span data-stu-id="2780b-155">Inline code for methods is not a default XAML capability.</span></span> <span data-ttu-id="2780b-156">在大部分情況下，您不會直接從 XAML 參考方法成員，而 XAML 中的方法角色只是為了提供特定 XAML 模式的支援。</span><span class="sxs-lookup"><span data-stu-id="2780b-156">In most cases you do not directly reference method members from XAML, and the role of methods in XAML is only to provide support for specific XAML patterns.</span></span> <span data-ttu-id="2780b-157">[x:FactoryMethod](x-factorymethod-directive.md)指示詞是例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2780b-157">[x:FactoryMethod Directive](x-factorymethod-directive.md) is an exception.</span></span>  
  
### <a name="fields"></a><span data-ttu-id="2780b-158">欄位</span><span class="sxs-lookup"><span data-stu-id="2780b-158">Fields</span></span>  
 <span data-ttu-id="2780b-159">CLR 設計方針不鼓勵非靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="2780b-159">CLR design guidelines discourage nonstatic fields.</span></span> <span data-ttu-id="2780b-160">對於靜態欄位，您只能透過[X:Static 標記延伸](x-static-markup-extension.md)來存取靜態域值。在此情況下，您不會在 CLR 定義中執行任何特殊動作，以公開[x:Static](x-static-markup-extension.md)使用方式的欄位。</span><span class="sxs-lookup"><span data-stu-id="2780b-160">For static fields, you can access static field values only through [x:Static Markup Extension](x-static-markup-extension.md); in this case you are not doing anything special in the CLR definition to expose a field for [x:Static](x-static-markup-extension.md) usages.</span></span>  
  
## <a name="attachable-members"></a><span data-ttu-id="2780b-161">可附加成員</span><span class="sxs-lookup"><span data-stu-id="2780b-161">Attachable Members</span></span>  
 <span data-ttu-id="2780b-162">可附加的成員會透過定義類型上的存取子方法模式，向 XAML 公開。</span><span class="sxs-lookup"><span data-stu-id="2780b-162">Attachable members are exposed to XAML through an accessor method pattern on a defining type.</span></span> <span data-ttu-id="2780b-163">定義類型本身不需要是 XAML 可用的物件。</span><span class="sxs-lookup"><span data-stu-id="2780b-163">The defining type itself does not need to be XAML-usable as an object.</span></span> <span data-ttu-id="2780b-164">事實上，常見的模式是宣告一個服務類別，其角色是要擁有可附加的成員並執行相關的行為，但不提供其他功能，例如 UI 標記法。</span><span class="sxs-lookup"><span data-stu-id="2780b-164">In fact, a common pattern is to declare a service class whose role is to own the attachable member and implement the related behaviors, but serve no other function such as a UI representation.</span></span> <span data-ttu-id="2780b-165">在下列各節中，預留位置*PropertyName*代表可附加成員的名稱。</span><span class="sxs-lookup"><span data-stu-id="2780b-165">For the following sections, the placeholder *PropertyName* represents the name of your attachable member.</span></span> <span data-ttu-id="2780b-166">該名稱在[XamlName 文法](xamlname-grammar.md)中必須是有效的。</span><span class="sxs-lookup"><span data-stu-id="2780b-166">That name must be valid in the [XamlName Grammar](xamlname-grammar.md).</span></span>  
  
 <span data-ttu-id="2780b-167">請注意這些模式和類型的其他方法之間的名稱衝突。</span><span class="sxs-lookup"><span data-stu-id="2780b-167">Be cautious of name collisions between these patterns and other methods of a type.</span></span> <span data-ttu-id="2780b-168">如果符合其中一種模式的成員存在，則即使不是您的意圖，也可以透過 XAML 處理器將它解讀為可附加的成員使用路徑。</span><span class="sxs-lookup"><span data-stu-id="2780b-168">If a member exists that matches one of the patterns, it can be interpreted as an attachable member usage pathway by a XAML processor even if that was not your intention.</span></span>  
  
#### <a name="the-getpropertyname-accessor"></a><span data-ttu-id="2780b-169">GetPropertyName 存取子</span><span class="sxs-lookup"><span data-stu-id="2780b-169">The GetPropertyName Accessor</span></span>  
 <span data-ttu-id="2780b-170">`Get`<屬性名稱> 存取子的簽章必須是︰</span><span class="sxs-lookup"><span data-stu-id="2780b-170">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="2780b-171">`public static object Get` <屬性名稱> `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="2780b-171">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
- <span data-ttu-id="2780b-172">`target` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="2780b-172">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="2780b-173">您可以使用此值來界定可附加成員的使用範圍;在您預期範圍外的使用方式將會擲回不正確轉換例外狀況，然後由 XAML 剖析錯誤呈現。</span><span class="sxs-lookup"><span data-stu-id="2780b-173">You can use this to scope the usage of your attachable member; usages outside your intended scope will throw invalid cast exceptions that are then surfaced by a XAML parse error.</span></span> <span data-ttu-id="2780b-174">參數名稱 `target` 不是必要條件，但在大部分的執行中會依照慣例來命名 `target`。</span><span class="sxs-lookup"><span data-stu-id="2780b-174">The parameter name `target` is not a requirement, but is named `target` by convention in most implementations.</span></span>  
  
- <span data-ttu-id="2780b-175">傳回值可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="2780b-175">The return value can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="2780b-176">若要支援可附加成員之屬性使用方式的 <xref:System.ComponentModel.TypeConverter> 啟用文字語法，請將 <xref:System.ComponentModel.TypeConverterAttribute> 套用至 `Get`*PropertyName*存取子。</span><span class="sxs-lookup"><span data-stu-id="2780b-176">To support a <xref:System.ComponentModel.TypeConverter> enabled text syntax for attribute usage of the attachable member, apply <xref:System.ComponentModel.TypeConverterAttribute> to the `Get`*PropertyName* accessor.</span></span> <span data-ttu-id="2780b-177">套用至 `get`，而不是 `set`，可能看起來 nonintuitive;不過，此慣例可以支援可序列化之唯讀可附加成員的概念，這在設計工具案例中很有用。</span><span class="sxs-lookup"><span data-stu-id="2780b-177">Applying to the `get` instead of the `set` may seem nonintuitive; however, this convention can support the concept of read-only attachable members that are serializable, which is useful in designer scenarios.</span></span>  
  
#### <a name="the-setpropertyname-accessor"></a><span data-ttu-id="2780b-178">SetPropertyName 存取子</span><span class="sxs-lookup"><span data-stu-id="2780b-178">The SetPropertyName Accessor</span></span>  
 <span data-ttu-id="2780b-179">Set*PropertyName*存取子的簽章必須是：</span><span class="sxs-lookup"><span data-stu-id="2780b-179">The signature for the Set*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="2780b-180">`public static void Set` <屬性名稱> `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="2780b-180">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
- <span data-ttu-id="2780b-181">在您的執行中，可以將 `target` 物件指定為更特定的類型，且具有與上一節中所述相同的邏輯和結果。</span><span class="sxs-lookup"><span data-stu-id="2780b-181">The `target` object can be specified as a more specific type in your implementation, with same logic and consequences as described in the previous section.</span></span>  
  
- <span data-ttu-id="2780b-182">`value` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="2780b-182">The `value` object can be specified as a more specific type in your implementation.</span></span>  
  
 <span data-ttu-id="2780b-183">請記住，這個方法的值是來自 XAML 用法的輸入，通常是以屬性形式呈現。</span><span class="sxs-lookup"><span data-stu-id="2780b-183">Remember that the value for this method is the input coming from the XAML usage, typically in attribute form.</span></span> <span data-ttu-id="2780b-184">在屬性形式中，文字語法必須有值轉換器支援，而您可以在 `Get`*PropertyName*存取子上使用屬性。</span><span class="sxs-lookup"><span data-stu-id="2780b-184">From attribute form there must be value converter support for a text syntax, and you attribute on the `Get`*PropertyName* accessor.</span></span>  
  
### <a name="attachable-member-stores"></a><span data-ttu-id="2780b-185">可附加的成員存放區</span><span class="sxs-lookup"><span data-stu-id="2780b-185">Attachable Member Stores</span></span>  
 <span data-ttu-id="2780b-186">存取子方法通常不足以提供將可附加的成員值放入物件圖形的方法，或是從物件圖形抓取值並正確地加以序列化。</span><span class="sxs-lookup"><span data-stu-id="2780b-186">The accessor methods are typically not enough to provide a means to place attachable member values into an object graph, or to retrieve values out of the object graph and serialize them properly.</span></span> <span data-ttu-id="2780b-187">為了提供這項功能，先前存取子簽章中的 `target` 物件必須能夠儲存值。</span><span class="sxs-lookup"><span data-stu-id="2780b-187">To provide this functionality, the `target` objects in the previous accessor signatures must be capable of storing values.</span></span> <span data-ttu-id="2780b-188">儲存機制應該與可附加的成員（可附加的成員不在成員清單中的目標）保持一致。</span><span class="sxs-lookup"><span data-stu-id="2780b-188">The storage mechanism should be consistent with the attachable member principle that the member is attachable to targets where the attachable member is not in the members list.</span></span> <span data-ttu-id="2780b-189">.NET Framework XAML 服務會透過 Api <xref:System.Xaml.IAttachedPropertyStore> 和 <xref:System.Xaml.AttachablePropertyServices>，提供可附加成員存放區的執行技術。</span><span class="sxs-lookup"><span data-stu-id="2780b-189">.NET Framework XAML Services provides an implementation technique for attachable member stores through the APIs <xref:System.Xaml.IAttachedPropertyStore> and <xref:System.Xaml.AttachablePropertyServices>.</span></span> <span data-ttu-id="2780b-190">XAML 寫入器會使用 <xref:System.Xaml.IAttachedPropertyStore> 來探索存放區的執行，而且應該在做為存取子之 `target` 的類型上執行。</span><span class="sxs-lookup"><span data-stu-id="2780b-190"><xref:System.Xaml.IAttachedPropertyStore> is used by the XAML writers to discover the store implementation, and should be implemented on the type that is the `target` of the accessors.</span></span> <span data-ttu-id="2780b-191">靜態 <xref:System.Xaml.AttachablePropertyServices> Api 會在存取子的主體內使用，並依其 <xref:System.Xaml.AttachableMemberIdentifier>參考可附加成員。</span><span class="sxs-lookup"><span data-stu-id="2780b-191">The static <xref:System.Xaml.AttachablePropertyServices> APIs are used within the body of the accessors, and refer to the attachable member by its <xref:System.Xaml.AttachableMemberIdentifier>.</span></span>  
  
## <a name="xaml-related-clr-attributes"></a><span data-ttu-id="2780b-192">XAML 相關的 CLR 屬性</span><span class="sxs-lookup"><span data-stu-id="2780b-192">XAML-Related CLR Attributes</span></span>  
 <span data-ttu-id="2780b-193">將 XAML 類型系統資訊報告為 .NET Framework XAML 服務時，正確地將類型、成員和元件的特性化會很重要。</span><span class="sxs-lookup"><span data-stu-id="2780b-193">Correctly attributing your types, members, and assemblies is important in order to report XAML type system information to .NET Framework XAML Services.</span></span> <span data-ttu-id="2780b-194">如果您想要讓型別與直接以 .NET Framework XAML 服務 XAML 讀取器和 XAML 寫入器為基礎的 XAML 系統搭配使用，或如果您定義或使用以 xaml 讀取器和 XAML 寫入器為基礎的 xaml 型架構，這就是相關的。</span><span class="sxs-lookup"><span data-stu-id="2780b-194">This is relevant if you intend your types for use with XAML systems that are directly based on .NET Framework XAML Services XAML readers and XAML writers, or if you define or use a XAML-utilizing framework that is based on those XAML readers and XAML writers.</span></span>  
  
 <span data-ttu-id="2780b-195">如需與自訂類型的 XAML 支援相關之每個 XAML 相關屬性的清單，請參閱[自訂類型和程式庫的 Xaml 相關 CLR 屬性](xaml-related-clr-attributes-for-custom-types-and-libraries.md)。</span><span class="sxs-lookup"><span data-stu-id="2780b-195">For a listing of each XAML-related attribute that is relevant for XAML support of your custom types, see [XAML-Related CLR Attributes for Custom Types and Libraries](xaml-related-clr-attributes-for-custom-types-and-libraries.md).</span></span>  
  
## <a name="usage"></a><span data-ttu-id="2780b-196">使用量</span><span class="sxs-lookup"><span data-stu-id="2780b-196">Usage</span></span>  
 <span data-ttu-id="2780b-197">使用自訂類型時，標記作者必須對應包含自訂類型之元件與 CLR 命名空間的前置詞。</span><span class="sxs-lookup"><span data-stu-id="2780b-197">Usage of custom types requires that the markup author must map a prefix for the assembly and CLR namespace that contain the custom type.</span></span> <span data-ttu-id="2780b-198">本主題未記載此程式。</span><span class="sxs-lookup"><span data-stu-id="2780b-198">This procedure is not documented in this topic.</span></span>  
  
## <a name="access-level"></a><span data-ttu-id="2780b-199">存取層級</span><span class="sxs-lookup"><span data-stu-id="2780b-199">Access Level</span></span>  
 <span data-ttu-id="2780b-200">XAML 提供載入及具現化具有 `internal` 存取層級之類型的方法。</span><span class="sxs-lookup"><span data-stu-id="2780b-200">XAML provides a means to load and instantiate types that have an `internal` access level.</span></span> <span data-ttu-id="2780b-201">提供這項功能的目的是讓使用者程式碼可以定義自己的型別，然後從同時也屬於相同使用者程式碼範圍的標記，將這些類別具現化。</span><span class="sxs-lookup"><span data-stu-id="2780b-201">This capability is provided so that user code can define its own types, and then instantiate those classes from markup that is also part of the same user code scope.</span></span>  
  
 <span data-ttu-id="2780b-202">WPF 的一個範例，就是使用者程式碼定義的 <xref:System.Windows.Controls.UserControl>，其目的是要用來重構 UI 行為，而不是使用 `public` 存取層級宣告支援的類別，而不是任何可能隱含的擴充機制的一部分。</span><span class="sxs-lookup"><span data-stu-id="2780b-202">An example from WPF is whenever user code defines a <xref:System.Windows.Controls.UserControl> that is intended as a way to refactor a UI behavior, but not as part of any possible extension mechanism that might be implied by declaring the supporting class with `public` access level.</span></span> <span data-ttu-id="2780b-203">如果支援程式碼編譯成與當做 XAML 類型參考的相同元件，則可以使用 `internal` 存取來宣告這類 <xref:System.Windows.Controls.UserControl>。</span><span class="sxs-lookup"><span data-stu-id="2780b-203">Such a <xref:System.Windows.Controls.UserControl> can be declared with `internal` access if the backing code is compiled into the same assembly from which it is referenced as a XAML type.</span></span>  
  
 <span data-ttu-id="2780b-204">對於在完全信任之下載入 XAML 並使用 <xref:System.Xaml.XamlObjectWriter>的應用程式，一律會啟用載入具有 `internal` 存取層級的類別。</span><span class="sxs-lookup"><span data-stu-id="2780b-204">For an application that loads XAML under full trust and uses <xref:System.Xaml.XamlObjectWriter>, loading classes with `internal` access level is always enabled.</span></span>  
  
 <span data-ttu-id="2780b-205">對於在部分信任下載入 XAML 的應用程式，您可以使用 <xref:System.Xaml.Permissions.XamlAccessLevel> API 來控制存取層級的特性。</span><span class="sxs-lookup"><span data-stu-id="2780b-205">For an application that loads XAML under partial trust, you can control the access level characteristics by using the <xref:System.Xaml.Permissions.XamlAccessLevel> API.</span></span> <span data-ttu-id="2780b-206">此外，延遲機制（例如 WPF 範本系統）必須能夠傳播任何存取層級許可權，並保留它們以進行最終的執行時間評估;這是藉由傳遞 <xref:System.Xaml.Permissions.XamlAccessLevel> 資訊在內部處理。</span><span class="sxs-lookup"><span data-stu-id="2780b-206">Also, deferral mechanisms (such as the WPF template system) must be able to propagate any access level permissions and preserve them for the eventual run time evaluations; this is handled internally by passing the <xref:System.Xaml.Permissions.XamlAccessLevel> information.</span></span>  
  
### <a name="wpf-implementation"></a><span data-ttu-id="2780b-207">WPF 執行</span><span class="sxs-lookup"><span data-stu-id="2780b-207">WPF Implementation</span></span>  
 <span data-ttu-id="2780b-208">WPF XAML 會使用部分信任存取模型，其中如果 BAML 是在部分信任下載入，則只會限制為 BAML 來源元件的 <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> 存取。</span><span class="sxs-lookup"><span data-stu-id="2780b-208">WPF XAML uses a partial-trust access model where if BAML is loaded under partial trust, access is restricted to <xref:System.Xaml.Permissions.XamlAccessLevel.AssemblyAccessTo%2A> for the assembly that is the BAML source.</span></span> <span data-ttu-id="2780b-209">對於延遲，WPF 會使用 <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> 做為傳遞存取層級資訊的機制。</span><span class="sxs-lookup"><span data-stu-id="2780b-209">For deferral, WPF uses <xref:System.Xaml.IXamlObjectWriterFactory.GetParentSettings%2A?displayProperty=nameWithType> as a mechanism for passing the access level information.</span></span>  
  
 <span data-ttu-id="2780b-210">在 WPF XAML 術語中，*內部類型*是由相同元件所定義的類型，其中也包含參考 XAML。</span><span class="sxs-lookup"><span data-stu-id="2780b-210">In WPF XAML terminology, an *internal type* is a type that is defined by the same assembly that also includes the referencing XAML.</span></span> <span data-ttu-id="2780b-211">這類型別可以透過 XAML 命名空間來對應，此命名空間故意省略對應的元件 = 部分，例如 `xmlns:local="clr-namespace:WPFApplication1"`。</span><span class="sxs-lookup"><span data-stu-id="2780b-211">Such a type can be mapped through a XAML namespace that deliberately omits the assembly= portion of a mapping, for example, `xmlns:local="clr-namespace:WPFApplication1"`.</span></span>  <span data-ttu-id="2780b-212">如果 BAML 參考內部型別，而該型別具有 `internal` 的存取層級，這就會產生元件的 `GeneratedInternalTypeHelper` 類別。</span><span class="sxs-lookup"><span data-stu-id="2780b-212">If BAML references an internal type and that type has `internal` access level, this generates a `GeneratedInternalTypeHelper` class for the assembly.</span></span> <span data-ttu-id="2780b-213">如果您想要避免 `GeneratedInternalTypeHelper`，則必須使用 `public` 存取層級，或必須將相關的類別納入個別的元件中，並使該元件相依。</span><span class="sxs-lookup"><span data-stu-id="2780b-213">If you want to avoid `GeneratedInternalTypeHelper`, you either must use `public` access level, or must factor the relevant class into a separate assembly and make that assembly dependent.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2780b-214">請參閱</span><span class="sxs-lookup"><span data-stu-id="2780b-214">See also</span></span>

- [<span data-ttu-id="2780b-215">自訂類型和程式庫的 XAML 相關 CLR 屬性</span><span class="sxs-lookup"><span data-stu-id="2780b-215">XAML-Related CLR Attributes for Custom Types and Libraries</span></span>](xaml-related-clr-attributes-for-custom-types-and-libraries.md)
- [<span data-ttu-id="2780b-216">XAML Services</span><span class="sxs-lookup"><span data-stu-id="2780b-216">XAML Services</span></span>](index.md)
