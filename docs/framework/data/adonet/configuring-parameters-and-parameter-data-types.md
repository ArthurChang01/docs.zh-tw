---
title: 設定參數和參數資料類型
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 537d8a2c-d40b-4000-83eb-bc1fcc93f707
ms.openlocfilehash: 5d35e2775c6c6912d2a36c550202b309ebdeaa32
ms.sourcegitcommit: c7a7e1468bf0fa7f7065de951d60dfc8d5ba89f5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/14/2019
ms.locfileid: "65583835"
---
# <a name="configuring-parameters-and-parameter-data-types"></a><span data-ttu-id="7ae2a-102">設定參數和參數資料類型</span><span class="sxs-lookup"><span data-stu-id="7ae2a-102">Configuring parameters and parameter data types</span></span>

<span data-ttu-id="7ae2a-103">命令物件會使用參數將值傳遞至 SQL 陳述式或預存程序 (Stored Procedure)，以提供型別檢查及驗證。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-103">Command objects use parameters to pass values to SQL statements or stored procedures, providing type checking and validation.</span></span> <span data-ttu-id="7ae2a-104">與命令文字不同的是，參數輸入會被視為常值 (Literal)，而非可執行程式碼。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-104">Unlike command text, parameter input is treated as a literal value, not as executable code.</span></span> <span data-ttu-id="7ae2a-105">這有助於防衛「SQL 插入式」攻擊，在此類攻擊中，攻擊者會將危害伺服器安全的命令插入 SQL 陳述式中。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-105">This helps guard against "SQL injection" attacks, in which an attacker inserts a command that compromises security on the server into an SQL statement.</span></span>

<span data-ttu-id="7ae2a-106">參數型命令 (Parameterized Command) 也可以改善查詢執行效能，因為它們可以協助資料庫伺服器正確地比對內送命令與正確快取的查詢計畫。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-106">Parameterized commands can also improve query execution performance, because they help the database server accurately match the incoming command with a proper cached query plan.</span></span> <span data-ttu-id="7ae2a-107">如需詳細資訊，請參閱 <<c0> [ 執行計畫快取和重複使用](/sql/relational-databases/query-processing-architecture-guide#execution-plan-caching-and-reuse)並[參數和執行計畫的重複使用](/sql/relational-databases/query-processing-architecture-guide#PlanReuse)。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-107">For more information, see [Execution Plan Caching and Reuse](/sql/relational-databases/query-processing-architecture-guide#execution-plan-caching-and-reuse) and [Parameters and Execution Plan Reuse](/sql/relational-databases/query-processing-architecture-guide#PlanReuse).</span></span> <span data-ttu-id="7ae2a-108">除了安全性和效能的優點以外，參數型命令也提供方便的方法，可讓您安排傳遞至資料來源的值。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-108">In addition to the security and performance benefits, parameterized commands provide a convenient method for organizing values passed to a data source.</span></span>

<span data-ttu-id="7ae2a-109"><xref:System.Data.Common.DbParameter> 物件可透過其建構函式建立，或者透過呼叫 <xref:System.Data.Common.DbCommand.DbParameterCollection%2A> 集合的 `Add` 方法，將其加入 <xref:System.Data.Common.DbParameterCollection> 來建立。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-109">A <xref:System.Data.Common.DbParameter> object can be created by using its constructor, or by adding it to the <xref:System.Data.Common.DbCommand.DbParameterCollection%2A> by calling the `Add` method of the <xref:System.Data.Common.DbParameterCollection> collection.</span></span> <span data-ttu-id="7ae2a-110">`Add` 方法會將建構函式引數或現有的參數物件當做輸出，依資料提供者而定。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-110">The `Add` method will take as input either constructor arguments or an existing parameter object, depending on the data provider.</span></span>

## <a name="supplying-the-parameterdirection-property"></a><span data-ttu-id="7ae2a-111">提供 ParameterDirection 屬性</span><span class="sxs-lookup"><span data-stu-id="7ae2a-111">Supplying the ParameterDirection property</span></span>

<span data-ttu-id="7ae2a-112">在加入參數時，您必須為不是輸入參數的參數提供 <xref:System.Data.ParameterDirection> 屬性。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-112">When adding parameters, you must supply a <xref:System.Data.ParameterDirection> property for parameters other than input parameters.</span></span> <span data-ttu-id="7ae2a-113">下表所顯示的 `ParameterDirection` 值是可以與 <xref:System.Data.ParameterDirection> 列舉一起使用的。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-113">The following table shows the `ParameterDirection` values that you can use with the <xref:System.Data.ParameterDirection> enumeration.</span></span>

|<span data-ttu-id="7ae2a-114">成員名稱</span><span class="sxs-lookup"><span data-stu-id="7ae2a-114">Member name</span></span>|<span data-ttu-id="7ae2a-115">描述</span><span class="sxs-lookup"><span data-stu-id="7ae2a-115">Description</span></span>|
|-----------------|-----------------|
|<xref:System.Data.ParameterDirection.Input>|<span data-ttu-id="7ae2a-116">這是輸入參數，</span><span class="sxs-lookup"><span data-stu-id="7ae2a-116">The parameter is an input parameter.</span></span> <span data-ttu-id="7ae2a-117">這是預設值。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-117">This is the default.</span></span>|
|<xref:System.Data.ParameterDirection.InputOutput>|<span data-ttu-id="7ae2a-118">這個參數可執行輸入和輸出。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-118">The parameter can perform both input and output.</span></span>|
|<xref:System.Data.ParameterDirection.Output>|<span data-ttu-id="7ae2a-119">這是輸出參數。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-119">The parameter is an output parameter.</span></span>|
|<xref:System.Data.ParameterDirection.ReturnValue>|<span data-ttu-id="7ae2a-120">此參數代表預存程序 (Stored Procedure)、內建函式或使用者定義函式等作業的傳回值。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-120">The parameter represents a return value from an operation such as a stored procedure, built-in function, or user-defined function.</span></span>|

## <a name="working-with-parameter-placeholders"></a><span data-ttu-id="7ae2a-121">使用參數預留位置</span><span class="sxs-lookup"><span data-stu-id="7ae2a-121">Working with parameter placeholders</span></span>

<span data-ttu-id="7ae2a-122">參數預留位置的語法會隨資料來源而有所不同。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-122">The syntax for parameter placeholders depends on the data source.</span></span> <span data-ttu-id="7ae2a-123">.NET Framework 資料提供者會以不同方式來處理參數和參數預留位置的命名及指定。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-123">The .NET Framework data providers handle naming and specifying parameters and parameter placeholders differently.</span></span> <span data-ttu-id="7ae2a-124">這個語法是特定資料來源專用的，如以下資料表所述：</span><span class="sxs-lookup"><span data-stu-id="7ae2a-124">This syntax is customized to a specific data source, as described in the following table.</span></span>

|<span data-ttu-id="7ae2a-125">資料提供者</span><span class="sxs-lookup"><span data-stu-id="7ae2a-125">Data provider</span></span>|<span data-ttu-id="7ae2a-126">參數命名語法</span><span class="sxs-lookup"><span data-stu-id="7ae2a-126">Parameter naming syntax</span></span>|
|-------------------|-----------------------------|
|<xref:System.Data.SqlClient>|<span data-ttu-id="7ae2a-127">以格式 `@`*parametername*使用具名參數。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-127">Uses named parameters in the format `@`*parametername*.</span></span>|
|<xref:System.Data.OleDb>|<span data-ttu-id="7ae2a-128">使用由問號 (`?`) 表示的位置參數標記。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-128">Uses positional parameter markers indicated by a question mark (`?`).</span></span>|
|<xref:System.Data.Odbc>|<span data-ttu-id="7ae2a-129">使用由問號 (`?`) 表示的位置參數標記。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-129">Uses positional parameter markers indicated by a question mark (`?`).</span></span>|
|<xref:System.Data.OracleClient>|<span data-ttu-id="7ae2a-130">以格式 `:`*parmname* (或 *parmname*) 使用具名參數。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-130">Uses named parameters in the format `:`*parmname* (or *parmname*).</span></span>|

## <a name="specifying-parameter-data-types"></a><span data-ttu-id="7ae2a-131">指定的參數資料類型</span><span class="sxs-lookup"><span data-stu-id="7ae2a-131">Specifying parameter data types</span></span>

<span data-ttu-id="7ae2a-132">參數的資料型別是.NET Framework 資料提供者特有的。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-132">The data type of a parameter is specific to the .NET Framework data provider.</span></span> <span data-ttu-id="7ae2a-133">指定類型的值轉換`Parameter`為.NET Framework 資料提供者型別，再將值傳遞至資料來源。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-133">Specifying the type converts the value of the `Parameter` to the .NET Framework data provider type before passing the value to the data source.</span></span> <span data-ttu-id="7ae2a-134">您也可以使用一般方式指定 `Parameter` 的型別，方法是將 `DbType` 物件的 `Parameter` 屬性設為特定的 <xref:System.Data.DbType>。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-134">You may also specify the type of a `Parameter` in a generic manner by setting the `DbType` property of the `Parameter` object to a particular <xref:System.Data.DbType>.</span></span>

<span data-ttu-id="7ae2a-135">.NET Framework 資料提供者型別`Parameter`物件從.NET Framework 型別推斷`Value`的`Parameter`物件，或從`DbType`的`Parameter`物件。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-135">The .NET Framework data provider type of a `Parameter` object is inferred from the .NET Framework type of the `Value` of the `Parameter` object, or from the `DbType` of the `Parameter` object.</span></span> <span data-ttu-id="7ae2a-136">下列表格說明根據以 `Parameter` 值或指定之 `Parameter` 來傳遞的物件而推斷出的 `DbType`型別。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-136">The following table shows the inferred `Parameter` type based on the object passed as the `Parameter` value or the specified `DbType`.</span></span>

|<span data-ttu-id="7ae2a-137">.NET Framework 類型</span><span class="sxs-lookup"><span data-stu-id="7ae2a-137">.NET Framework type</span></span>|<span data-ttu-id="7ae2a-138">DbType</span><span class="sxs-lookup"><span data-stu-id="7ae2a-138">DbType</span></span>|<span data-ttu-id="7ae2a-139">SqlDbType</span><span class="sxs-lookup"><span data-stu-id="7ae2a-139">SqlDbType</span></span>|<span data-ttu-id="7ae2a-140">OleDbType</span><span class="sxs-lookup"><span data-stu-id="7ae2a-140">OleDbType</span></span>|<span data-ttu-id="7ae2a-141">OdbcType</span><span class="sxs-lookup"><span data-stu-id="7ae2a-141">OdbcType</span></span>|<span data-ttu-id="7ae2a-142">OracleType</span><span class="sxs-lookup"><span data-stu-id="7ae2a-142">OracleType</span></span>|
|-------------------------|------------|---------------|---------------|--------------|----------------|
|<xref:System.Boolean>|<span data-ttu-id="7ae2a-143">Boolean</span><span class="sxs-lookup"><span data-stu-id="7ae2a-143">Boolean</span></span>|<span data-ttu-id="7ae2a-144">位元</span><span class="sxs-lookup"><span data-stu-id="7ae2a-144">Bit</span></span>|<span data-ttu-id="7ae2a-145">Boolean</span><span class="sxs-lookup"><span data-stu-id="7ae2a-145">Boolean</span></span>|<span data-ttu-id="7ae2a-146">位元</span><span class="sxs-lookup"><span data-stu-id="7ae2a-146">Bit</span></span>|<span data-ttu-id="7ae2a-147">Byte</span><span class="sxs-lookup"><span data-stu-id="7ae2a-147">Byte</span></span>|
|<xref:System.Byte>|<span data-ttu-id="7ae2a-148">Byte</span><span class="sxs-lookup"><span data-stu-id="7ae2a-148">Byte</span></span>|<span data-ttu-id="7ae2a-149">TinyInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-149">TinyInt</span></span>|<span data-ttu-id="7ae2a-150">UnsignedTinyInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-150">UnsignedTinyInt</span></span>|<span data-ttu-id="7ae2a-151">TinyInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-151">TinyInt</span></span>|<span data-ttu-id="7ae2a-152">Byte</span><span class="sxs-lookup"><span data-stu-id="7ae2a-152">Byte</span></span>|
|<span data-ttu-id="7ae2a-153">byte[]</span><span class="sxs-lookup"><span data-stu-id="7ae2a-153">byte[]</span></span>|<span data-ttu-id="7ae2a-154">二元</span><span class="sxs-lookup"><span data-stu-id="7ae2a-154">Binary</span></span>|<span data-ttu-id="7ae2a-155">VarBinary。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-155">VarBinary.</span></span> <span data-ttu-id="7ae2a-156">如果位元組陣列超過 VarBinary 的最大大小即 8000 個位元組，這項隱含轉換將會失敗。大於 8000 個位元組的位元組陣列，請明確設定<xref:System.Data.SqlDbType>。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-156">This implicit conversion will fail if the byte array is larger than the maximum size of a VarBinary, which is 8000 bytes.For byte arrays larger than 8000 bytes, explicitly set the <xref:System.Data.SqlDbType>.</span></span>|<span data-ttu-id="7ae2a-157">VarBinary</span><span class="sxs-lookup"><span data-stu-id="7ae2a-157">VarBinary</span></span>|<span data-ttu-id="7ae2a-158">二元</span><span class="sxs-lookup"><span data-stu-id="7ae2a-158">Binary</span></span>|<span data-ttu-id="7ae2a-159">Raw</span><span class="sxs-lookup"><span data-stu-id="7ae2a-159">Raw</span></span>|
|<xref:System.Char>| |<span data-ttu-id="7ae2a-160">不支援從 char 推斷 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-160">Inferring a <xref:System.Data.SqlDbType> from char is not supported.</span></span>|<span data-ttu-id="7ae2a-161">Char</span><span class="sxs-lookup"><span data-stu-id="7ae2a-161">Char</span></span>|<span data-ttu-id="7ae2a-162">Char</span><span class="sxs-lookup"><span data-stu-id="7ae2a-162">Char</span></span>|<span data-ttu-id="7ae2a-163">Byte</span><span class="sxs-lookup"><span data-stu-id="7ae2a-163">Byte</span></span>|
|<xref:System.DateTime>|<span data-ttu-id="7ae2a-164">DateTime</span><span class="sxs-lookup"><span data-stu-id="7ae2a-164">DateTime</span></span>|<span data-ttu-id="7ae2a-165">DateTime</span><span class="sxs-lookup"><span data-stu-id="7ae2a-165">DateTime</span></span>|<span data-ttu-id="7ae2a-166">DBTimeStamp</span><span class="sxs-lookup"><span data-stu-id="7ae2a-166">DBTimeStamp</span></span>|<span data-ttu-id="7ae2a-167">DateTime</span><span class="sxs-lookup"><span data-stu-id="7ae2a-167">DateTime</span></span>|<span data-ttu-id="7ae2a-168">DateTime</span><span class="sxs-lookup"><span data-stu-id="7ae2a-168">DateTime</span></span>|
|<xref:System.DateTimeOffset>|<span data-ttu-id="7ae2a-169">DateTimeOffset</span><span class="sxs-lookup"><span data-stu-id="7ae2a-169">DateTimeOffset</span></span>|<span data-ttu-id="7ae2a-170">SQL Server 2008 中的 DateTimeOffset。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-170">DateTimeOffset in SQL Server 2008.</span></span> <span data-ttu-id="7ae2a-171">SQL Server 2008 之前的 SQL Server 版本不支援從 DateTimeOffset 推斷 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-171">Inferring a <xref:System.Data.SqlDbType> from DateTimeOffset is not supported in versions of SQL Server earlier than SQL Server 2008.</span></span>|||<span data-ttu-id="7ae2a-172">DateTime</span><span class="sxs-lookup"><span data-stu-id="7ae2a-172">DateTime</span></span>|
|<xref:System.Decimal>|<span data-ttu-id="7ae2a-173">Decimal</span><span class="sxs-lookup"><span data-stu-id="7ae2a-173">Decimal</span></span>|<span data-ttu-id="7ae2a-174">Decimal</span><span class="sxs-lookup"><span data-stu-id="7ae2a-174">Decimal</span></span>|<span data-ttu-id="7ae2a-175">Decimal</span><span class="sxs-lookup"><span data-stu-id="7ae2a-175">Decimal</span></span>|<span data-ttu-id="7ae2a-176">數值</span><span class="sxs-lookup"><span data-stu-id="7ae2a-176">Numeric</span></span>|<span data-ttu-id="7ae2a-177">number</span><span class="sxs-lookup"><span data-stu-id="7ae2a-177">Number</span></span>|
|<xref:System.Double>|<span data-ttu-id="7ae2a-178">Double</span><span class="sxs-lookup"><span data-stu-id="7ae2a-178">Double</span></span>|<span data-ttu-id="7ae2a-179">浮動</span><span class="sxs-lookup"><span data-stu-id="7ae2a-179">Float</span></span>|<span data-ttu-id="7ae2a-180">Double</span><span class="sxs-lookup"><span data-stu-id="7ae2a-180">Double</span></span>|<span data-ttu-id="7ae2a-181">Double</span><span class="sxs-lookup"><span data-stu-id="7ae2a-181">Double</span></span>|<span data-ttu-id="7ae2a-182">Double</span><span class="sxs-lookup"><span data-stu-id="7ae2a-182">Double</span></span>|
|<xref:System.Single>|<span data-ttu-id="7ae2a-183">Single</span><span class="sxs-lookup"><span data-stu-id="7ae2a-183">Single</span></span>|<span data-ttu-id="7ae2a-184">Real</span><span class="sxs-lookup"><span data-stu-id="7ae2a-184">Real</span></span>|<span data-ttu-id="7ae2a-185">Single</span><span class="sxs-lookup"><span data-stu-id="7ae2a-185">Single</span></span>|<span data-ttu-id="7ae2a-186">Real</span><span class="sxs-lookup"><span data-stu-id="7ae2a-186">Real</span></span>|<span data-ttu-id="7ae2a-187">浮動</span><span class="sxs-lookup"><span data-stu-id="7ae2a-187">Float</span></span>|
|<xref:System.Guid>|<span data-ttu-id="7ae2a-188">Guid</span><span class="sxs-lookup"><span data-stu-id="7ae2a-188">Guid</span></span>|<span data-ttu-id="7ae2a-189">UniqueIdentifier</span><span class="sxs-lookup"><span data-stu-id="7ae2a-189">UniqueIdentifier</span></span>|<span data-ttu-id="7ae2a-190">Guid</span><span class="sxs-lookup"><span data-stu-id="7ae2a-190">Guid</span></span>|<span data-ttu-id="7ae2a-191">UniqueIdentifier</span><span class="sxs-lookup"><span data-stu-id="7ae2a-191">UniqueIdentifier</span></span>|<span data-ttu-id="7ae2a-192">Raw</span><span class="sxs-lookup"><span data-stu-id="7ae2a-192">Raw</span></span>|
|<xref:System.Int16>|<span data-ttu-id="7ae2a-193">Int16</span><span class="sxs-lookup"><span data-stu-id="7ae2a-193">Int16</span></span>|<span data-ttu-id="7ae2a-194">SmallInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-194">SmallInt</span></span>|<span data-ttu-id="7ae2a-195">SmallInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-195">SmallInt</span></span>|<span data-ttu-id="7ae2a-196">SmallInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-196">SmallInt</span></span>|<span data-ttu-id="7ae2a-197">Int16</span><span class="sxs-lookup"><span data-stu-id="7ae2a-197">Int16</span></span>|
|<xref:System.Int32>|<span data-ttu-id="7ae2a-198">Int32</span><span class="sxs-lookup"><span data-stu-id="7ae2a-198">Int32</span></span>|<span data-ttu-id="7ae2a-199">Int</span><span class="sxs-lookup"><span data-stu-id="7ae2a-199">Int</span></span>|<span data-ttu-id="7ae2a-200">Int</span><span class="sxs-lookup"><span data-stu-id="7ae2a-200">Int</span></span>|<span data-ttu-id="7ae2a-201">Int</span><span class="sxs-lookup"><span data-stu-id="7ae2a-201">Int</span></span>|<span data-ttu-id="7ae2a-202">Int32</span><span class="sxs-lookup"><span data-stu-id="7ae2a-202">Int32</span></span>|
|<xref:System.Int64>|<span data-ttu-id="7ae2a-203">Int64</span><span class="sxs-lookup"><span data-stu-id="7ae2a-203">Int64</span></span>|<span data-ttu-id="7ae2a-204">BigInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-204">BigInt</span></span>|<span data-ttu-id="7ae2a-205">BigInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-205">BigInt</span></span>|<span data-ttu-id="7ae2a-206">BigInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-206">BigInt</span></span>|<span data-ttu-id="7ae2a-207">數字</span><span class="sxs-lookup"><span data-stu-id="7ae2a-207">Number</span></span>|
|<xref:System.Object>|<span data-ttu-id="7ae2a-208">Object</span><span class="sxs-lookup"><span data-stu-id="7ae2a-208">Object</span></span>|<span data-ttu-id="7ae2a-209">變異</span><span class="sxs-lookup"><span data-stu-id="7ae2a-209">Variant</span></span>|<span data-ttu-id="7ae2a-210">變異</span><span class="sxs-lookup"><span data-stu-id="7ae2a-210">Variant</span></span>|<span data-ttu-id="7ae2a-211">不支援從 Object 推斷 OdbcType。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-211">Inferring an OdbcType from Object is not supported.</span></span>|<span data-ttu-id="7ae2a-212">Blob</span><span class="sxs-lookup"><span data-stu-id="7ae2a-212">Blob</span></span>|
|<xref:System.String>|<span data-ttu-id="7ae2a-213">String</span><span class="sxs-lookup"><span data-stu-id="7ae2a-213">String</span></span>|<span data-ttu-id="7ae2a-214">NVarChar。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-214">NVarChar.</span></span> <span data-ttu-id="7ae2a-215">如果字串超過 NVarChar 的最大大小 (4000 個字元)，則這項隱含轉換將會失敗。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-215">This implicit conversion will fail if the string is larger than the maximum size of an NVarChar, which is 4000 characters.</span></span> <span data-ttu-id="7ae2a-216">若要使用超過 4000 個字元的字串，請明確設定 <xref:System.Data.SqlDbType>。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-216">For strings larger than 4000 characters, explicitly set the <xref:System.Data.SqlDbType>.</span></span>|<span data-ttu-id="7ae2a-217">VarWChar</span><span class="sxs-lookup"><span data-stu-id="7ae2a-217">VarWChar</span></span>|<span data-ttu-id="7ae2a-218">NVarChar</span><span class="sxs-lookup"><span data-stu-id="7ae2a-218">NVarChar</span></span>|<span data-ttu-id="7ae2a-219">NVarChar</span><span class="sxs-lookup"><span data-stu-id="7ae2a-219">NVarChar</span></span>|
|<xref:System.TimeSpan>|<span data-ttu-id="7ae2a-220">時間</span><span class="sxs-lookup"><span data-stu-id="7ae2a-220">Time</span></span>|<span data-ttu-id="7ae2a-221">SQL Server 2008 中的 Time。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-221">Time in SQL Server 2008.</span></span> <span data-ttu-id="7ae2a-222">SQL Server 2008 之前的 SQL Server 版本不支援從 TimeSpan 推斷 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-222">Inferring a <xref:System.Data.SqlDbType> from TimeSpan is not supported in versions of SQL Server earlier than SQL Server 2008.</span></span>|<span data-ttu-id="7ae2a-223">DBTime</span><span class="sxs-lookup"><span data-stu-id="7ae2a-223">DBTime</span></span>|<span data-ttu-id="7ae2a-224">時間</span><span class="sxs-lookup"><span data-stu-id="7ae2a-224">Time</span></span>|<span data-ttu-id="7ae2a-225">DateTime</span><span class="sxs-lookup"><span data-stu-id="7ae2a-225">DateTime</span></span>|
|<xref:System.UInt16>|<span data-ttu-id="7ae2a-226">UInt16</span><span class="sxs-lookup"><span data-stu-id="7ae2a-226">UInt16</span></span>|<span data-ttu-id="7ae2a-227">不支援從 UInt16 推斷 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-227">Inferring a <xref:System.Data.SqlDbType> from UInt16 is not supported.</span></span>|<span data-ttu-id="7ae2a-228">UnsignedSmallInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-228">UnsignedSmallInt</span></span>|<span data-ttu-id="7ae2a-229">Int</span><span class="sxs-lookup"><span data-stu-id="7ae2a-229">Int</span></span>|<span data-ttu-id="7ae2a-230">UInt16</span><span class="sxs-lookup"><span data-stu-id="7ae2a-230">UInt16</span></span>|
|<xref:System.UInt32>|<span data-ttu-id="7ae2a-231">UInt32</span><span class="sxs-lookup"><span data-stu-id="7ae2a-231">UInt32</span></span>|<span data-ttu-id="7ae2a-232">不支援從 UInt32 推斷 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-232">Inferring a <xref:System.Data.SqlDbType> from UInt32 is not supported.</span></span>|<span data-ttu-id="7ae2a-233">UnsignedInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-233">UnsignedInt</span></span>|<span data-ttu-id="7ae2a-234">BigInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-234">BigInt</span></span>|<span data-ttu-id="7ae2a-235">UInt32</span><span class="sxs-lookup"><span data-stu-id="7ae2a-235">UInt32</span></span>|
|<xref:System.UInt64>|<span data-ttu-id="7ae2a-236">UInt64</span><span class="sxs-lookup"><span data-stu-id="7ae2a-236">UInt64</span></span>|<span data-ttu-id="7ae2a-237">不支援從 UInt64 推斷 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-237">Inferring a <xref:System.Data.SqlDbType> from UInt64 is not supported.</span></span>|<span data-ttu-id="7ae2a-238">UnsignedBigInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-238">UnsignedBigInt</span></span>|<span data-ttu-id="7ae2a-239">數值</span><span class="sxs-lookup"><span data-stu-id="7ae2a-239">Numeric</span></span>|<span data-ttu-id="7ae2a-240">number</span><span class="sxs-lookup"><span data-stu-id="7ae2a-240">Number</span></span>|
||<span data-ttu-id="7ae2a-241">AnsiString</span><span class="sxs-lookup"><span data-stu-id="7ae2a-241">AnsiString</span></span>|<span data-ttu-id="7ae2a-242">VarChar</span><span class="sxs-lookup"><span data-stu-id="7ae2a-242">VarChar</span></span>|<span data-ttu-id="7ae2a-243">VarChar</span><span class="sxs-lookup"><span data-stu-id="7ae2a-243">VarChar</span></span>|<span data-ttu-id="7ae2a-244">VarChar</span><span class="sxs-lookup"><span data-stu-id="7ae2a-244">VarChar</span></span>|<span data-ttu-id="7ae2a-245">VarChar</span><span class="sxs-lookup"><span data-stu-id="7ae2a-245">VarChar</span></span>|
||<span data-ttu-id="7ae2a-246">AnsiStringFixedLength</span><span class="sxs-lookup"><span data-stu-id="7ae2a-246">AnsiStringFixedLength</span></span>|<span data-ttu-id="7ae2a-247">Char</span><span class="sxs-lookup"><span data-stu-id="7ae2a-247">Char</span></span>|<span data-ttu-id="7ae2a-248">Char</span><span class="sxs-lookup"><span data-stu-id="7ae2a-248">Char</span></span>|<span data-ttu-id="7ae2a-249">Char</span><span class="sxs-lookup"><span data-stu-id="7ae2a-249">Char</span></span>|<span data-ttu-id="7ae2a-250">Char</span><span class="sxs-lookup"><span data-stu-id="7ae2a-250">Char</span></span>|
||<span data-ttu-id="7ae2a-251">貨幣</span><span class="sxs-lookup"><span data-stu-id="7ae2a-251">Currency</span></span>|<span data-ttu-id="7ae2a-252">Money</span><span class="sxs-lookup"><span data-stu-id="7ae2a-252">Money</span></span>|<span data-ttu-id="7ae2a-253">貨幣</span><span class="sxs-lookup"><span data-stu-id="7ae2a-253">Currency</span></span>|<span data-ttu-id="7ae2a-254">不支援從 `OdbcType` 推斷 `Currency` 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-254">Inferring an `OdbcType` from `Currency` is not supported.</span></span>|<span data-ttu-id="7ae2a-255">number</span><span class="sxs-lookup"><span data-stu-id="7ae2a-255">Number</span></span>|
||<span data-ttu-id="7ae2a-256">日期</span><span class="sxs-lookup"><span data-stu-id="7ae2a-256">Date</span></span>|<span data-ttu-id="7ae2a-257">SQL Server 2008 中的 Date。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-257">Date in SQL Server 2008.</span></span> <span data-ttu-id="7ae2a-258">SQL Server 2008 之前的 SQL Server 版本不支援從 Date 推斷 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-258">Inferring a <xref:System.Data.SqlDbType> from Date is not supported in versions of SQL Server earlier than SQL Server 2008.</span></span>|<span data-ttu-id="7ae2a-259">DBDate</span><span class="sxs-lookup"><span data-stu-id="7ae2a-259">DBDate</span></span>|<span data-ttu-id="7ae2a-260">Date</span><span class="sxs-lookup"><span data-stu-id="7ae2a-260">Date</span></span>|<span data-ttu-id="7ae2a-261">DateTime</span><span class="sxs-lookup"><span data-stu-id="7ae2a-261">DateTime</span></span>|
||<span data-ttu-id="7ae2a-262">SByte</span><span class="sxs-lookup"><span data-stu-id="7ae2a-262">SByte</span></span>|<span data-ttu-id="7ae2a-263">不支援從 SByte 推斷 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-263">Inferring a <xref:System.Data.SqlDbType> from SByte is not supported.</span></span>|<span data-ttu-id="7ae2a-264">TinyInt</span><span class="sxs-lookup"><span data-stu-id="7ae2a-264">TinyInt</span></span>|<span data-ttu-id="7ae2a-265">不支援從 SByte 推斷 `OdbcType` 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-265">Inferring an `OdbcType` from SByte is not supported.</span></span>|<span data-ttu-id="7ae2a-266">SByte</span><span class="sxs-lookup"><span data-stu-id="7ae2a-266">SByte</span></span>|
||<span data-ttu-id="7ae2a-267">StringFixedLength</span><span class="sxs-lookup"><span data-stu-id="7ae2a-267">StringFixedLength</span></span>|<span data-ttu-id="7ae2a-268">NChar</span><span class="sxs-lookup"><span data-stu-id="7ae2a-268">NChar</span></span>|<span data-ttu-id="7ae2a-269">WChar</span><span class="sxs-lookup"><span data-stu-id="7ae2a-269">WChar</span></span>|<span data-ttu-id="7ae2a-270">NChar</span><span class="sxs-lookup"><span data-stu-id="7ae2a-270">NChar</span></span>|<span data-ttu-id="7ae2a-271">NChar</span><span class="sxs-lookup"><span data-stu-id="7ae2a-271">NChar</span></span>|
||<span data-ttu-id="7ae2a-272">時間</span><span class="sxs-lookup"><span data-stu-id="7ae2a-272">Time</span></span>|<span data-ttu-id="7ae2a-273">SQL Server 2008 中的 Time。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-273">Time in SQL Server 2008.</span></span> <span data-ttu-id="7ae2a-274">SQL Server 2008 之前的 SQL Server 版本不支援從 Time 推斷 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-274">Inferring a <xref:System.Data.SqlDbType> from Time is not supported in versions of SQL Server earlier than SQL Server 2008.</span></span>|<span data-ttu-id="7ae2a-275">DBTime</span><span class="sxs-lookup"><span data-stu-id="7ae2a-275">DBTime</span></span>|<span data-ttu-id="7ae2a-276">時間</span><span class="sxs-lookup"><span data-stu-id="7ae2a-276">Time</span></span>|<span data-ttu-id="7ae2a-277">DateTime</span><span class="sxs-lookup"><span data-stu-id="7ae2a-277">DateTime</span></span>|
||<span data-ttu-id="7ae2a-278">VarNumeric</span><span class="sxs-lookup"><span data-stu-id="7ae2a-278">VarNumeric</span></span>|<span data-ttu-id="7ae2a-279">不支援從 VarNumeric 推斷 <xref:System.Data.SqlDbType> 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-279">Inferring a <xref:System.Data.SqlDbType> from VarNumeric is not supported.</span></span>|<span data-ttu-id="7ae2a-280">VarNumeric</span><span class="sxs-lookup"><span data-stu-id="7ae2a-280">VarNumeric</span></span>|<span data-ttu-id="7ae2a-281">不支援從 VarNumeric 推斷 `OdbcType` 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-281">Inferring an `OdbcType` from VarNumeric is not supported.</span></span>|<span data-ttu-id="7ae2a-282">number</span><span class="sxs-lookup"><span data-stu-id="7ae2a-282">Number</span></span>|
|<span data-ttu-id="7ae2a-283">使用者定義型別 (包含 <xref:Microsoft.SqlServer.Server.SqlUserDefinedAggregateAttribute>的物件)</span><span class="sxs-lookup"><span data-stu-id="7ae2a-283">user-defined type (an object with <xref:Microsoft.SqlServer.Server.SqlUserDefinedAggregateAttribute></span></span>|<span data-ttu-id="7ae2a-284">Object 或 String 是取決於提供者而定 (SqlClient 一律會傳回 Object，Odbc 一律會傳回 String，而 OleDb Managed 資料提供者可查看這兩者)</span><span class="sxs-lookup"><span data-stu-id="7ae2a-284">Object or String, depending the provider (SqlClient always returns an Object, Odbc always returns a String, and the OleDb managed data provider can see either</span></span>|<span data-ttu-id="7ae2a-285">若 <xref:Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute> 存在即為 SqlDbType.Udt，否則為 Variant</span><span class="sxs-lookup"><span data-stu-id="7ae2a-285">SqlDbType.Udt if <xref:Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute> is present, otherwise Variant</span></span>|<span data-ttu-id="7ae2a-286">OleDbType.VarWChar (如果值為 null)，否則為 OleDbType.Variant。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-286">OleDbType.VarWChar (if value is null) otherwise OleDbType.Variant.</span></span>|<span data-ttu-id="7ae2a-287">OdbcType.NVarChar</span><span class="sxs-lookup"><span data-stu-id="7ae2a-287">OdbcType.NVarChar</span></span>|<span data-ttu-id="7ae2a-288">不支援</span><span class="sxs-lookup"><span data-stu-id="7ae2a-288">not supported</span></span>|

> [!NOTE]
> <span data-ttu-id="7ae2a-289">將十進位值轉換為其他型別的過程稱為窄化轉換，此類轉換會將十進位值向零的方向取整數。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-289">Conversions from decimal to other types are narrowing conversions that round the decimal value to the nearest integer value toward zero.</span></span> <span data-ttu-id="7ae2a-290">如果目的型別無法代表此項轉換的結果，則會擲回 <xref:System.OverflowException> 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-290">If the result of the conversion is not representable in the destination type, an <xref:System.OverflowException> is thrown.</span></span>

> [!NOTE]
> <span data-ttu-id="7ae2a-291">當您將 null 參數值傳送至伺服器時，您必須指定<xref:System.DBNull>，而非`null`(`Nothing` Visual Basic 中)。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-291">When you send a null parameter value to the server, you must specify <xref:System.DBNull>, not `null` (`Nothing` in Visual Basic).</span></span> <span data-ttu-id="7ae2a-292">系統中的 Null 值是沒有值的空物件。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-292">The null value in the system is an empty object that has no value.</span></span> <span data-ttu-id="7ae2a-293"><xref:System.DBNull> 用於表示 null 值。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-293"><xref:System.DBNull> is used to represent null values.</span></span> <span data-ttu-id="7ae2a-294">如需資料庫 null 值的詳細資訊，請參閱 [Handling Null Values](./sql/handling-null-values.md)。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-294">For more information about database nulls, see [Handling Null Values](./sql/handling-null-values.md).</span></span>

## <a name="deriving-parameter-information"></a><span data-ttu-id="7ae2a-295">衍生參數資訊</span><span class="sxs-lookup"><span data-stu-id="7ae2a-295">Deriving parameter information</span></span>

<span data-ttu-id="7ae2a-296">您也可以使用 `DbCommandBuilder` 類別 (Class) 從預存程序衍生參數。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-296">Parameters can also be derived from a stored procedure using the `DbCommandBuilder` class.</span></span> <span data-ttu-id="7ae2a-297">`SqlCommandBuilder` 和 `OleDbCommandBuilder` 類別都能提供靜態方法 ( `DeriveParameters`)，該方法會在使用預存程序之參數資訊的命令物件，自動填入參數集合。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-297">Both the `SqlCommandBuilder` and `OleDbCommandBuilder` classes provide a static method, `DeriveParameters`, which automatically populates the parameters collection of a command object that uses parameter information from a stored procedure.</span></span> <span data-ttu-id="7ae2a-298">請注意， `DeriveParameters` 將會覆寫命令所有的現有參數資訊。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-298">Note that `DeriveParameters` overwrites any existing parameter information for the command.</span></span>

> [!NOTE]
> <span data-ttu-id="7ae2a-299">衍生參數資訊會造成效能降低，因為這項作業需要對資料來源進行額外的來回行程才能擷取資訊。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-299">Deriving parameter information incurs a performance penalty because it requires an additional round trip to the data source to retrieve the information.</span></span> <span data-ttu-id="7ae2a-300">若在設計階段已知參數資訊，您便可以明確設定參數，改善應用程式的效能。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-300">If parameter information is known at design time, you can improve the performance of your application by setting the parameters explicitly.</span></span>

<span data-ttu-id="7ae2a-301">如需詳細資訊，請參閱 < [Commandbuilder 產生命令](generating-commands-with-commandbuilders.md)。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-301">For more information, see [Generating Commands with CommandBuilders](generating-commands-with-commandbuilders.md).</span></span>

## <a name="using-parameters-with-a-sqlcommand-and-a-stored-procedure"></a><span data-ttu-id="7ae2a-302">使用參數配合 SqlCommand 和預存程序</span><span class="sxs-lookup"><span data-stu-id="7ae2a-302">Using parameters with a SqlCommand and a stored procedure</span></span>

<span data-ttu-id="7ae2a-303">預存程序對資料驅動應用程式有許多好處。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-303">Stored procedures offer many advantages in data-driven applications.</span></span> <span data-ttu-id="7ae2a-304">藉由使用預存程序，資料庫作業可以封裝在單一命令中、最佳化為最佳效能，並且可進一步提升安全性。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-304">By using stored procedures, database operations can be encapsulated in a single command, optimized for best performance, and enhanced with additional security.</span></span> <span data-ttu-id="7ae2a-305">雖然可以呼叫預存程序，預存程序名稱後, 接參數引數當成 SQL 陳述式，藉由傳遞<xref:System.Data.Common.DbCommand.Parameters%2A>的集合[!INCLUDE[vstecado](../../../../includes/vstecado-md.md)]<xref:System.Data.Common.DbCommand>物件可讓您更明確地定義預存程序參數，來存取輸出參數和傳回值。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-305">Although a stored procedure can be called by passing the stored procedure name followed by parameter arguments as an SQL statement, by using the <xref:System.Data.Common.DbCommand.Parameters%2A> collection of the [!INCLUDE[vstecado](../../../../includes/vstecado-md.md)] <xref:System.Data.Common.DbCommand> object enables you to more explicitly define stored procedure parameters, and to access output parameters and return values.</span></span>

> [!NOTE]
> <span data-ttu-id="7ae2a-306">參數化陳述式能在伺服器上執行，都是透過允許查詢計畫重複使用的 `sp_executesql,` 。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-306">Parameterized statements are executed on the server by using `sp_executesql,` which allows for query plan reuse.</span></span> <span data-ttu-id="7ae2a-307">呼叫 `sp_executesql` 的批次無法見到 `sp_executesql`批次中的本機資料指標或變數。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-307">Local cursors or variables in the `sp_executesql` batch are not visible to the batch that calls `sp_executesql`.</span></span> <span data-ttu-id="7ae2a-308">資料庫內容中的變更只會持續到 `sp_executesql` 陳述式結束。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-308">Changes in database context last only to the end of the `sp_executesql` statement.</span></span> <span data-ttu-id="7ae2a-309">如需詳細資訊，請參閱 [sp_executesql (transact-SQL)](/sql/relational-databases/system-stored-procedures/sp-executesql-transact-sql)。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-309">For more information, see [sp_executesql (Transact-SQL)](/sql/relational-databases/system-stored-procedures/sp-executesql-transact-sql).</span></span>

<span data-ttu-id="7ae2a-310">將參數與 <xref:System.Data.SqlClient.SqlCommand> 搭配使用以執行 SQL Server 預存程序時，加入 <xref:System.Data.SqlClient.SqlCommand.Parameters%2A> 集合的參數名稱必須與預存程序中的參數標記名稱相符。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-310">When using parameters with a <xref:System.Data.SqlClient.SqlCommand> to execute a SQL Server stored procedure, the names of the parameters added to the <xref:System.Data.SqlClient.SqlCommand.Parameters%2A> collection must match the names of the parameter markers in the stored procedure.</span></span> <span data-ttu-id="7ae2a-311">.NET Framework Data Provider for SQL Server 不支援問號 （？） 預留位置將參數傳遞至 SQL 陳述式或預存程序。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-311">The .NET Framework Data Provider for SQL Server does not support the question mark (?) placeholder for passing parameters to an SQL statement or a stored procedure.</span></span> <span data-ttu-id="7ae2a-312">它會將預存程式中的參數視為具名參數，並搜尋相符的參數標記。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-312">It treats parameters in the stored procedure as named parameters and searches for matching parameter markers.</span></span> <span data-ttu-id="7ae2a-313">例如， `CustOrderHist` 預存程序是使用名為 `@CustomerID`的參數所定義的。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-313">For example, the `CustOrderHist` stored procedure is defined by using a parameter named `@CustomerID`.</span></span> <span data-ttu-id="7ae2a-314">則當您的程式碼執行預存程序時，也必須使用名為 `@CustomerID`的參數。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-314">When your code executes the stored procedure, it must also use a parameter named `@CustomerID`.</span></span>

```sql
CREATE PROCEDURE dbo.CustOrderHist @CustomerID varchar(5)
```

### <a name="example"></a><span data-ttu-id="7ae2a-315">範例</span><span class="sxs-lookup"><span data-stu-id="7ae2a-315">Example</span></span>

<span data-ttu-id="7ae2a-316">此範例會示範如何在 `Northwind` 範例資料庫中呼叫 SQL Server 預存程序。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-316">This example demonstrates how to call a SQL Server stored procedure in the `Northwind` sample database.</span></span> <span data-ttu-id="7ae2a-317">預存程序的名稱為 `dbo.SalesByCategory` ，而且具有名為 `@CategoryName` 的輸入參數 (資料型別為 `nvarchar(15)`)。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-317">The name of the stored procedure is `dbo.SalesByCategory` and it has an input parameter named `@CategoryName` with a data type of `nvarchar(15)`.</span></span> <span data-ttu-id="7ae2a-318">此程式碼會在 Using 區塊中建立新的 <xref:System.Data.SqlClient.SqlConnection> ，這樣當程序結束時就會清除連接。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-318">The code creates a new <xref:System.Data.SqlClient.SqlConnection> inside a using block so that the connection is disposed when the procedure ends.</span></span> <span data-ttu-id="7ae2a-319"><xref:System.Data.SqlClient.SqlCommand> 和 <xref:System.Data.SqlClient.SqlParameter> 物件會建立，其屬性也會設定。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-319">The <xref:System.Data.SqlClient.SqlCommand> and <xref:System.Data.SqlClient.SqlParameter> objects are created, and their properties set.</span></span> <span data-ttu-id="7ae2a-320"><xref:System.Data.SqlClient.SqlDataReader> 會執行 `SqlCommand` 並從預存程序傳回結果集，在主控台視窗中顯示輸出。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-320">A <xref:System.Data.SqlClient.SqlDataReader> executes the `SqlCommand` and returns the result set from the stored procedure, displaying the output in the console window.</span></span>

> [!NOTE]
> <span data-ttu-id="7ae2a-321">與其建立 `SqlCommand` 和 `SqlParameter` 物件，然後再以個別的陳述式設定屬性，您可以選擇使用其中一個多載建構函式 (Constructor)，以單一的陳述式設定多個屬性。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-321">Instead of creating `SqlCommand` and `SqlParameter` objects and then setting properties in separate statements, you can instead elect to use one of the overloaded constructors to set multiple properties in a single statement.</span></span>

[!code-csharp[DataWorks SqlClient.StoredProcedure#1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SqlClient.StoredProcedure/CS/source.cs#1)]
[!code-vb[DataWorks SqlClient.StoredProcedure#1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SqlClient.StoredProcedure/VB/source.vb#1)]

## <a name="using-parameters-with-an-oledbcommand-or-odbccommand"></a><span data-ttu-id="7ae2a-322">使用參數配合 OleDbCommand 或 OdbcCommand</span><span class="sxs-lookup"><span data-stu-id="7ae2a-322">Using parameters with an OleDbCommand or OdbcCommand</span></span>

<span data-ttu-id="7ae2a-323">將參數與 <xref:System.Data.OleDb.OleDbCommand> 或 <xref:System.Data.Odbc.OdbcCommand>搭配使用時，加入至 `Parameters` 集合的參數順序必須與預存程序中所定義的參數順序相符。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-323">When using parameters with an <xref:System.Data.OleDb.OleDbCommand> or <xref:System.Data.Odbc.OdbcCommand>, the order of the parameters added to the `Parameters` collection must match the order of the parameters defined in your stored procedure.</span></span> <span data-ttu-id="7ae2a-324">.NET Framework Data Provider for OLE DB 和 ODBC 的.NET Framework 資料提供者在預存程序的參數視為預留位置，並套用順序的參數值。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-324">The .NET Framework Data Provider for OLE DB and .NET Framework Data Provider for ODBC treat parameters in a stored procedure as placeholders and apply parameter values in order.</span></span> <span data-ttu-id="7ae2a-325">此外，傳回值參數必須是第一個加入至 `Parameters` 集合的參數。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-325">In addition, return value parameters must be the first parameters added to the `Parameters` collection.</span></span>

<span data-ttu-id="7ae2a-326">.NET Framework Data Provider for OLE DB 和 ODBC 的.NET Framework 資料提供者不支援具名的參數來傳遞參數至 SQL 陳述式或預存程序。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-326">The .NET Framework Data Provider for OLE DB and .NET Framework Data Provider for ODBC do not support named parameters for passing parameters to an SQL statement or a stored procedure.</span></span> <span data-ttu-id="7ae2a-327">這種情況下，您必須使用問號 (?) 預留位置，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-327">In this case, you must use the question mark (?) placeholder, as in the following example.</span></span>

```sql
SELECT * FROM Customers WHERE CustomerID = ?
```

<span data-ttu-id="7ae2a-328">所以， `Parameter` 物件加入至 `Parameters` 集合的順序，必須直接對應至參數的 ?</span><span class="sxs-lookup"><span data-stu-id="7ae2a-328">As a result, the order in which `Parameter` objects are added to the `Parameters` collection must directly correspond to the position of the ?</span></span> <span data-ttu-id="7ae2a-329">預留位置。</span><span class="sxs-lookup"><span data-stu-id="7ae2a-329">placeholder for the parameter.</span></span>

### <a name="oledb-example"></a><span data-ttu-id="7ae2a-330">OleDb 範例</span><span class="sxs-lookup"><span data-stu-id="7ae2a-330">OleDb Example</span></span>

```vb
Dim command As OleDbCommand = New OleDbCommand( _
  "SampleProc", connection)
command.CommandType = CommandType.StoredProcedure

Dim parameter As OleDbParameter = command.Parameters.Add( _
  "RETURN_VALUE", OleDbType.Integer)
parameter.Direction = ParameterDirection.ReturnValue

parameter = command.Parameters.Add( _
  "@InputParm", OleDbType.VarChar, 12)
parameter.Value = "Sample Value"

parameter = command.Parameters.Add( _
  "@OutputParm", OleDbType.VarChar, 28)
parameter.Direction = ParameterDirection.Output
```

```csharp
OleDbCommand command = new OleDbCommand("SampleProc", connection);
command.CommandType = CommandType.StoredProcedure;

OleDbParameter parameter = command.Parameters.Add(
  "RETURN_VALUE", OleDbType.Integer);
parameter.Direction = ParameterDirection.ReturnValue;

parameter = command.Parameters.Add(
  "@InputParm", OleDbType.VarChar, 12);
parameter.Value = "Sample Value";

parameter = command.Parameters.Add(
  "@OutputParm", OleDbType.VarChar, 28);
parameter.Direction = ParameterDirection.Output;
```

## <a name="odbc-example"></a><span data-ttu-id="7ae2a-331">Odbc 範例</span><span class="sxs-lookup"><span data-stu-id="7ae2a-331">Odbc Example</span></span>

```vb
Dim command As OdbcCommand = New OdbcCommand( _
  "{ ? = CALL SampleProc(?, ?) }", connection)
command.CommandType = CommandType.StoredProcedure

Dim parameter As OdbcParameter = command.Parameters.Add("RETURN_VALUE", OdbcType.Int)
parameter.Direction = ParameterDirection.ReturnValue

parameter = command.Parameters.Add( _
  "@InputParm", OdbcType.VarChar, 12)
parameter.Value = "Sample Value"

parameter = command.Parameters.Add( _
  "@OutputParm", OdbcType.VarChar, 28)
parameter.Direction = ParameterDirection.Output
```

```csharp
OdbcCommand command = new OdbcCommand( _
  "{ ? = CALL SampleProc(?, ?) }", connection);
command.CommandType = CommandType.StoredProcedure;

OdbcParameter parameter = command.Parameters.Add( _
  "RETURN_VALUE", OdbcType.Int);
parameter.Direction = ParameterDirection.ReturnValue;

parameter = command.Parameters.Add( _
  "@InputParm", OdbcType.VarChar, 12);
parameter.Value = "Sample Value";

parameter = command.Parameters.Add( _
  "@OutputParm", OdbcType.VarChar, 28);
parameter.Direction = ParameterDirection.Output;
```

## <a name="see-also"></a><span data-ttu-id="7ae2a-332">另請參閱</span><span class="sxs-lookup"><span data-stu-id="7ae2a-332">See also</span></span>

- [<span data-ttu-id="7ae2a-333">命令和參數</span><span class="sxs-lookup"><span data-stu-id="7ae2a-333">Commands and Parameters</span></span>](commands-and-parameters.md)
- [<span data-ttu-id="7ae2a-334">DataAdapter 參數</span><span class="sxs-lookup"><span data-stu-id="7ae2a-334">DataAdapter Parameters</span></span>](dataadapter-parameters.md)
- [<span data-ttu-id="7ae2a-335">ADO.NET 中的資料類型對應</span><span class="sxs-lookup"><span data-stu-id="7ae2a-335">Data Type Mappings in ADO.NET</span></span>](data-type-mappings-in-ado-net.md)
- [<span data-ttu-id="7ae2a-336">ADO.NET 概觀</span><span class="sxs-lookup"><span data-stu-id="7ae2a-336">ADO.NET Overview</span></span>](ado-net-overview.md)
