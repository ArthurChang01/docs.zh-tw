---
title: 合併資料集內容
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: e5e9309a-3ebb-4a9c-9d78-21c4e2bafc5b
ms.openlocfilehash: c0cc0834dc087df89131a720f517cd34f757a0f3
ms.sourcegitcommit: 11f11ca6cefe555972b3a5c99729d1a7523d8f50
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/03/2018
---
# <a name="merging-dataset-contents"></a><span data-ttu-id="c81c7-102">合併資料集內容</span><span class="sxs-lookup"><span data-stu-id="c81c7-102">Merging DataSet Contents</span></span>
<span data-ttu-id="c81c7-103">您可以使用 <xref:System.Data.DataSet.Merge%2A> 方法，將 <xref:System.Data.DataSet>、<xref:System.Data.DataTable> 或 <xref:System.Data.DataRow> 陣列的內容合併至現有的 `DataSet` 中。</span><span class="sxs-lookup"><span data-stu-id="c81c7-103">You can use the <xref:System.Data.DataSet.Merge%2A> method to merge the contents of a <xref:System.Data.DataSet>, <xref:System.Data.DataTable>, or <xref:System.Data.DataRow> array into an existing `DataSet`.</span></span> <span data-ttu-id="c81c7-104">有許多因素和選項會影響新資料合併至現有 `DataSet` 的方式。</span><span class="sxs-lookup"><span data-stu-id="c81c7-104">Several factors and options affect how new data is merged into an existing `DataSet`.</span></span>  
  
## <a name="primary-keys"></a><span data-ttu-id="c81c7-105">主索引鍵</span><span class="sxs-lookup"><span data-stu-id="c81c7-105">Primary Keys</span></span>  
 <span data-ttu-id="c81c7-106">如果從合併接收新資料和結構描述的資料表有主索引鍵，則來自內送資料的新資料列會與現有資料列 (與內送資料中的資料列具有相同的 <xref:System.Data.DataRowVersion.Original> 主索引鍵值) 進行比對。</span><span class="sxs-lookup"><span data-stu-id="c81c7-106">If the table receiving new data and schema from a merge has a primary key, new rows from the incoming data are matched with existing rows that have the same <xref:System.Data.DataRowVersion.Original> primary key values as those in the incoming data.</span></span> <span data-ttu-id="c81c7-107">如果來自內送結構描述的資料行與現有結構描述相符，則會修改現有資料列內的資料。</span><span class="sxs-lookup"><span data-stu-id="c81c7-107">If the columns from the incoming schema match those of the existing schema, the data in the existing rows is modified.</span></span> <span data-ttu-id="c81c7-108">系統會根據 <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> 參數來忽略或加入與現有結構描述不符的資料行。</span><span class="sxs-lookup"><span data-stu-id="c81c7-108">Columns that do not match the existing schema are either ignored or added based on the <xref:System.Data.Common.DataAdapter.MissingSchemaAction%2A> parameter.</span></span> <span data-ttu-id="c81c7-109">主索引鍵值不符合任何現有資料列的新資料列會附加至現有的資料表。</span><span class="sxs-lookup"><span data-stu-id="c81c7-109">New rows with primary key values that do not match any existing rows are appended to the existing table.</span></span>  
  
 <span data-ttu-id="c81c7-110">如果內送或現有資料列的資料列狀態為 <xref:System.Data.DataRowState.Added>，系統就會使用 <xref:System.Data.DataRowVersion.Current> 資料列的 `Added` 主索引鍵值來比對其主索引鍵值，因為沒有任何 `Original` 資料列版本存在。</span><span class="sxs-lookup"><span data-stu-id="c81c7-110">If incoming or existing rows have a row state of <xref:System.Data.DataRowState.Added>, their primary key values are matched using the <xref:System.Data.DataRowVersion.Current> primary key value of the `Added` row because no `Original` row version exists.</span></span>  
  
 <span data-ttu-id="c81c7-111">如果內送資料表和現有資料表包含名稱相同但資料型別不同的資料行，則會擲回例外狀況，而且會引發 <xref:System.Data.DataSet.MergeFailed> 的 `DataSet` 事件。</span><span class="sxs-lookup"><span data-stu-id="c81c7-111">If an incoming table and an existing table contain a column with the same name but different data types, an exception is thrown and the <xref:System.Data.DataSet.MergeFailed> event of the `DataSet` is raised.</span></span> <span data-ttu-id="c81c7-112">如果內送資料表和現有資料表都已定義索引鍵，但主索引鍵用於不同的資料行，則會擲回例外狀況，而且會引發 `MergeFailed` 的 `DataSet` 事件。</span><span class="sxs-lookup"><span data-stu-id="c81c7-112">If an incoming table and an existing table both have defined keys, but the primary keys are for different columns, an exception is thrown and the `MergeFailed` event of the `DataSet` is raised.</span></span>  
  
 <span data-ttu-id="c81c7-113">如果在合併時接收新資料的資料表沒有主索引鍵，則來自內送資料的新資料列將無法與資料表中的現有資料列對應，反而會附加至現有資料表。</span><span class="sxs-lookup"><span data-stu-id="c81c7-113">If the table receiving new data from a merge does not have a primary key, new rows from the incoming data cannot be matched to existing rows in the table and are instead appended to the existing table.</span></span>  
  
## <a name="table-names-and-namespaces"></a><span data-ttu-id="c81c7-114">資料表名稱和命名空間</span><span class="sxs-lookup"><span data-stu-id="c81c7-114">Table Names and Namespaces</span></span>  
 <span data-ttu-id="c81c7-115">您可以選擇性地指派 <xref:System.Data.DataTable> 屬性值給 <xref:System.Data.DataTable.Namespace%2A> 物件。</span><span class="sxs-lookup"><span data-stu-id="c81c7-115"><xref:System.Data.DataTable> objects can optionally be assigned a <xref:System.Data.DataTable.Namespace%2A> property value.</span></span> <span data-ttu-id="c81c7-116">當您指派 <xref:System.Data.DataTable.Namespace%2A> 值時，<xref:System.Data.DataSet> 可以包含多個具有相同 <xref:System.Data.DataTable> 值的 <xref:System.Data.DataTable.TableName%2A> 物件。</span><span class="sxs-lookup"><span data-stu-id="c81c7-116">When <xref:System.Data.DataTable.Namespace%2A> values are assigned, a <xref:System.Data.DataSet> can contain multiple <xref:System.Data.DataTable> objects with the same <xref:System.Data.DataTable.TableName%2A> value.</span></span> <span data-ttu-id="c81c7-117">進行合併作業期間，<xref:System.Data.DataTable.TableName%2A> 和 <xref:System.Data.DataTable.Namespace%2A> 都會用於識別合併的目標。</span><span class="sxs-lookup"><span data-stu-id="c81c7-117">During merge operations, both <xref:System.Data.DataTable.TableName%2A> and <xref:System.Data.DataTable.Namespace%2A> are used to identify the target of a merge.</span></span> <span data-ttu-id="c81c7-118">如果沒有指派任何 <xref:System.Data.DataTable.Namespace%2A>，系統就只會使用 <xref:System.Data.DataTable.TableName%2A> 來識別合併的目標。</span><span class="sxs-lookup"><span data-stu-id="c81c7-118">If no <xref:System.Data.DataTable.Namespace%2A> has been assigned, only the <xref:System.Data.DataTable.TableName%2A> is used to identify the target of a merge.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c81c7-119">這個行為在 .NET Framework 2.0 版中已變更。</span><span class="sxs-lookup"><span data-stu-id="c81c7-119">This behavior changed in version 2.0 of the .NET Framework.</span></span> <span data-ttu-id="c81c7-120">在 1.1 版中，雖然系統支援命名空間 (Namespace)，但是會在合併作業期間忽略命名空間。</span><span class="sxs-lookup"><span data-stu-id="c81c7-120">In version 1.1, namespaces were supported but were ignored during merge operations.</span></span> <span data-ttu-id="c81c7-121">因此，使用 <xref:System.Data.DataSet> 屬性值的 <xref:System.Data.DataTable.Namespace%2A> 將根據您正在執行的 .NET Framework 版本而具有不同的行為。</span><span class="sxs-lookup"><span data-stu-id="c81c7-121">For this reason, a <xref:System.Data.DataSet> that uses <xref:System.Data.DataTable.Namespace%2A> property values will have different behaviors depending on which version of the .NET Framework you are running.</span></span> <span data-ttu-id="c81c7-122">例如，假設您有兩個 `DataSets`，其中包含 `DataTables` 屬性值相同但 <xref:System.Data.DataTable.TableName%2A> 屬性值不同的 <xref:System.Data.DataTable.Namespace%2A>。</span><span class="sxs-lookup"><span data-stu-id="c81c7-122">For example, suppose you have two `DataSets` containing `DataTables` with the same <xref:System.Data.DataTable.TableName%2A> property values but different <xref:System.Data.DataTable.Namespace%2A> property values.</span></span> <span data-ttu-id="c81c7-123">在 .NET Framework 1.1 版中，當您合併這兩個 <xref:System.Data.DataTable.Namespace%2A> 物件時，系統會忽略不同的 <xref:System.Data.DataSet> 名稱。</span><span class="sxs-lookup"><span data-stu-id="c81c7-123">In version 1.1 of the .NET Framework, the different <xref:System.Data.DataTable.Namespace%2A> names will be ignored when merging the two <xref:System.Data.DataSet> objects.</span></span> <span data-ttu-id="c81c7-124">不過，從 2.0 版開始，合併會導致系統在目標 `DataTables` 中建立兩個新的 <xref:System.Data.DataSet>。</span><span class="sxs-lookup"><span data-stu-id="c81c7-124">However, starting with version 2.0, merging causes two new `DataTables` to be created in the target <xref:System.Data.DataSet>.</span></span> <span data-ttu-id="c81c7-125">原始 `DataTables` 將不會受到合併的影響。</span><span class="sxs-lookup"><span data-stu-id="c81c7-125">The original `DataTables` will be unaffected by the merge.</span></span>  
  
## <a name="preservechanges"></a><span data-ttu-id="c81c7-126">PreserveChanges</span><span class="sxs-lookup"><span data-stu-id="c81c7-126">PreserveChanges</span></span>  
 <span data-ttu-id="c81c7-127">當您將 `DataSet`、`DataTable` 或 `DataRow` 陣列傳遞給 `Merge` 方法時，可以包含選擇性參數來指定是否要保留現有 `DataSet` 的變更，以及如何處理內送資料中發現的新結構描述項目。</span><span class="sxs-lookup"><span data-stu-id="c81c7-127">When you pass a `DataSet`, `DataTable`, or `DataRow` array to the `Merge` method, you can include optional parameters that specify whether or not to preserve changes in the existing `DataSet`, and how to handle new schema elements found in the incoming data.</span></span> <span data-ttu-id="c81c7-128">內送資料後續參數中的第一個參數是布林值 (Boolean) 旗標 <xref:System.Data.LoadOption.PreserveChanges>，它可指定是否要保留現有 `DataSet` 的變更。</span><span class="sxs-lookup"><span data-stu-id="c81c7-128">The first of these parameters after the incoming data is a Boolean flag, <xref:System.Data.LoadOption.PreserveChanges>, which specifies whether or not to preserve the changes in the existing `DataSet`.</span></span> <span data-ttu-id="c81c7-129">如果 `PreserveChanges` 旗標設定為 `true`，內送值就不會覆寫現有資料列之 `Current` 資料列版本中現有的值。</span><span class="sxs-lookup"><span data-stu-id="c81c7-129">If the `PreserveChanges` flag is set to `true`, incoming values do not overwrite existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="c81c7-130">如果 `PreserveChanges` 旗標設定為 `false`，內送值就會覆寫現有資料列之 `Current` 資料列版本中現有的值。</span><span class="sxs-lookup"><span data-stu-id="c81c7-130">If the `PreserveChanges` flag is set to `false`, incoming values do overwrite the existing values in the `Current` row version of the existing row.</span></span> <span data-ttu-id="c81c7-131">如果您沒有指定 `PreserveChanges` 旗標，它預設會設定為 `false`。</span><span class="sxs-lookup"><span data-stu-id="c81c7-131">If the `PreserveChanges` flag is not specified, it is set to `false` by default.</span></span> <span data-ttu-id="c81c7-132">如需詳細資料列版本的詳細資訊，請參閱[資料列狀態和資料列版本](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)。</span><span class="sxs-lookup"><span data-stu-id="c81c7-132">For more information about row versions, see [Row States and Row Versions](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md).</span></span>  
  
 <span data-ttu-id="c81c7-133">當 `PreserveChanges` 為 `true` 時，現有資料列的資料會保留在現有資料列的 <xref:System.Data.DataRowVersion.Current> 資料列版本中，而現有資料列之 <xref:System.Data.DataRowVersion.Original> 資料列版本的資料則會以內送資料列之 `Original` 資料列版本的資料加以覆寫。</span><span class="sxs-lookup"><span data-stu-id="c81c7-133">When `PreserveChanges` is `true`, the data from the existing row is maintained in the <xref:System.Data.DataRowVersion.Current> row version of the existing row, while the data from the <xref:System.Data.DataRowVersion.Original> row version of the existing row is overwritten with the data from the `Original` row version of the incoming row.</span></span> <span data-ttu-id="c81c7-134">現有資料列的 <xref:System.Data.DataRow.RowState%2A> 會設定為 <xref:System.Data.DataRowState.Modified>。</span><span class="sxs-lookup"><span data-stu-id="c81c7-134">The <xref:System.Data.DataRow.RowState%2A> of the existing row is set to <xref:System.Data.DataRowState.Modified>.</span></span> <span data-ttu-id="c81c7-135">下列情況則例外：</span><span class="sxs-lookup"><span data-stu-id="c81c7-135">The following exceptions apply:</span></span>  
  
-   <span data-ttu-id="c81c7-136">如果現有資料列的 `RowState` 為 `Deleted`，則這個 `RowState` 會維持 `Deleted` 而不會設定為 `Modified`。</span><span class="sxs-lookup"><span data-stu-id="c81c7-136">If the existing row has a `RowState` of `Deleted`, this `RowState` remains `Deleted` and is not set to `Modified`.</span></span> <span data-ttu-id="c81c7-137">在這種情況下，內送資料列的資料仍然會儲存在現有資料列的 `Original` 資料列版本中，並覆寫現有資料列的 `Original` 資料列版本 (除非內送資料列的 `RowState` 為 `Added`)。</span><span class="sxs-lookup"><span data-stu-id="c81c7-137">In this case, the data from the incoming row will still be stored in the `Original` row version of the existing row, overwriting the `Original` row version of the existing row (unless the incoming row has a `RowState` of `Added`).</span></span>  
  
-   <span data-ttu-id="c81c7-138">如果內送資料列的 `RowState` 為 `Added`，現有資料列之 `Original` 資料列版本的資料將不會以內送資料列的資料加以覆寫，因為內送資料列沒有 `Original` 資料列版本。</span><span class="sxs-lookup"><span data-stu-id="c81c7-138">If the incoming row has a `RowState` of `Added`, the data from the `Original` row version of the existing row will not be overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>  
  
 <span data-ttu-id="c81c7-139">當 `PreserveChanges` 為 `false` 時，現有資料列中的 `Current` 和 `Original` 資料列版本都會以內送資料列的資料加以覆寫，而且現有資料列的 `RowState` 會設定為內送資料列的 `RowState`。</span><span class="sxs-lookup"><span data-stu-id="c81c7-139">When `PreserveChanges` is `false`, both the `Current` and `Original` row versions in the existing row are overwritten with the data from the incoming row, and the `RowState` of the existing row is set to the `RowState` of the incoming row.</span></span> <span data-ttu-id="c81c7-140">下列情況則例外：</span><span class="sxs-lookup"><span data-stu-id="c81c7-140">The following exceptions apply:</span></span>  
  
-   <span data-ttu-id="c81c7-141">如果內送資料列的 `RowState` 為 `Unchanged` 而且現有資料列的 `RowState` 為 `Modified`、`Deleted` 或 `Added`，則現有資料列的 `RowState` 會設定為 `Modified`。</span><span class="sxs-lookup"><span data-stu-id="c81c7-141">If the incoming row has a `RowState` of `Unchanged` and the existing row has a `RowState` of `Modified`, `Deleted`, or `Added`, the `RowState` of the existing row is set to `Modified`.</span></span>  
  
-   <span data-ttu-id="c81c7-142">如果內送資料列的 `RowState` 為 `Added`，而且現有資料列的 `RowState` 為 `Unchanged`、`Modified` 或 `Deleted`，則現有資料列的 `RowState` 會設定為 `Modified`。</span><span class="sxs-lookup"><span data-stu-id="c81c7-142">If the incoming row has a `RowState` of `Added`, and the existing row has a `RowState` of `Unchanged`, `Modified`, or `Deleted`, the `RowState` of the existing row is set to `Modified`.</span></span> <span data-ttu-id="c81c7-143">此外，現有資料列之 `Original` 資料列版本的資料不會以內送資料列的資料加以覆寫，因為內送資料列沒有 `Original` 資料列版本。</span><span class="sxs-lookup"><span data-stu-id="c81c7-143">Also, the data from the `Original` row version of the existing row is not overwritten with data from the incoming row, because the incoming row does not have an `Original` row version.</span></span>  
  
## <a name="missingschemaaction"></a><span data-ttu-id="c81c7-144">MissingSchemaAction</span><span class="sxs-lookup"><span data-stu-id="c81c7-144">MissingSchemaAction</span></span>  
 <span data-ttu-id="c81c7-145">您可以使用 <xref:System.Data.MissingSchemaAction> 方法的選擇性 `Merge` 參數來指定 `Merge` 該如何處理不屬於現有 `DataSet` 之內送資料中的結構描述項目。</span><span class="sxs-lookup"><span data-stu-id="c81c7-145">You can use the optional <xref:System.Data.MissingSchemaAction> parameter of the `Merge` method to specify how `Merge` will handle schema elements in the incoming data that are not part of the existing `DataSet`.</span></span>  
  
 <span data-ttu-id="c81c7-146">下表將說明 `MissingSchemaAction` 的選項。</span><span class="sxs-lookup"><span data-stu-id="c81c7-146">The following table describes the options for `MissingSchemaAction`.</span></span>  
  
|<span data-ttu-id="c81c7-147">MissingSchemaAction 選項</span><span class="sxs-lookup"><span data-stu-id="c81c7-147">MissingSchemaAction option</span></span>|<span data-ttu-id="c81c7-148">描述</span><span class="sxs-lookup"><span data-stu-id="c81c7-148">Description</span></span>|  
|--------------------------------|-----------------|  
|<xref:System.Data.MissingSchemaAction.Add>|<span data-ttu-id="c81c7-149">將新的結構描述資訊加入至 `DataSet`，並將內送值填入新資料行。</span><span class="sxs-lookup"><span data-stu-id="c81c7-149">Add the new schema information to the `DataSet` and populate the new columns with the incoming values.</span></span> <span data-ttu-id="c81c7-150">這是預設值。</span><span class="sxs-lookup"><span data-stu-id="c81c7-150">This is the default.</span></span>|  
|<xref:System.Data.MissingSchemaAction.AddWithKey>|<span data-ttu-id="c81c7-151">將新的結構描述和主索引鍵資訊加入至 `DataSet`，並將內送值填入新資料行。</span><span class="sxs-lookup"><span data-stu-id="c81c7-151">Add the new schema and primary key information to the `DataSet` and populate the new columns with the incoming values.</span></span>|  
|<xref:System.Data.MissingSchemaAction.Error>|<span data-ttu-id="c81c7-152">若有不相符的結構描述資訊，則會發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c81c7-152">Throw an exception if mismatched schema information is encountered.</span></span>|  
|<xref:System.Data.MissingSchemaAction.Ignore>|<span data-ttu-id="c81c7-153">忽略新的結構描述資訊。</span><span class="sxs-lookup"><span data-stu-id="c81c7-153">Ignore the new schema information.</span></span>|  
  
## <a name="constraints"></a><span data-ttu-id="c81c7-154">條件約束</span><span class="sxs-lookup"><span data-stu-id="c81c7-154">Constraints</span></span>  
 <span data-ttu-id="c81c7-155">使用 `Merge` 方法時，系統要等到所有的新資料都已經加入至現有 `DataSet` 之後，才會檢查條件約束。</span><span class="sxs-lookup"><span data-stu-id="c81c7-155">With the `Merge` method, constraints are not checked until all new data has been added to the existing `DataSet`.</span></span> <span data-ttu-id="c81c7-156">一旦資料加入後，條件約束會強制執行於 `DataSet` 中目前的值。</span><span class="sxs-lookup"><span data-stu-id="c81c7-156">Once the data has been added, constraints are enforced on the current values in the `DataSet`.</span></span> <span data-ttu-id="c81c7-157">您必須確保程式碼可處理任何因條件約束違規而造成的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="c81c7-157">You must ensure that your code handles any exceptions that might be thrown due to constraint violations.</span></span>  
  
 <span data-ttu-id="c81c7-158">假設 `DataSet` 中的現有資料列是主索引鍵值為 1 的 `Unchanged` 資料列。</span><span class="sxs-lookup"><span data-stu-id="c81c7-158">Consider a case where an existing row in a `DataSet` is an `Unchanged` row with a primary key value of 1.</span></span> <span data-ttu-id="c81c7-159">當它與 `Modified` 主索引鍵值為 2 而 `Original` 主索引鍵值為 1 的 `Current` 內送資料列進行合併時，現有資料列和內送資料列不會被視為相符，因為 `Original` 主索引鍵值不同。</span><span class="sxs-lookup"><span data-stu-id="c81c7-159">During a merge operation with a `Modified` incoming row with an `Original` primary key value of 2 and a `Current` primary key value of 1, the existing row and the incoming row are not considered matching because the `Original` primary key values differ.</span></span> <span data-ttu-id="c81c7-160">但是，在合併完成而且檢查過條件約束之後，系統會擲回例外狀況，因為該 `Current` 主索引鍵值違反了主索引鍵資料行的唯一條件約束。</span><span class="sxs-lookup"><span data-stu-id="c81c7-160">However, when the merge is completed and constraints are checked, an exception will be thrown because the `Current` primary key values violate the unique constraint for the primary key column.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c81c7-161">當資料列插入含有自動遞增資料行 (例如識別資料行) 的資料庫資料表時，插入作業所傳回的識別資料行值可能會與 `DataSet` 中的值不符，因而導致系統附加而非合併傳回的資料列。</span><span class="sxs-lookup"><span data-stu-id="c81c7-161">When rows are inserted into a database table containing an auto incrementing column such as an identity column, the identity column value returned by the insert may not match the value in the `DataSet`, causing the returned rows to be appended instead of merged.</span></span> <span data-ttu-id="c81c7-162">如需詳細資訊，請參閱[擷取識別或自動編號值](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md)。</span><span class="sxs-lookup"><span data-stu-id="c81c7-162">For more information, see [Retrieving Identity or Autonumber Values](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md).</span></span>  
  
 <span data-ttu-id="c81c7-163">下列程式碼範例會將兩個具有不同結構描述的 `DataSet` 物件合併成結合了兩個內送 `DataSet` 物件之結構描述的單一 `DataSet`。</span><span class="sxs-lookup"><span data-stu-id="c81c7-163">The following code example merges two `DataSet` objects with differents schemas into one `DataSet` with the combined schemas of the two incoming `DataSet` objects.</span></span>  
  
 [!code-csharp[DataWorks DataSet.Merge#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.Merge#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.Merge/VB/source.vb#1)]  
  
 <span data-ttu-id="c81c7-164">下列程式碼範例會採取含有更新的現有 `DataSet`，並將這些更新傳遞至要在資料來源中處理的 `DataAdapter`。</span><span class="sxs-lookup"><span data-stu-id="c81c7-164">The following code example takes an existing `DataSet` with updates and passes those updates to a `DataAdapter` to be processed at the data source.</span></span> <span data-ttu-id="c81c7-165">接著，結果會合併至原始 `DataSet` 中。</span><span class="sxs-lookup"><span data-stu-id="c81c7-165">The results are then merged into the original `DataSet`.</span></span> <span data-ttu-id="c81c7-166">在拒絕導致錯誤發生的變更後，即可透過 `AcceptChanges` 認可已合併的變更。</span><span class="sxs-lookup"><span data-stu-id="c81c7-166">After rejecting changes that resulted in an error, the merged changes are committed with `AcceptChanges`.</span></span>  
  
 [!code-csharp[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#1)]
 [!code-vb[DataWorks DataSet.MergeAcceptChanges#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#1)]  
  
 [!code-csharp[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/CS/source.cs#2)]
 [!code-vb[DataWorks DataSet.MergeAcceptChanges#2](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks DataSet.MergeAcceptChanges/VB/source.vb#2)]  
  
## <a name="see-also"></a><span data-ttu-id="c81c7-167">另請參閱</span><span class="sxs-lookup"><span data-stu-id="c81c7-167">See Also</span></span>  
 [<span data-ttu-id="c81c7-168">DataSet、DataTable 和 DataView</span><span class="sxs-lookup"><span data-stu-id="c81c7-168">DataSets, DataTables, and DataViews</span></span>](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/index.md)  
 [<span data-ttu-id="c81c7-169">資料列狀態和資料列版本</span><span class="sxs-lookup"><span data-stu-id="c81c7-169">Row States and Row Versions</span></span>](../../../../../docs/framework/data/adonet/dataset-datatable-dataview/row-states-and-row-versions.md)  
 [<span data-ttu-id="c81c7-170">DataAdapter 和 DataReader</span><span class="sxs-lookup"><span data-stu-id="c81c7-170">DataAdapters and DataReaders</span></span>](../../../../../docs/framework/data/adonet/dataadapters-and-datareaders.md)  
 [<span data-ttu-id="c81c7-171">在 ADO.NET 中擷取和修改資料</span><span class="sxs-lookup"><span data-stu-id="c81c7-171">Retrieving and Modifying Data in ADO.NET</span></span>](../../../../../docs/framework/data/adonet/retrieving-and-modifying-data.md)  
 [<span data-ttu-id="c81c7-172">擷取身分識別或自動編號值</span><span class="sxs-lookup"><span data-stu-id="c81c7-172">Retrieving Identity or Autonumber Values</span></span>](../../../../../docs/framework/data/adonet/retrieving-identity-or-autonumber-values.md)  
 [<span data-ttu-id="c81c7-173">ADO.NET Managed 提供者和 DataSet 開發人員中心</span><span class="sxs-lookup"><span data-stu-id="c81c7-173">ADO.NET Managed Providers and DataSet Developer Center</span></span>](http://go.microsoft.com/fwlink/?LinkId=217917)
