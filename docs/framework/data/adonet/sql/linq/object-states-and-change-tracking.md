---
title: 物件狀態和變更追蹤
ms.date: 03/30/2017
ms.assetid: 7a808b00-9c3c-479a-aa94-717280fefd71
ms.openlocfilehash: 63b04d3a4b6e48594e9664833a6e539d62bbab0e
ms.sourcegitcommit: 0be8a279af6d8a43e03141e349d3efd5d35f8767
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/18/2019
ms.locfileid: "59191151"
---
# <a name="object-states-and-change-tracking"></a><span data-ttu-id="af3d6-102">物件狀態和變更追蹤</span><span class="sxs-lookup"><span data-stu-id="af3d6-102">Object States and Change-Tracking</span></span>
[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] <span data-ttu-id="af3d6-103">物件一律會處於某種*狀態*。</span><span class="sxs-lookup"><span data-stu-id="af3d6-103">objects always participate in some *state*.</span></span> <span data-ttu-id="af3d6-104">例如，[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 建立新物件時，該物件會是 `Unchanged` 狀態。</span><span class="sxs-lookup"><span data-stu-id="af3d6-104">For example, when [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] creates a new object, the object is in `Unchanged` state.</span></span> <span data-ttu-id="af3d6-105">您自己建立的新物件不知道<xref:System.Data.Linq.DataContext>且位於`Untracked`狀態。</span><span class="sxs-lookup"><span data-stu-id="af3d6-105">A new object that you yourself create is unknown to the <xref:System.Data.Linq.DataContext> and is in `Untracked` state.</span></span> <span data-ttu-id="af3d6-106">順利執行 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 之後，[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 得知的所有物件都會是 `Unchanged` 狀態 </span><span class="sxs-lookup"><span data-stu-id="af3d6-106">Following successful execution of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, all objects known to [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] are in `Unchanged` state.</span></span> <span data-ttu-id="af3d6-107">(唯一的例外是已順利從資料庫中刪除的物件，這些物件是 `Deleted` 狀態，而且無法在該 <xref:System.Data.Linq.DataContext> 執行個體中使用)。</span><span class="sxs-lookup"><span data-stu-id="af3d6-107">(The single exception is represented by those that have been successfully deleted from the database, which are in `Deleted` state and unusable in that <xref:System.Data.Linq.DataContext> instance.)</span></span>  
  
## <a name="object-states"></a><span data-ttu-id="af3d6-108">物件狀態</span><span class="sxs-lookup"><span data-stu-id="af3d6-108">Object States</span></span>  
 <span data-ttu-id="af3d6-109">下表列出 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 物件的可能狀態。</span><span class="sxs-lookup"><span data-stu-id="af3d6-109">The following table lists the possible states for [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] objects.</span></span>  
  
|<span data-ttu-id="af3d6-110">狀況</span><span class="sxs-lookup"><span data-stu-id="af3d6-110">State</span></span>|<span data-ttu-id="af3d6-111">描述</span><span class="sxs-lookup"><span data-stu-id="af3d6-111">Description</span></span>|  
|-----------|-----------------|  
|`Untracked`|<span data-ttu-id="af3d6-112">[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 無法追蹤的物件。</span><span class="sxs-lookup"><span data-stu-id="af3d6-112">An object not tracked by [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)].</span></span> <span data-ttu-id="af3d6-113">範例包含下列：</span><span class="sxs-lookup"><span data-stu-id="af3d6-113">Examples include the following:</span></span><br /><br /> <span data-ttu-id="af3d6-114">-未透過目前查詢物件<xref:System.Data.Linq.DataContext>（例如新建立的物件）。</span><span class="sxs-lookup"><span data-stu-id="af3d6-114">-   An object not queried through the current <xref:System.Data.Linq.DataContext> (such as a newly created object).</span></span><br /><span data-ttu-id="af3d6-115">-建立透過還原序列化的物件</span><span class="sxs-lookup"><span data-stu-id="af3d6-115">-   An object created through deserialization</span></span><br /><span data-ttu-id="af3d6-116">-透過不同的查詢物件<xref:System.Data.Linq.DataContext>。</span><span class="sxs-lookup"><span data-stu-id="af3d6-116">-   An object queried through a different <xref:System.Data.Linq.DataContext>.</span></span>|  
|`Unchanged`|<span data-ttu-id="af3d6-117">使用 <xref:System.Data.Linq.DataContext> 擷取而且已知自建立後尚未修改的物件。</span><span class="sxs-lookup"><span data-stu-id="af3d6-117">An object retrieved by using the current <xref:System.Data.Linq.DataContext> and not known to have been modified since it was created.</span></span>|  
|`PossiblyModified`|<span data-ttu-id="af3d6-118">物件，即*附加*至<xref:System.Data.Linq.DataContext>。</span><span class="sxs-lookup"><span data-stu-id="af3d6-118">An object which is *attached* to a <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="af3d6-119">如需詳細資訊，請參閱 <<c0> [ 資料擷取和 CUD 作業 (LINQ to SQL) 的多層式架構應用程式中](../../../../../../docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md)。</span><span class="sxs-lookup"><span data-stu-id="af3d6-119">For more information, see [Data Retrieval and CUD Operations in N-Tier Applications (LINQ to SQL)](../../../../../../docs/framework/data/adonet/sql/linq/data-retrieval-and-cud-operations-in-n-tier-applications.md).</span></span>|  
|`ToBeInserted`|<span data-ttu-id="af3d6-120">未使用目前 <xref:System.Data.Linq.DataContext> 擷取的物件。</span><span class="sxs-lookup"><span data-stu-id="af3d6-120">An object not retrieved by using the current <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="af3d6-121">這會導致 `INSERT` 期間執行資料庫 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 動作。</span><span class="sxs-lookup"><span data-stu-id="af3d6-121">This causes a database `INSERT` during <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span>|  
|`ToBeUpdated`|<span data-ttu-id="af3d6-122">已知自擷取後曾經修改的物件。</span><span class="sxs-lookup"><span data-stu-id="af3d6-122">An object known to have been modified since it was retrieved.</span></span> <span data-ttu-id="af3d6-123">這會導致 `UPDATE` 期間執行資料庫 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 動作。</span><span class="sxs-lookup"><span data-stu-id="af3d6-123">This causes a database `UPDATE` during <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span>|  
|`ToBeDeleted`|<span data-ttu-id="af3d6-124">標記要刪除的物件，這會導致在 `DELETE` 期間執行資料庫 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 動作。</span><span class="sxs-lookup"><span data-stu-id="af3d6-124">An object marked for deletion, causing a database `DELETE` during <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span>|  
|`Deleted`|<span data-ttu-id="af3d6-125">已在資料庫中刪除的物件。</span><span class="sxs-lookup"><span data-stu-id="af3d6-125">An object that has been deleted in the database.</span></span> <span data-ttu-id="af3d6-126">這個狀態為最終狀態，不允許進行其他轉換。</span><span class="sxs-lookup"><span data-stu-id="af3d6-126">This state is final and does not allow for additional transitions.</span></span>|  
  
## <a name="inserting-objects"></a><span data-ttu-id="af3d6-127">插入物件</span><span class="sxs-lookup"><span data-stu-id="af3d6-127">Inserting Objects</span></span>  
 <span data-ttu-id="af3d6-128">您可以使用 `Inserts` 明確要求執行 <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>。</span><span class="sxs-lookup"><span data-stu-id="af3d6-128">You can explicitly request `Inserts` by using <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>.</span></span> <span data-ttu-id="af3d6-129">或者，[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]可以推斷`Inserts`尋找連接至其中一個必須更新的已知物件的物件。</span><span class="sxs-lookup"><span data-stu-id="af3d6-129">Alternatively, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] can infer `Inserts` by finding objects connected to one of the known objects that must be updated.</span></span> <span data-ttu-id="af3d6-130">比方說，如果您加入`Untracked`物件至<xref:System.Data.Linq.EntitySet%601>或設定<xref:System.Data.Linq.EntityRef%601>要`Untracked`物件，`Untracked`可透過圖形中的追蹤物件的物件。</span><span class="sxs-lookup"><span data-stu-id="af3d6-130">For example, if you add an `Untracked` object to an <xref:System.Data.Linq.EntitySet%601> or set an <xref:System.Data.Linq.EntityRef%601> to an `Untracked` object, you make the `Untracked` object reachable by way of tracked objects in the graph.</span></span> <span data-ttu-id="af3d6-131">在處理過程<xref:System.Data.Linq.DataContext.SubmitChanges%2A>，[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]周遊已追蹤的物件，並會探索並不會追蹤任何連線到持續性物件。</span><span class="sxs-lookup"><span data-stu-id="af3d6-131">While processing <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] traverses the tracked objects and discovers any reachable persistent objects that are not tracked.</span></span> <span data-ttu-id="af3d6-132">這些物件會成為等候插入資料庫中的項目。</span><span class="sxs-lookup"><span data-stu-id="af3d6-132">Such objects are candidates for insertion into the database.</span></span>  
  
 <span data-ttu-id="af3d6-133">繼承階層架構中的類別<xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>(`o`) 也會指定為成員的值設定*鑑別子*來比對的物件型別`o`。</span><span class="sxs-lookup"><span data-stu-id="af3d6-133">For classes in an inheritance hierarchy, <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>(`o`) also sets the value of the member designated as the *discriminator* to match the type of the object `o`.</span></span> <span data-ttu-id="af3d6-134">當型別符合預設鑑別子值時，這個動作會導致鑑別子值遭預設值覆寫。</span><span class="sxs-lookup"><span data-stu-id="af3d6-134">In the case of a type matching the default discriminator value, this action causes the discriminator value to be overwritten with the default value.</span></span> <span data-ttu-id="af3d6-135">如需詳細資訊，請參閱 <<c0> [ 繼承支援](../../../../../../docs/framework/data/adonet/sql/linq/inheritance-support.md)。</span><span class="sxs-lookup"><span data-stu-id="af3d6-135">For more information, see [Inheritance Support](../../../../../../docs/framework/data/adonet/sql/linq/inheritance-support.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="af3d6-136">已加入至 `Table` 的物件不會出現在識別 (Identity) 快取中。</span><span class="sxs-lookup"><span data-stu-id="af3d6-136">An object added to a `Table` is not in the identity cache.</span></span> <span data-ttu-id="af3d6-137">識別快取只會反映從資料庫擷取的物件。</span><span class="sxs-lookup"><span data-stu-id="af3d6-137">The identity cache reflects only what is retrieved from the database.</span></span> <span data-ttu-id="af3d6-138">呼叫 <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A> 之後，除非 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 順利完成，否則加入的實體都不會出現在對資料庫的查詢中。</span><span class="sxs-lookup"><span data-stu-id="af3d6-138">After a call to <xref:System.Data.Linq.Table%601.InsertOnSubmit%2A>, the added entity does not appear in queries against the database until <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is successfully completed.</span></span>  
  
## <a name="deleting-objects"></a><span data-ttu-id="af3d6-139">刪除物件</span><span class="sxs-lookup"><span data-stu-id="af3d6-139">Deleting Objects</span></span>  
 <span data-ttu-id="af3d6-140">您可以在適當的 `o` 上呼叫 <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>(o)，將已追蹤的物件 <xref:System.Data.Linq.Table%601> 標記為要刪除。</span><span class="sxs-lookup"><span data-stu-id="af3d6-140">You mark a tracked object `o` for deletion by calling <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>(o) on the appropriate <xref:System.Data.Linq.Table%601>.</span></span> [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] <span data-ttu-id="af3d6-141">考慮從物件移除<xref:System.Data.Linq.EntitySet%601>為更新作業，並對應的外部索引鍵值設定為 null。</span><span class="sxs-lookup"><span data-stu-id="af3d6-141">considers the removal of an object from an <xref:System.Data.Linq.EntitySet%601> as an update operation, and the corresponding foreign key value is set to null.</span></span> <span data-ttu-id="af3d6-142">作業的目標 (`o`) 並不會從其資料表中刪除。</span><span class="sxs-lookup"><span data-stu-id="af3d6-142">The target of the operation (`o`) is not deleted from its table.</span></span> <span data-ttu-id="af3d6-143">例如，`cust.Orders.DeleteOnSubmit(ord)` 所表示的更新，是將外部索引鍵 `cust` 設為 null 來切斷 `ord` 和 `ord.CustomerID` 之間的關聯性 (Relationship)。</span><span class="sxs-lookup"><span data-stu-id="af3d6-143">For example, `cust.Orders.DeleteOnSubmit(ord)` indicates an update where the relationship between `cust` and `ord` is severed by setting the foreign key `ord.CustomerID` to null.</span></span> <span data-ttu-id="af3d6-144">這並不會刪除 `ord` 所對應的資料列。</span><span class="sxs-lookup"><span data-stu-id="af3d6-144">It does not cause the deletion of the row corresponding to `ord`.</span></span>  
  
 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] <span data-ttu-id="af3d6-145">執行下列的處理時刪除物件 (<xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>) 從其資料表：</span><span class="sxs-lookup"><span data-stu-id="af3d6-145">performs the following processing when an object is deleted (<xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>) from its table:</span></span>  
  
-   <span data-ttu-id="af3d6-146">呼叫 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 時，會對該物件執行 `DELETE` 作業。</span><span class="sxs-lookup"><span data-stu-id="af3d6-146">When <xref:System.Data.Linq.DataContext.SubmitChanges%2A> is called, a `DELETE` operation is performed for that object.</span></span>  
  
-   <span data-ttu-id="af3d6-147">不論是否已載入相關物件，移除作業都不會擴及相關物件。</span><span class="sxs-lookup"><span data-stu-id="af3d6-147">The removal is not propagated to related objects regardless of whether they are loaded.</span></span> <span data-ttu-id="af3d6-148">具體來說，並不會載入相關物件來更新關聯性屬性。</span><span class="sxs-lookup"><span data-stu-id="af3d6-148">Specifically, related objects are not loaded for updating the relationship property.</span></span>  
  
-   <span data-ttu-id="af3d6-149">順利執行 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 之後，物件會設為 `Deleted` 狀態。</span><span class="sxs-lookup"><span data-stu-id="af3d6-149">After successful execution of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, the objects are set to the `Deleted` state.</span></span> <span data-ttu-id="af3d6-150">因此，您無法使用該物件也無法使用其在該 `id` 中的 <xref:System.Data.Linq.DataContext>。</span><span class="sxs-lookup"><span data-stu-id="af3d6-150">As a result, you cannot use the object or its `id` in that <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="af3d6-151">由 <xref:System.Data.Linq.DataContext> 執行個體維護的內部快取並不會刪除已擷取或新加入的物件，即使物件已從資料庫中刪除也一樣。</span><span class="sxs-lookup"><span data-stu-id="af3d6-151">The internal cache maintained by a <xref:System.Data.Linq.DataContext> instance does not eliminate objects that are retrieved or added as new, even after the objects have been deleted in the database.</span></span>  
  
 <span data-ttu-id="af3d6-152">您只可以對 <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> 所追蹤的物件呼叫 <xref:System.Data.Linq.DataContext>。</span><span class="sxs-lookup"><span data-stu-id="af3d6-152">You can call <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> only on an object tracked by the <xref:System.Data.Linq.DataContext>.</span></span> <span data-ttu-id="af3d6-153">至於 `Untracked` 物件，您必須先呼叫 <xref:System.Data.Linq.Table%601.Attach%2A>，然後再呼叫 <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>。</span><span class="sxs-lookup"><span data-stu-id="af3d6-153">For an `Untracked` object, you must call <xref:System.Data.Linq.Table%601.Attach%2A> before you call <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A>.</span></span> <span data-ttu-id="af3d6-154">對 <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> 物件呼叫 `Untracked` 會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="af3d6-154">Calling <xref:System.Data.Linq.Table%601.DeleteOnSubmit%2A> on an `Untracked` object throws an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="af3d6-155">從資料表中移除物件會告訴[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]來產生對應的 SQL`DELETE`命令時<xref:System.Data.Linq.DataContext.SubmitChanges%2A>。</span><span class="sxs-lookup"><span data-stu-id="af3d6-155">Removing an object from a table tells [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] to generate a corresponding SQL `DELETE` command at the time of <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span> <span data-ttu-id="af3d6-156">這個動作並不會從快取中移除物件，也不會將刪除作業擴及相關的物件。</span><span class="sxs-lookup"><span data-stu-id="af3d6-156">This action does not remove the object from the cache or propagate the deletion to related objects.</span></span>  
>   
>  <span data-ttu-id="af3d6-157">若要回收已刪除物件的 `id`，請使用新的 <xref:System.Data.Linq.DataContext> 執行個體。</span><span class="sxs-lookup"><span data-stu-id="af3d6-157">To reclaim the `id` of a deleted object, use a new <xref:System.Data.Linq.DataContext> instance.</span></span> <span data-ttu-id="af3d6-158">清除的相關物件，您可以使用*串聯刪除*功能的資料庫，或自行手動刪除相關聯的物件。</span><span class="sxs-lookup"><span data-stu-id="af3d6-158">For cleanup of related objects, you can use the *cascade delete* feature of the database, or else manually delete the related objects.</span></span>  
>   
>  <span data-ttu-id="af3d6-159">刪除相關的物件時不必按照任何特定順序 (不像在資料庫中)。</span><span class="sxs-lookup"><span data-stu-id="af3d6-159">The related objects do not have to be deleted in any special order (unlike in the database).</span></span>  
  
## <a name="updating-objects"></a><span data-ttu-id="af3d6-160">更新物件</span><span class="sxs-lookup"><span data-stu-id="af3d6-160">Updating Objects</span></span>  
 <span data-ttu-id="af3d6-161">您可以藉由觀察有沒有變更告知來偵測 `Updates`。</span><span class="sxs-lookup"><span data-stu-id="af3d6-161">You can detect `Updates` by observing notifications of changes.</span></span> <span data-ttu-id="af3d6-162">告知是透過屬性 setter 中的 <xref:System.ComponentModel.INotifyPropertyChanging.PropertyChanging> 事件來提供。</span><span class="sxs-lookup"><span data-stu-id="af3d6-162">Notifications are provided through the <xref:System.ComponentModel.INotifyPropertyChanging.PropertyChanging> event in property setters.</span></span> <span data-ttu-id="af3d6-163">當 [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] 獲知物件第一次受到變更時，它會建立物件的複本並且將此物件列為要產生 `Update` 陳述式的對象。</span><span class="sxs-lookup"><span data-stu-id="af3d6-163">When [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] is notified of the first change to an object, it creates a copy of the object and considers the object a candidate for generating an `Update` statement.</span></span>  
  
 <span data-ttu-id="af3d6-164">物件不會實作<xref:System.ComponentModel.INotifyPropertyChanging>，[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]會保留一份他們已初次具體化時，已有物件的值。</span><span class="sxs-lookup"><span data-stu-id="af3d6-164">For objects that do not implement <xref:System.ComponentModel.INotifyPropertyChanging>, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] maintains a copy of the values that objects had when they were first materialized.</span></span> <span data-ttu-id="af3d6-165">當您呼叫<xref:System.Data.Linq.DataContext.SubmitChanges%2A>，[!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)]比較來決定物件是否已變更的最大值目前和原始值。</span><span class="sxs-lookup"><span data-stu-id="af3d6-165">When you call <xref:System.Data.Linq.DataContext.SubmitChanges%2A>, [!INCLUDE[vbtecdlinq](../../../../../../includes/vbtecdlinq-md.md)] compares the current and original values to decide whether the object has been changed.</span></span>  
  
 <span data-ttu-id="af3d6-166">如果是要更新關聯性，則子系 (Child) 對父代 (Parent) 的參考 (也就是對應於外部索引鍵的參考) 會是最主要的參考。</span><span class="sxs-lookup"><span data-stu-id="af3d6-166">For updates to relationships, the reference from the child to the parent (that is, the reference corresponding to the foreign key) is considered the authority.</span></span> <span data-ttu-id="af3d6-167">反方向 (也就是父代對子系的參考) 的參考則為選擇性的。</span><span class="sxs-lookup"><span data-stu-id="af3d6-167">The reference in the reverse direction (that is, from parent to child) is optional.</span></span> <span data-ttu-id="af3d6-168">關聯性類別 (<xref:System.Data.Linq.EntitySet%601> 和 <xref:System.Data.Linq.EntityRef%601>) 會保證一對多和一對一關聯性中的雙向參考都是一致的。</span><span class="sxs-lookup"><span data-stu-id="af3d6-168">Relationship classes (<xref:System.Data.Linq.EntitySet%601> and <xref:System.Data.Linq.EntityRef%601>) guarantee that the bidirectional references are consistent for one-to-many and one-to-one relationships.</span></span> <span data-ttu-id="af3d6-169">如果物件模型未使用 <xref:System.Data.Linq.EntitySet%601> 或 <xref:System.Data.Linq.EntityRef%601>，而反向參考存在，您就有責任使它在更新關聯性後，與向前參考 (Forward Reference) 一致。</span><span class="sxs-lookup"><span data-stu-id="af3d6-169">If the object model does not use <xref:System.Data.Linq.EntitySet%601> or <xref:System.Data.Linq.EntityRef%601>, and if the reverse reference is present, it is your responsibility to keep it consistent with the forward reference when the relationship is updated.</span></span>  
  
 <span data-ttu-id="af3d6-170">如果要同時更新必要的參考和對應的外部索引鍵，就必須確定兩者一致。</span><span class="sxs-lookup"><span data-stu-id="af3d6-170">If you update both the required reference and the corresponding foreign key, you must make sure that they agree.</span></span> <span data-ttu-id="af3d6-171">如果在您呼叫 <xref:System.InvalidOperationException> 時這兩者並未同步，則會擲回 <xref:System.Data.Linq.DataContext.SubmitChanges%2A> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="af3d6-171">An <xref:System.InvalidOperationException> exception is thrown if the two are not synchronized at the time that you call <xref:System.Data.Linq.DataContext.SubmitChanges%2A>.</span></span> <span data-ttu-id="af3d6-172">雖然只要變更外部索引鍵值就能更新基礎資料列，但您仍應該變更參考，以維護物件圖形中的連接並保持雙向關聯性的一致性。</span><span class="sxs-lookup"><span data-stu-id="af3d6-172">Although foreign key value changes are sufficient for affecting an update of the underlying row, you should change the reference to maintain connectivity of the object graph and bidirectional consistency of relationships.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="af3d6-173">另請參閱</span><span class="sxs-lookup"><span data-stu-id="af3d6-173">See also</span></span>

- [<span data-ttu-id="af3d6-174">背景資訊</span><span class="sxs-lookup"><span data-stu-id="af3d6-174">Background Information</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/background-information.md)
- [<span data-ttu-id="af3d6-175">插入、更新和刪除作業</span><span class="sxs-lookup"><span data-stu-id="af3d6-175">Insert, Update, and Delete Operations</span></span>](../../../../../../docs/framework/data/adonet/sql/linq/insert-update-and-delete-operations.md)
