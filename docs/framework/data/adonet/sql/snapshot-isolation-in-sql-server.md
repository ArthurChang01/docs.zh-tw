---
title: SQL Server 中的快照隔離
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 43ae5dd3-50f5-43a8-8d01-e37a61664176
ms.openlocfilehash: 6d85cc041850300d1d079b227dcb8ed9201a0502
ms.sourcegitcommit: 3094dcd17141b32a570a82ae3f62a331616e2c9c
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/01/2019
ms.locfileid: "71699066"
---
# <a name="snapshot-isolation-in-sql-server"></a><span data-ttu-id="65811-102">SQL Server 中的快照隔離</span><span class="sxs-lookup"><span data-stu-id="65811-102">Snapshot Isolation in SQL Server</span></span>
<span data-ttu-id="65811-103">快照隔離可強化 OLTP 應用程式的並行功能。</span><span class="sxs-lookup"><span data-stu-id="65811-103">Snapshot isolation enhances concurrency for OLTP applications.</span></span>  
  
## <a name="understanding-snapshot-isolation-and-row-versioning"></a><span data-ttu-id="65811-104">瞭解快照集隔離及資料列版本控制</span><span class="sxs-lookup"><span data-stu-id="65811-104">Understanding Snapshot Isolation and Row Versioning</span></span>  
 <span data-ttu-id="65811-105">一旦啟用快照集隔離，就必須維護每個交易的更新資料列版本。</span><span class="sxs-lookup"><span data-stu-id="65811-105">Once snapshot isolation is enabled, updated row versions for each transaction must be maintained.</span></span>  <span data-ttu-id="65811-106">在 SQL Server 2019 之前，這些版本會儲存在**tempdb**中。</span><span class="sxs-lookup"><span data-stu-id="65811-106">Prior to SQL Server 2019, these versions were stored in **tempdb**.</span></span> <span data-ttu-id="65811-107">SQL Server 2019 引進了一項新功能：加速資料庫復原（ADR），它需要自己的一組資料列版本。</span><span class="sxs-lookup"><span data-stu-id="65811-107">SQL Server 2019 introduces a new feature, Accelerated Database Recovery (ADR) which requires its own set of row versions.</span></span>  <span data-ttu-id="65811-108">因此，從 SQL Server 2019，如果未啟用 ADR，則資料列版本會一律保留在**tempdb**中。</span><span class="sxs-lookup"><span data-stu-id="65811-108">So, as of SQL Server 2019, if ADR is not enabled, row versions are kept in **tempdb** as always.</span></span>  <span data-ttu-id="65811-109">如果已啟用 ADR，則與 snapshot 隔離和 ADR 相關的所有資料列版本都會保留在 ADR 的持續版本存放區（PV）中，該資料庫位於使用者指定的檔案群組中。</span><span class="sxs-lookup"><span data-stu-id="65811-109">If ADR is enabled, then all row versions, both related to snapshot isolation and ADR, are kept in ADR's Persistent Version Store (PVS), which is located in the user database in a filegroup which the user specifies.</span></span> <span data-ttu-id="65811-110">唯一交易序號識別每筆交易，並會針對每個資料列版本記錄這些唯一的號碼。</span><span class="sxs-lookup"><span data-stu-id="65811-110">A unique transaction sequence number identifies each transaction, and these unique numbers are recorded for each row version.</span></span> <span data-ttu-id="65811-111">交易使用其序號在該交易序號之前的最新資料列版本。</span><span class="sxs-lookup"><span data-stu-id="65811-111">The transaction works with the most recent row versions having a sequence number before the sequence number of the transaction.</span></span> <span data-ttu-id="65811-112">該異動會忽略在異動開始之後建立的較新資料列版本。</span><span class="sxs-lookup"><span data-stu-id="65811-112">Newer row versions created after the transaction has begun are ignored by the transaction.</span></span>  
  
 <span data-ttu-id="65811-113">「快照集」這個詞彙反映了根據異動開始時資料庫的狀態，異動中所有查詢都看到資料庫的同一版本 (或快照集) 這一事實。</span><span class="sxs-lookup"><span data-stu-id="65811-113">The term "snapshot" reflects the fact that all queries in the transaction see the same version, or snapshot, of the database, based on the state of the database at the moment in time when the transaction begins.</span></span> <span data-ttu-id="65811-114">在快照集交易中的基礎資料列或資料頁面上沒有鎖定，這允許其他交易執行，而不會被之前未完成的交易封鎖。</span><span class="sxs-lookup"><span data-stu-id="65811-114">No locks are acquired on the underlying data rows or data pages in a snapshot transaction, which permits other transactions to execute without being blocked by a prior uncompleted transaction.</span></span> <span data-ttu-id="65811-115">修改資料的異動不會封鎖讀取資料的異動，而讀取資料的異動也不會封鎖寫入資料的異動，因為它們通常處於 SQL Server 中預設的 READ COMMITTED 隔離等級中。</span><span class="sxs-lookup"><span data-stu-id="65811-115">Transactions that modify data do not block transactions that read data, and transactions that read data do not block transactions that write data, as they normally would under the default READ COMMITTED isolation level in SQL Server.</span></span> <span data-ttu-id="65811-116">這種無封鎖的行為也會大幅降低複雜異動發生死結的可能性。</span><span class="sxs-lookup"><span data-stu-id="65811-116">This non-blocking behavior also significantly reduces the likelihood of deadlocks for complex transactions.</span></span>  
  
 <span data-ttu-id="65811-117">快照集隔離使用開放式同步存取模型。</span><span class="sxs-lookup"><span data-stu-id="65811-117">Snapshot isolation uses an optimistic concurrency model.</span></span> <span data-ttu-id="65811-118">如果快照集異動嘗試認可對異動開始後發生變更之資料的修改，則該異動將復原並將發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="65811-118">If a snapshot transaction attempts to commit modifications to data that has changed since the transaction began, the transaction will roll back and an error will be raised.</span></span> <span data-ttu-id="65811-119">對存取要修改之資料的 SELECT 陳述式使用 UPDLOCK 提示，可避免發生上述情況。</span><span class="sxs-lookup"><span data-stu-id="65811-119">You can avoid this by using UPDLOCK hints for SELECT statements that access data to be modified.</span></span> <span data-ttu-id="65811-120">如需詳細資訊，請參閱《SQL Server 線上叢書》的＜鎖定提示＞。</span><span class="sxs-lookup"><span data-stu-id="65811-120">See "Locking Hints" in SQL Server Books Online for more information.</span></span>  
  
 <span data-ttu-id="65811-121">必須先設定 ALLOW_SNAPSHOT_ISOLATION ON 資料庫選項以啟用快照集隔離，才能在交易中使用快照集隔離。</span><span class="sxs-lookup"><span data-stu-id="65811-121">Snapshot isolation must be enabled by setting the ALLOW_SNAPSHOT_ISOLATION ON database option before it is used in transactions.</span></span> <span data-ttu-id="65811-122">這會啟用在暫存資料庫（**tempdb**）中儲存資料列版本的機制。</span><span class="sxs-lookup"><span data-stu-id="65811-122">This activates the mechanism for storing row versions in the temporary database (**tempdb**).</span></span> <span data-ttu-id="65811-123">必須在搭配使用快照集隔離與 Transact-SQL ALTER DATABASE 陳述式的每個資料庫中啟用快照集隔離。</span><span class="sxs-lookup"><span data-stu-id="65811-123">You must enable snapshot isolation in each database that uses it with the Transact-SQL ALTER DATABASE statement.</span></span> <span data-ttu-id="65811-124">在這一方面，快照集隔離不同於無需設定的傳統隔離等級 READ COMMITTED、REPEATABLE READ、SERIALIZABLE 及 READ UNCOMMITTED。</span><span class="sxs-lookup"><span data-stu-id="65811-124">In this respect, snapshot isolation differs from the traditional isolation levels of READ COMMITTED, REPEATABLE READ, SERIALIZABLE, and READ UNCOMMITTED, which require no configuration.</span></span> <span data-ttu-id="65811-125">下列陳述式會啟動快照集隔離，並以 SNAPSHOT 取代預設的 READ COMMITTED 行為：</span><span class="sxs-lookup"><span data-stu-id="65811-125">The following statements activate snapshot isolation and replace the default READ COMMITTED behavior with SNAPSHOT:</span></span>  
  
```sql  
ALTER DATABASE MyDatabase  
SET ALLOW_SNAPSHOT_ISOLATION ON  
  
ALTER DATABASE MyDatabase  
SET READ_COMMITTED_SNAPSHOT ON  
```  
  
 <span data-ttu-id="65811-126">藉由設定 READ_COMMITTED_SNAPSHOT ON 選項，可存取預設 READ COMMITTED 隔離等級下已指定版本的資料列。</span><span class="sxs-lookup"><span data-stu-id="65811-126">Setting the READ_COMMITTED_SNAPSHOT ON option allows access to versioned rows under the default READ COMMITTED isolation level.</span></span> <span data-ttu-id="65811-127">如果將 READ_COMMITTED_SNAPSHOT 選項設為 OFF，則必須明確設定每個工作階段的快照隔離等級，以便存取已指定版本的資料列。</span><span class="sxs-lookup"><span data-stu-id="65811-127">If the READ_COMMITTED_SNAPSHOT option is set to OFF, you must explicitly set the Snapshot isolation level for each session in order to access versioned rows.</span></span>  
  
## <a name="managing-concurrency-with-isolation-levels"></a><span data-ttu-id="65811-128">使用隔離等級管理並行存取</span><span class="sxs-lookup"><span data-stu-id="65811-128">Managing Concurrency with Isolation Levels</span></span>  
 <span data-ttu-id="65811-129">Transact-SQL 陳述式執行所在的隔離等級決定了其鎖定及資料列版本控制行為。</span><span class="sxs-lookup"><span data-stu-id="65811-129">The isolation level under which a Transact-SQL statement executes determines its locking and row versioning behavior.</span></span> <span data-ttu-id="65811-130">隔離等級的範圍涵蓋整個連接，一旦以 SET TRANSACTION ISOLATION LEVEL 陳述式設定某連接的隔離等級後，它會持續有效，直到連接關閉或設定了另一隔離等級為止。</span><span class="sxs-lookup"><span data-stu-id="65811-130">An isolation level has connection-wide scope, and once set for a connection with the SET TRANSACTION ISOLATION LEVEL statement, it remains in effect until the connection is closed or another isolation level is set.</span></span> <span data-ttu-id="65811-131">當連接關閉且傳回至集區時，會保留最後一個 SET TRANSACTION ISOLATION LEVEL 陳述式的隔離等級 (Isolation Level)。</span><span class="sxs-lookup"><span data-stu-id="65811-131">When a connection is closed and returned to the pool, the isolation level from the last SET TRANSACTION ISOLATION LEVEL statement is retained.</span></span> <span data-ttu-id="65811-132">重複使用共用連接的後續連接會使用在共用連接時有效的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="65811-132">Subsequent connections reusing a pooled connection use the isolation level that was in effect at the time the connection is pooled.</span></span>  
  
 <span data-ttu-id="65811-133">在連接內發出的個別查詢可包含修改單一陳述式或異動之隔離的鎖定提示，但不會影響連接的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="65811-133">Individual queries issued within a connection can contain lock hints that modify the isolation for a single statement or transaction but do not affect the isolation level of the connection.</span></span> <span data-ttu-id="65811-134">預存程序或函式中設定的隔離等級或鎖定提示，不會變更呼叫它們之連接的隔離等級，並僅在預存程序或函式呼叫期間有效。</span><span class="sxs-lookup"><span data-stu-id="65811-134">Isolation levels or lock hints set in stored procedures or functions do not change the isolation level of the connection that calls them and are in effect only for the duration of the stored procedure or function call.</span></span>  
  
 <span data-ttu-id="65811-135">舊版 SQL Server 支援 SQL-92 標準中定義的四種隔離等級：</span><span class="sxs-lookup"><span data-stu-id="65811-135">Four isolation levels defined in the SQL-92 standard were supported in early versions of SQL Server:</span></span>  
  
- <span data-ttu-id="65811-136">READ UNCOMMITTED 是最為寬鬆的隔離等級，因為它會忽略其他異動設定的鎖定。</span><span class="sxs-lookup"><span data-stu-id="65811-136">READ UNCOMMITTED is the least restrictive isolation level because it ignores locks placed by other transactions.</span></span> <span data-ttu-id="65811-137">在 READ UNCOMMITTED 之下執行的交易可讀取其他交易尚未認可的已修改資料值；這種讀取稱為 Dirty 讀取。</span><span class="sxs-lookup"><span data-stu-id="65811-137">Transactions executing under READ UNCOMMITTED can read modified data values that have not yet been committed by other transactions; these are called "dirty" reads.</span></span>  
  
- <span data-ttu-id="65811-138">READ COMMITTED 是 SQL Server 的預設隔離等級。</span><span class="sxs-lookup"><span data-stu-id="65811-138">READ COMMITTED is the default isolation level for SQL Server.</span></span> <span data-ttu-id="65811-139">它藉由指定陳述式不可讀取已修改但未獲得其他異動認可的資料值，來防止 Dirty 讀取。</span><span class="sxs-lookup"><span data-stu-id="65811-139">It prevents dirty reads by specifying that statements cannot read data values that have been modified but not yet committed by other transactions.</span></span> <span data-ttu-id="65811-140">在目前交易內個別陳述式執行之間，其他交易仍可修改、插入或刪除資料，這會導致不可重複的讀取，即「虛設」資料。</span><span class="sxs-lookup"><span data-stu-id="65811-140">Other transactions can still modify, insert, or delete data between executions of individual statements within the current transaction, resulting in non-repeatable reads, or "phantom" data.</span></span>  
  
- <span data-ttu-id="65811-141">REPEATABLE READ 隔離等級比 READ COMMITTED 嚴格。</span><span class="sxs-lookup"><span data-stu-id="65811-141">REPEATABLE READ is a more restrictive isolation level than READ COMMITTED.</span></span> <span data-ttu-id="65811-142">它包含 READ COMMITTED，並額外指定任何其他交易都不可修改或刪除目前交易已讀取的資料，直到目前交易認可資料為止。</span><span class="sxs-lookup"><span data-stu-id="65811-142">It encompasses READ COMMITTED and additionally specifies that no other transactions can modify or delete data that has been read by the current transaction until the current transaction commits.</span></span> <span data-ttu-id="65811-143">此時的並行存取較 READ COMMITTED 封閉，因為在異動期間會保持對讀取資料的共用鎖定，而不是在每個陳述式結束時釋放鎖定。</span><span class="sxs-lookup"><span data-stu-id="65811-143">Concurrency is lower than for READ COMMITTED because shared locks on read data are held for the duration of the transaction instead of being released at the end of each statement.</span></span>  
  
- <span data-ttu-id="65811-144">SERIALIZABLE 是最嚴格的隔離等級，因為它會鎖定整個範圍的索引鍵，並保持鎖定直到交易完成。</span><span class="sxs-lookup"><span data-stu-id="65811-144">SERIALIZABLE is the most restrictive isolation level, because it locks entire ranges of keys and holds the locks until the transaction is complete.</span></span> <span data-ttu-id="65811-145">它包含 REPEATABLE READ，並增加了在異動完成之前，其他異動不可在該異動已讀取的範圍內插入新資料列的限制。</span><span class="sxs-lookup"><span data-stu-id="65811-145">It encompasses REPEATABLE READ and adds the restriction that other transactions cannot insert new rows into ranges that have been read by the transaction until the transaction is complete.</span></span>  
  
 <span data-ttu-id="65811-146">如需詳細資訊，請參閱[交易鎖定和資料列版本設定指南](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)。</span><span class="sxs-lookup"><span data-stu-id="65811-146">For more information, refer to the [Transaction Locking and Row Versioning Guide](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide).</span></span>  
  
### <a name="snapshot-isolation-level-extensions"></a><span data-ttu-id="65811-147">快照隔離等級擴充</span><span class="sxs-lookup"><span data-stu-id="65811-147">Snapshot Isolation Level Extensions</span></span>  
 <span data-ttu-id="65811-148">SQL Server 在引進 SNAPSHOT 隔離等級的同時，還引進了 SQL-92 隔離等級的擴充及 READ COMMITTED 的其他實作。</span><span class="sxs-lookup"><span data-stu-id="65811-148">SQL Server introduced extensions to the SQL-92 isolation levels with the introduction of the SNAPSHOT isolation level and an additional implementation of READ COMMITTED.</span></span> <span data-ttu-id="65811-149">READ_COMMITTED_SNAPSHOT 隔離等級可透明化取代所有異動的 READ COMMITTED。</span><span class="sxs-lookup"><span data-stu-id="65811-149">The READ_COMMITTED_SNAPSHOT isolation level can transparently replace READ COMMITTED for all transactions.</span></span>  
  
- <span data-ttu-id="65811-150">SNAPSHOT 隔離指定交易內的資料讀取永遠不會反映其他同時進行之交易所進行的變更。</span><span class="sxs-lookup"><span data-stu-id="65811-150">SNAPSHOT isolation specifies that data read within a transaction will never reflect changes made by other simultaneous transactions.</span></span> <span data-ttu-id="65811-151">異動使用異動開始時存在的資料列版本。</span><span class="sxs-lookup"><span data-stu-id="65811-151">The transaction uses the data row versions that exist when the transaction begins.</span></span> <span data-ttu-id="65811-152">讀取資料時不會對資料設定鎖定，因此 SNAPSHOT 交易不會阻止其他交易寫入資料。</span><span class="sxs-lookup"><span data-stu-id="65811-152">No locks are placed on the data when it is read, so SNAPSHOT transactions do not block other transactions from writing data.</span></span> <span data-ttu-id="65811-153">寫入資料的交易不會阻止快照集交易讀取資料。</span><span class="sxs-lookup"><span data-stu-id="65811-153">Transactions that write data do not block snapshot transactions from reading data.</span></span> <span data-ttu-id="65811-154">您需要藉由設定 ALLOW_SNAPSHOT_ISOLATION 資料庫選項來啟用快照集隔離，以便使用該隔離。</span><span class="sxs-lookup"><span data-stu-id="65811-154">You need to enable snapshot isolation by setting the ALLOW_SNAPSHOT_ISOLATION database option in order to use it.</span></span>  
  
- <span data-ttu-id="65811-155">READ_COMMITTED_SNAPSHOT 資料庫選項可判斷在資料庫中啟用快照集隔離時，預設 READ COMMITTED 隔離等級的行為。</span><span class="sxs-lookup"><span data-stu-id="65811-155">The READ_COMMITTED_SNAPSHOT database option determines the behavior of the default READ COMMITTED isolation level when snapshot isolation is enabled in a database.</span></span> <span data-ttu-id="65811-156">如果您未明確指定 READ_COMMITTED_SNAPSHOT ON，則 READ COMMITTED 會套用至所有隱含交易。</span><span class="sxs-lookup"><span data-stu-id="65811-156">If you do not explicitly specify READ_COMMITTED_SNAPSHOT ON, READ COMMITTED is applied to all implicit transactions.</span></span> <span data-ttu-id="65811-157">如此會產生與設定 READ_COMMITTED_SNAPSHOT OFF (預設值) 相同的行為。</span><span class="sxs-lookup"><span data-stu-id="65811-157">This produces the same behavior as setting READ_COMMITTED_SNAPSHOT OFF (the default).</span></span> <span data-ttu-id="65811-158">READ_COMMITTED_SNAPSHOT OFF 生效後，資料庫引擎會使用共用鎖定來強制執行預設的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="65811-158">When READ_COMMITTED_SNAPSHOT OFF is in effect, the Database Engine uses shared locks to enforce the default isolation level.</span></span> <span data-ttu-id="65811-159">如果將 READ_COMMITTED_SNAPSHOT 資料庫選項設為 ON，則資料庫引擎會使用資料列版本控制及快照集隔離做為預設值，而不是使用鎖定保護資料。</span><span class="sxs-lookup"><span data-stu-id="65811-159">If you set the READ_COMMITTED_SNAPSHOT database option to ON, the database engine uses row versioning and snapshot isolation as the default, instead of using locks to protect the data.</span></span>  
  
## <a name="how-snapshot-isolation-and-row-versioning-work"></a><span data-ttu-id="65811-160">快照集隔離及資料列版本控制的運作方式</span><span class="sxs-lookup"><span data-stu-id="65811-160">How Snapshot Isolation and Row Versioning Work</span></span>  
 <span data-ttu-id="65811-161">啟用快照隔離等級時，每次更新資料列時，SQL Server 資料庫引擎會將原始資料列的複本儲存在**tempdb**中，並將交易序號加入資料列。</span><span class="sxs-lookup"><span data-stu-id="65811-161">When the SNAPSHOT isolation level is enabled, each time a row is updated, the SQL Server Database Engine stores a copy of the original row in **tempdb**, and adds a transaction sequence number to the row.</span></span> <span data-ttu-id="65811-162">以下是事件的發生順序：</span><span class="sxs-lookup"><span data-stu-id="65811-162">The following is the sequence of events that occurs:</span></span>  
  
- <span data-ttu-id="65811-163">初始新交易，並為其指派交易序號。</span><span class="sxs-lookup"><span data-stu-id="65811-163">A new transaction is initiated, and it is assigned a transaction sequence number.</span></span>  
  
- <span data-ttu-id="65811-164">資料庫引擎會讀取交易中的資料列，並從其序號最接近且小於交易序號的**tempdb**抓取資料列版本。</span><span class="sxs-lookup"><span data-stu-id="65811-164">The Database Engine reads a row within the transaction and retrieves the row version from **tempdb** whose sequence number is closest to, and lower than, the transaction sequence number.</span></span>  
  
- <span data-ttu-id="65811-165">資料庫引擎檢查該交易序號是否不在快照集交易開始時啟用之未認可交易的序號清單中。</span><span class="sxs-lookup"><span data-stu-id="65811-165">The Database Engine checks to see if the transaction sequence number is not in the list of transaction sequence numbers of the uncommitted transactions active when the snapshot transaction started.</span></span>  
  
- <span data-ttu-id="65811-166">交易會從交易開始時的最新**tempdb**讀取資料列的版本。</span><span class="sxs-lookup"><span data-stu-id="65811-166">The transaction reads the version of the row from **tempdb** that was current as of the start of the transaction.</span></span> <span data-ttu-id="65811-167">它不會看到異動開始後插入的新資料列，因為那些序號值會高於該異動序號值。</span><span class="sxs-lookup"><span data-stu-id="65811-167">It will not see new rows inserted after the transaction was started because those sequence number values will be higher than the value of the transaction sequence number.</span></span>  
  
- <span data-ttu-id="65811-168">目前的交易將會看到在交易開始後刪除的資料列，因為**tempdb**中會有一個資料列版本，其序號值較低。</span><span class="sxs-lookup"><span data-stu-id="65811-168">The current transaction will see rows that were deleted after the transaction began, because there will be a row version in **tempdb** with a lower sequence number value.</span></span>  
  
 <span data-ttu-id="65811-169">快照集隔離的唯一影響是異動可看到異動開始時就存在的所有資料，而不會在基底資料表上接受或設定鎖定。</span><span class="sxs-lookup"><span data-stu-id="65811-169">The net effect of snapshot isolation is that the transaction sees all of the data as it existed at the start of the transaction, without honoring or placing any locks on the underlying tables.</span></span> <span data-ttu-id="65811-170">在發生爭用時，這可提升效能。</span><span class="sxs-lookup"><span data-stu-id="65811-170">This can result in performance improvements in situations where there is contention.</span></span>  
  
 <span data-ttu-id="65811-171">快照集異動通常使用開放式同步存取控制，抑制任何可防止其他異動更新資料列的鎖定。</span><span class="sxs-lookup"><span data-stu-id="65811-171">A snapshot transaction always uses optimistic concurrency control, withholding any locks that would prevent other transactions from updating rows.</span></span> <span data-ttu-id="65811-172">如果快照集異動嘗試認可對異動開始後發生變更之資料列的更新，則該異動會復原並將發生錯誤。</span><span class="sxs-lookup"><span data-stu-id="65811-172">If a snapshot transaction attempts to commit an update to a row that was changed after the transaction began, the transaction is rolled back, and an error is raised.</span></span>  
  
## <a name="working-with-snapshot-isolation-in-adonet"></a><span data-ttu-id="65811-173">在 ADO.NET 中使用快照集隔離</span><span class="sxs-lookup"><span data-stu-id="65811-173">Working with Snapshot Isolation in ADO.NET</span></span>  
 <span data-ttu-id="65811-174">ADO.NET 中的 <xref:System.Data.SqlClient.SqlTransaction> 類別支援快照集隔離。</span><span class="sxs-lookup"><span data-stu-id="65811-174">Snapshot isolation is supported in ADO.NET by the <xref:System.Data.SqlClient.SqlTransaction> class.</span></span> <span data-ttu-id="65811-175">如果資料庫已啟用快照集隔離，但未設定為在上進行 READ_COMMITTED_SNAPSHOT，您必須在呼叫 <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> 方法時，使用**IsolationLevel**來起始 <xref:System.Data.SqlClient.SqlTransaction>。</span><span class="sxs-lookup"><span data-stu-id="65811-175">If a database has been enabled for snapshot isolation but is not configured for READ_COMMITTED_SNAPSHOT ON, you must initiate a <xref:System.Data.SqlClient.SqlTransaction> using the **IsolationLevel.Snapshot** enumeration value when calling the <xref:System.Data.SqlClient.SqlConnection.BeginTransaction%2A> method.</span></span> <span data-ttu-id="65811-176">此程式碼片段假設連接是開啟的 <xref:System.Data.SqlClient.SqlConnection> 物件。</span><span class="sxs-lookup"><span data-stu-id="65811-176">This code fragment assumes that connection is an open <xref:System.Data.SqlClient.SqlConnection> object.</span></span>  
  
```vb  
Dim sqlTran As SqlTransaction = _  
  connection.BeginTransaction(IsolationLevel.Snapshot)  
```  
  
```csharp  
SqlTransaction sqlTran =   
  connection.BeginTransaction(IsolationLevel.Snapshot);  
```  
  
### <a name="example"></a><span data-ttu-id="65811-177">範例</span><span class="sxs-lookup"><span data-stu-id="65811-177">Example</span></span>  
 <span data-ttu-id="65811-178">下列範例說明不同隔離等級嘗試存取鎖定資料的行為方式，該範例不適用於實際執行的程式碼。</span><span class="sxs-lookup"><span data-stu-id="65811-178">The following example demonstrates how the different isolation levels behave by attempting to access locked data, and it is not intended to be used in production code.</span></span>  
  
 <span data-ttu-id="65811-179">程式碼會連接到 SQL Server 中的**AdventureWorks**範例資料庫，並建立名為**TestSnapshot**的資料表，並插入一個資料列。</span><span class="sxs-lookup"><span data-stu-id="65811-179">The code connects to the **AdventureWorks** sample database in SQL Server and creates a table named **TestSnapshot** and inserts one row of data.</span></span> <span data-ttu-id="65811-180">該程式碼使用 ALTER DATABASE Transact-SQL 陳述式來啟用資料庫的快照集隔離，但不會設定 READ_COMMITTED_SNAPSHOT 選項，而是讓預設的 READ COMMITTED 隔離等級行為生效。</span><span class="sxs-lookup"><span data-stu-id="65811-180">The code uses the ALTER DATABASE Transact-SQL statement to turn on snapshot isolation for the database, but it does not set the READ_COMMITTED_SNAPSHOT option, leaving the default READ COMMITTED isolation-level behavior in effect.</span></span> <span data-ttu-id="65811-181">然後，程式碼執行下列動作：</span><span class="sxs-lookup"><span data-stu-id="65811-181">The code then performs the following actions:</span></span>  
  
- <span data-ttu-id="65811-182">它會開始但不完成 sqlTransaction1，其使用 SERIALIZABLE 隔離等級來啟動更新異動。</span><span class="sxs-lookup"><span data-stu-id="65811-182">It begins, but does not complete, sqlTransaction1, which uses the SERIALIZABLE isolation level to start an update transaction.</span></span> <span data-ttu-id="65811-183">它的作用是鎖定資料表。</span><span class="sxs-lookup"><span data-stu-id="65811-183">This has the effect of locking the table.</span></span>  
  
- <span data-ttu-id="65811-184">它會開啟第二個連接，並使用快照隔離等級來起始第二筆交易，以讀取**TestSnapshot**資料表中的資料。</span><span class="sxs-lookup"><span data-stu-id="65811-184">It opens a second connection and initiates a second transaction using the SNAPSHOT isolation level to read the data in the **TestSnapshot** table.</span></span> <span data-ttu-id="65811-185">因為已啟用快照集隔離，所以此異動可讀取 sqlTransaction1 啟動之前存在的資料。</span><span class="sxs-lookup"><span data-stu-id="65811-185">Because snapshot isolation is enabled, this transaction can read the data that existed before sqlTransaction1 started.</span></span>  
  
- <span data-ttu-id="65811-186">它會開啟第三個連接並初始使用 READ COMMITTED 隔離等級的交易，以嘗試讀取資料表中的資料。</span><span class="sxs-lookup"><span data-stu-id="65811-186">It opens a third connection and initiates a transaction using the READ COMMITTED isolation level to attempt to read the data in the table.</span></span> <span data-ttu-id="65811-187">在這種情況下，程式碼無法讀取資料，因為第一個交易在資料表上設定的鎖定阻止其讀取資料並發生逾時。如果使用 REPEATABLE READ 及 SERIALIZABLE 隔離等級也會導致相同的結果，因為第一個交易設定的鎖定也會阻止這些隔離等級進行讀取。</span><span class="sxs-lookup"><span data-stu-id="65811-187">In this case, the code cannot read the data because it cannot read past the locks placed on the table in the first transaction and times out. The same result would occur if the REPEATABLE READ and SERIALIZABLE isolation levels were used because these isolation levels also cannot read past the locks placed in the first transaction.</span></span>  
  
- <span data-ttu-id="65811-188">它會開啟第四個連接並初始使用 READ UNCOMMITTED 隔離等級的異動，其會執行對 sqlTransaction1 中未認可值的 Dirty 讀取。</span><span class="sxs-lookup"><span data-stu-id="65811-188">It opens a fourth connection and initiates a transaction using the READ UNCOMMITTED isolation level, which performs a dirty read of the uncommitted value in sqlTransaction1.</span></span> <span data-ttu-id="65811-189">若未認可第一個異動，則資料庫實際上可能從未擁有此值。</span><span class="sxs-lookup"><span data-stu-id="65811-189">This value may never actually exist in the database if the first transaction is not committed.</span></span>  
  
- <span data-ttu-id="65811-190">它會復原第一個交易，並藉由刪除**TestSnapshot**資料表並關閉**AdventureWorks**資料庫的快照集隔離來進行清除。</span><span class="sxs-lookup"><span data-stu-id="65811-190">It rolls back the first transaction and cleans up by deleting the **TestSnapshot** table and turning off snapshot isolation for the **AdventureWorks** database.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="65811-191">下列範例在連接共用 (Connection Pooling) 關閉時會使用相同的連接字串。</span><span class="sxs-lookup"><span data-stu-id="65811-191">The following examples use the same connection string with connection pooling turned off.</span></span> <span data-ttu-id="65811-192">如果共用連接，則重設其隔離等級並不會重設伺服器的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="65811-192">If a connection is pooled, resetting its isolation level does not reset the isolation level at the server.</span></span> <span data-ttu-id="65811-193">因此，使用同一共用內部連接的後續連接在啟動時的隔離等級會設定為共用連接的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="65811-193">As a result, subsequent connections that use the same pooled inner connection start with their isolation levels set to that of the pooled connection.</span></span> <span data-ttu-id="65811-194">關閉連接共用的方法之一，是明確地設定每個連接的隔離等級。</span><span class="sxs-lookup"><span data-stu-id="65811-194">An alternative to turning off connection pooling is to set the isolation level explicitly for each connection.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.Demo#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.Demo/VB/source.vb#1)]  
  
### <a name="example"></a><span data-ttu-id="65811-195">範例</span><span class="sxs-lookup"><span data-stu-id="65811-195">Example</span></span>  
 <span data-ttu-id="65811-196">下列範例說明修改資料時快照集隔離的行為。</span><span class="sxs-lookup"><span data-stu-id="65811-196">The following example demonstrates the behavior of snapshot isolation when data is being modified.</span></span> <span data-ttu-id="65811-197">該程式碼執行下列動作：</span><span class="sxs-lookup"><span data-stu-id="65811-197">The code performs the following actions:</span></span>  
  
- <span data-ttu-id="65811-198">連接到**AdventureWorks**範例資料庫，並啟用快照集隔離。</span><span class="sxs-lookup"><span data-stu-id="65811-198">Connects to the **AdventureWorks** sample database and enables SNAPSHOT isolation.</span></span>  
  
- <span data-ttu-id="65811-199">建立名為**TestSnapshotUpdate**的資料表，並插入三個數據列的範例資料。</span><span class="sxs-lookup"><span data-stu-id="65811-199">Creates a table named **TestSnapshotUpdate** and inserts three rows of sample data.</span></span>  
  
- <span data-ttu-id="65811-200">開始使用 SNAPSHOT 隔離的 sqlTransaction1 但不完成它。</span><span class="sxs-lookup"><span data-stu-id="65811-200">Begins, but does not complete, sqlTransaction1 using SNAPSHOT isolation.</span></span> <span data-ttu-id="65811-201">在交易中選取三個資料列。</span><span class="sxs-lookup"><span data-stu-id="65811-201">Three rows of data are selected in the transaction.</span></span>  
  
- <span data-ttu-id="65811-202">建立第二個**SqlConnection**至**AdventureWorks** ，並使用讀取認可隔離等級建立第二筆交易，以更新 sqlTransaction1 中所選其中一個資料列的值。</span><span class="sxs-lookup"><span data-stu-id="65811-202">Creates a second **SqlConnection** to **AdventureWorks** and creates a second transaction using the READ COMMITTED isolation level that updates a value in one of the rows selected in sqlTransaction1.</span></span>  
  
- <span data-ttu-id="65811-203">認可 sqlTransaction2。</span><span class="sxs-lookup"><span data-stu-id="65811-203">Commits sqlTransaction2.</span></span>  
  
- <span data-ttu-id="65811-204">返回 sqlTransaction1 並嘗試更新 sqlTransaction1 已認可的同一資料列。</span><span class="sxs-lookup"><span data-stu-id="65811-204">Returns to sqlTransaction1 and attempts to update the same row that sqlTransaction1 already committed.</span></span> <span data-ttu-id="65811-205">發生錯誤 3960，sqlTransaction1 自動復原。</span><span class="sxs-lookup"><span data-stu-id="65811-205">Error 3960 is raised, and sqlTransaction1 is rolled back automatically.</span></span> <span data-ttu-id="65811-206">[ **SqlException** ] 和 [ **SqlException** ] 會顯示在主控台視窗中。</span><span class="sxs-lookup"><span data-stu-id="65811-206">The **SqlException.Number** and **SqlException.Message** are displayed in the Console window.</span></span>  
  
- <span data-ttu-id="65811-207">執行清除程式碼以關閉**AdventureWorks**中的快照集隔離，並刪除**TestSnapshotUpdate**資料表。</span><span class="sxs-lookup"><span data-stu-id="65811-207">Executes clean-up code to turn off snapshot isolation in **AdventureWorks** and delete the **TestSnapshotUpdate** table.</span></span>  
  
 [!code-csharp[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/CS/source.cs#1)]
 [!code-vb[DataWorks SnapshotIsolation.DemoUpdate#1](../../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DataWorks SnapshotIsolation.DemoUpdate/VB/source.vb#1)]  
  
### <a name="using-lock-hints-with-snapshot-isolation"></a><span data-ttu-id="65811-208">搭配使用鎖定提示與快照集隔離</span><span class="sxs-lookup"><span data-stu-id="65811-208">Using Lock Hints with Snapshot Isolation</span></span>  
 <span data-ttu-id="65811-209">在前一範例中，第一筆異動選取了資料，而第二筆異動在第一筆異動尚未完成時就更新該資料，因而在第一筆異動嘗試更新同一資料列時發生更新衝突。</span><span class="sxs-lookup"><span data-stu-id="65811-209">In the previous example, the first transaction selects data, and a second transaction updates the data before the first transaction is able to complete, causing an update conflict when the first transaction tries to update the same row.</span></span> <span data-ttu-id="65811-210">藉由在異動開始時提供鎖定提示，可減少長期執行之快照集異動發生更新衝突的機率。</span><span class="sxs-lookup"><span data-stu-id="65811-210">You can reduce the chance of update conflicts in long-running snapshot transactions by supplying lock hints at the beginning of the transaction.</span></span> <span data-ttu-id="65811-211">下列 SELECT 陳述式使用 UPDLOCK 提示來鎖定已選取的資料列：</span><span class="sxs-lookup"><span data-stu-id="65811-211">The following SELECT statement uses the UPDLOCK hint to lock the selected rows:</span></span>  
  
```sql  
SELECT * FROM TestSnapshotUpdate WITH (UPDLOCK)   
  WHERE PriKey BETWEEN 1 AND 3  
```  
  
 <span data-ttu-id="65811-212">使用 UPDLOCK 鎖定提示可阻止任何資料列在第一筆交易完成之前嘗試更新資料列。</span><span class="sxs-lookup"><span data-stu-id="65811-212">Using the UPDLOCK lock hint blocks any rows attempting to update the rows before the first transaction completes.</span></span> <span data-ttu-id="65811-213">如此可確保異動中在稍後更新選取的資料列時不會發生衝突。</span><span class="sxs-lookup"><span data-stu-id="65811-213">This guarantees that the selected rows have no conflicts when they are updated later in the transaction.</span></span> <span data-ttu-id="65811-214">請參閱《SQL Server 線上叢書》的＜鎖定提示＞。</span><span class="sxs-lookup"><span data-stu-id="65811-214">See "Locking Hints" in SQL Server Books Online.</span></span>  
  
 <span data-ttu-id="65811-215">如果應用程式有許多衝突，快照集隔離也許並非是最佳選擇。</span><span class="sxs-lookup"><span data-stu-id="65811-215">If your application has many conflicts, snapshot isolation may not be the best choice.</span></span> <span data-ttu-id="65811-216">僅在確實需要時才使用提示。</span><span class="sxs-lookup"><span data-stu-id="65811-216">Hints should only be used when really needed.</span></span> <span data-ttu-id="65811-217">您的應用程式不應設計為必須依賴鎖定提示來執行作業。</span><span class="sxs-lookup"><span data-stu-id="65811-217">Your application should not be designed so that it constantly relies on lock hints for its operation.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="65811-218">另請參閱</span><span class="sxs-lookup"><span data-stu-id="65811-218">See also</span></span>

- [<span data-ttu-id="65811-219">SQL Server 和 ADO.NET</span><span class="sxs-lookup"><span data-stu-id="65811-219">SQL Server and ADO.NET</span></span>](index.md)
- [<span data-ttu-id="65811-220">ADO.NET 概觀</span><span class="sxs-lookup"><span data-stu-id="65811-220">ADO.NET Overview</span></span>](../ado-net-overview.md)
- [<span data-ttu-id="65811-221">交易鎖定和資料列版本設定指南</span><span class="sxs-lookup"><span data-stu-id="65811-221">Transaction Locking and Row Versioning Guide</span></span>](/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide)
