---
title: 控制項撰寫概觀
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- controls [WPF], authoring overview
- authoring overview for controls [WPF]
ms.assetid: 3d864748-cff0-4e63-9b23-d8e5a635b28f
ms.openlocfilehash: ca11a5787dfd3e5f3089d44689d96ec64c75e4f3
ms.sourcegitcommit: efff8f331fd9467f093f8ab8d23a203d6ecb5b60
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/01/2018
ms.locfileid: "43394064"
---
# <a name="control-authoring-overview"></a><span data-ttu-id="5b5ad-102">控制項撰寫概觀</span><span class="sxs-lookup"><span data-stu-id="5b5ad-102">Control Authoring Overview</span></span>
<span data-ttu-id="5b5ad-103">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 控制項模型由於具有擴充性，因此大幅減少了建立新控制項的需求。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-103">The extensibility of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] control model greatly reduces the need to create a new control.</span></span> <span data-ttu-id="5b5ad-104">不過，在某些情況下，您可能還是需要建立自訂控制項。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-104">However, in certain cases you may still need to create a custom control.</span></span> <span data-ttu-id="5b5ad-105">本主題將討論可讓您建立自訂控制項的需求降到最低的一些功能，以及 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中的不同控制項撰寫模型。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-105">This topic discusses the features that minimize your need to create a custom control and the different control authoring models in [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)].</span></span> <span data-ttu-id="5b5ad-106">本主題也將示範如何建立新的控制項。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-106">This topic also demonstrates how to create a new control.</span></span>  
  
 
  
<a name="when_to_write_a_new_control"></a>   
## <a name="alternatives-to-writing-a-new-control"></a><span data-ttu-id="5b5ad-107">撰寫新控制項的替代方案</span><span class="sxs-lookup"><span data-stu-id="5b5ad-107">Alternatives to Writing a New Control</span></span>  
 <span data-ttu-id="5b5ad-108">在過去，若要從現有控制項自訂控制項，只能變更控制項的標準屬性，例如背景色彩、框線寬度和字型大小。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-108">Historically, if you wanted to get a customized experience from an existing control, you were limited to changing the standard properties of the control, such as background color, border width, and font size.</span></span> <span data-ttu-id="5b5ad-109">除了這些預先定義的參數外，若還想擴充控制項的外觀或行為，就需要建立新的控制項，建立的方式通常是繼承現有控制項並覆寫負責繪製控制項。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-109">If you wished to extend the appearance or behavior of a control beyond these predefined parameters, you would need to create a new control, usually by inheriting from an existing control and overriding the method responsible for drawing the control.</span></span>  <span data-ttu-id="5b5ad-110">雖然您現在還是可以使用前述方式，但 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 可以讓您藉由使用其豐富的內容模型、樣式、範本和觸發程序來自訂現有的控制項。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-110">Although that is still an option, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] enables to you customize existing controls by using its rich content model, styles, templates, and triggers.</span></span> <span data-ttu-id="5b5ad-111">下列清單提供的範例說明如何在不建立新控制項的情況下，使用這些功能來建立自訂且一致的控制項。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-111">The following list gives examples of how these features can be used to create custom and consistent experiences without having to create a new control.</span></span>  
  
-   <span data-ttu-id="5b5ad-112">**豐富內容。**</span><span class="sxs-lookup"><span data-stu-id="5b5ad-112">**Rich Content.**</span></span> <span data-ttu-id="5b5ad-113">許多標準的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 控制項都支援豐富內容。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-113">Many of the standard [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls support rich content.</span></span> <span data-ttu-id="5b5ad-114">例如，內容屬性的<xref:System.Windows.Controls.Button>屬於型別<xref:System.Object>，所以理論上的任何項目可以顯示在<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-114">For example, the content property of a <xref:System.Windows.Controls.Button> is of type <xref:System.Object>, so theoretically anything can be displayed on a <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="5b5ad-115">若要讓按鈕顯示影像和文字，您可以新增映像和<xref:System.Windows.Controls.TextBlock>要<xref:System.Windows.Controls.StackPanel>並指派<xref:System.Windows.Controls.StackPanel>到<xref:System.Windows.Controls.ContentControl.Content%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-115">To have a button display an image and text, you can add an image and a <xref:System.Windows.Controls.TextBlock> to a <xref:System.Windows.Controls.StackPanel> and assign the <xref:System.Windows.Controls.StackPanel> to the <xref:System.Windows.Controls.ContentControl.Content%2A> property.</span></span> <span data-ttu-id="5b5ad-116">因為控制項可以顯示 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 視覺化項目和任意資料，就比較不需要建立新控制項或修改現有控制項來支援複雜的視覺效果。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-116">Because the controls can display [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] visual elements and arbitrary data, there is less need to create a new control or to modify an existing control to support a complex visualization.</span></span> <span data-ttu-id="5b5ad-117">如需有關的內容模型<xref:System.Windows.Controls.Button>和其他內容模型中工作流程[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]，請參閱[WPF 內容模型](../../../../docs/framework/wpf/controls/wpf-content-model.md)。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-117">For more information about the content model for <xref:System.Windows.Controls.Button> and other content models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [WPF Content Model](../../../../docs/framework/wpf/controls/wpf-content-model.md).</span></span>  
  
-   <span data-ttu-id="5b5ad-118">**樣式。**</span><span class="sxs-lookup"><span data-stu-id="5b5ad-118">**Styles.**</span></span> <span data-ttu-id="5b5ad-119">A<xref:System.Windows.Style>是集合，代表控制項屬性的值。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-119">A <xref:System.Windows.Style> is a collection of values that represent properties for a control.</span></span> <span data-ttu-id="5b5ad-120">藉由使用樣式，您可以針對所要的控制項外觀和行為，建立可重複使用的表示方式，而不需要撰寫新的控制項。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-120">By using styles, you can create a reusable representation of a desired control appearance and behavior without writing a new control.</span></span> <span data-ttu-id="5b5ad-121">例如，假設您想要所有您<xref:System.Windows.Controls.TextBlock>控制項都具有紅色新細明體字型字型大小為 14。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-121">For example, assume that you want all of your <xref:System.Windows.Controls.TextBlock> controls to have red, Arial font with a font size of 14.</span></span> <span data-ttu-id="5b5ad-122">您可以建立樣式作為資源，並對應地設定適當的屬性。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-122">You can create a style as a resource and set the appropriate properties accordingly.</span></span> <span data-ttu-id="5b5ad-123">然後每隔<xref:System.Windows.Controls.TextBlock>，您將新增至您的應用程式會有相同的外觀。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-123">Then every <xref:System.Windows.Controls.TextBlock> that you add to your application will have the same appearance.</span></span>  
  
-   <span data-ttu-id="5b5ad-124">**資料範本。**</span><span class="sxs-lookup"><span data-stu-id="5b5ad-124">**Data Templates.**</span></span> <span data-ttu-id="5b5ad-125">A<xref:System.Windows.DataTemplate>可讓您自訂控制項上顯示資料的方式。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-125">A <xref:System.Windows.DataTemplate> enables you to customize how data is displayed on a control.</span></span> <span data-ttu-id="5b5ad-126">例如，<xref:System.Windows.DataTemplate>可用來指定如何將資料顯示在<xref:System.Windows.Controls.ListBox>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-126">For example, a <xref:System.Windows.DataTemplate> can be used to specify how data is displayed in a <xref:System.Windows.Controls.ListBox>.</span></span>  <span data-ttu-id="5b5ad-127">如需此作業的範例，請參閱[資料範本化概觀](../../../../docs/framework/wpf/data/data-templating-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-127">For an example of this, see [Data Templating Overview](../../../../docs/framework/wpf/data/data-templating-overview.md).</span></span>  <span data-ttu-id="5b5ad-128">除了自訂的資料、 外觀<xref:System.Windows.DataTemplate>可以包含 UI 項目，可在自訂 Ui 讓您很大的彈性。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-128">In addition to customizing the appearance of data, a <xref:System.Windows.DataTemplate> can include UI elements, which gives you a lot of flexibility in custom UIs.</span></span>  <span data-ttu-id="5b5ad-129">例如，藉由使用<xref:System.Windows.DataTemplate>，您可以建立<xref:System.Windows.Controls.ComboBox>的每個項目都包含核取方塊。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-129">For example, by using a <xref:System.Windows.DataTemplate>, you can create a <xref:System.Windows.Controls.ComboBox> in which each item contains a check box.</span></span>  
  
-   <span data-ttu-id="5b5ad-130">**控制項範本。**</span><span class="sxs-lookup"><span data-stu-id="5b5ad-130">**Control Templates.**</span></span> <span data-ttu-id="5b5ad-131">中的許多控制項[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]使用<xref:System.Windows.Controls.ControlTemplate>來定義控制項的結構和外觀，控制項的外觀分開控制項的功能。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-131">Many controls in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] use a <xref:System.Windows.Controls.ControlTemplate> to define the control's structure and appearance, which separates the appearance of a control from the functionality of the control.</span></span> <span data-ttu-id="5b5ad-132">您可以重新定義，以大幅變更控制項的外觀及其<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-132">You can drastically change the appearance of a control by redefining its <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="5b5ad-133">例如，假設您希望控制項看起來像號誌燈。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-133">For example, suppose you want a control that looks like a stoplight.</span></span> <span data-ttu-id="5b5ad-134">這個控制項具有簡單的使用者介面和功能。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-134">This control has a simple user interface and functionality.</span></span>  <span data-ttu-id="5b5ad-135">控制項是三個圓圈，每次只會亮其中一個。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-135">The control is three circles, only one of which can be lit up at a time.</span></span> <span data-ttu-id="5b5ad-136">一些反映之後, 您可能會發現<xref:System.Windows.Controls.RadioButton>提供的功能只能選取一個時間，但預設外觀的<xref:System.Windows.Controls.RadioButton>看起來不像號誌燈的亮燈。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-136">After some reflection, you might realize that a <xref:System.Windows.Controls.RadioButton> offers the functionality of only one being selected at a time, but the default appearance of the <xref:System.Windows.Controls.RadioButton> looks nothing like the lights on a stoplight.</span></span>  <span data-ttu-id="5b5ad-137">因為<xref:System.Windows.Controls.RadioButton>使用控制項範本定義其外觀時，就可以輕鬆地重新定義<xref:System.Windows.Controls.ControlTemplate>容納控制項的需求，並使用選項按鈕製作號誌燈。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-137">Because the <xref:System.Windows.Controls.RadioButton> uses a control template to define its appearance, it is easy to redefine the <xref:System.Windows.Controls.ControlTemplate> to fit the requirements of the control, and use radio buttons to make your stoplight.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="5b5ad-138">雖然<xref:System.Windows.Controls.RadioButton>可以使用<xref:System.Windows.DataTemplate>、<xref:System.Windows.DataTemplate>不足，無法在此範例中。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-138">Although a <xref:System.Windows.Controls.RadioButton> can use a <xref:System.Windows.DataTemplate>, a <xref:System.Windows.DataTemplate> is not sufficient in this example.</span></span>  <span data-ttu-id="5b5ad-139"><xref:System.Windows.DataTemplate>定義控制項內容的外觀。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-139">The <xref:System.Windows.DataTemplate> defines the appearance of the content of a control.</span></span> <span data-ttu-id="5b5ad-140">若是<xref:System.Windows.Controls.RadioButton>，內容是任何顯示於右側的圓形，指出是否<xref:System.Windows.Controls.RadioButton>已選取。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-140">In the case of a <xref:System.Windows.Controls.RadioButton>, the content is whatever appears to the right of the circle that indicates whether the <xref:System.Windows.Controls.RadioButton> is selected.</span></span>  <span data-ttu-id="5b5ad-141">在號誌燈的範例中，選項按鈕只需要是可以發亮的圓圈。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-141">In the example of the stoplight, the radio button needs just be a circle that can "light up."</span></span> <span data-ttu-id="5b5ad-142">因為號誌燈的外觀需求是如此的不同的預設外觀<xref:System.Windows.Controls.RadioButton>，就必須重新定義<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-142">Because the appearance requirement for the stoplight is so different than the default appearance of the <xref:System.Windows.Controls.RadioButton>, it is necessary to redefine the <xref:System.Windows.Controls.ControlTemplate>.</span></span>  <span data-ttu-id="5b5ad-143">一般而言<xref:System.Windows.DataTemplate>用來定義的內容 （或資料） 的控制項，以及<xref:System.Windows.Controls.ControlTemplate>用於定義控制項的結構方式。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-143">In general a <xref:System.Windows.DataTemplate> is used for defining the content (or data) of a control, and a <xref:System.Windows.Controls.ControlTemplate> is used for defining how a control is structured.</span></span>  
  
-   <span data-ttu-id="5b5ad-144">**觸發程序。**</span><span class="sxs-lookup"><span data-stu-id="5b5ad-144">**Triggers.**</span></span> <span data-ttu-id="5b5ad-145">A<xref:System.Windows.Trigger>可讓您以動態方式變更的外觀和行為的控制項，而不需要建立新的控制項。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-145">A <xref:System.Windows.Trigger> allows you to dynamically change the appearance and behavior of a control without creating a new control.</span></span> <span data-ttu-id="5b5ad-146">例如，假設您有多個<xref:System.Windows.Controls.ListBox>應用程式中的控制項和想要在每個項目<xref:System.Windows.Controls.ListBox>選取時，其中是粗體的紅色。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-146">For example, suppose you have multiple <xref:System.Windows.Controls.ListBox> controls in your application and want the items in each <xref:System.Windows.Controls.ListBox> to be bold and red when they are selected.</span></span> <span data-ttu-id="5b5ad-147">您的第一個想法可能是建立繼承自類別<xref:System.Windows.Controls.ListBox>，並覆寫<xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A>方法，以變更選取的項目，但更好的方法的外觀是將觸發程序加入至樣式<xref:System.Windows.Controls.ListBoxItem>變更其外觀的選取的項目。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-147">Your first instinct might be to create a class that inherits from <xref:System.Windows.Controls.ListBox> and override the <xref:System.Windows.Controls.Primitives.Selector.OnSelectionChanged%2A> method to change the appearance of the selected item, but a better approach is to add a trigger to a style of a <xref:System.Windows.Controls.ListBoxItem> that changes the appearance of the selected item.</span></span> <span data-ttu-id="5b5ad-148">觸發程序可讓您變更屬性值，或是依據屬性值採取動作。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-148">A trigger enables you to change property values or take actions based on the value of a property.</span></span> <span data-ttu-id="5b5ad-149"><xref:System.Windows.EventTrigger>可讓您在事件發生時採取的動作。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-149">An <xref:System.Windows.EventTrigger> enables you to take actions when an event occurs.</span></span>  
  
 <span data-ttu-id="5b5ad-150">如需樣式、範本和觸發程序的詳細資訊，請參閱[設定樣式和範本](../../../../docs/framework/wpf/controls/styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-150">For more information about styles, templates, and triggers, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="5b5ad-151">一般而言，若您的控制項可以對應到現有控制項的功能，但您希望控制項看起來不太一樣，則應該先考慮是否能使用本節中所討論的任何方法來變更現有控制項的外觀。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-151">In general, if your control mirrors the functionality of an existing control, but you want the control to look different, you should first consider whether you can use any of the methods discussed in this section to change the existing control's appearance.</span></span>  
  
<a name="models_for_control_authoring"></a>   
## <a name="models-for-control-authoring"></a><span data-ttu-id="5b5ad-152">控制項撰寫模型</span><span class="sxs-lookup"><span data-stu-id="5b5ad-152">Models for Control Authoring</span></span>  
 <span data-ttu-id="5b5ad-153">豐富的內容模型、樣式、範本和觸發程序，可以讓您將建立新控制項的需求降到最低。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-153">The rich content model, styles, templates, and triggers minimize the need for you to create a new control.</span></span> <span data-ttu-id="5b5ad-154">然而，若有必要建立新的控制項，最好能先了解 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的不同控制項撰寫模型。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-154">However, if you do need to create a new control, it is important to understand the different control authoring models in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="5b5ad-155"> 提供三種建立控制項的常用模型，每種模型都提供不同的功能集和不同程度的彈性。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-155"> provides three general models for creating a control, each of which provides a different set of features and level of flexibility.</span></span> <span data-ttu-id="5b5ad-156">基底類別的三個模型都<xref:System.Windows.Controls.UserControl>， <xref:System.Windows.Controls.Control>，和<xref:System.Windows.FrameworkElement>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-156">The base classes for the three models are <xref:System.Windows.Controls.UserControl>, <xref:System.Windows.Controls.Control>, and <xref:System.Windows.FrameworkElement>.</span></span>  
  
### <a name="deriving-from-usercontrol"></a><span data-ttu-id="5b5ad-157">衍生自 UserControl</span><span class="sxs-lookup"><span data-stu-id="5b5ad-157">Deriving from UserControl</span></span>  
 <span data-ttu-id="5b5ad-158">中建立控制項最簡單的辦法[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]是衍生自<xref:System.Windows.Controls.UserControl>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-158">The simplest way to create a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to derive from <xref:System.Windows.Controls.UserControl>.</span></span> <span data-ttu-id="5b5ad-159">當您建置控制項，繼承自<xref:System.Windows.Controls.UserControl>，您將現有的元件，加入<xref:System.Windows.Controls.UserControl>、 為元件命名，並參考中的事件處理常式[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-159">When you build a control that inherits from <xref:System.Windows.Controls.UserControl>, you add existing components to the <xref:System.Windows.Controls.UserControl>, name the components, and reference event handlers in [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)].</span></span> <span data-ttu-id="5b5ad-160">接著，您可以在程式碼中參考該具名項目，並定義事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-160">You can then reference the named elements and define the event handlers in code.</span></span> <span data-ttu-id="5b5ad-161">這個開發模型與 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中應用程式開發所使用的模型非常類似。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-161">This development model is very similar to the model used for application development in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
 <span data-ttu-id="5b5ad-162">如果正確，建置<xref:System.Windows.Controls.UserControl>可以利用豐富的內容、 樣式和觸發程序的優點。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-162">If built correctly, a <xref:System.Windows.Controls.UserControl> can take advantage of the benefits of rich content, styles, and triggers.</span></span> <span data-ttu-id="5b5ad-163">不過，如果您的控制項繼承自<xref:System.Windows.Controls.UserControl>，使用您的控制項的人將無法使用<xref:System.Windows.DataTemplate>或<xref:System.Windows.Controls.ControlTemplate>以自訂其外觀。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-163">However, if your control inherits from <xref:System.Windows.Controls.UserControl>, people who use your control will not be able to use a <xref:System.Windows.DataTemplate> or <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span>  <span data-ttu-id="5b5ad-164">必須衍生自<xref:System.Windows.Controls.Control>類別或其中一個衍生的類別 (而非<xref:System.Windows.Controls.UserControl>) 建立自訂的控制項可支援範本。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-164">It is necessary to derive from the <xref:System.Windows.Controls.Control> class or one of its derived classes (other than <xref:System.Windows.Controls.UserControl>) to create a custom control that supports templates.</span></span>  
  
#### <a name="benefits-of-deriving-from-usercontrol"></a><span data-ttu-id="5b5ad-165">從 UserControl 衍生的優點</span><span class="sxs-lookup"><span data-stu-id="5b5ad-165">Benefits of Deriving from UserControl</span></span>  
 <span data-ttu-id="5b5ad-166">請考慮衍生自<xref:System.Windows.Controls.UserControl>如果下列所有項目套用：</span><span class="sxs-lookup"><span data-stu-id="5b5ad-166">Consider deriving from <xref:System.Windows.Controls.UserControl> if all of the following apply:</span></span>  
  
-   <span data-ttu-id="5b5ad-167">您想要以類似建置應用程式的方式來建置控制項。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-167">You want to build your control similarly to how you build an application.</span></span>  
  
-   <span data-ttu-id="5b5ad-168">您的控制項只包含現有的元件。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-168">Your control consists only of existing components.</span></span>  
  
-   <span data-ttu-id="5b5ad-169">您不需要支援複雜的自訂作業。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-169">You don't need to support complex customization.</span></span>  
  
### <a name="deriving-from-control"></a><span data-ttu-id="5b5ad-170">衍生自 Control</span><span class="sxs-lookup"><span data-stu-id="5b5ad-170">Deriving from Control</span></span>  
 <span data-ttu-id="5b5ad-171">衍生自<xref:System.Windows.Controls.Control>類別是使用大部分現有的模型[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]控制項。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-171">Deriving from the <xref:System.Windows.Controls.Control> class is the model used by most of the existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] controls.</span></span> <span data-ttu-id="5b5ad-172">當您建立的控制項繼承自<xref:System.Windows.Controls.Control>使用範本欄位定義其外觀類別。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-172">When you create a control that inherits from the <xref:System.Windows.Controls.Control> class, you define its appearance by using templates.</span></span> <span data-ttu-id="5b5ad-173">這樣做您便可以將作業邏輯與視覺表示方式分開處理。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-173">By doing so, you separate the operational logic from the visual representation.</span></span> <span data-ttu-id="5b5ad-174">您也可以確保使用命令和繫結，而不是事件並避免參考的項目中的 UI 和邏輯分離<xref:System.Windows.Controls.ControlTemplate>盡可能。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-174">You can also ensure the decoupling of the UI and logic by using commands and bindings instead of events and avoiding referencing elements in the <xref:System.Windows.Controls.ControlTemplate> whenever possible.</span></span>  <span data-ttu-id="5b5ad-175">如果 UI 和控制項的邏輯適當分開處理，則控制項的使用者可以重新定義控制項的<xref:System.Windows.Controls.ControlTemplate>以自訂其外觀。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-175">If the UI and logic of your control are properly decoupled, a user of your control can redefine the control's <xref:System.Windows.Controls.ControlTemplate> to customize its appearance.</span></span> <span data-ttu-id="5b5ad-176">雖然建置自訂<xref:System.Windows.Controls.Control>不是簡單，只要建置<xref:System.Windows.Controls.UserControl>，自訂<xref:System.Windows.Controls.Control>提供最大的彈性。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-176">Although building a custom <xref:System.Windows.Controls.Control> is not as simple as building a <xref:System.Windows.Controls.UserControl>, a custom <xref:System.Windows.Controls.Control> provides the most flexibility.</span></span>  
  
#### <a name="benefits-of-deriving-from-control"></a><span data-ttu-id="5b5ad-177">從 Control 衍生的優點</span><span class="sxs-lookup"><span data-stu-id="5b5ad-177">Benefits of Deriving from Control</span></span>  
 <span data-ttu-id="5b5ad-178">請考慮衍生自<xref:System.Windows.Controls.Control>而不是使用<xref:System.Windows.Controls.UserControl>類別如果有的話則適用下列步驟：</span><span class="sxs-lookup"><span data-stu-id="5b5ad-178">Consider deriving from <xref:System.Windows.Controls.Control> instead of using the <xref:System.Windows.Controls.UserControl> class if any of the following apply:</span></span>  
  
-   <span data-ttu-id="5b5ad-179">您想要透過可自訂控制項外觀<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-179">You want the appearance of your control to be customizable via the <xref:System.Windows.Controls.ControlTemplate>.</span></span>  
  
-   <span data-ttu-id="5b5ad-180">您想要控制項支援不同的佈景主題。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-180">You want your control to support different themes.</span></span>  
  
### <a name="deriving-from-frameworkelement"></a><span data-ttu-id="5b5ad-181">衍生自 FrameworkElement</span><span class="sxs-lookup"><span data-stu-id="5b5ad-181">Deriving from FrameworkElement</span></span>  
 <span data-ttu-id="5b5ad-182">控制項是衍生自<xref:System.Windows.Controls.UserControl>或<xref:System.Windows.Controls.Control>需要撰寫現有的項目。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-182">Controls that derive from <xref:System.Windows.Controls.UserControl> or <xref:System.Windows.Controls.Control> rely upon composing existing elements.</span></span> <span data-ttu-id="5b5ad-183">對於許多案例中，這是可接受的解決方案，因為任何物件，繼承自<xref:System.Windows.FrameworkElement>可以是<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-183">For many scenarios, this is an acceptable solution, because any object that inherits from <xref:System.Windows.FrameworkElement> can be in a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="5b5ad-184">然而，有時候控制項外觀需要的不僅止於簡單項目組合的功能。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-184">However, there are times when a control's appearance requires more than the functionality of simple element composition.</span></span> <span data-ttu-id="5b5ad-185">針對這些案例中，為基礎的元件<xref:System.Windows.FrameworkElement>是正確的選擇。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-185">For these scenarios, basing a component on <xref:System.Windows.FrameworkElement> is the right choice.</span></span>  
  
 <span data-ttu-id="5b5ad-186">有兩種標準方法，用於建置<xref:System.Windows.FrameworkElement>為基礎的元件： 直接轉譯和自訂項目組合。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-186">There are two standard methods for building <xref:System.Windows.FrameworkElement>-based components: direct rendering and custom element composition.</span></span> <span data-ttu-id="5b5ad-187">直接轉譯是覆寫<xref:System.Windows.UIElement.OnRender%2A>方法<xref:System.Windows.FrameworkElement>，並提供<xref:System.Windows.Media.DrawingContext>明確定義元件視覺效果的作業。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-187">Direct rendering involves overriding the <xref:System.Windows.UIElement.OnRender%2A> method of <xref:System.Windows.FrameworkElement> and providing <xref:System.Windows.Media.DrawingContext> operations that explicitly define the component visuals.</span></span> <span data-ttu-id="5b5ad-188">這是所使用的方法<xref:System.Windows.Controls.Image>和<xref:System.Windows.Controls.Border>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-188">This is the method used by <xref:System.Windows.Controls.Image> and <xref:System.Windows.Controls.Border>.</span></span> <span data-ttu-id="5b5ad-189">自訂項目組合則是使用物件型別的<xref:System.Windows.Media.Visual>撰寫元件的外觀。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-189">Custom element composition involves using objects of type <xref:System.Windows.Media.Visual> to compose the appearance of your component.</span></span> <span data-ttu-id="5b5ad-190">如需範例，請參閱[使用 DrawingVisual 物件](../../../../docs/framework/wpf/graphics-multimedia/using-drawingvisual-objects.md)。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-190">For an example, see [Using DrawingVisual Objects](../../../../docs/framework/wpf/graphics-multimedia/using-drawingvisual-objects.md).</span></span> <span data-ttu-id="5b5ad-191"><xref:System.Windows.Controls.Primitives.Track> 舉例說明中的控制項[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]使用自訂的項目組合。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-191"><xref:System.Windows.Controls.Primitives.Track> is an example of a control in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] that uses custom element composition.</span></span> <span data-ttu-id="5b5ad-192">您也可以在同一個控制項中混合使用直接轉譯和自訂項目組合。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-192">It is also possible to mix direct rendering and custom element composition in the same control.</span></span>  
  
#### <a name="benefits-of-deriving-from-frameworkelement"></a><span data-ttu-id="5b5ad-193">從 FrameworkElement 衍生的優點</span><span class="sxs-lookup"><span data-stu-id="5b5ad-193">Benefits of Deriving from FrameworkElement</span></span>  
 <span data-ttu-id="5b5ad-194">請考慮衍生自<xref:System.Windows.FrameworkElement>如果有的話則適用下列步驟：</span><span class="sxs-lookup"><span data-stu-id="5b5ad-194">Consider deriving from <xref:System.Windows.FrameworkElement> if any of the following apply:</span></span>  
  
-   <span data-ttu-id="5b5ad-195">您想要精確控制控制項的外觀，而這超出了簡單項目組合所能提供的控制。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-195">You want to have precise control over the appearance of your control beyond what is provided by simple element composition.</span></span>  
  
-   <span data-ttu-id="5b5ad-196">您想要藉由定義自己的轉譯邏輯，來定義控制項的外觀。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-196">You want to define the appearance of your control by defining your own render logic.</span></span>  
  
-   <span data-ttu-id="5b5ad-197">您想要超越了全新方式撰寫現有的項目<xref:System.Windows.Controls.UserControl>和<xref:System.Windows.Controls.Control>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-197">You want to compose existing elements in novel ways that go beyond what is possible with <xref:System.Windows.Controls.UserControl> and <xref:System.Windows.Controls.Control>.</span></span>  
  
<a name="control_authoring_basics"></a>   
## <a name="control-authoring-basics"></a><span data-ttu-id="5b5ad-198">控制項撰寫基本概念</span><span class="sxs-lookup"><span data-stu-id="5b5ad-198">Control Authoring Basics</span></span>  
 <span data-ttu-id="5b5ad-199">如稍早所討論，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 其中一個最強大的功能，在於除了設定控制項的基本屬性之外，尚有能力變更其外觀和行為，並且不需要建立自訂控制項。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-199">As discussed earlier, one of the most powerful features of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the ability to go beyond setting basic properties of a control to change its appearance and behavior, yet still not needing to create a custom control.</span></span> <span data-ttu-id="5b5ad-200">樣式、資料繫結和觸發程序功能是透過 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 屬性系統和 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 事件系統來達成的。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-200">The styling, data binding, and trigger features are made possible by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system and the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="5b5ad-201">下列各節說明您應該遵循的一些做法，而不論您是使用哪種模型來建立自訂控制項，讓自訂控制項的使用者能夠使用這些功能，就如同使用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 隨附的控制項一樣。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-201">The following sections describe some practices that you should follow, regardless of the model you use to create the custom control, so that users of your custom control can use these features just as they would for a control that is included with [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
### <a name="use-dependency-properties"></a><span data-ttu-id="5b5ad-202">使用相依性屬性</span><span class="sxs-lookup"><span data-stu-id="5b5ad-202">Use Dependency Properties</span></span>  
 <span data-ttu-id="5b5ad-203">當屬性是相依性屬性時，有可能會進行下列作業：</span><span class="sxs-lookup"><span data-stu-id="5b5ad-203">When a property is a dependency property, it is possible to do the following:</span></span>  
  
-   <span data-ttu-id="5b5ad-204">設定樣式中的屬性。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-204">Set the property in a style.</span></span>  
  
-   <span data-ttu-id="5b5ad-205">將屬性繫結至資料來源。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-205">Bind the property to a data source.</span></span>  
  
-   <span data-ttu-id="5b5ad-206">使用動態資源作為屬性值。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-206">Use a dynamic resource as the property's value.</span></span>  
  
-   <span data-ttu-id="5b5ad-207">顯示屬性的動畫。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-207">Animate the property.</span></span>  
  
 <span data-ttu-id="5b5ad-208">若希望控制項屬性可以支援這些任一功能，就應該將控制項實作為相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-208">If you want a property of your control to support any of this functionality, you should implement it as a dependency property.</span></span> <span data-ttu-id="5b5ad-209">下列範例會藉由執行下列動作，定義名為 `Value` 的相依性屬性：</span><span class="sxs-lookup"><span data-stu-id="5b5ad-209">The following example defines a dependency property named `Value` by doing the following:</span></span>  
  
-   <span data-ttu-id="5b5ad-210">定義<xref:System.Windows.DependencyProperty>名為的識別項`ValueProperty`作為`public` `static` `readonly`欄位。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-210">Define a <xref:System.Windows.DependencyProperty> identifier named `ValueProperty` as a `public` `static` `readonly` field.</span></span>  
  
-   <span data-ttu-id="5b5ad-211">向屬性系統中的屬性名稱，藉由呼叫<xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType>，以指定下列項目：</span><span class="sxs-lookup"><span data-stu-id="5b5ad-211">Register the property name with the property system, by calling <xref:System.Windows.DependencyProperty.Register%2A?displayProperty=nameWithType>, to specify the following:</span></span>  
  
    -   <span data-ttu-id="5b5ad-212">屬性的名稱。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-212">The name of the property.</span></span>  
  
    -   <span data-ttu-id="5b5ad-213">屬性的類型。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-213">The type of the property.</span></span>  
  
    -   <span data-ttu-id="5b5ad-214">擁有屬性的類型。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-214">The type that owns the property.</span></span>  
  
    -   <span data-ttu-id="5b5ad-215">屬性的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-215">The metadata for the property.</span></span> <span data-ttu-id="5b5ad-216">中繼資料包含屬性的預設值，<xref:System.Windows.CoerceValueCallback>和<xref:System.Windows.PropertyChangedCallback>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-216">The metadata contains the property's default value, a <xref:System.Windows.CoerceValueCallback> and a <xref:System.Windows.PropertyChangedCallback>.</span></span>  
  
-   <span data-ttu-id="5b5ad-217">藉由實作屬性的 `get` 和 `set` 存取子，定義名為 `Value` 的 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 包裝函式屬性，這個名稱與註冊相依性屬性所使用的名稱相同。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-217">Define a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] wrapper property named `Value`, which is the same name that is used to register the dependency property, by implementing the property's `get` and `set` accessors.</span></span> <span data-ttu-id="5b5ad-218">請注意，`get`並`set`存取子只呼叫<xref:System.Windows.DependencyObject.GetValue%2A>和<xref:System.Windows.DependencyObject.SetValue%2A>分別。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-218">Note that the `get` and `set` accessors only call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> respectively.</span></span> <span data-ttu-id="5b5ad-219">建議是因為，相依性屬性的存取子不包含額外的邏輯用戶端和[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]存取子和呼叫就可以略過<xref:System.Windows.DependencyObject.GetValue%2A>和<xref:System.Windows.DependencyObject.SetValue%2A>直接。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-219">It is recommended that the accessors of dependency properties not contain additional logic because clients and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can bypass the accessors and call <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> directly.</span></span> <span data-ttu-id="5b5ad-220">例如，在屬性繫結到資料來源時，就不會呼叫屬性的 `set` 存取子。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-220">For example, when a property is bound to a data source, the property's `set` accessor is not called.</span></span>  <span data-ttu-id="5b5ad-221">而不是將其他邏輯新增至 get 和 set 存取子，請使用<xref:System.Windows.ValidateValueCallback>， <xref:System.Windows.CoerceValueCallback>，和<xref:System.Windows.PropertyChangedCallback>回應，或變更時，請檢查值的委派。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-221">Instead of adding additional logic to the get and set accessors, use the <xref:System.Windows.ValidateValueCallback>, <xref:System.Windows.CoerceValueCallback>, and <xref:System.Windows.PropertyChangedCallback> delegates to respond to or check the value when it changes.</span></span>  <span data-ttu-id="5b5ad-222">如需這些回呼的詳細資訊，請參閱[相依性屬性回呼和驗證](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-222">For more information on these callbacks, see [Dependency Property Callbacks and Validation](../../../../docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).</span></span>  
  
-   <span data-ttu-id="5b5ad-223">定義方法<xref:System.Windows.CoerceValueCallback>名為`CoerceValue`。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-223">Define a method for the <xref:System.Windows.CoerceValueCallback> named `CoerceValue`.</span></span> <span data-ttu-id="5b5ad-224">`CoerceValue` 可以確保 `Value` 大於或等於 `MinValue`，且小於或等於 `MaxValue`。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-224">`CoerceValue` ensures that `Value` is greater or equal to `MinValue` and less than or equal to `MaxValue`.</span></span>  
  
-   <span data-ttu-id="5b5ad-225">定義方法<xref:System.Windows.PropertyChangedCallback>具名`OnValueChanged`。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-225">Define a method for the <xref:System.Windows.PropertyChangedCallback>, named `OnValueChanged`.</span></span> <span data-ttu-id="5b5ad-226">`OnValueChanged` 會建立<xref:System.Windows.RoutedPropertyChangedEventArgs%601>物件，並準備引發`ValueChanged`路由的事件。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-226">`OnValueChanged` creates a <xref:System.Windows.RoutedPropertyChangedEventArgs%601> object and prepares to raise the `ValueChanged` routed event.</span></span> <span data-ttu-id="5b5ad-227">下一節中將討論路由事件。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-227">Routed events are discussed in the next section.</span></span>  
  
 [!code-csharp[UserControlNumericUpDown#DependencyProperty](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#dependencyproperty)]
 [!code-vb[UserControlNumericUpDown#DependencyProperty](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#dependencyproperty)]  
  
 <span data-ttu-id="5b5ad-228">如需詳細資訊，請參閱[自訂相依性屬性](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-228">For more information, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
### <a name="use-routed-events"></a><span data-ttu-id="5b5ad-229">使用路由事件</span><span class="sxs-lookup"><span data-stu-id="5b5ad-229">Use Routed Events</span></span>  
 <span data-ttu-id="5b5ad-230">就如同相依性屬性會使用其他功能擴充 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 屬性的概念，路由事件也同樣擴充了標準 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件的概念。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-230">Just as dependency properties extend the notion of [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] properties with additional functionality, routed events extend the notion of standard [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] events.</span></span> <span data-ttu-id="5b5ad-231">建立新的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 控制項時，最好也能將事件實作為路由事件，因為路由事件支援下列行為：</span><span class="sxs-lookup"><span data-stu-id="5b5ad-231">When you create a new [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control, it is also good practice to implement your event as a routed event because a routed event supports the following behavior:</span></span>  
  
-   <span data-ttu-id="5b5ad-232">事件可以對多個控制項的父項進行處理。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-232">Events can be handled on a parent of multiple controls.</span></span> <span data-ttu-id="5b5ad-233">若事件是反昇事件，項目樹狀結構中的單一父項可以訂閱事件。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-233">If an event is a bubbling event, a single parent in the element tree can subscribe to the event.</span></span> <span data-ttu-id="5b5ad-234">然後應用程式作者可以使用一個處理常式，以回應多個控制項的事件。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-234">Then application authors can use one handler to respond to the event of multiple controls.</span></span> <span data-ttu-id="5b5ad-235">例如，如果您的控制項是在每個項目一部分<xref:System.Windows.Controls.ListBox>(因為它包含在<xref:System.Windows.DataTemplate>)，應用程式開發人員可以定義您的控制項事件的事件處理常式上<xref:System.Windows.Controls.ListBox>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-235">For example, if your control is a part of each item in a <xref:System.Windows.Controls.ListBox> (because it is included in a <xref:System.Windows.DataTemplate>), the application developer can define the event handler for your control's event on the <xref:System.Windows.Controls.ListBox>.</span></span> <span data-ttu-id="5b5ad-236">每當任一控制項上發生事件時，就會呼叫事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-236">Whenever the event occurs on any of the controls, the event handler is called.</span></span>  
  
-   <span data-ttu-id="5b5ad-237">路由的事件可用於<xref:System.Windows.EventSetter>，可讓應用程式開發人員指定樣式內的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-237">Routed events can be used in an <xref:System.Windows.EventSetter>, which enables application developers to specify the handler of an event within a style.</span></span>  
  
-   <span data-ttu-id="5b5ad-238">路由的事件可用於<xref:System.Windows.EventTrigger>，這是用於建立屬性動畫使用[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-238">Routed events can be used in an <xref:System.Windows.EventTrigger>, which is useful for animating properties by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="5b5ad-239">如需詳細資訊，請參閱 [動畫概觀](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-239">For more information, see [Animation Overview](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md).</span></span>  
  
 <span data-ttu-id="5b5ad-240">下列範例會藉由執行下列動作，定義路由事件：</span><span class="sxs-lookup"><span data-stu-id="5b5ad-240">The following example defines a routed event by doing the following:</span></span>  
  
-   <span data-ttu-id="5b5ad-241">定義<xref:System.Windows.RoutedEvent>名為的識別項`ValueChangedEvent`作為`public` `static` `readonly`欄位。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-241">Define a <xref:System.Windows.RoutedEvent> identifier named `ValueChangedEvent` as a `public` `static` `readonly` field.</span></span>  
  
-   <span data-ttu-id="5b5ad-242">藉由呼叫註冊路由的事件<xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-242">Register the routed event by calling the <xref:System.Windows.EventManager.RegisterRoutedEvent%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="5b5ad-243">呼叫時，此範例會指定下列資訊<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>:</span><span class="sxs-lookup"><span data-stu-id="5b5ad-243">The example specifies the following information when it calls <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>:</span></span>  
  
    -   <span data-ttu-id="5b5ad-244">事件名稱是 `ValueChanged`。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-244">The name of the event is `ValueChanged`.</span></span>  
  
    -   <span data-ttu-id="5b5ad-245">路由策略是<xref:System.Windows.RoutingStrategy.Bubble>，這表示，在來源 （引發事件的物件） 上的事件處理常式會呼叫第一次，然後接續，開始在最接近的事件處理常式呼叫來源的父項目上的事件處理常式父項目。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-245">The routing strategy is <xref:System.Windows.RoutingStrategy.Bubble>, which means that an event handler on the source (the object that raises the event) is called first, and then event handlers on the source's parent elements are called in succession, starting with the event handler on the closest parent element.</span></span>  
  
    -   <span data-ttu-id="5b5ad-246">事件處理常式的類型是<xref:System.Windows.RoutedPropertyChangedEventHandler%601>，以建構<xref:System.Decimal>型別。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-246">The type of the event handler is <xref:System.Windows.RoutedPropertyChangedEventHandler%601>, constructed with a <xref:System.Decimal> type.</span></span>  
  
    -   <span data-ttu-id="5b5ad-247">事件的擁有者類型是 `NumericUpDown`。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-247">The owning type of the event is `NumericUpDown`.</span></span>  
  
-   <span data-ttu-id="5b5ad-248">宣告名為 `ValueChanged` 的公用事件，並包含事件存取子宣告。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-248">Declare a public event named `ValueChanged` and includes event-accessor declarations.</span></span> <span data-ttu-id="5b5ad-249">此範例會呼叫<xref:System.Windows.UIElement.AddHandler%2A>中`add`存取子宣告並<xref:System.Windows.UIElement.RemoveHandler%2A>中`remove`存取子宣告，以使用[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]事件服務。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-249">The example calls <xref:System.Windows.UIElement.AddHandler%2A> in the `add` accessor declaration and <xref:System.Windows.UIElement.RemoveHandler%2A> in the `remove` accessor declaration to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event services.</span></span>  
  
-   <span data-ttu-id="5b5ad-250">建立名為 `OnValueChanged` 的受保護虛擬方法，該方法會引發 `ValueChanged` 事件。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-250">Create a protected, virtual method named `OnValueChanged` that raises the `ValueChanged` event.</span></span>  
  
 [!code-csharp[UserControlNumericUpDown#RoutedEvent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml.cs#routedevent)]
 [!code-vb[UserControlNumericUpDown#RoutedEvent](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDown/visualbasic/numericupdown.xaml.vb#routedevent)]  
  
 <span data-ttu-id="5b5ad-251">如需詳細資訊，請參閱[路由事件概觀](../../../../docs/framework/wpf/advanced/routed-events-overview.md)和[建立自訂路由事件](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md)。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-251">For more information, see [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md) and [Create a Custom Routed Event](../../../../docs/framework/wpf/advanced/how-to-create-a-custom-routed-event.md).</span></span>  
  
### <a name="use-binding"></a><span data-ttu-id="5b5ad-252">使用繫結</span><span class="sxs-lookup"><span data-stu-id="5b5ad-252">Use Binding</span></span>  
 <span data-ttu-id="5b5ad-253">若要降低控制項 UI 和邏輯間的耦合，請考慮使用資料繫結。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-253">To decouple the UI of your control from its logic, consider using data binding.</span></span> <span data-ttu-id="5b5ad-254">這是特別重要，如果您使用定義控制項外觀<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-254">This is particularly important if you define the appearance of your control by using a <xref:System.Windows.Controls.ControlTemplate>.</span></span> <span data-ttu-id="5b5ad-255">在您使用資料繫結時，也許可以排除從程式碼參考特定部分之 UI 的需要。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-255">When you use data binding, you might be able to eliminate the need to reference specific parts of the UI from the code.</span></span> <span data-ttu-id="5b5ad-256">它是個不錯的主意，若要避免參考中的項目<xref:System.Windows.Controls.ControlTemplate>因為當程式碼參考中的項目<xref:System.Windows.Controls.ControlTemplate>並<xref:System.Windows.Controls.ControlTemplate>變更時，參考的項目必須包含在新<xref:System.Windows.Controls.ControlTemplate>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-256">It's a good idea to avoid referencing elements that are in the <xref:System.Windows.Controls.ControlTemplate> because when the code references elements that are in the <xref:System.Windows.Controls.ControlTemplate> and the <xref:System.Windows.Controls.ControlTemplate> is changed, the referenced element needs to be included in the new <xref:System.Windows.Controls.ControlTemplate>.</span></span>  
  
 <span data-ttu-id="5b5ad-257">下列範例會更新<xref:System.Windows.Controls.TextBlock>的`NumericUpDown`控制項，將名稱指派給它，並在程式碼中依名稱參考文字方塊。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-257">The following example updates the <xref:System.Windows.Controls.TextBlock> of the `NumericUpDown` control, assigning a name to it and referencing the textbox by name in code.</span></span>  
  
 [!code-xaml[UserControlNumericUpDownSimple#UIRefMarkup](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml#uirefmarkup)]  
  
 [!code-csharp[UserControlNumericUpDownSimple#UIRefCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDownSimple/CSharp/NumericUpDown.xaml.cs#uirefcode)]
 [!code-vb[UserControlNumericUpDownSimple#UIRefCode](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/UserControlNumericUpDownSimple/VisualBasic/NumericUpDown.xaml.vb#uirefcode)]  
  
 <span data-ttu-id="5b5ad-258">下列範例使用繫結達成相同目的。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-258">The following example uses binding to accomplish the same thing.</span></span>  
  
 [!code-xaml[UserControlNumericUpDown#Binding](../../../../samples/snippets/csharp/VS_Snippets_Wpf/UserControlNumericUpDown/CSharp/NumericUpDown.xaml#binding)]  
  
 <span data-ttu-id="5b5ad-259">如需資料繫結的詳細資訊，請參閱[資料繫結概觀](../../../../docs/framework/wpf/data/data-binding-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-259">For more information about data binding, see [Data Binding Overview](../../../../docs/framework/wpf/data/data-binding-overview.md).</span></span>  
  
### <a name="design-for-designers"></a><span data-ttu-id="5b5ad-260">設計工具的設計</span><span class="sxs-lookup"><span data-stu-id="5b5ad-260">Design for Designers</span></span>  
 <span data-ttu-id="5b5ad-261">若要獲得 [!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] 中的自訂 WPF 控制項支援 (例如使用 [屬性] 視窗編輯屬性)，請遵循這些方針。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-261">To receive support for custom WPF controls in the [!INCLUDE[wpfdesigner_current_long](../../../../includes/wpfdesigner-current-long-md.md)] (for example, property editing with the Properties window), follow these guidelines.</span></span>  <span data-ttu-id="5b5ad-262">如需有關開發[!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)]，請參閱 < [Visual Studio 中設計 XAML](/visualstudio/designers/designing-xaml-in-visual-studio)。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-262">For more information on developing for the [!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)], see [Design XAML in Visual Studio](/visualstudio/designers/designing-xaml-in-visual-studio).</span></span>  
  
#### <a name="dependency-properties"></a><span data-ttu-id="5b5ad-263">相依性屬性</span><span class="sxs-lookup"><span data-stu-id="5b5ad-263">Dependency Properties</span></span>  
 <span data-ttu-id="5b5ad-264">請務必依照稍早「使用相依性屬性」中的討論來實作 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] `get` 和 `set` 存取子。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-264">Be sure to implement [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] `get` and `set` accessors as described earlier, in "Use Dependency Properties."</span></span> <span data-ttu-id="5b5ad-265">設計工具可以使用包裝函式來偵測相依性屬性的存在，但就跟 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 和控制項用戶端一樣，設計工具在取得或設定屬性時不一定要呼叫存取子。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-265">Designers may use the wrapper to detect the presence of a dependency property, but they, like [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and clients of the control, are not required to call the accessors when getting or setting the property.</span></span>  
  
#### <a name="attached-properties"></a><span data-ttu-id="5b5ad-266">附加屬性</span><span class="sxs-lookup"><span data-stu-id="5b5ad-266">Attached Properties</span></span>  
 <span data-ttu-id="5b5ad-267">請使用下列方針，實作自訂控制項上的附加屬性：</span><span class="sxs-lookup"><span data-stu-id="5b5ad-267">You should implement attached properties on custom controls using the following guidelines:</span></span>  
  
-   <span data-ttu-id="5b5ad-268">已`public` `static` `readonly` <xref:System.Windows.DependencyProperty>的形式*PropertyName* `Property` ，建立使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-268">Have a `public` `static` `readonly` <xref:System.Windows.DependencyProperty> of the form *PropertyName*`Property` that was creating using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="5b5ad-269">屬性名稱傳遞給<xref:System.Windows.DependencyProperty.RegisterAttached%2A>必須符合*PropertyName*。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-269">The property name that is passed to <xref:System.Windows.DependencyProperty.RegisterAttached%2A> must match *PropertyName*.</span></span>  
  
-   <span data-ttu-id="5b5ad-270">實作一組 `public` `static` CLR 方法，分別名為 `Set`<屬性名稱> 和 `Get`<屬性名稱>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-270">Implement a pair of `public` `static` CLR methods named `Set`*PropertyName* and `Get`*PropertyName*.</span></span> <span data-ttu-id="5b5ad-271">這兩種方法應接受衍生自<xref:System.Windows.DependencyProperty>做為其第一個引數。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-271">Both methods should accept a class derived from <xref:System.Windows.DependencyProperty> as their first argument.</span></span> <span data-ttu-id="5b5ad-272">`Set`*PropertyName* 方法也接受其型別與屬性之已註冊資料型別相符的引數。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-272">The `Set`*PropertyName* method also accepts an argument whose type matches the registered data type for the property.</span></span> <span data-ttu-id="5b5ad-273"><屬性名稱>`Get` 方法應傳回相同類型的值。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-273">The `Get`*PropertyName* method should return a value of the same type.</span></span> <span data-ttu-id="5b5ad-274">若遺漏 <屬性名稱>`Set` 方法，屬性就會標示為唯讀。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-274">If the `Set`*PropertyName* method is missing, the property is marked read-only.</span></span>  
  
-   <span data-ttu-id="5b5ad-275">`Set` *PropertyName*並`Get` *PropertyName*必須直接路由傳送<xref:System.Windows.DependencyObject.GetValue%2A>和<xref:System.Windows.DependencyObject.SetValue%2A>分別於目標相依性的方法物件。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-275">`Set` *PropertyName* and `Get`*PropertyName* must route directly to the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> methods on the target dependency object, respectively.</span></span> <span data-ttu-id="5b5ad-276">藉由呼叫方法包裝函式，或直接呼叫目標相依性物件，設計工具可以存取附加屬性。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-276">Designers may access the attached property by calling through the method wrapper or making a direct call to the target dependency object.</span></span>  
  
 <span data-ttu-id="5b5ad-277">如需附加屬性的詳細資訊，請參閱[附加屬性概觀](../../../../docs/framework/wpf/advanced/attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-277">For more information on attached properties, see [Attached Properties Overview](../../../../docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
### <a name="define-and-use-shared-resources"></a><span data-ttu-id="5b5ad-278">定義和使用共用資源</span><span class="sxs-lookup"><span data-stu-id="5b5ad-278">Define and Use Shared Resources</span></span>  
 <span data-ttu-id="5b5ad-279">您可以將控制項納入與應用程式相同的組件，或者將控制項封裝在不同的組件中，以用於多個應用程式。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-279">You can include your control in the same assembly as your application, or you can package your control in a separate assembly that can be used in multiple applications.</span></span> <span data-ttu-id="5b5ad-280">在大多數情況下，不論使用的方法為何，本主題所討論的資訊都適用。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-280">For the most part, the information discussed in this topic applies regardless of the method you use.</span></span>  <span data-ttu-id="5b5ad-281">不過，有一項差異值得注意。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-281">There is one difference worth noting, however.</span></span>  <span data-ttu-id="5b5ad-282">當您將控制項放入與應用程式相同的組件中時，可以任意將全域資源新增至 App.xaml 檔案。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-282">When you put a control in the same assembly as an application, you are free to add global resources to the App.xaml file.</span></span> <span data-ttu-id="5b5ad-283">但只包含控制項的組件並沒有<xref:System.Windows.Application>物件與其相關聯，因此 App.xaml 檔案就無法使用。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-283">But an assembly that contains only controls does not have an <xref:System.Windows.Application> object associated with it, so an App.xaml file is not available.</span></span>  
  
 <span data-ttu-id="5b5ad-284">當應用程式尋找資源時，會以下列順序在三個層級中尋找：</span><span class="sxs-lookup"><span data-stu-id="5b5ad-284">When an application looks for a resource, it looks at three levels in the following order:</span></span>  
  
1.  <span data-ttu-id="5b5ad-285">項目層級。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-285">The element level.</span></span>  
  
     <span data-ttu-id="5b5ad-286">系統會從參考資源的項目開始，然後搜尋邏輯父項的資源，以此類推，直到達到根項目為止。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-286">The system starts with the element that references the resource and then searches resources of the logical parent and so forth until the root element is reached.</span></span>  
  
2.  <span data-ttu-id="5b5ad-287">應用程式層級。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-287">The application level.</span></span>  
  
     <span data-ttu-id="5b5ad-288">藉由定義資源<xref:System.Windows.Application>物件。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-288">Resources defined by the <xref:System.Windows.Application> object.</span></span>  
  
3.  <span data-ttu-id="5b5ad-289">佈景主題層級。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-289">The theme level.</span></span>  
  
     <span data-ttu-id="5b5ad-290">佈景主題層級字典會儲存在名為 Themes 的子資料夾。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-290">Theme-level dictionaries are stored in a subfolder named Themes.</span></span>  <span data-ttu-id="5b5ad-291">Themes 資料夾中的檔案會與佈景主題對應。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-291">The files in the Themes folder correspond to themes.</span></span>  <span data-ttu-id="5b5ad-292">例如，您可能有 Aero.NormalColor.xaml、Luna.NormalColor.xaml、Royale.NormalColor.xaml 等等。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-292">For example, you might have Aero.NormalColor.xaml, Luna.NormalColor.xaml, Royale.NormalColor.xaml, and so on.</span></span>  <span data-ttu-id="5b5ad-293">您也可以有名為 generic.xaml 的檔案。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-293">You can also have a file named generic.xaml.</span></span>  <span data-ttu-id="5b5ad-294">當系統在佈景主題層級尋找資源時，會先在佈景主題特定檔案中尋找資源，再到 generic.xaml 中尋找資源。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-294">When the system looks for a resource at the themes level, it first looks for it in the theme-specific file and then looks for it in generic.xaml.</span></span>  
  
 <span data-ttu-id="5b5ad-295">當您的控制項位於與應用程式不同的組件中時，必須將全域資源置於項目層級或佈景主題層級。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-295">When your control is in an assembly that is separate from the application, you must put your global resources at the element level or at the theme level.</span></span> <span data-ttu-id="5b5ad-296">這兩種方法各有其優點。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-296">Both methods have their advantages.</span></span>  
  
#### <a name="defining-resources-at-the-element-level"></a><span data-ttu-id="5b5ad-297">在項目層級定義資源</span><span class="sxs-lookup"><span data-stu-id="5b5ad-297">Defining Resources at the Element Level</span></span>  
 <span data-ttu-id="5b5ad-298">您可以在項目層級定義共用資源，方式是建立自訂資源字典，然後將它與控制項的資源字典合併。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-298">You can define shared resources at the element level by creating a custom resource dictionary and merging it with your control’s resource dictionary.</span></span>  <span data-ttu-id="5b5ad-299">當您使用這個方法時，可以隨意命名資源檔，而且資源檔可以與控制項位於相同的資料夾中。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-299">When you use this method, you can name your resource file anything you want, and it can be in the same folder as your controls.</span></span> <span data-ttu-id="5b5ad-300">項目層級的資源也可以使用簡單的字串作為索引鍵。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-300">Resources at the element level can also use simple strings as keys.</span></span> <span data-ttu-id="5b5ad-301">下列範例會建立<xref:System.Windows.Media.LinearGradientBrush>名為 Dictionary1.xaml 的資源檔。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-301">The following example creates a <xref:System.Windows.Media.LinearGradientBrush> resource file named Dictionary1.xaml.</span></span>  
  
 [!code-xaml[SharedResources#1](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/Dictionary1.xaml#1)]  
  
 <span data-ttu-id="5b5ad-302">定義字典之後，您需要將它與控制項的資源字典合併。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-302">Once you have defined your dictionary, you need to merge it with your control's resource dictionary.</span></span>  <span data-ttu-id="5b5ad-303">您可以使用 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 或程式碼完成這項動作。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-303">You can do this by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code.</span></span>  
  
 <span data-ttu-id="5b5ad-304">下列範例會使用 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 合併資源字典。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-304">The following example merges a resource dictionary by using [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 [!code-xaml[SharedResources#2](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml#2)]  
  
 <span data-ttu-id="5b5ad-305">這種方法的缺點在於<xref:System.Windows.ResourceDictionary>參考它每次建立物件。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-305">The disadvantage to this approach is that a <xref:System.Windows.ResourceDictionary> object is created each time you reference it.</span></span>  <span data-ttu-id="5b5ad-306">例如，如果您程式庫中有 10 個自訂控制項，並使用 XAML 合併每個控制項的共用的資源字典，您建立 10 個相同<xref:System.Windows.ResourceDictionary>物件。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-306">For example, if you have 10 custom controls in your library and merge the shared resource dictionaries for each control by using XAML, you create 10 identical <xref:System.Windows.ResourceDictionary> objects.</span></span>  <span data-ttu-id="5b5ad-307">您可以藉由建立合併程式碼中的資源，並傳回產生的靜態類別避免此<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-307">You can avoid this by creating a static class that merges the resources in code and returns the resulting <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="5b5ad-308">下列範例會建立傳回共用的類別<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-308">The following example creates a class that returns a shared <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 [!code-csharp[SharedResources#3](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/SharedDictionaryManager.cs#3)]  
  
 <span data-ttu-id="5b5ad-309">下列範例會在呼叫 `InitializeComponent` 之前，在自訂控制項的建構函式中將共用資源與該控制項的資源合併。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-309">The following example merges the shared resource with the resources of a custom control in the control's constructor before it calls `InitializeComponent`.</span></span>  <span data-ttu-id="5b5ad-310">因為`SharedDictionaryManager.SharedDictionary`是靜態屬性，<xref:System.Windows.ResourceDictionary>只建立一次。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-310">Because the `SharedDictionaryManager.SharedDictionary` is a static property, the <xref:System.Windows.ResourceDictionary> is created only once.</span></span> <span data-ttu-id="5b5ad-311">由於資源字典是在呼叫 `InitializeComponent` 之前合併，因此控制項可在其 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 檔案中使用資源。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-311">Because the resource dictionary was merged before `InitializeComponent` was called, the resources are available to the control in its [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] file.</span></span>  
  
 [!code-csharp[SharedResources#4](../../../../samples/snippets/csharp/VS_Snippets_Wpf/SharedResources/CS/ShapeResizer.xaml.cs#4)]  
  
#### <a name="defining-resources-at-the-theme-level"></a><span data-ttu-id="5b5ad-312">在佈景主題層級定義資源</span><span class="sxs-lookup"><span data-stu-id="5b5ad-312">Defining Resources at the Theme Level</span></span>  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="5b5ad-313"> 可讓您為不同的 Windows 佈景主題建立資源。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-313"> enables you to create resources for different Windows themes.</span></span>  <span data-ttu-id="5b5ad-314">身為控制項作者，您可以為特定佈景主題定義資源，以根據使用的佈景主題變更控制項的外觀。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-314">As a control author, you can define a resource for a specific theme to change your control's appearance depending on what theme is in use.</span></span> <span data-ttu-id="5b5ad-315">例如的外觀<xref:System.Windows.Controls.Button>佈景主題 （Windows 2000 的預設佈景主題） 不同於在 Windows 傳統<xref:System.Windows.Controls.Button>Windows Luna 佈景主題 （Windows XP 的預設佈景主題） 中因為<xref:System.Windows.Controls.Button>會使用不同<xref:System.Windows.Controls.ControlTemplate>每個佈景主題。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-315">For example, the appearance of a <xref:System.Windows.Controls.Button> in the Windows Classic theme (the default theme for Windows 2000) differs from a <xref:System.Windows.Controls.Button> in the Windows Luna theme (the default theme for Windows XP) because the <xref:System.Windows.Controls.Button> uses a different <xref:System.Windows.Controls.ControlTemplate> for each theme.</span></span>  
  
 <span data-ttu-id="5b5ad-316">某個佈景主題專屬的資源會存放在具有特定檔名的資源字典中。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-316">Resources that are specific to a theme are kept in a resource dictionary with a specific file name.</span></span> <span data-ttu-id="5b5ad-317">這些檔案必須位於名為 `Themes` 的資料夾中，這是包含控制項之資料夾的子資料夾。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-317">These files must be in a folder named `Themes` that is a subfolder of the folder that contains the control.</span></span> <span data-ttu-id="5b5ad-318">下表列出資源字典檔以及與每個檔案相關聯的佈景主題：</span><span class="sxs-lookup"><span data-stu-id="5b5ad-318">The following table lists the resource dictionary files and the theme that is associated with each file:</span></span>  
  
|<span data-ttu-id="5b5ad-319">資源字典檔名稱</span><span class="sxs-lookup"><span data-stu-id="5b5ad-319">Resource dictionary file name</span></span>|<span data-ttu-id="5b5ad-320">Windows 佈景主題</span><span class="sxs-lookup"><span data-stu-id="5b5ad-320">Windows theme</span></span>|  
|-----------------------------------|-------------------|  
|`Classic.xaml`|<span data-ttu-id="5b5ad-321">Windows XP 上的傳統 Windows 9x/2000 外觀</span><span class="sxs-lookup"><span data-stu-id="5b5ad-321">Classic Windows 9x/2000 look on Windows XP</span></span>|  
|`Luna.NormalColor.xaml`|<span data-ttu-id="5b5ad-322">Windows XP 上的預設藍色佈景主題</span><span class="sxs-lookup"><span data-stu-id="5b5ad-322">Default blue theme on Windows XP</span></span>|  
|`Luna.Homestead.xaml`|<span data-ttu-id="5b5ad-323">Windows XP 上的橄欖色佈景主題</span><span class="sxs-lookup"><span data-stu-id="5b5ad-323">Olive theme on Windows XP</span></span>|  
|`Luna.Metallic.xaml`|<span data-ttu-id="5b5ad-324">Windows XP 上的銀色佈景主題</span><span class="sxs-lookup"><span data-stu-id="5b5ad-324">Silver theme on Windows XP</span></span>|  
|`Royale.NormalColor.xaml`|<span data-ttu-id="5b5ad-325">Windows XP Media Center Edition 上的預設佈景主題</span><span class="sxs-lookup"><span data-stu-id="5b5ad-325">Default theme on Windows XP Media Center Edition</span></span>|  
|`Aero.NormalColor.xaml`|<span data-ttu-id="5b5ad-326">Windows Vista 上的預設佈景主題</span><span class="sxs-lookup"><span data-stu-id="5b5ad-326">Default theme on Windows Vista</span></span>|  
  
 <span data-ttu-id="5b5ad-327">您不需要為每個佈景主題定義資源。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-327">You do not need to define a resource for every theme.</span></span> <span data-ttu-id="5b5ad-328">若未定義特定佈景主題的資源，則控制項會在 `Classic.xaml` 中檢查資源。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-328">If a resource is not defined for a specific theme, then the control checks `Classic.xaml` for the resource.</span></span> <span data-ttu-id="5b5ad-329">若在對應於目前佈景主題的檔案中或在 `Classic.xaml` 中都未定義資源，控制項會使用名為 `generic.xaml` 的資源字典檔中的一般資源。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-329">If the resource is not defined in the file that corresponds to the current theme or in `Classic.xaml`, the control uses the generic resource, which is in a resource dictionary file named `generic.xaml`.</span></span>  <span data-ttu-id="5b5ad-330">`generic.xaml` 檔案位於與佈景主題特有資源字典檔相同的資料夾中。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-330">The `generic.xaml` file is located in the same folder as the theme-specific resource dictionary files.</span></span> <span data-ttu-id="5b5ad-331">雖然 `generic.xaml` 並未對應到特定 Windows 佈景主題，但它仍是佈景主題層級字典。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-331">Although `generic.xaml` does not correspond to a specific Windows theme, it is still a theme-level dictionary.</span></span>  
  
 <span data-ttu-id="5b5ad-332">[具有與佈景主題和 UI 自動化支援的 NumericUpDown 自訂控制項範例](https://go.microsoft.com/fwlink/?LinkID=160025)包含 `NumericUpDown` 控制項的兩個資源字典：一個在 generic.xaml 中，另一個在 Luna.NormalColor.xaml 中。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-332">[NumericUpDown Custom Control with Theme and UI Automation Support Sample](https://go.microsoft.com/fwlink/?LinkID=160025) contains two resource dictionaries for the `NumericUpDown` control: one is in generic.xaml and one is in Luna.NormalColor.xaml.</span></span>  <span data-ttu-id="5b5ad-333">您可以執行應用程式，然後在 Windows XP 的銀色佈景主題和其他佈景主題之間切換，查看兩個控制項範本之間的差異。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-333">You can run the application and switch between the Silver theme in Windows XP and another theme to see the difference between the two control templates.</span></span> <span data-ttu-id="5b5ad-334">(若您執行 Windows Vista，則可以將 Luna.NormalColor.xaml 重新命名為 Aero.NormalColor.xaml，然後在兩個佈景主題之間切換，例如 Windows 傳統配色和 Windows Vista 的預設佈景主題。)</span><span class="sxs-lookup"><span data-stu-id="5b5ad-334">(If you are running Windows Vista, you can rename Luna.NormalColor.xaml to Aero.NormalColor.xaml and switch between two themes, such as Windows Classic and the default theme for Windows Vista.)</span></span>  
  
 <span data-ttu-id="5b5ad-335">當您將放<xref:System.Windows.Controls.ControlTemplate>在任何佈景主題特定資源字典檔，您必須建立您的控制項和呼叫的靜態建構函式<xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>方法<xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-335">When you put a <xref:System.Windows.Controls.ControlTemplate> in any of the theme-specific resource dictionary files, you must create a static constructor for your control and call the <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29> method on the <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A>, as shown in the following example.</span></span>  
  
 [!code-csharp[CustomControlNumericUpDownOneProject#StaticConstructor](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/CSharp/NumericUpDown.cs#staticconstructor)]
 [!code-vb[CustomControlNumericUpDownOneProject#StaticConstructor](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDownOneProject/visualbasic/numericupdown.vb#staticconstructor)]  
  
##### <a name="defining-and-referencing-keys-for-theme-resources"></a><span data-ttu-id="5b5ad-336">定義和參考佈景主題資源的索引鍵</span><span class="sxs-lookup"><span data-stu-id="5b5ad-336">Defining and Referencing Keys for Theme Resources</span></span>  
 <span data-ttu-id="5b5ad-337">當您在項目層級定義資源時，可以指派字串作為它的索引鍵，然後透過字串存取資源。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-337">When you define a resource at the element level, you can assign a string as its key and access the resource via the string.</span></span> <span data-ttu-id="5b5ad-338">當您定義的佈景主題層級的資源時，您必須使用<xref:System.Windows.ComponentResourceKey>做為索引鍵。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-338">When you define a resource at the theme level, you must use a <xref:System.Windows.ComponentResourceKey> as the key.</span></span>  <span data-ttu-id="5b5ad-339">下列範例會在 generic.xaml 中定義資源。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-339">The following example defines a resource in generic.xaml.</span></span>  
  
 [!code-xaml[ThemeResourcesControlLibrary#5](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/Themes/generic.xaml#5)]  
  
 <span data-ttu-id="5b5ad-340">下列範例會參考資源，藉由指定<xref:System.Windows.ComponentResourceKey>做為索引鍵。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-340">The following example references the resource by specifying the <xref:System.Windows.ComponentResourceKey> as the key.</span></span>  
  
 [!code-xaml[ThemeResourcesControlLibrary#6](../../../../samples/snippets/csharp/VS_Snippets_Wpf/ThemeResourcesControlLibrary/CS/NumericUpDown.xaml#6)]  
  
##### <a name="specifying-the-location-of-theme-resources"></a><span data-ttu-id="5b5ad-341">指定佈景主題資源的位置</span><span class="sxs-lookup"><span data-stu-id="5b5ad-341">Specifying the Location of Theme Resources</span></span>  
 <span data-ttu-id="5b5ad-342">若要尋找控制項的資源，裝載的應用程式必須知道組件是否包含控制項特定的資源。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-342">To find the resources for a control, the hosting application needs to know that the assembly contains control-specific resources.</span></span> <span data-ttu-id="5b5ad-343">您可以達到此目的新增<xref:System.Windows.ThemeInfoAttribute>包含控制項之組件。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-343">You can accomplish that by adding the <xref:System.Windows.ThemeInfoAttribute> to the assembly that contains the control.</span></span> <span data-ttu-id="5b5ad-344"><xref:System.Windows.ThemeInfoAttribute>已經<xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A>屬性，指定泛用資源的位置和<xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A>屬性，指定佈景主題特定資源的位置。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-344">The <xref:System.Windows.ThemeInfoAttribute> has a <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> property that specifies the location of generic resources, and a <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> property that specifies the location of the theme-specific resources.</span></span>  
  
 <span data-ttu-id="5b5ad-345">下列範例會設定<xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A>並<xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A>屬性，以<xref:System.Windows.ResourceDictionaryLocation.SourceAssembly>，以指定的泛型和佈景主題特定資源位於相同的組件控制項。</span><span class="sxs-lookup"><span data-stu-id="5b5ad-345">The following example sets the <xref:System.Windows.ThemeInfoAttribute.GenericDictionaryLocation%2A> and <xref:System.Windows.ThemeInfoAttribute.ThemeDictionaryLocation%2A> properties to <xref:System.Windows.ResourceDictionaryLocation.SourceAssembly>, to specify that the generic and theme-specific resources are in the same assembly as the control.</span></span>  
  
 [!code-csharp[CustomControlNumericUpDown#ThemesSection](../../../../samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/Properties/AssemblyInfo.cs#themessection)]
 [!code-vb[CustomControlNumericUpDown#ThemesSection](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/my project/assemblyinfo.vb#themessection)]  
  
## <a name="see-also"></a><span data-ttu-id="5b5ad-346">另請參閱</span><span class="sxs-lookup"><span data-stu-id="5b5ad-346">See Also</span></span>  
 [<span data-ttu-id="5b5ad-347">在 Visual Studio 中設計 XAML</span><span class="sxs-lookup"><span data-stu-id="5b5ad-347">Design XAML in Visual Studio</span></span>](/visualstudio/designers/designing-xaml-in-visual-studio)  
 [<span data-ttu-id="5b5ad-348">WPF 中的 Pack URI</span><span class="sxs-lookup"><span data-stu-id="5b5ad-348">Pack URIs in WPF</span></span>](../../../../docs/framework/wpf/app-development/pack-uris-in-wpf.md)  
 [<span data-ttu-id="5b5ad-349">控制項自訂</span><span class="sxs-lookup"><span data-stu-id="5b5ad-349">Control Customization</span></span>](../../../../docs/framework/wpf/controls/control-customization.md)
