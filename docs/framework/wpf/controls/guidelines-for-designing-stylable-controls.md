---
title: 設計可設定樣式控制項的方針
ms.date: 03/30/2017
helpviewer_keywords:
- style design for controls [WPF]
- controls [WPF], style design
ms.assetid: c52dde45-a311-4531-af4c-853371c4d5f4
ms.openlocfilehash: 99644be4a275c1de7f4b89ca23368a26a8b76f5b
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/28/2019
ms.locfileid: "64614547"
---
# <a name="guidelines-for-designing-stylable-controls"></a><span data-ttu-id="55142-102">設計可設定樣式控制項的方針</span><span class="sxs-lookup"><span data-stu-id="55142-102">Guidelines for Designing Stylable Controls</span></span>
<span data-ttu-id="55142-103">本文摘要說明當設計要能夠容易設定樣式及範本化的控制項時，可考量的一組最佳做法。</span><span class="sxs-lookup"><span data-stu-id="55142-103">This document summarizes a set of best practices to consider when designing a control which you intend to be easily stylable and templatable.</span></span> <span data-ttu-id="55142-104">我們是在研究內建之 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 控制項集的佈景主題控制項樣式時，經過許多嘗試和錯誤，才得出這組最佳做法。</span><span class="sxs-lookup"><span data-stu-id="55142-104">We came to this set of best practices through a lot of trial and error while working on the theme control styles for the built-in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control set.</span></span> <span data-ttu-id="55142-105">我們了解到成功的樣式設定對設計良好的物件模型來說，不僅是樣式本身，也是一項功能。</span><span class="sxs-lookup"><span data-stu-id="55142-105">We learned that successful styling is as much a function of a well-designed object model as it is of the style itself.</span></span> <span data-ttu-id="55142-106">本文件的適用對象是控制項作者，而不是樣式作者。</span><span class="sxs-lookup"><span data-stu-id="55142-106">The intended audience for this document is the control author, not the style author.</span></span>  
  
  <a name="Terminology"></a>   
## <a name="terminology"></a><span data-ttu-id="55142-107">用語</span><span class="sxs-lookup"><span data-stu-id="55142-107">Terminology</span></span>  
 <span data-ttu-id="55142-108">「樣式設定和範本化」係指一套技術，可讓控制項作者將控制項的視覺方面交給控制項的樣式和範本去處理。</span><span class="sxs-lookup"><span data-stu-id="55142-108">"Styling and templating" refer to the suite of technologies that enable a control author to defer the visual aspects of the control to the style and template of the control.</span></span> <span data-ttu-id="55142-109">這套技術包括：</span><span class="sxs-lookup"><span data-stu-id="55142-109">This suite of technologies includes:</span></span>  
  
- <span data-ttu-id="55142-110">樣式 (包括屬性 setter、觸發程序及分鏡腳本)。</span><span class="sxs-lookup"><span data-stu-id="55142-110">Styles (including property setters, triggers, and storyboards).</span></span>  
  
- <span data-ttu-id="55142-111">資源。</span><span class="sxs-lookup"><span data-stu-id="55142-111">Resources.</span></span>  
  
- <span data-ttu-id="55142-112">控制項範本。</span><span class="sxs-lookup"><span data-stu-id="55142-112">Control templates.</span></span>  
  
- <span data-ttu-id="55142-113">資料範本。</span><span class="sxs-lookup"><span data-stu-id="55142-113">Data templates.</span></span>  
  
 <span data-ttu-id="55142-114">如需樣式設定和範本化的簡介，請參閱[樣式設定和範本化範例](styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="55142-114">For an introduction to styling and templating, see [Styling and Templating](styling-and-templating.md).</span></span>  
  
<a name="Before_You_Start__Understanding_Your_Control"></a>   
## <a name="before-you-start-understanding-your-control"></a><span data-ttu-id="55142-115">在開始之前：了解您的控制項</span><span class="sxs-lookup"><span data-stu-id="55142-115">Before You Start: Understanding Your Control</span></span>  
 <span data-ttu-id="55142-116">在您開始研究這些方針之前，請務必先了解並定義您控制項的一般使用方式。</span><span class="sxs-lookup"><span data-stu-id="55142-116">Before you jump into these guidelines, it is important to understand and have defined the common usage of your control.</span></span> <span data-ttu-id="55142-117">樣式設定所揭露的通常是一組難以駕馭的可能性。</span><span class="sxs-lookup"><span data-stu-id="55142-117">Styling exposes an often unruly set of possibilities.</span></span> <span data-ttu-id="55142-118">撰寫來廣泛使用的控制項 (在許多應用程式中、供許多開發人員使用) 面臨挑戰，即樣式設定可用來對控制項的視覺外觀進行更深遠的變更。</span><span class="sxs-lookup"><span data-stu-id="55142-118">Controls that are written to be used broadly (in many applications, by many developers) face the challenge that styling can be used to make far-reaching changes to the visual appearance of the control.</span></span> <span data-ttu-id="55142-119">事實上，已設定樣式的控制項甚至可能與控制項作者的意圖不符。</span><span class="sxs-lookup"><span data-stu-id="55142-119">In fact, the styled control may not even resemble the control author's intentions.</span></span> <span data-ttu-id="55142-120">由於樣式設定所提供的彈性基本上是無限的，因此您可以使用一般使用方式的概念來協助限制您的決策範圍。</span><span class="sxs-lookup"><span data-stu-id="55142-120">Since the flexibility offered by styling is essentially boundless, you can use the idea of common usage to help you scope your decisions.</span></span>  
  
 <span data-ttu-id="55142-121">為了了解您控制項的一般使用方式，思考一下控制項的價值主張會相當有幫助。</span><span class="sxs-lookup"><span data-stu-id="55142-121">To understand your control's common usage, it's good to think about the value proposition of the control.</span></span> <span data-ttu-id="55142-122">您的控制項可為表格提供哪些任何其他控制所無法提供的效果？</span><span class="sxs-lookup"><span data-stu-id="55142-122">What does your control bring to the table that no other control can offer?</span></span> <span data-ttu-id="55142-123">一般使用方式不包含任何特定的視覺外觀，而是包含控制項的原理，以及一組關於其使用方式的合理預期。</span><span class="sxs-lookup"><span data-stu-id="55142-123">Common usage does not imply any specific visual appearance, but rather the philosophy of the control and a reasonable set of expectations about its usage.</span></span> <span data-ttu-id="55142-124">這項理解可讓您對一般情況下控制項的撰寫模型和已定義樣式的行為，進行一些假設。</span><span class="sxs-lookup"><span data-stu-id="55142-124">This understanding allows you to make some assumptions about the composition model and the style-defined behaviors of the control in the common case.</span></span> <span data-ttu-id="55142-125">若是<xref:System.Windows.Controls.ComboBox>，比方說，了解常見的用法不提供任何深入解析有關特定<xref:System.Windows.Controls.ComboBox>具有圓的角，但它可讓您深入了解這個事實，<xref:System.Windows.Controls.ComboBox>可能需要的快顯視窗和切換是否已開啟，所以某些方式。</span><span class="sxs-lookup"><span data-stu-id="55142-125">In the case of <xref:System.Windows.Controls.ComboBox>, for example, understanding the common usage won't give you any insight about whether a particular <xref:System.Windows.Controls.ComboBox> has rounded corners, but it will give you insight into the fact that the <xref:System.Windows.Controls.ComboBox> probably needs a pop-up window and some way of toggling whether it is open.</span></span>  
  
<a name="General_Guidelines"></a>   
## <a name="general-guidelines"></a><span data-ttu-id="55142-126">一般方針</span><span class="sxs-lookup"><span data-stu-id="55142-126">General Guidelines</span></span>  
  
- <span data-ttu-id="55142-127">**請勿強制執行範本合約。**</span><span class="sxs-lookup"><span data-stu-id="55142-127">**Do not strictly enforce template contracts.**</span></span> <span data-ttu-id="55142-128">控制項的範本合約成份可能包含元素、命令、繫結、觸發程序，或甚至是讓控制項正常運作所需或應有的屬性設定。</span><span class="sxs-lookup"><span data-stu-id="55142-128">The template contract of a control might consist of elements, commands, bindings, triggers, or even property settings that are required or expected for a control to function properly.</span></span>  
  
    - <span data-ttu-id="55142-129">將合約儘量縮減到最少。</span><span class="sxs-lookup"><span data-stu-id="55142-129">Minimize contracts as much as possible.</span></span>  
  
    - <span data-ttu-id="55142-130">設計時需有心理準備，即在設計階段 (亦即在使用設計工具時) 控制項範本處於不完整狀態是正常的。</span><span class="sxs-lookup"><span data-stu-id="55142-130">Design around the expectation that during design time (that is, when using a design tool) it is common for a control template to be in an incomplete state.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="55142-131">並不提供「撰寫中」狀態的基礎結構，因此建置控制項時，必須預期這類狀態可能是有效的狀態。</span><span class="sxs-lookup"><span data-stu-id="55142-131">does not offer a "composing" state infrastructure, so controls have to be built with the expectation that such a state might be valid.</span></span>  
  
    - <span data-ttu-id="55142-132">當有未遵守範本合約任何方面的情況時，請勿擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55142-132">Do not throw exceptions when any aspect of a template contract is not followed.</span></span> <span data-ttu-id="55142-133">同樣地，面板在子系太多或太少時，也不應該擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="55142-133">Along these lines, panels should not throw exceptions if they have too many or too few children.</span></span>  
  
- <span data-ttu-id="55142-134">**將周邊功能列入為範本協助程式元素的考量因素。**</span><span class="sxs-lookup"><span data-stu-id="55142-134">**Factor peripheral functionality into template helper elements.**</span></span> <span data-ttu-id="55142-135">每個控制項都應該將焦點放在其核心功能和實際的價值主張，並由控制項的一般使用方式定義。</span><span class="sxs-lookup"><span data-stu-id="55142-135">Each control should be focused on its core functionality and true value proposition and defined by the control's common usage.</span></span> <span data-ttu-id="55142-136">為了達到該目的，請使用範本內的撰寫和協助程式元素來啟用周邊行為和視覺效果，也就是未包含在控制項核心功能內的那些行為和視覺效果。</span><span class="sxs-lookup"><span data-stu-id="55142-136">To that end, use composition and helper elements within the template to enable peripheral behaviors and visualizations, that is, those behaviors and visualizations that do not contribute to the core functionality of the control.</span></span> <span data-ttu-id="55142-137">協助程式元素分成三個分類：</span><span class="sxs-lookup"><span data-stu-id="55142-137">Helper elements fall into three categories:</span></span>  
  
    - <span data-ttu-id="55142-138">「獨立」協助程式是範本中公開且可重複使用的控制項，或是以「匿名方式」使用的基本型別，也就是說，協助程式元素和已設定樣式的控制項都不知道彼此。</span><span class="sxs-lookup"><span data-stu-id="55142-138">**Standalone** helper types are public and reusable controls or primitives that are used "anonymously" in a template, meaning that neither the helper element nor the styled control is aware of the other.</span></span> <span data-ttu-id="55142-139">就技術而言，任何元素都可以是匿名型別，但在此內容中，此詞彙所描述的是那些封裝特製化功能來實現目標案例的型別。</span><span class="sxs-lookup"><span data-stu-id="55142-139">Technically, any element can be an anonymous type, but in this context the term describes those types that encapsulate specialized functionality to enable targeted scenarios.</span></span>  
  
    - <span data-ttu-id="55142-140">「型別型」協助程式元素是封裝了特製化功能的新型別。</span><span class="sxs-lookup"><span data-stu-id="55142-140">**Type-based** helper elements are new types that encapsulate specialized functionality.</span></span> <span data-ttu-id="55142-141">與一般控制項或基本型別相比，這些元素通常是設計為功能範圍較窄。</span><span class="sxs-lookup"><span data-stu-id="55142-141">These elements are typically designed with a narrower range of functionality than common controls or primitives.</span></span> <span data-ttu-id="55142-142">與獨立協助程式元素不同，型別型協助程式元素知道所處的使用內容，且通常必須與其所屬控制項範本的控制項共用資料。</span><span class="sxs-lookup"><span data-stu-id="55142-142">Unlike standalone helper elements, type-based helper elements are aware of the context in which they are used and typically must share data with the control to whose template they belong.</span></span>  
  
    - <span data-ttu-id="55142-143">「具名」協助程式元素是控制項預期要在其範本內，依名稱找到的一般控制項或基本型別。</span><span class="sxs-lookup"><span data-stu-id="55142-143">**Named** helper elements are common controls or primitives that a control expects to find within its template by name.</span></span> <span data-ttu-id="55142-144">這些元素在範本內都有一個已知的名稱，使得控制項能夠透過程式設計方式找到元素並與其進行互動。</span><span class="sxs-lookup"><span data-stu-id="55142-144">These elements are given a well-known name within the template, making it possible for a control to find the element and interact with it programmatically.</span></span> <span data-ttu-id="55142-145">在任一範本中，只能有一個元素具有指定的名稱。</span><span class="sxs-lookup"><span data-stu-id="55142-145">There can only be one element with a given name in any template.</span></span>  
  
     <span data-ttu-id="55142-146">下表說明現今控制項樣式所採用的協助程式元素 (本清單並不完全)：</span><span class="sxs-lookup"><span data-stu-id="55142-146">The following table shows helper elements employed by control styles today (this list is not exhaustive):</span></span>  
  
    |<span data-ttu-id="55142-147">項目</span><span class="sxs-lookup"><span data-stu-id="55142-147">Element</span></span>|<span data-ttu-id="55142-148">類型</span><span class="sxs-lookup"><span data-stu-id="55142-148">Type</span></span>|<span data-ttu-id="55142-149">使用對象</span><span class="sxs-lookup"><span data-stu-id="55142-149">Used by</span></span>|  
    |-------------|----------|-------------|  
    |<xref:System.Windows.Controls.ContentPresenter>|<span data-ttu-id="55142-150">型別型</span><span class="sxs-lookup"><span data-stu-id="55142-150">Type-based</span></span>|<span data-ttu-id="55142-151"><xref:System.Windows.Controls.Button><xref:System.Windows.Controls.CheckBox>， <xref:System.Windows.Controls.RadioButton>，<xref:System.Windows.Controls.Frame>等等 (所有<xref:System.Windows.Controls.ContentControl>類型)</span><span class="sxs-lookup"><span data-stu-id="55142-151"><xref:System.Windows.Controls.Button>, <xref:System.Windows.Controls.CheckBox>, <xref:System.Windows.Controls.RadioButton>, <xref:System.Windows.Controls.Frame>, and so on (all <xref:System.Windows.Controls.ContentControl> types)</span></span>|  
    |<xref:System.Windows.Controls.ItemsPresenter>|<span data-ttu-id="55142-152">型別型</span><span class="sxs-lookup"><span data-stu-id="55142-152">Type-based</span></span>|<span data-ttu-id="55142-153"><xref:System.Windows.Controls.ListBox><xref:System.Windows.Controls.ComboBox>，<xref:System.Windows.Controls.Menu>等等 (所有<xref:System.Windows.Controls.ItemsControl>類型)</span><span class="sxs-lookup"><span data-stu-id="55142-153"><xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ComboBox>, <xref:System.Windows.Controls.Menu>, and so on (all <xref:System.Windows.Controls.ItemsControl> types)</span></span>|  
    |<xref:System.Windows.Controls.Primitives.ToolBarOverflowPanel>|<span data-ttu-id="55142-154">具名</span><span class="sxs-lookup"><span data-stu-id="55142-154">Named</span></span>|<xref:System.Windows.Controls.ToolBar>|  
    |<xref:System.Windows.Controls.Primitives.Popup>|<span data-ttu-id="55142-155">獨立</span><span class="sxs-lookup"><span data-stu-id="55142-155">Standalone</span></span>|<span data-ttu-id="55142-156"><xref:System.Windows.Controls.ComboBox><xref:System.Windows.Controls.ToolBar>， <xref:System.Windows.Controls.Menu>，<xref:System.Windows.Controls.ToolTip>等等</span><span class="sxs-lookup"><span data-stu-id="55142-156"><xref:System.Windows.Controls.ComboBox>, <xref:System.Windows.Controls.ToolBar>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolTip>, and so on</span></span>|  
    |<xref:System.Windows.Controls.Primitives.RepeatButton>|<span data-ttu-id="55142-157">具名</span><span class="sxs-lookup"><span data-stu-id="55142-157">Named</span></span>|<span data-ttu-id="55142-158"><xref:System.Windows.Controls.Slider><xref:System.Windows.Controls.Primitives.ScrollBar>等等</span><span class="sxs-lookup"><span data-stu-id="55142-158"><xref:System.Windows.Controls.Slider>, <xref:System.Windows.Controls.Primitives.ScrollBar>, and so on</span></span>|  
    |<xref:System.Windows.Controls.Primitives.ScrollBar>|<span data-ttu-id="55142-159">具名</span><span class="sxs-lookup"><span data-stu-id="55142-159">Named</span></span>|<xref:System.Windows.Controls.ScrollViewer>|  
    |<xref:System.Windows.Controls.ScrollViewer>|<span data-ttu-id="55142-160">獨立</span><span class="sxs-lookup"><span data-stu-id="55142-160">Standalone</span></span>|<span data-ttu-id="55142-161"><xref:System.Windows.Controls.ListBox><xref:System.Windows.Controls.ComboBox>， <xref:System.Windows.Controls.Menu>，<xref:System.Windows.Controls.Frame>等等</span><span class="sxs-lookup"><span data-stu-id="55142-161"><xref:System.Windows.Controls.ListBox>, <xref:System.Windows.Controls.ComboBox>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.Frame>, and so on</span></span>|  
    |<xref:System.Windows.Controls.Primitives.TabPanel>|<span data-ttu-id="55142-162">獨立</span><span class="sxs-lookup"><span data-stu-id="55142-162">Standalone</span></span>|<xref:System.Windows.Controls.TabControl>|  
    |<xref:System.Windows.Controls.TextBox>|<span data-ttu-id="55142-163">具名</span><span class="sxs-lookup"><span data-stu-id="55142-163">Named</span></span>|<xref:System.Windows.Controls.ComboBox>|  
    |<xref:System.Windows.Controls.Primitives.TickBar>|<span data-ttu-id="55142-164">型別型</span><span class="sxs-lookup"><span data-stu-id="55142-164">Type-based</span></span>|<xref:System.Windows.Controls.Slider>|  
  
- <span data-ttu-id="55142-165">**將在協助程式元素上所需的使用者指定繫結或屬性設定縮減到最少**。</span><span class="sxs-lookup"><span data-stu-id="55142-165">**Minimize required user-specified bindings or property settings on helper elements**.</span></span> <span data-ttu-id="55142-166">協助程式元素通常必須要有特定繫結或屬性設定，才能在控制項範本內正常運作。</span><span class="sxs-lookup"><span data-stu-id="55142-166">It is common for a helper element to require certain bindings or property settings in order to function properly within the control template.</span></span> <span data-ttu-id="55142-167">協助程式元素和樣板化控制項應該儘可能建立這些設定。</span><span class="sxs-lookup"><span data-stu-id="55142-167">The helper element and templated control should, as much as possible, establish these settings.</span></span> <span data-ttu-id="55142-168">設定屬性或建立繫結時，應該小心，不要覆寫使用者所設定的值。</span><span class="sxs-lookup"><span data-stu-id="55142-168">When setting properties or establishing bindings, care should be taken to not override values set by the user.</span></span> <span data-ttu-id="55142-169">特定的最佳做法如下：</span><span class="sxs-lookup"><span data-stu-id="55142-169">Specific best practices are as follows:</span></span>  
  
    - <span data-ttu-id="55142-170">具名協助程式元素應該可由父代識別，而父代應該在該協助程式元素上建立任何必要的設定。</span><span class="sxs-lookup"><span data-stu-id="55142-170">Named helper elements should be identified by the parent and the parent should establish any required settings on the helper element.</span></span>  
  
    - <span data-ttu-id="55142-171">型別型協助程式元素應該在本身直接建立任何必要的設定。</span><span class="sxs-lookup"><span data-stu-id="55142-171">Type-based helper elements should establish any required settings directly on themselves.</span></span> <span data-ttu-id="55142-172">這麼做可能需要協助程式元素查詢所處的使用資訊內容，包括其 `TemplatedParent` (所處使用範本的控制項型別)。</span><span class="sxs-lookup"><span data-stu-id="55142-172">Doing this may require the helper element to query for information context in which it is being used, including its `TemplatedParent` (the control type of the template in which it is being used).</span></span> <span data-ttu-id="55142-173">例如，<xref:System.Windows.Controls.ContentPresenter>自動繫結`Content`屬性其`TemplatedParent`至其<xref:System.Windows.Controls.ContentPresenter.Content%2A>屬性中使用時<xref:System.Windows.Controls.ContentControl>衍生型別。</span><span class="sxs-lookup"><span data-stu-id="55142-173">For example, <xref:System.Windows.Controls.ContentPresenter> automatically binds the `Content` property of its `TemplatedParent` to its <xref:System.Windows.Controls.ContentPresenter.Content%2A> property when used in a <xref:System.Windows.Controls.ContentControl> derived type.</span></span>  
  
    - <span data-ttu-id="55142-174">您無法以此方式將獨立協助程式元素最佳化，因為根據定義，協助程式元素和父代都不知道彼此。</span><span class="sxs-lookup"><span data-stu-id="55142-174">Standalone helper elements cannot be optimized in this way because, by definition, neither the helper element nor the parent knows about the other.</span></span>  
  
- <span data-ttu-id="55142-175">**使用 Name 屬性在範本內標幟元素**。</span><span class="sxs-lookup"><span data-stu-id="55142-175">**Use the Name property to flag elements within a template**.</span></span> <span data-ttu-id="55142-176">控制項如果需要在其樣式中尋找元素，以便透過程式設計方式存取該元素，應該使用 `Name` 屬性和 `FindName` 典型來執行此操作。</span><span class="sxs-lookup"><span data-stu-id="55142-176">A control that needs to find an element in its style in order to access it programmatically should do so using the `Name` property and the `FindName` paradigm.</span></span> <span data-ttu-id="55142-177">控制項不應該在找不到元素時擲回例外狀況，而是應該以無訊息且依正常程序的方式，停用需要該元素的功能。</span><span class="sxs-lookup"><span data-stu-id="55142-177">A control should not throw an exception when an element is not found, but silently and gracefully disable the functionality which required that element.</span></span>  
  
- <span data-ttu-id="55142-178">**使用可表達樣式中控制項狀態和行為的最佳做法。**</span><span class="sxs-lookup"><span data-stu-id="55142-178">**Use best practices for expressing control state and behavior in a style.**</span></span> <span data-ttu-id="55142-179">以下是已排序的最佳做法清單，用來表達樣式中的控制項狀態變更和行為。</span><span class="sxs-lookup"><span data-stu-id="55142-179">The following is an ordered list of best practices for expressing control state changes and behavior in a style.</span></span> <span data-ttu-id="55142-180">您應該使用清單上第一個可實現您案例的項目。</span><span class="sxs-lookup"><span data-stu-id="55142-180">You should use the first item on the list that enables your scenario.</span></span>  
  
    1. <span data-ttu-id="55142-181">屬性繫結。</span><span class="sxs-lookup"><span data-stu-id="55142-181">Property binding.</span></span> <span data-ttu-id="55142-182">範例： 繫結之間<xref:System.Windows.Controls.ComboBox.IsDropDownOpen%2A?displayProperty=nameWithType>和<xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="55142-182">Example: binding between <xref:System.Windows.Controls.ComboBox.IsDropDownOpen%2A?displayProperty=nameWithType> and <xref:System.Windows.Controls.Primitives.ToggleButton.IsChecked%2A?displayProperty=nameWithType>.</span></span>  
  
    2. <span data-ttu-id="55142-183">觸發的屬性變更或屬性動畫。</span><span class="sxs-lookup"><span data-stu-id="55142-183">Triggered property changes or property animations.</span></span> <span data-ttu-id="55142-184">範例： 暫留狀態<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="55142-184">Example: the hover state of a <xref:System.Windows.Controls.Button>.</span></span>  
  
    3. <span data-ttu-id="55142-185">命令。</span><span class="sxs-lookup"><span data-stu-id="55142-185">Command.</span></span> <span data-ttu-id="55142-186">範例： <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand>  /  <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand>在<xref:System.Windows.Controls.Primitives.ScrollBar>。</span><span class="sxs-lookup"><span data-stu-id="55142-186">Example: <xref:System.Windows.Controls.Primitives.ScrollBar.LineUpCommand> / <xref:System.Windows.Controls.Primitives.ScrollBar.LineDownCommand> in <xref:System.Windows.Controls.Primitives.ScrollBar>.</span></span>  
  
    4. <span data-ttu-id="55142-187">獨立協助程式元素。</span><span class="sxs-lookup"><span data-stu-id="55142-187">Standalone helper elements.</span></span> <span data-ttu-id="55142-188">範例：<xref:System.Windows.Controls.Primitives.TabPanel>在<xref:System.Windows.Controls.TabControl>。</span><span class="sxs-lookup"><span data-stu-id="55142-188">Example: <xref:System.Windows.Controls.Primitives.TabPanel> in <xref:System.Windows.Controls.TabControl>.</span></span>  
  
    5. <span data-ttu-id="55142-189">型別型協助程式型別。</span><span class="sxs-lookup"><span data-stu-id="55142-189">Type-based helper types.</span></span> <span data-ttu-id="55142-190">範例：<xref:System.Windows.Controls.ContentPresenter>中<xref:System.Windows.Controls.Button>，<xref:System.Windows.Controls.Primitives.TickBar>在<xref:System.Windows.Controls.Slider>。</span><span class="sxs-lookup"><span data-stu-id="55142-190">Example: <xref:System.Windows.Controls.ContentPresenter> in <xref:System.Windows.Controls.Button>, <xref:System.Windows.Controls.Primitives.TickBar> in <xref:System.Windows.Controls.Slider>.</span></span>  
  
    6. <span data-ttu-id="55142-191">具名協助程式元素。</span><span class="sxs-lookup"><span data-stu-id="55142-191">Named helper elements.</span></span> <span data-ttu-id="55142-192">範例：<xref:System.Windows.Controls.TextBox>在<xref:System.Windows.Controls.ComboBox>。</span><span class="sxs-lookup"><span data-stu-id="55142-192">Example: <xref:System.Windows.Controls.TextBox> in <xref:System.Windows.Controls.ComboBox>.</span></span>  
  
    7. <span data-ttu-id="55142-193">來自具名協助程式型別的反昇事件。</span><span class="sxs-lookup"><span data-stu-id="55142-193">Bubbled events from named helper types.</span></span> <span data-ttu-id="55142-194">如果您接聽來自樣式元素的反昇事件，您應該要求必須能夠唯一識別產生該事件的元素。</span><span class="sxs-lookup"><span data-stu-id="55142-194">If you listen for bubbled events from a style element, you should require that the element generating the event can be uniquely identified.</span></span> <span data-ttu-id="55142-195">範例：<xref:System.Windows.Controls.Primitives.Thumb>在<xref:System.Windows.Controls.ToolBar>。</span><span class="sxs-lookup"><span data-stu-id="55142-195">Example: <xref:System.Windows.Controls.Primitives.Thumb> in <xref:System.Windows.Controls.ToolBar>.</span></span>  
  
    8. <span data-ttu-id="55142-196">自訂的 `OnRender` 行為。</span><span class="sxs-lookup"><span data-stu-id="55142-196">Custom `OnRender` behavior.</span></span> <span data-ttu-id="55142-197">範例：<xref:Microsoft.Windows.Themes.ButtonChrome>在<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="55142-197">Example: <xref:Microsoft.Windows.Themes.ButtonChrome> in <xref:System.Windows.Controls.Button>.</span></span>  
  
- <span data-ttu-id="55142-198">**儘量不要使用樣式觸發程序 (與範本觸發程序相反)**。</span><span class="sxs-lookup"><span data-stu-id="55142-198">**Use style triggers (as opposed to template triggers) sparingly**.</span></span> <span data-ttu-id="55142-199">針對會影響範本中元素上屬性的觸發程序，您必須在範本中進行宣告。</span><span class="sxs-lookup"><span data-stu-id="55142-199">Triggers that affect properties on elements in the template must be declared in the template.</span></span> <span data-ttu-id="55142-200">針對會影響控制項 (無 `TargetName`) 上屬性的觸發程序，除非您知道變更範本應該也會終結觸發程序，否則您可以在樣式中進行宣告。</span><span class="sxs-lookup"><span data-stu-id="55142-200">Triggers that affect properties on the control (no `TargetName`) may be declared in the style unless you know that changing the template should also destroy the trigger.</span></span>  
  
- <span data-ttu-id="55142-201">**與現有的樣式設定模式保持一致。**</span><span class="sxs-lookup"><span data-stu-id="55142-201">**Be consistent with existing styling patterns.**</span></span> <span data-ttu-id="55142-202">在很多時候，都有多種方式可以解決問題。</span><span class="sxs-lookup"><span data-stu-id="55142-202">Many times there are multiple ways to solve a problem.</span></span> <span data-ttu-id="55142-203">請注意，儘可能與現有的控制項樣式設定模式保持一致。</span><span class="sxs-lookup"><span data-stu-id="55142-203">Be aware of and, when possible, consistent with existing control styling patterns.</span></span> <span data-ttu-id="55142-204">這點特別重要，衍生自相同基底類型的控制項 (例如<xref:System.Windows.Controls.ContentControl>， <xref:System.Windows.Controls.ItemsControl>，<xref:System.Windows.Controls.Primitives.RangeBase>等等)。</span><span class="sxs-lookup"><span data-stu-id="55142-204">This is especially important for controls that derive from the same base type (for example, <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, <xref:System.Windows.Controls.Primitives.RangeBase>, and so on).</span></span>  
  
- <span data-ttu-id="55142-205">**公開屬性來啟用常見的自訂案例，而不重新範本化**。</span><span class="sxs-lookup"><span data-stu-id="55142-205">**Expose properties to enable common customization scenarios without retemplating**.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="55142-206">不支援可插式/可自訂的組件，因此控制項使用者僅有兩種自訂方法可用：直接設定屬性，或使用樣式來設定屬性。</span><span class="sxs-lookup"><span data-stu-id="55142-206">does not support pluggable/customizable parts, so a control user is left with only two methods of customization: setting properties directly or setting properties using styles.</span></span> <span data-ttu-id="55142-207">記住這一點之後，就可以公開以非常常見、高優先順序自訂案例為目標的數量有限屬性，否則這些案例將需要重新範本化。</span><span class="sxs-lookup"><span data-stu-id="55142-207">With that in mind, it is appropriate to surface a limited number of properties targeted at very common, high-priority customization scenarios which would otherwise require the retemplating.</span></span> <span data-ttu-id="55142-208">以下是啟用自訂案例的時機和方式的最佳做法：</span><span class="sxs-lookup"><span data-stu-id="55142-208">Here are best practices for when and how to enable customization scenarios:</span></span>  
  
    - <span data-ttu-id="55142-209">非常常見的自訂應該以控制項上屬性的形式公開，並由範本取用。</span><span class="sxs-lookup"><span data-stu-id="55142-209">Very common customizations should be exposed as properties on the control and consumed by the template.</span></span>  
  
    - <span data-ttu-id="55142-210">較不常見 (但並非罕見) 的自訂應該以附加屬性的形式公開，並由範本取用。</span><span class="sxs-lookup"><span data-stu-id="55142-210">Less common (though not rare) customizations should be exposed as attached properties and consumed by the template.</span></span>  
  
    - <span data-ttu-id="55142-211">針對已知但罕見的自訂，則可接受要求重新範本化。</span><span class="sxs-lookup"><span data-stu-id="55142-211">It is acceptable for known but rare customizations to require retemplating.</span></span>  
  
<a name="Theme_Considerations"></a>   
## <a name="theme-considerations"></a><span data-ttu-id="55142-212">佈景主題考量</span><span class="sxs-lookup"><span data-stu-id="55142-212">Theme Considerations</span></span>  
  
- <span data-ttu-id="55142-213">**佈景主題樣式應該嘗試在所有佈景主題都具有一致的屬性語意，但不保證能做到**。</span><span class="sxs-lookup"><span data-stu-id="55142-213">**Theme styles should attempt to have consistent property semantics across all themes, but make no guarantee**.</span></span> <span data-ttu-id="55142-214">作為其記載的一部分，您的控制項應該要有一份文件，其中描述控制項的屬性語意，也就是控制項屬性的「意義」。</span><span class="sxs-lookup"><span data-stu-id="55142-214">As part of its documentation, your control should have a document describing the control's property semantics, that is, the "meaning" of a property for a control.</span></span> <span data-ttu-id="55142-215">例如，<xref:System.Windows.Controls.ComboBox>控制項應該定義的意義<xref:System.Windows.Controls.Control.Background%2A>內的屬性<xref:System.Windows.Controls.ComboBox>。</span><span class="sxs-lookup"><span data-stu-id="55142-215">For example, the <xref:System.Windows.Controls.ComboBox> control should define the meaning of the <xref:System.Windows.Controls.Control.Background%2A> property within <xref:System.Windows.Controls.ComboBox>.</span></span> <span data-ttu-id="55142-216">您控制項的預設樣式應該嘗試在所有佈景主題都遵守該文件中定義的語意。</span><span class="sxs-lookup"><span data-stu-id="55142-216">The default styles for your control should attempt to follow the semantics defined in that document across all themes.</span></span> <span data-ttu-id="55142-217">另一方面，控制項使用者則應該注意屬性語意可能會因佈景主題不同而改變。</span><span class="sxs-lookup"><span data-stu-id="55142-217">Control users, on the other hand, should be aware that property semantics can change from theme to theme.</span></span> <span data-ttu-id="55142-218">在某些情況下，在特定佈景主題所需的視覺條件約束下，可能會無法表達指定的屬性。</span><span class="sxs-lookup"><span data-stu-id="55142-218">In certain cases, a given property may not be expressible under the visual constraints required by a particular theme.</span></span> <span data-ttu-id="55142-219">(例如，「傳統」佈景主題並沒有可針對許多控制項套用 `Thickness` 的單一框線)。</span><span class="sxs-lookup"><span data-stu-id="55142-219">(The Classic theme, for example, does not have a single border to which `Thickness` can be applied for many controls.)</span></span>  
  
- <span data-ttu-id="55142-220">**佈景主題樣式不需要在所有佈景主題都具有一致的觸發程序語意**。</span><span class="sxs-lookup"><span data-stu-id="55142-220">**Theme styles do not need to have consistent trigger semantics across all themes**.</span></span> <span data-ttu-id="55142-221">控制項樣式透過觸發程序或動畫公開的行為可能會因佈景主題不同而不同。</span><span class="sxs-lookup"><span data-stu-id="55142-221">The behavior exposed by a control style through triggers or animations may vary from theme to theme.</span></span> <span data-ttu-id="55142-222">控制項使用者應該注意，控制項未必會採用相同的機制在所有佈景主題達到特定的行為。</span><span class="sxs-lookup"><span data-stu-id="55142-222">Control users should be aware that a control will not necessarily employ the same mechanism to achieve a particular behavior across all themes.</span></span> <span data-ttu-id="55142-223">例如，可能有一個佈景主題使用動畫來表達暫留行為，而另一個佈景主題則使用觸發程序。</span><span class="sxs-lookup"><span data-stu-id="55142-223">One theme, for example, may use an animation to express hover behavior where another theme uses a trigger.</span></span> <span data-ttu-id="55142-224">這會導致在保留自訂控制項上的行為時不一致。</span><span class="sxs-lookup"><span data-stu-id="55142-224">This can result in inconsistencies in behavior preservation on customized controls.</span></span> <span data-ttu-id="55142-225">(例如，變更背景屬性可能不會影響控制項的暫留狀態，如果是使用觸發程序來表達該狀態。</span><span class="sxs-lookup"><span data-stu-id="55142-225">(Changing the background property, for example, might not affect the hover state of the control if that state is expressed using a trigger.</span></span> <span data-ttu-id="55142-226">不過，如果是使用動畫來實作暫留狀態，變更背景可能就會無法挽回地破壞動畫，也因而破壞狀態轉換)。</span><span class="sxs-lookup"><span data-stu-id="55142-226">However, if the hover state is implemented using an animation, changing to background could irreparably break the animation and therefore the state transition.)</span></span>  
  
- <span data-ttu-id="55142-227">**佈景主題樣式不需要在所有佈景主題都具有一致的「版面配置」語意**。</span><span class="sxs-lookup"><span data-stu-id="55142-227">**Theme styles do not need to have consistent "layout" semantics across all themes**.</span></span> <span data-ttu-id="55142-228">例如，預設樣式不需要保證控制項在所有佈景主題中都佔據相同的大小，或是保證控制項在所有佈景主題中都具有相同的內容邊界/邊框間距。</span><span class="sxs-lookup"><span data-stu-id="55142-228">For example, the default style does not need to guarantee that a control will occupy the same amount of size in all themes or guarantee that a control will have the same content margins / padding across all themes.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="55142-229">另請參閱</span><span class="sxs-lookup"><span data-stu-id="55142-229">See also</span></span>

- [<span data-ttu-id="55142-230">樣式設定和範本化</span><span class="sxs-lookup"><span data-stu-id="55142-230">Styling and Templating</span></span>](styling-and-templating.md)
- [<span data-ttu-id="55142-231">控制項撰寫概觀</span><span class="sxs-lookup"><span data-stu-id="55142-231">Control Authoring Overview</span></span>](control-authoring-overview.md)
