---
title: 視覺分層中的點擊測試
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- hit testing functionality [WPF]
- visual layer [WPF], hit testing functionality
ms.assetid: b1a64b61-14be-4d75-b89a-5c67bebb2c7b
ms.openlocfilehash: d4d304353e91147c57297dcc4525759ff1474b4f
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186408"
---
# <a name="hit-testing-in-the-visual-layer"></a><span data-ttu-id="b2227-102">視覺分層中的點擊測試</span><span class="sxs-lookup"><span data-stu-id="b2227-102">Hit Testing in the Visual Layer</span></span>
<span data-ttu-id="b2227-103">本主題提供視覺分層所提供點擊測試功能的概觀。</span><span class="sxs-lookup"><span data-stu-id="b2227-103">This topic provides an overview of hit testing functionality provided by the visual layer.</span></span> <span data-ttu-id="b2227-104">點擊測試支援允許您確定幾何或點值是否屬於渲染的內容<xref:System.Windows.Media.Visual>，允許您實現使用者介面行為（如選取矩形）來選擇多個物件。</span><span class="sxs-lookup"><span data-stu-id="b2227-104">Hit testing support allows you to determine whether a geometry or point value falls within the rendered content of a <xref:System.Windows.Media.Visual>, allowing you to implement user interface behavior such as a selection rectangle to select multiple objects.</span></span>  

<a name="hit_testing_scenarios"></a>
## <a name="hit-testing-scenarios"></a><span data-ttu-id="b2227-105">點擊測試案例</span><span class="sxs-lookup"><span data-stu-id="b2227-105">Hit Testing Scenarios</span></span>  
 <span data-ttu-id="b2227-106">類<xref:System.Windows.UIElement>提供的方法<xref:System.Windows.UIElement.InputHitTest%2A>，它允許您使用給定座標值對元素進行測試。</span><span class="sxs-lookup"><span data-stu-id="b2227-106">The <xref:System.Windows.UIElement> class provides the <xref:System.Windows.UIElement.InputHitTest%2A> method, which allows you to hit test against an element using a given coordinate value.</span></span> <span data-ttu-id="b2227-107">在許多情況下，<xref:System.Windows.UIElement.InputHitTest%2A>該方法提供了實現元素點擊測試所需的功能。</span><span class="sxs-lookup"><span data-stu-id="b2227-107">In many cases, the <xref:System.Windows.UIElement.InputHitTest%2A> method provides the desired functionality for implementing hit testing of elements.</span></span> <span data-ttu-id="b2227-108">不過，有幾個案例，您可能需要在視覺分層實作點擊測試。</span><span class="sxs-lookup"><span data-stu-id="b2227-108">However, there are several scenarios in which you may need to implement hit testing at the visual layer.</span></span>  
  
- <span data-ttu-id="b2227-109">對非<xref:System.Windows.UIElement>物件進行點擊測試：如果點擊測試非<xref:System.Windows.UIElement>物件（如<xref:System.Windows.Media.DrawingVisual>或繪圖物件），則此測試適用。</span><span class="sxs-lookup"><span data-stu-id="b2227-109">Hit testing against non-<xref:System.Windows.UIElement> objects: This applies if you are hit testing non-<xref:System.Windows.UIElement> objects, such as <xref:System.Windows.Media.DrawingVisual> or graphics objects.</span></span>  
  
- <span data-ttu-id="b2227-110">使用幾何進行點擊測試︰這適用於您需要使用幾何物件，而不是點的座標值進行點擊測試時。</span><span class="sxs-lookup"><span data-stu-id="b2227-110">Hit testing using a geometry: This applies if you need to hit test using a geometry object rather than the coordinate value of a point.</span></span>  
  
- <span data-ttu-id="b2227-111">對多個物件進行點擊測試︰這適用於當您需要對多個物件進行點擊測試，例如重疊的物件。</span><span class="sxs-lookup"><span data-stu-id="b2227-111">Hit testing against multiple objects: This applies when you need to hit test against multiple objects, such as overlapping objects.</span></span> <span data-ttu-id="b2227-112">您可以取得和幾何或點交集的所有視覺效果結果，不只有第一個結果。</span><span class="sxs-lookup"><span data-stu-id="b2227-112">You can get results for all visuals intersecting a geometry or point, not just the first one.</span></span>  
  
- <span data-ttu-id="b2227-113">忽略<xref:System.Windows.UIElement>點擊測試策略：當您需要忽略<xref:System.Windows.UIElement>點擊測試策略時，這適用于該策略，該策略考慮的是元素是禁用還是不可見等因素。</span><span class="sxs-lookup"><span data-stu-id="b2227-113">Ignoring <xref:System.Windows.UIElement> hit testing policy: This applies when you need to ignore the <xref:System.Windows.UIElement> hit testing policy, which takes into consideration such factors as whether an element is disabled or invisible.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b2227-114">如需示範在視覺分層進行點擊測試的完整程式碼範例，請參閱[使用 DrawingVisuals 進行點擊測試範例 (英文)](https://github.com/Microsoft/WPF-Samples/tree/master/Visual%20Layer/DrawingVisual) 和[使用 Win32 交互操作進行點擊測試範例 (英文)](https://github.com/microsoft/WPF-Samples/tree/master/Visual%20Layer/VisualsHitTesting)。</span><span class="sxs-lookup"><span data-stu-id="b2227-114">For a complete code sample illustrating hit testing at the visual layer, see [Hit Test Using DrawingVisuals Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Visual%20Layer/DrawingVisual) and [Hit Test with Win32 Interoperation Sample](https://github.com/microsoft/WPF-Samples/tree/master/Visual%20Layer/VisualsHitTesting).</span></span>  
  
<a name="hit_testing_support"></a>
## <a name="hit-testing-support"></a><span data-ttu-id="b2227-115">點擊測試支援</span><span class="sxs-lookup"><span data-stu-id="b2227-115">Hit Testing Support</span></span>  
 <span data-ttu-id="b2227-116"><xref:System.Windows.Media.VisualTreeHelper>類中<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>的方法的目的是確定幾何或點座標值是否位於給定物件的渲染內容（如控制項或圖形元素）內。</span><span class="sxs-lookup"><span data-stu-id="b2227-116">The purpose of the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> methods in the <xref:System.Windows.Media.VisualTreeHelper> class is to determine whether a geometry or point coordinate value is within the rendered content of a given object, such as a control or graphic element.</span></span> <span data-ttu-id="b2227-117">例如，您可以使用點擊測試來判斷物件的週框矩形內的滑鼠點擊是否落於圓形的幾何內。</span><span class="sxs-lookup"><span data-stu-id="b2227-117">For example, you could use hit testing to determine whether a mouse click within the bounding rectangle of an object falls within the geometry of a circle.</span></span> <span data-ttu-id="b2227-118">您也可以選擇覆寫預設點擊測試實作，以執行您的自訂點擊測試計算。</span><span class="sxs-lookup"><span data-stu-id="b2227-118">You can also choose to override the default implementation of hit testing to perform your own custom hit test calculations.</span></span>  
  
 <span data-ttu-id="b2227-119">下圖說明非矩形物件的區域和其週框之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="b2227-119">The following illustration shows the relationship between a non-rectangular object's region and its bounding rectangle.</span></span>  
  
 <span data-ttu-id="b2227-120">![有效點擊測試區域的圖表](./media/wcpsdk-mmgraphics-visuals-hittest-1.png "wcpsdk_mmgraphics_visuals_hittest_1")</span><span class="sxs-lookup"><span data-stu-id="b2227-120">![Diagram of valid hit test region](./media/wcpsdk-mmgraphics-visuals-hittest-1.png "wcpsdk_mmgraphics_visuals_hittest_1")</span></span>  
<span data-ttu-id="b2227-121">有效點擊測試區域的圖表</span><span class="sxs-lookup"><span data-stu-id="b2227-121">Diagram of valid hit test region</span></span>  
  
<a name="hit_testing_and_z-order"></a>
## <a name="hit-testing-and-z-order"></a><span data-ttu-id="b2227-122">點擊測試和疊置順序</span><span class="sxs-lookup"><span data-stu-id="b2227-122">Hit Testing and Z-Order</span></span>  
 <span data-ttu-id="b2227-123">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 視覺分層支援對點或幾何底下的所有物件進行點擊測試，而不只有最上層物件。</span><span class="sxs-lookup"><span data-stu-id="b2227-123">The [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] visual layer supports hit testing against all objects under a point or geometry, not just the top-most object.</span></span> <span data-ttu-id="b2227-124">以疊置順序傳回結果。</span><span class="sxs-lookup"><span data-stu-id="b2227-124">Results are returned in z-order.</span></span> <span data-ttu-id="b2227-125">但是，作為參數傳遞給<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>方法的可視物件確定要點擊測試的視覺化樹的哪個部分。</span><span class="sxs-lookup"><span data-stu-id="b2227-125">However, the visual object that you pass as the parameter to the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> method determines which portion of the visual tree that will be hit test.</span></span> <span data-ttu-id="b2227-126">您可以對整個視覺化樹狀結構或其任何部分進行點擊測試。</span><span class="sxs-lookup"><span data-stu-id="b2227-126">You can hit test against the entire visual tree, or any portion of it.</span></span>  
  
 <span data-ttu-id="b2227-127">在下圖中，圓形物件位於正方形和三角形物件上方。</span><span class="sxs-lookup"><span data-stu-id="b2227-127">In the following illustration, the circle object is on top of both the square and triangle objects.</span></span> <span data-ttu-id="b2227-128">如果您只對 z 順序值為最高的視覺物件的點擊測試感興趣，則可以將可視點擊測試枚舉設置為從第一<xref:System.Windows.Media.HitTestResultBehavior.Stop><xref:System.Windows.Media.HitTestResultCallback>項後返回以停止點擊測試遍歷。</span><span class="sxs-lookup"><span data-stu-id="b2227-128">If you are only interested in hit testing the visual object whose z-order value is top-most, you can set the visual hit test enumeration to return <xref:System.Windows.Media.HitTestResultBehavior.Stop> from the <xref:System.Windows.Media.HitTestResultCallback> to stop the hit test traversal after the first item.</span></span>  
  
 <span data-ttu-id="b2227-129">![視覺化樹狀之疊置順序的圖表](./media/wcpsdk-mmgraphics-visuals-hittest-2.png "wcpsdk_mmgraphics_visuals_hittest_2")</span><span class="sxs-lookup"><span data-stu-id="b2227-129">![Diagram of the z&#45;order of a visual tree](./media/wcpsdk-mmgraphics-visuals-hittest-2.png "wcpsdk_mmgraphics_visuals_hittest_2")</span></span>  
<span data-ttu-id="b2227-130">視覺化樹狀之疊置順序的圖表</span><span class="sxs-lookup"><span data-stu-id="b2227-130">Diagram of the z-order of a visual tree</span></span>  
  
 <span data-ttu-id="b2227-131">如果要枚舉特定點或幾何體下的所有可視物件，則從 返回<xref:System.Windows.Media.HitTestResultBehavior.Continue><xref:System.Windows.Media.HitTestResultCallback>。</span><span class="sxs-lookup"><span data-stu-id="b2227-131">If you want to enumerate all visual objects under a specific point or geometry, return <xref:System.Windows.Media.HitTestResultBehavior.Continue> from the <xref:System.Windows.Media.HitTestResultCallback>.</span></span> <span data-ttu-id="b2227-132">這表示您可以對其他物件底下的視覺物件進行點擊測試，即使它們完全遭到遮蔽。</span><span class="sxs-lookup"><span data-stu-id="b2227-132">This means you can hit test for visual objects that are beneath other objects, even if they are wholly obscured.</span></span> <span data-ttu-id="b2227-133">如需詳細資訊，請參閱「使用點擊測試結果回呼 」一節中的範例程式碼。</span><span class="sxs-lookup"><span data-stu-id="b2227-133">See the sample code in the section "Using a Hit Test Results Callback" for more information.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b2227-134">透明的視覺物件也可以進行點擊測試。</span><span class="sxs-lookup"><span data-stu-id="b2227-134">A visual object that is transparent can also be hit test.</span></span>  
  
<a name="using_default_hit_testing"></a>
## <a name="using-default-hit-testing"></a><span data-ttu-id="b2227-135">使用預設點擊測試</span><span class="sxs-lookup"><span data-stu-id="b2227-135">Using Default Hit Testing</span></span>  
 <span data-ttu-id="b2227-136">通過使用<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>方法指定可視物件和要測試的點座標值，可以識別點是否位於可視物件的幾何體內。</span><span class="sxs-lookup"><span data-stu-id="b2227-136">You can identify whether a point is within the geometry of a visual object, by using the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> method to specify a visual object and a point coordinate value to test against.</span></span> <span data-ttu-id="b2227-137">視覺物件參數可在視覺化樹狀結構中識別進行點擊測試搜尋的起點。</span><span class="sxs-lookup"><span data-stu-id="b2227-137">The visual object parameter identifies the starting point in the visual tree for the hit test search.</span></span> <span data-ttu-id="b2227-138">如果在圖形包含座標的視覺化樹中找到可視物件，則將其設置為<xref:System.Windows.Media.HitTestResult.VisualHit%2A><xref:System.Windows.Media.HitTestResult>物件的屬性。</span><span class="sxs-lookup"><span data-stu-id="b2227-138">If a visual object is found in the visual tree whose geometry contains the coordinate, it is set to the <xref:System.Windows.Media.HitTestResult.VisualHit%2A> property of a <xref:System.Windows.Media.HitTestResult> object.</span></span> <span data-ttu-id="b2227-139"><xref:System.Windows.Media.HitTestResult>然後從 方法返回<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>。</span><span class="sxs-lookup"><span data-stu-id="b2227-139">The <xref:System.Windows.Media.HitTestResult> is then returned from the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> method.</span></span> <span data-ttu-id="b2227-140">如果該點不包含在用於測試的視覺化子樹中，<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>則返回`null`。</span><span class="sxs-lookup"><span data-stu-id="b2227-140">If the point is not contained with the visual sub-tree you are hit testing, <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> returns `null`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b2227-141">預設點擊測試一定會傳回疊置順序中最上層的物件。</span><span class="sxs-lookup"><span data-stu-id="b2227-141">Default hit testing always returns the top-most object in the z-order.</span></span> <span data-ttu-id="b2227-142">若要識別所有視覺物件，甚至是遭到部分或全部遮蔽的物件，可使用點擊測試結果回呼。</span><span class="sxs-lookup"><span data-stu-id="b2227-142">In order to identify all visual objects, even those that may be partly or wholly obscured, use a hit test result callback.</span></span>  
  
 <span data-ttu-id="b2227-143">作為<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>方法的點參數傳遞的座標值必須相對於要針對的可視物件的座標空間進行測試。</span><span class="sxs-lookup"><span data-stu-id="b2227-143">The coordinate value you pass as the point parameter for the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> method has to be relative to the coordinate space of the visual object you are hit testing against.</span></span> <span data-ttu-id="b2227-144">例如，如果您在父項座標空間的 (100, 100) 定義巢狀視覺物件，然後對位於 (0, 0) 的子視覺物件進行點擊測試，其相當於父項座標空間的 (100, 100)。</span><span class="sxs-lookup"><span data-stu-id="b2227-144">For example, if you have nested visual objects defined at (100, 100) in the parent's coordinate space, then hit testing a child visual at (0, 0) is equivalent to hit testing at (100, 100) in the parent's coordinate space.</span></span>  
  
 <span data-ttu-id="b2227-145">以下代碼演示如何為用於捕獲用於點擊測試的事件<xref:System.Windows.UIElement>的物件設置滑鼠事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="b2227-145">The following code shows how to set up mouse event handlers for a <xref:System.Windows.UIElement> object that is used to capture events used for hit testing.</span></span>  
  
 [!code-csharp[HitTestingOverview#100](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#100)]
 [!code-vb[HitTestingOverview#100](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#100)]  
  
### <a name="how-the-visual-tree-affects-hit-testing"></a><span data-ttu-id="b2227-146">視覺化樹狀結構如何影響點擊測試</span><span class="sxs-lookup"><span data-stu-id="b2227-146">How the Visual Tree Affects Hit Testing</span></span>  
 <span data-ttu-id="b2227-147">視覺化樹狀結構中的起點可決定在物件的點擊測試列舉期間會傳回哪些物件。</span><span class="sxs-lookup"><span data-stu-id="b2227-147">The starting point in the visual tree determines which objects are returned during the hit test enumeration of objects.</span></span> <span data-ttu-id="b2227-148">如果您有多個想要進行點擊測試的物件，在視覺化樹狀結構中做為起點的視覺物件必須是所有相關物件的通用上階。</span><span class="sxs-lookup"><span data-stu-id="b2227-148">If you have multiple objects you want to hit test, the visual object used as the starting point in the visual tree must be the common ancestor of all objects of interest.</span></span> <span data-ttu-id="b2227-149">例如，如果您想要對下圖中的按鈕元素和繪圖視覺物件進行點擊測試，您必須將視覺樹狀結構中的起點設定為兩者的通用上階。</span><span class="sxs-lookup"><span data-stu-id="b2227-149">For example, if you were interested in hit testing both the button element and drawing visual in the following diagram, you would have to set the starting point in the visual tree to the common ancestor of both.</span></span> <span data-ttu-id="b2227-150">在此情況下，畫布元素是按鈕元素和繪製視覺物件兩者的通用上階。</span><span class="sxs-lookup"><span data-stu-id="b2227-150">In this case, the canvas element is the common ancestor of both the button element and the drawing visual.</span></span>  
  
 <span data-ttu-id="b2227-151">![視覺化樹狀階層架構的圖表](./media/wcpsdk-mmgraphics-visuals-overview-01.gif "wcpsdk_mmgraphics_visuals_overview_01")</span><span class="sxs-lookup"><span data-stu-id="b2227-151">![Diagram of a visual tree hierarchy](./media/wcpsdk-mmgraphics-visuals-overview-01.gif "wcpsdk_mmgraphics_visuals_overview_01")</span></span>  
<span data-ttu-id="b2227-152">視覺化樹狀階層架構的圖表</span><span class="sxs-lookup"><span data-stu-id="b2227-152">Diagram of a visual tree hierarchy</span></span>  
  
> [!NOTE]
> <span data-ttu-id="b2227-153">屬性<xref:System.Windows.UIElement.IsHitTestVisible%2A>獲取或設置一個值，該值聲明<xref:System.Windows.UIElement>派生物件是否可以從其呈現內容的某些部分作為點擊測試結果返回。</span><span class="sxs-lookup"><span data-stu-id="b2227-153">The <xref:System.Windows.UIElement.IsHitTestVisible%2A> property gets or sets a value that declares whether a <xref:System.Windows.UIElement>-derived object can possibly be returned as a hit test result from some portion of its rendered content.</span></span> <span data-ttu-id="b2227-154">這可讓您選擇性地更改視覺化樹狀結構，以判斷哪一個視覺物件要進行點擊測試。</span><span class="sxs-lookup"><span data-stu-id="b2227-154">This allows you to selectively alter the visual tree to determine which visual objects are involved in a hit test.</span></span>  
  
<a name="using_a_hit_test_result_callback"></a>
## <a name="using-a-hit-test-result-callback"></a><span data-ttu-id="b2227-155">使用點擊測試結果回呼</span><span class="sxs-lookup"><span data-stu-id="b2227-155">Using a Hit Test Result Callback</span></span>  
 <span data-ttu-id="b2227-156">視覺化樹狀結構中的幾何只要包含指定座標值，您就可以列舉所有視覺物件。</span><span class="sxs-lookup"><span data-stu-id="b2227-156">You can enumerate all visual objects in a visual tree whose geometry contains a specified coordinate value.</span></span> <span data-ttu-id="b2227-157">這可讓您識別所有視覺物件，甚至是遭到其他視覺物件部分或全部遮蔽的那些物件。</span><span class="sxs-lookup"><span data-stu-id="b2227-157">This allows you to identify all visual objects, even those that may be partly or wholly obscured by other visual objects.</span></span> <span data-ttu-id="b2227-158">要枚舉視覺化樹中的可視物件，<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>請使用 具有點擊測試回呼函數的方法。</span><span class="sxs-lookup"><span data-stu-id="b2227-158">To enumerate visual objects in a visual tree use the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> method with a hit test callback function.</span></span> <span data-ttu-id="b2227-159">當視覺物件中包含您指定的座標值時，系統便會呼叫點擊測試回呼函式。</span><span class="sxs-lookup"><span data-stu-id="b2227-159">The hit test callback function is called by the system when the coordinate value you specify is contained in a visual object.</span></span>  
  
 <span data-ttu-id="b2227-160">在點擊測試結果列舉期間，您不應該執行任何修改視覺化樹狀結構的作業。</span><span class="sxs-lookup"><span data-stu-id="b2227-160">During the hit test results enumeration, you should not perform any operation that modifies the visual tree.</span></span> <span data-ttu-id="b2227-161">在周遊時新增或移除視覺化樹狀結構的物件，可能會導致無法預期的行為。</span><span class="sxs-lookup"><span data-stu-id="b2227-161">Adding or removing an object from the visual tree while it is being traversed can result in unpredictable behavior.</span></span> <span data-ttu-id="b2227-162">返回<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>後，可以安全地修改視覺化樹。</span><span class="sxs-lookup"><span data-stu-id="b2227-162">You can safely modify the visual tree after the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> method returns.</span></span> <span data-ttu-id="b2227-163">您可能希望提供資料結構（如 ，）<xref:System.Collections.ArrayList>以在點擊測試結果枚舉期間存儲值。</span><span class="sxs-lookup"><span data-stu-id="b2227-163">You may want to provide a data structure, such as an <xref:System.Collections.ArrayList>, to store values during the hit test results enumeration.</span></span>  
  
 [!code-csharp[HitTestingOverview#101](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#101)]
 [!code-vb[HitTestingOverview#101](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#101)]  
  
 <span data-ttu-id="b2227-164">點擊測試回呼方法定義您在視覺化樹狀結構中的特定視覺物件上，識別出點擊測試時執行的動作。</span><span class="sxs-lookup"><span data-stu-id="b2227-164">The hit test callback method defines the actions you perform when a hit test is identified on a particular visual object in the visual tree.</span></span> <span data-ttu-id="b2227-165">執行操作後，返回一個<xref:System.Windows.Media.HitTestResultBehavior>值，用於確定是否繼續枚舉任何其他可視物件。</span><span class="sxs-lookup"><span data-stu-id="b2227-165">After you perform the actions, you return a <xref:System.Windows.Media.HitTestResultBehavior> value that determines whether to continue the enumeration of any other visual objects or not.</span></span>  
  
 [!code-csharp[HitTestingOverview#102](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#102)]
 [!code-vb[HitTestingOverview#102](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#102)]  
  
> [!NOTE]
> <span data-ttu-id="b2227-166">點擊視覺物件列舉順序是依照疊置順序。</span><span class="sxs-lookup"><span data-stu-id="b2227-166">The order of enumeration of hit visual objects is by z-order.</span></span> <span data-ttu-id="b2227-167">在最上層疊置順序層級的視覺物件是第一個列舉的物件。</span><span class="sxs-lookup"><span data-stu-id="b2227-167">The visual object at the top-most z-order level is the first object enumerated.</span></span> <span data-ttu-id="b2227-168">任何其他視覺物件都會以遞減的疊置順序層級列舉。</span><span class="sxs-lookup"><span data-stu-id="b2227-168">Any other visual objects enumerated are at decreasing z-order level.</span></span> <span data-ttu-id="b2227-169">此列舉類型順序對應至視覺效果的轉譯順序。</span><span class="sxs-lookup"><span data-stu-id="b2227-169">This order of enumeration corresponds to the rendering order of the visuals.</span></span>  
  
 <span data-ttu-id="b2227-170">您可以通過返回<xref:System.Windows.Media.HitTestResultBehavior.Stop>在點擊測試回呼函數中隨時停止枚舉可視物件。</span><span class="sxs-lookup"><span data-stu-id="b2227-170">You can stop the enumeration of visual objects at any time in the hit test callback function by returning <xref:System.Windows.Media.HitTestResultBehavior.Stop>.</span></span>  
  
 [!code-csharp[HitTestingOverview#103](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#103)]
 [!code-vb[HitTestingOverview#103](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#103)]  
  
<a name="using_a_hit_test_filter_callback"></a>
## <a name="using-a-hit-test-filter-callback"></a><span data-ttu-id="b2227-171">使用點擊測試篩選回呼</span><span class="sxs-lookup"><span data-stu-id="b2227-171">Using a Hit Test Filter Callback</span></span>  
 <span data-ttu-id="b2227-172">您可以使用選用的點擊測試篩選來限制傳遞至點擊測試結果的物件。</span><span class="sxs-lookup"><span data-stu-id="b2227-172">You can use an optional hit test filter to restrict the objects that are passed on to the hit test results.</span></span> <span data-ttu-id="b2227-173">這可讓您忽略點擊測試結果中處理時不感興趣的視覺化樹狀結構組件。</span><span class="sxs-lookup"><span data-stu-id="b2227-173">This allows you to ignore parts of the visual tree that you are not interested in processing in your hit test results.</span></span> <span data-ttu-id="b2227-174">要實現點擊測試篩選器，請定義點擊測試篩選器回呼函數，並在調用<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>方法時將其作為參數值傳遞。</span><span class="sxs-lookup"><span data-stu-id="b2227-174">To implement a hit test filter, you define a hit test filter callback function and pass it as a parameter value when you call the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> method.</span></span>  
  
 [!code-csharp[HitTestingOverview#104](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#104)]
 [!code-vb[HitTestingOverview#104](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#104)]  
  
 <span data-ttu-id="b2227-175">如果不想提供可選的點擊測試篩選器回檔功能，請傳遞值`null`作為該方法的<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>參數。</span><span class="sxs-lookup"><span data-stu-id="b2227-175">If you do not want to supply the optional hit test filter callback function, pass a `null` value as its parameter for the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> method.</span></span>  
  
 [!code-csharp[HitTestingOverview#105](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#105)]
 [!code-vb[HitTestingOverview#105](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#105)]  
  
 <span data-ttu-id="b2227-176">![使用點擊測試篩選剪除視覺化樹狀](./media/filteredvisualtree-01.png "FilteredVisualTree_01")</span><span class="sxs-lookup"><span data-stu-id="b2227-176">![Pruning a visual tree using a hit test filter](./media/filteredvisualtree-01.png "FilteredVisualTree_01")</span></span>  
<span data-ttu-id="b2227-177">剪除視覺化樹狀結構</span><span class="sxs-lookup"><span data-stu-id="b2227-177">Pruning a visual tree</span></span>  
  
 <span data-ttu-id="b2227-178">點擊測試篩選回呼函式可讓您列舉呈現內容中包含指定座標的所有視覺效果。</span><span class="sxs-lookup"><span data-stu-id="b2227-178">The hit test filter callback function allows you to enumerate through all the visuals whose rendered content contains the coordinates you specify.</span></span> <span data-ttu-id="b2227-179">不過，您可能想要忽略點擊測試結果回呼函式中處理時不感興趣的視覺化樹狀結構特定分支。</span><span class="sxs-lookup"><span data-stu-id="b2227-179">However, you may want to ignore certain branches of the visual tree that you are not interested in processing in your hit test results callback function.</span></span> <span data-ttu-id="b2227-180">點擊測試篩選回呼函式的傳回值會決定列舉視覺物件時應採取的動作類型。</span><span class="sxs-lookup"><span data-stu-id="b2227-180">The return value of the hit test filter callback function determines what type of action the enumeration of the visual objects should take.</span></span> <span data-ttu-id="b2227-181">例如，如果傳回值 ，<xref:System.Windows.Media.HitTestFilterBehavior.ContinueSkipSelfAndChildren>則可以從點擊測試結果枚舉中刪除當前可視物件及其子物件。</span><span class="sxs-lookup"><span data-stu-id="b2227-181">For example, if you return the value, <xref:System.Windows.Media.HitTestFilterBehavior.ContinueSkipSelfAndChildren>, you can remove the current visual object and its children from the hit test results enumeration.</span></span> <span data-ttu-id="b2227-182">這表示點擊測試結果回呼函式不會在其列舉中看到這些物件。</span><span class="sxs-lookup"><span data-stu-id="b2227-182">This means that the hit test results callback function will not see these objects in its enumeration.</span></span> <span data-ttu-id="b2227-183">剪除物件的視覺化樹狀結構會減少在點擊測試結果列舉通過期間的處理量。</span><span class="sxs-lookup"><span data-stu-id="b2227-183">Pruning the visual tree of objects decreases the amount of processing during the hit test results enumeration pass.</span></span> <span data-ttu-id="b2227-184">在下列程式碼範例中，篩選會略過標籤和其下階並點擊測試所有其他項目。</span><span class="sxs-lookup"><span data-stu-id="b2227-184">In the following code example, the filter skips labels and their descendants and hit tests everything else.</span></span>  
  
 [!code-csharp[HitTestingOverview#106](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#106)]
 [!code-vb[HitTestingOverview#106](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#106)]  
  
> [!NOTE]
> <span data-ttu-id="b2227-185">有時候會呼叫點擊測試篩選回呼，以免未呼叫點擊測試結果回呼。</span><span class="sxs-lookup"><span data-stu-id="b2227-185">The hit test filter callback will sometimes be called in cases where the hit test results callback is not called.</span></span>  
  
<a name="overriding_default_hit_testing"></a>
## <a name="overriding-default-hit-testing"></a><span data-ttu-id="b2227-186">覆寫預設點擊測試</span><span class="sxs-lookup"><span data-stu-id="b2227-186">Overriding Default Hit Testing</span></span>  
 <span data-ttu-id="b2227-187">您可以通過重寫<xref:System.Windows.Media.Visual.HitTestCore%2A>方法來覆蓋可視物件的預設點擊測試支援。</span><span class="sxs-lookup"><span data-stu-id="b2227-187">You can override a visual object’s default hit testing support by overriding the <xref:System.Windows.Media.Visual.HitTestCore%2A> method.</span></span> <span data-ttu-id="b2227-188">這意味著，當您調用 方法<xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>時，將調用重寫的<xref:System.Windows.Media.Visual.HitTestCore%2A>實現。</span><span class="sxs-lookup"><span data-stu-id="b2227-188">This means that when you invoke the <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A> method, your overridden implementation of <xref:System.Windows.Media.Visual.HitTestCore%2A> is called.</span></span> <span data-ttu-id="b2227-189">即使座標落在視覺物件的呈現內容外部，還是會在點擊測試落在視覺物件的週框內時呼叫覆寫方法。</span><span class="sxs-lookup"><span data-stu-id="b2227-189">Your overridden method is called when a hit test falls within the bounding rectangle of the visual object, even if the coordinate falls outside the rendered content of the visual object.</span></span>  
  
 [!code-csharp[HitTestingOverview#107](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#107)]
 [!code-vb[HitTestingOverview#107](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#107)]  
  
 <span data-ttu-id="b2227-190">有時候您可能想要對週框和視覺物件的呈現內容進行點擊測試。</span><span class="sxs-lookup"><span data-stu-id="b2227-190">There may be times when you want to hit test against both the bounding rectangle and the rendered content of a visual object.</span></span> <span data-ttu-id="b2227-191">通過使用重寫`PointHitTestParameters`<xref:System.Windows.Media.Visual.HitTestCore%2A>方法中的參數值作為基方法<xref:System.Windows.Media.Visual.HitTestCore%2A>的參數，可以基於可視物件邊界矩形的命中執行操作，然後對可視物件的渲染內容執行第二次點擊測試。</span><span class="sxs-lookup"><span data-stu-id="b2227-191">By using the `PointHitTestParameters` parameter value in your overridden <xref:System.Windows.Media.Visual.HitTestCore%2A> method as the parameter to the base method <xref:System.Windows.Media.Visual.HitTestCore%2A>, you can perform actions based on a hit of the bounding rectangle of a visual object, and then perform a second hit test against the rendered content of the visual object.</span></span>  
  
 [!code-csharp[HitTestingOverview#108](~/samples/snippets/csharp/VS_Snippets_Wpf/HitTestingOverview/CSharp/Window1.xaml.cs#108)]
 [!code-vb[HitTestingOverview#108](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HitTestingOverview/visualbasic/window1.xaml.vb#108)]  
  
## <a name="see-also"></a><span data-ttu-id="b2227-192">另請參閱</span><span class="sxs-lookup"><span data-stu-id="b2227-192">See also</span></span>

- <xref:System.Windows.Media.VisualTreeHelper.HitTest%2A>
- <xref:System.Windows.Media.HitTestResult>
- <xref:System.Windows.Media.HitTestResultCallback>
- <xref:System.Windows.Media.HitTestFilterCallback>
- <xref:System.Windows.UIElement.IsHitTestVisible%2A>
- [<span data-ttu-id="b2227-193">使用 DrawingVisuals 範例進行點擊測試</span><span class="sxs-lookup"><span data-stu-id="b2227-193">Hit Test Using DrawingVisuals Sample</span></span>](https://github.com/Microsoft/WPF-Samples/tree/master/Visual%20Layer/DrawingVisual)
- [<span data-ttu-id="b2227-194">使用 Win32 交互操作進行點擊測試範例 (英文)</span><span class="sxs-lookup"><span data-stu-id="b2227-194">Hit Test with Win32 Interoperation Sample</span></span>](https://github.com/microsoft/WPF-Samples/tree/master/Visual%20Layer/VisualsHitTesting)
- [<span data-ttu-id="b2227-195">對 Visual 中的幾何進行點擊測試</span><span class="sxs-lookup"><span data-stu-id="b2227-195">Hit Test Geometry in a Visual</span></span>](how-to-hit-test-geometry-in-a-visual.md)
- [<span data-ttu-id="b2227-196">使用 Win32 裝載容器進行點擊測試</span><span class="sxs-lookup"><span data-stu-id="b2227-196">Hit Test Using a Win32 Host Container</span></span>](how-to-hit-test-using-a-win32-host-container.md)
