---
title: 在 Win32 和 WPF 之間共用訊息迴圈
titleSuffix: ''
ms.date: 03/30/2017
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
ms.openlocfilehash: e1b96284d69645876d3e383beb03a2cc540d8b7b
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/24/2020
ms.locfileid: "76731717"
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="3e1b9-102">在 Win32 和 WPF 之間共用訊息迴圈</span><span class="sxs-lookup"><span data-stu-id="3e1b9-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="3e1b9-103">本主題描述如何使用 <xref:System.Windows.Threading.Dispatcher> 中的現有訊息迴圈公開，或在交互操作程式碼的 Win32 端上建立個別的訊息迴圈，來執行與 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]交互操作的訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the Win32 side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="3e1b9-104">ComponentDispatcher 和訊息迴圈</span><span class="sxs-lookup"><span data-stu-id="3e1b9-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="3e1b9-105">互通和鍵盤事件支援的一般案例是執行 <xref:System.Windows.Interop.IKeyboardInputSink>，或從已經實 <xref:System.Windows.Interop.IKeyboardInputSink>的類別（例如 <xref:System.Windows.Interop.HwndSource> 或 <xref:System.Windows.Interop.HwndHost>）進行子類別化。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="3e1b9-106">不過，鍵盤接收支援無法解決您在相交互操作界限之間傳送和接收訊息時，可能會有的所有可能訊息迴圈需求。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="3e1b9-107">為了協助將應用程式訊息迴圈架構正規化，[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 提供 <xref:System.Windows.Interop.ComponentDispatcher> 類別，它會定義簡單的通訊協定，讓訊息迴圈遵循。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="3e1b9-108"><xref:System.Windows.Interop.ComponentDispatcher> 是公開數個成員的靜態類別。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="3e1b9-109">每個方法的範圍會隱含地系結至呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="3e1b9-110">訊息迴圈必須在關鍵時間呼叫其中一些 Api （如下一節中所定義）。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-110">A message loop must call some of those APIs at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="3e1b9-111"><xref:System.Windows.Interop.ComponentDispatcher> 提供其他元件（例如鍵盤接收）可接聽的事件。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="3e1b9-112"><xref:System.Windows.Threading.Dispatcher> 類別會以適當的順序呼叫所有適當的 <xref:System.Windows.Interop.ComponentDispatcher> 方法。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="3e1b9-113">如果您要執行自己的訊息迴圈，您的程式碼會負責以類似的方式呼叫 <xref:System.Windows.Interop.ComponentDispatcher> 方法。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="3e1b9-114">線上程上呼叫 <xref:System.Windows.Interop.ComponentDispatcher> 方法，只會叫用在該執行緒上註冊的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="3e1b9-115">撰寫訊息迴圈</span><span class="sxs-lookup"><span data-stu-id="3e1b9-115">Writing Message Loops</span></span>  
 <span data-ttu-id="3e1b9-116">以下是您在撰寫自己的訊息迴圈時，將會使用 <xref:System.Windows.Interop.ComponentDispatcher> 成員的檢查清單：</span><span class="sxs-lookup"><span data-stu-id="3e1b9-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
- <span data-ttu-id="3e1b9-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>：您的訊息迴圈應該呼叫這個來表示執行緒是強制回應的。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
- <span data-ttu-id="3e1b9-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>：您的訊息迴圈應該呼叫這個，表示執行緒已還原為 nonmodal。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
- <span data-ttu-id="3e1b9-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>：您的訊息迴圈應該呼叫這個，以指出 <xref:System.Windows.Interop.ComponentDispatcher> 應該引發 <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> 事件。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="3e1b9-120">如果 `true`<xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>，則 <xref:System.Windows.Interop.ComponentDispatcher> 不會引發 <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>，但訊息迴圈可能會選擇呼叫 <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>，即使 <xref:System.Windows.Interop.ComponentDispatcher> 無法在處於強制回應狀態時對其進行回應也一樣。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
- <span data-ttu-id="3e1b9-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>：您的訊息迴圈應該呼叫這個，以指出有新的訊息可供使用。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="3e1b9-122">傳回值會指出 <xref:System.Windows.Interop.ComponentDispatcher> 事件的接聽程式是否處理訊息。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="3e1b9-123">如果 <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> 傳回 `true` （已處理），發送器應該不會再對訊息執行任何動作。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="3e1b9-124">如果傳回值是 `false`，發送器應該會呼叫 Win32 函數 `TranslateMessage`，然後呼叫 `DispatchMessage`。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-124">If the return value is `false`, the dispatcher is expected to call the Win32 function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="3e1b9-125">使用 ComponentDispatcher 和現有的訊息處理</span><span class="sxs-lookup"><span data-stu-id="3e1b9-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="3e1b9-126">以下是當您依賴固有的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 訊息迴圈時，將會使用 <xref:System.Windows.Interop.ComponentDispatcher> 成員的檢查清單。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
- <span data-ttu-id="3e1b9-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>：傳回應用程式是否已通過強制回應（例如已推送強制回應訊息迴圈）。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="3e1b9-128"><xref:System.Windows.Interop.ComponentDispatcher> 可以追蹤這個狀態，因為類別會維護來自訊息迴圈的 <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> 和 <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> 呼叫計數。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
- <span data-ttu-id="3e1b9-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> 和 <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> 事件會遵循委派調用的標準規則。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="3e1b9-130">委派是以未指定的順序叫用，而且即使第一個委派將訊息標示為已處理，也會叫用所有委派。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
- <span data-ttu-id="3e1b9-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>：表示執行閒置處理的適當且有效率的時間（執行緒沒有其他擱置的訊息）。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="3e1b9-132">如果執行緒為強制回應，則不會引發 <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
- <span data-ttu-id="3e1b9-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>：針對訊息抽取處理的所有訊息引發。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
- <span data-ttu-id="3e1b9-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>：針對在 <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>期間未處理的所有訊息引發。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="3e1b9-135">如果在 <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> 事件或 <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> 事件之後，就會將訊息視為已處理，`true`會在事件資料中以傳址方式傳遞的 `handled` 參數。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="3e1b9-136">如果 `handled` `true`，事件處理常式應該忽略訊息，因為這表示不同的處理常式會先處理訊息。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="3e1b9-137">這兩個事件的事件處理常式都可以修改訊息。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="3e1b9-138">發送器應分派已修改的訊息，而不是原始的未變更訊息。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="3e1b9-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> 會傳遞至所有接聽程式，但架構的目的是只包含最上層的視窗，而此 HWND 的目標訊息應叫用程式碼來回應訊息。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="3e1b9-140">HwndSource 如何處理 ComponentDispatcher 事件</span><span class="sxs-lookup"><span data-stu-id="3e1b9-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="3e1b9-141">如果 <xref:System.Windows.Interop.HwndSource> 是最上層視窗（沒有父 HWND），它會向 <xref:System.Windows.Interop.ComponentDispatcher>註冊。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="3e1b9-142">如果引發 <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>，而且訊息適用于 <xref:System.Windows.Interop.HwndSource> 或子視窗，<xref:System.Windows.Interop.HwndSource> 會呼叫其 <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>，<xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>，<xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> 鍵盤接收序列。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="3e1b9-143">如果 <xref:System.Windows.Interop.HwndSource> 不是最上層視窗（具有父系 HWND），則不會處理。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="3e1b9-144">只有最上層的視窗才會進行處理，而且預期在任何交互操作案例中，都必須是最上層的視窗，並具有鍵盤接收支援。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="3e1b9-145">如果在未先呼叫適當的鍵盤接收方法的情況下呼叫 <xref:System.Windows.Interop.HwndSource> 上的 <xref:System.Windows.Interop.HwndHost.WndProc%2A>，您的應用程式將會收到較高層級的鍵盤事件，例如 <xref:System.Windows.UIElement.KeyDown>。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="3e1b9-146">不過，將不會呼叫鍵盤接收方法，這會避開所需的鍵盤輸入模型功能，例如存取金鑰支援。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="3e1b9-147">這可能是因為訊息迴圈未在 <xref:System.Windows.Interop.ComponentDispatcher>上適當地通知相關的執行緒，或父 HWND 並未叫用適當的鍵盤接收回應。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="3e1b9-148">如果您使用 <xref:System.Windows.Interop.HwndSource.AddHook%2A> 方法來新增該訊息的勾點，則傳送至鍵盤接收的訊息可能不會傳送至 HWND。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="3e1b9-149">訊息可能已直接在訊息抽取層級處理，而未提交至 `DispatchMessage` 函數。</span><span class="sxs-lookup"><span data-stu-id="3e1b9-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3e1b9-150">另請參閱</span><span class="sxs-lookup"><span data-stu-id="3e1b9-150">See also</span></span>

- <xref:System.Windows.Interop.ComponentDispatcher>
- <xref:System.Windows.Interop.IKeyboardInputSink>
- [<span data-ttu-id="3e1b9-151">WPF 和 Win32 交互操作</span><span class="sxs-lookup"><span data-stu-id="3e1b9-151">WPF and Win32 Interoperation</span></span>](wpf-and-win32-interoperation.md)
- [<span data-ttu-id="3e1b9-152">執行緒模型</span><span class="sxs-lookup"><span data-stu-id="3e1b9-152">Threading Model</span></span>](threading-model.md)
- [<span data-ttu-id="3e1b9-153">輸入概觀</span><span class="sxs-lookup"><span data-stu-id="3e1b9-153">Input Overview</span></span>](input-overview.md)
