---
title: 在 Win32 和 WPF 之間共用訊息迴圈
ms.date: 03/30/2017
helpviewer_keywords:
- Win32 code [WPF], sharing message loops
- message loops [WPF]
- sharing message loops [WPF]
- interoperability [WPF], Win32
ms.assetid: 39ee888c-e5ec-41c8-b11f-7b851a554442
ms.openlocfilehash: 35a908cc26e6b70c9acd8732521837f2b20eaf5b
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/04/2018
---
# <a name="sharing-message-loops-between-win32-and-wpf"></a><span data-ttu-id="7e9f8-102">在 Win32 和 WPF 之間共用訊息迴圈</span><span class="sxs-lookup"><span data-stu-id="7e9f8-102">Sharing Message Loops Between Win32 and WPF</span></span>
<span data-ttu-id="7e9f8-103">本主題描述如何實作與互通的訊息迴圈[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]，藉由使用現有訊息中的迴圈曝光<xref:System.Windows.Threading.Dispatcher>或藉由建立個別的訊息迴圈上[!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)]這邊的交互操作的程式碼。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-103">This topic describes how to implement a message loop for interoperation with [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], either by using existing message loop exposure in <xref:System.Windows.Threading.Dispatcher> or by creating a separate message loop on the [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] side of your interoperation code.</span></span>  
  
## <a name="componentdispatcher-and-the-message-loop"></a><span data-ttu-id="7e9f8-104">ComponentDispatcher 和訊息迴圈</span><span class="sxs-lookup"><span data-stu-id="7e9f8-104">ComponentDispatcher and the Message Loop</span></span>  
 <span data-ttu-id="7e9f8-105">要實作的互通性和鍵盤事件支援一般案例是<xref:System.Windows.Interop.IKeyboardInputSink>，或從已經實作的類別的子類別化<xref:System.Windows.Interop.IKeyboardInputSink>，例如<xref:System.Windows.Interop.HwndSource>或<xref:System.Windows.Interop.HwndHost>。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-105">A normal scenario for interoperation and keyboard event support is to implement <xref:System.Windows.Interop.IKeyboardInputSink>, or to subclass from classes that already implement <xref:System.Windows.Interop.IKeyboardInputSink>, such as <xref:System.Windows.Interop.HwndSource> or <xref:System.Windows.Interop.HwndHost>.</span></span> <span data-ttu-id="7e9f8-106">不過，鍵盤接收器支援不會處理所有的訊息迴圈需求，您可能必須傳送和接收訊息跨互通界限時。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-106">However, keyboard sink support does not address all possible message loop needs you might have when sending and receiving messages across your interoperation boundaries.</span></span> <span data-ttu-id="7e9f8-107">若要協助擬定應用程式訊息迴圈架構，[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]提供<xref:System.Windows.Interop.ComponentDispatcher>類別，定義訊息迴圈，以遵循簡單的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-107">To help formalize an application message loop architecture, [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] provides the <xref:System.Windows.Interop.ComponentDispatcher> class, which defines a simple protocol for a message loop to follow.</span></span>  
  
 <span data-ttu-id="7e9f8-108"><xref:System.Windows.Interop.ComponentDispatcher> 是靜態類別會公開數個成員。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-108"><xref:System.Windows.Interop.ComponentDispatcher> is a static class that exposes several members.</span></span> <span data-ttu-id="7e9f8-109">每個方法的範圍會隱含地繫結呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-109">The scope of each method is implicitly tied to the calling thread.</span></span> <span data-ttu-id="7e9f8-110">訊息迴圈必須呼叫部分[!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]在關鍵時刻 （如 下一節中所定義）。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-110">A message loop must call some of those [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] at critical times (as defined in the next section).</span></span>  
  
 <span data-ttu-id="7e9f8-111"><xref:System.Windows.Interop.ComponentDispatcher> 提供的其他元件 （例如鍵盤接收器） 可以接聽的事件。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-111"><xref:System.Windows.Interop.ComponentDispatcher> provides events that other components (such as the keyboard sink) can listen for.</span></span> <span data-ttu-id="7e9f8-112"><xref:System.Windows.Threading.Dispatcher>類別會呼叫所有適當<xref:System.Windows.Interop.ComponentDispatcher>中適當的順序的方法。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-112">The <xref:System.Windows.Threading.Dispatcher> class calls all the appropriate <xref:System.Windows.Interop.ComponentDispatcher> methods in an appropriate sequence.</span></span> <span data-ttu-id="7e9f8-113">如果您要實作您自己的訊息迴圈，您的程式碼會負責呼叫<xref:System.Windows.Interop.ComponentDispatcher>方法，以類似的方式。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-113">If you are implementing your own message loop, your code is responsible for calling <xref:System.Windows.Interop.ComponentDispatcher> methods in a similar fashion.</span></span>  
  
 <span data-ttu-id="7e9f8-114">呼叫<xref:System.Windows.Interop.ComponentDispatcher>執行緒上的方法只會叫用該執行緒已註冊的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-114">Calling <xref:System.Windows.Interop.ComponentDispatcher> methods on a thread will only invoke event handlers that were registered on that thread.</span></span>  
  
## <a name="writing-message-loops"></a><span data-ttu-id="7e9f8-115">撰寫訊息迴圈</span><span class="sxs-lookup"><span data-stu-id="7e9f8-115">Writing Message Loops</span></span>  
 <span data-ttu-id="7e9f8-116">下列是檢查清單<xref:System.Windows.Interop.ComponentDispatcher>如果您要撰寫您自己的訊息迴圈，您將使用的成員：</span><span class="sxs-lookup"><span data-stu-id="7e9f8-116">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you write your own message loop:</span></span>  
  
-   <span data-ttu-id="7e9f8-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>： 呼叫這個方法來表示執行緒為強制回應訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-117"><xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>: your message loop should call this to indicate that the thread is modal.</span></span>  
  
-   <span data-ttu-id="7e9f8-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>： 呼叫這個方法來表示執行緒已還原成 nonmodal 訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-118"><xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>:your message loop should call this to indicate that the thread has reverted to nonmodal.</span></span>  
  
-   <span data-ttu-id="7e9f8-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>： 呼叫這個方法，表示訊息迴圈<xref:System.Windows.Interop.ComponentDispatcher>應該引發<xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>事件。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-119"><xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>: your message loop should call this to indicate that <xref:System.Windows.Interop.ComponentDispatcher> should raise the <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> event.</span></span> <span data-ttu-id="7e9f8-120"><xref:System.Windows.Interop.ComponentDispatcher> 將不會引發<xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>如果<xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>是`true`，但呼叫可能會選擇訊息迴圈<xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A>即使<xref:System.Windows.Interop.ComponentDispatcher>它處於強制回應狀態時無法回應。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-120"><xref:System.Windows.Interop.ComponentDispatcher> will not raise <xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> if <xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A> is `true`, but message loops may choose to call <xref:System.Windows.Interop.ComponentDispatcher.RaiseIdle%2A> even if <xref:System.Windows.Interop.ComponentDispatcher> cannot respond to it while in modal state.</span></span>  
  
-   <span data-ttu-id="7e9f8-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>： 呼叫這個方法以指出新的訊息是使用訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-121"><xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>: your message loop should call this to indicate that a new message is available.</span></span> <span data-ttu-id="7e9f8-122">傳回值會指出是否要接聽程式<xref:System.Windows.Interop.ComponentDispatcher>處理訊息的事件。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-122">The return value indicates whether a listener to a <xref:System.Windows.Interop.ComponentDispatcher> event handled the message.</span></span> <span data-ttu-id="7e9f8-123">如果<xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A>傳回`true`（處理），發送器應該執行任何進一步處理訊息。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-123">If <xref:System.Windows.Interop.ComponentDispatcher.RaiseThreadMessage%2A> returns `true` (handled), the dispatcher should do nothing further with the message.</span></span> <span data-ttu-id="7e9f8-124">如果傳回值是`false`，發送器應該如何呼叫[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]函式`TranslateMessage`，然後呼叫`DispatchMessage`。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-124">If the return value is `false`, the dispatcher is expected to call the [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] function `TranslateMessage`, then call `DispatchMessage`.</span></span>  
  
## <a name="using-componentdispatcher-and-existing-message-handling"></a><span data-ttu-id="7e9f8-125">使用 ComponentDispatcher 」 和 「 現有訊息處理</span><span class="sxs-lookup"><span data-stu-id="7e9f8-125">Using ComponentDispatcher and Existing Message Handling</span></span>  
 <span data-ttu-id="7e9f8-126">下列是檢查清單<xref:System.Windows.Interop.ComponentDispatcher>成員，您將使用如果您依賴固有[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-126">The following is a checklist of <xref:System.Windows.Interop.ComponentDispatcher> members you will use if you rely on the inherent [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] message loop.</span></span>  
  
-   <span data-ttu-id="7e9f8-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>： 傳回應用程式是否已進入強制回應 （例如，強制訊息迴圈已排除）。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-127"><xref:System.Windows.Interop.ComponentDispatcher.IsThreadModal%2A>: returns whether the application has gone modal (e.g., a modal message loop has been pushed).</span></span> <span data-ttu-id="7e9f8-128"><xref:System.Windows.Interop.ComponentDispatcher> 可以追蹤此狀態，因為該類別會維護的計數<xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A>和<xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A>於訊息迴圈的呼叫。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-128"><xref:System.Windows.Interop.ComponentDispatcher> can track this state because the class maintains a count of <xref:System.Windows.Interop.ComponentDispatcher.PushModal%2A> and <xref:System.Windows.Interop.ComponentDispatcher.PopModal%2A> calls from the message loop.</span></span>  
  
-   <span data-ttu-id="7e9f8-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> 和<xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>事件遵循標準的規則，以便委派引動過程。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-129"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> and <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> events follow the standard rules for delegate invocations.</span></span> <span data-ttu-id="7e9f8-130">未指定的順序，會叫用委派，即使第一個會將訊息標示為已處理，會叫用所有的委派。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-130">Delegates are invoked in an unspecified order, and all delegates are invoked even if the first one marks the message as handled.</span></span>  
  
-   <span data-ttu-id="7e9f8-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>： 表示適當且有效率的時間，以執行閒置處理 （沒有其他擱置中訊息的執行緒）。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-131"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle>: indicates an appropriate and efficient time to do idle processing (there are no other pending messages for the thread).</span></span> <span data-ttu-id="7e9f8-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> 系統不會引發如果執行緒為強制回應。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-132"><xref:System.Windows.Interop.ComponentDispatcher.ThreadIdle> will not be raised if the thread is modal.</span></span>  
  
-   <span data-ttu-id="7e9f8-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>： 在訊息幫浦內處理的所有訊息時都引發。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-133"><xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>: raised for all messages that the message pump processes.</span></span>  
  
-   <span data-ttu-id="7e9f8-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>： 所有期間未處理的訊息時引發<xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-134"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>: raised for all messages that were not handled during <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>.</span></span>  
  
 <span data-ttu-id="7e9f8-135">訊息會被視為已處理之後如果<xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage>事件或<xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>事件，`handled`事件資料的參考所傳遞的參數是`true`。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-135">A message is considered handled if after the <xref:System.Windows.Interop.ComponentDispatcher.ThreadFilterMessage> event or <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> event, the `handled` parameter passed by reference in event data is `true`.</span></span> <span data-ttu-id="7e9f8-136">如果事件處理常式應忽略該訊息`handled`是`true`，因為這表示不同的處理常式已處理訊息第一次。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-136">Event handlers should ignore the message if `handled` is `true`, because that means the different handler handled the message first.</span></span> <span data-ttu-id="7e9f8-137">這兩個事件的事件處理常式可能會修改訊息。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-137">Event handlers to both events may modify the message.</span></span> <span data-ttu-id="7e9f8-138">發送器應該分派已修改的訊息而不原始未變更的訊息。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-138">The dispatcher should dispatch the modified message and not the original unchanged message.</span></span> <span data-ttu-id="7e9f8-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> 傳遞至所有接聽程式，但是架構設計用意在於只包含的 HWND 的目標訊息應叫用程式碼以回應訊息的最上層視窗。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-139"><xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is delivered to all listeners, but the architectural intention is that only the top-level window containing the HWND at which the messages targeted should invoke code in response to the message.</span></span>  
  
## <a name="how-hwndsource-treats-componentdispatcher-events"></a><span data-ttu-id="7e9f8-140">HwndSource 如何處理 ComponentDispatcher 事件</span><span class="sxs-lookup"><span data-stu-id="7e9f8-140">How HwndSource Treats ComponentDispatcher Events</span></span>  
 <span data-ttu-id="7e9f8-141">如果<xref:System.Windows.Interop.HwndSource>是最上層的視窗 （沒有父代 HWND），它會向<xref:System.Windows.Interop.ComponentDispatcher>。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-141">If the <xref:System.Windows.Interop.HwndSource> is a top-level window (no parent HWND), it will register with <xref:System.Windows.Interop.ComponentDispatcher>.</span></span> <span data-ttu-id="7e9f8-142">如果<xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage>引發時，如果訊息專供<xref:System.Windows.Interop.HwndSource>或子視窗<xref:System.Windows.Interop.HwndSource>呼叫其<xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>， <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>，<xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A>鍵盤接收器的順序。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-142">If <xref:System.Windows.Interop.ComponentDispatcher.ThreadPreprocessMessage> is raised, and if the message is intended for the <xref:System.Windows.Interop.HwndSource> or child windows, <xref:System.Windows.Interop.HwndSource> calls its <xref:System.Windows.Interop.HwndSource.System%23Windows%23Interop%23IKeyboardInputSink%23TranslateAccelerator%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.TranslateChar%2A>, <xref:System.Windows.Interop.IKeyboardInputSink.OnMnemonic%2A> keyboard sink sequence.</span></span>  
  
 <span data-ttu-id="7e9f8-143">如果<xref:System.Windows.Interop.HwndSource>不是最上層視窗 （具有父 HWND），會有任何處理。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-143">If the <xref:System.Windows.Interop.HwndSource> is not a top-level window (has a parent HWND), there will be no handling.</span></span> <span data-ttu-id="7e9f8-144">只有最上層視窗是需要進行處理，但那里預計要做為任何互通性案例的一部分的鍵盤接收器支援的最上層視窗。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-144">Only the top level window is expected to do the handling, and there is expected to be a top level window with keyboard sink support as part of any interoperation scenario.</span></span>  
  
 <span data-ttu-id="7e9f8-145">如果<xref:System.Windows.Interop.HwndHost.WndProc%2A>上<xref:System.Windows.Interop.HwndSource>呼叫沒有先呼叫適當的鍵盤接收器方法，您的應用程式會收到較高的層級的鍵盤事件諸如<xref:System.Windows.UIElement.KeyDown>。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-145">If <xref:System.Windows.Interop.HwndHost.WndProc%2A> on an <xref:System.Windows.Interop.HwndSource> is called without an appropriate keyboard sink method being called first, your application will receive the higher level keyboard events such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="7e9f8-146">不過，沒有任何的鍵盤接收器方法會呼叫，其中規避理想的鍵盤輸入的模型功能，例如存取金鑰的支援。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-146">However, no keyboard sink methods will be called, which circumvents desirable keyboard input model features such as access key support.</span></span> <span data-ttu-id="7e9f8-147">這可能是因為訊息迴圈沒有適當地通知相關的執行緒上<xref:System.Windows.Interop.ComponentDispatcher>，或因為父 HWND 未叫用適當的鍵盤接收器回應。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-147">This might happen because the message loop did not properly notify the relevant thread on the <xref:System.Windows.Interop.ComponentDispatcher>, or because the parent HWND did not invoke the proper keyboard sink responses.</span></span>  
  
 <span data-ttu-id="7e9f8-148">移至的鍵盤接收器的訊息可能不會傳送到 HWND 如果使用加入的訊息勾點<xref:System.Windows.Interop.HwndSource.AddHook%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-148">A message that goes to the keyboard sink might not be sent to the HWND if you added hooks for that message by using the <xref:System.Windows.Interop.HwndSource.AddHook%2A> method.</span></span> <span data-ttu-id="7e9f8-149">訊息可能已經直接而不提交至訊息幫浦層級處理`DispatchMessage`函式。</span><span class="sxs-lookup"><span data-stu-id="7e9f8-149">The message might have been handled at the message pump level directly and not submitted to the `DispatchMessage` function.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="7e9f8-150">另請參閱</span><span class="sxs-lookup"><span data-stu-id="7e9f8-150">See Also</span></span>  
 <xref:System.Windows.Interop.ComponentDispatcher>  
 <xref:System.Windows.Interop.IKeyboardInputSink>  
 [<span data-ttu-id="7e9f8-151">WPF 和 Win32 交互操作</span><span class="sxs-lookup"><span data-stu-id="7e9f8-151">WPF and Win32 Interoperation</span></span>](../../../../docs/framework/wpf/advanced/wpf-and-win32-interoperation.md)  
 [<span data-ttu-id="7e9f8-152">執行緒模型</span><span class="sxs-lookup"><span data-stu-id="7e9f8-152">Threading Model</span></span>](../../../../docs/framework/wpf/advanced/threading-model.md)  
 [<span data-ttu-id="7e9f8-153">輸入概觀</span><span class="sxs-lookup"><span data-stu-id="7e9f8-153">Input Overview</span></span>](../../../../docs/framework/wpf/advanced/input-overview.md)
