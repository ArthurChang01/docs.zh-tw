---
title: Visual Basic 和 WPF 事件處理
ms.date: 03/30/2017
helpviewer_keywords:
- Visual Basic [WPF], event handlers
- event handlers [WPF], Visual Basic
ms.assetid: ad4eb9aa-3afc-4a71-8cf6-add3fbea54a1
ms.openlocfilehash: c6e1863850ebf04408c7ffc7b784e9ca3ca12cf5
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/08/2019
ms.locfileid: "59078014"
---
# <a name="visual-basic-and-wpf-event-handling"></a><span data-ttu-id="28f50-102">Visual Basic 和 WPF 事件處理</span><span class="sxs-lookup"><span data-stu-id="28f50-102">Visual Basic and WPF Event Handling</span></span>
<span data-ttu-id="28f50-103">Microsoft Visual Basic.NET 語言的具體來說，您可以使用語言特有`Handles`關鍵字加入事件處理常式關聯執行個體，而不是附加屬性的事件處理常式，或使用<xref:System.Windows.UIElement.AddHandler%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="28f50-103">For the Microsoft Visual Basic .NET language specifically, you can use the language-specific `Handles` keyword to associate event handlers with instances, instead of attaching event handlers with attributes or using the <xref:System.Windows.UIElement.AddHandler%2A> method.</span></span> <span data-ttu-id="28f50-104">不過，將處理常式附加至執行個體的 `Handles` 技術有一些限制，因為 `Handles` 語法無法支援 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 事件系統中某些特定的路由事件功能。</span><span class="sxs-lookup"><span data-stu-id="28f50-104">However, the `Handles` technique for attaching handlers to instances does have some limitations, because the `Handles` syntax cannot support some of the specific routed event features of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span>  
  
## <a name="using-handles-in-a-wpf-application"></a><span data-ttu-id="28f50-105">在 WPF 應用程式中使用「Handles」</span><span class="sxs-lookup"><span data-stu-id="28f50-105">Using "Handles" in a WPF Application</span></span>  
 <span data-ttu-id="28f50-106">使用 `Handles` 連線到執行個體和事件的事件處理常式全需定義於執行個體的部分類別宣告中，這也是透過元素上的屬性值所指派之事件處理常式的需求。</span><span class="sxs-lookup"><span data-stu-id="28f50-106">The event handlers that are connected to instances and events with `Handles` must all be defined within the partial class declaration of the instance, which is also a requirement for event handlers that are assigned through attribute values on elements.</span></span> <span data-ttu-id="28f50-107">您只能指定`Handles`頁面上所擁有的項目<xref:System.Windows.FrameworkContentElement.Name%2A>屬性值 (或[X:name 指示詞](../../xaml-services/x-name-directive.md)宣告)。</span><span class="sxs-lookup"><span data-stu-id="28f50-107">You can only specify `Handles` for an element on the page that has a <xref:System.Windows.FrameworkContentElement.Name%2A> property value (or [x:Name Directive](../../xaml-services/x-name-directive.md) declared).</span></span> <span data-ttu-id="28f50-108">這是因為<xref:System.Windows.FrameworkContentElement.Name%2A>中[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]建立，才能支援執行個體參考*Instance.Event*所需的參考格式`Handles`語法。</span><span class="sxs-lookup"><span data-stu-id="28f50-108">This is because the <xref:System.Windows.FrameworkContentElement.Name%2A> in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] creates the instance reference that is necessary to support the *Instance.Event* reference format required by the `Handles` syntax.</span></span> <span data-ttu-id="28f50-109">可用於唯一項目`Handles`而不需要<xref:System.Windows.FrameworkContentElement.Name%2A>參考是定義部分類別的根項目執行個體。</span><span class="sxs-lookup"><span data-stu-id="28f50-109">The only element that can be used for `Handles` without a <xref:System.Windows.FrameworkContentElement.Name%2A> reference is the root-element instance that defines the partial class.</span></span>  
  
 <span data-ttu-id="28f50-110">您可以將相同的處理常式指派給多個元素，方法是在 `Handles` 之後使用逗號來隔開 Instance.Event 參考。</span><span class="sxs-lookup"><span data-stu-id="28f50-110">You can assign the same handler to multiple elements by separating *Instance.Event* references after `Handles` with commas.</span></span>  
  
 <span data-ttu-id="28f50-111">您可以使用 `Handles`，將多個處理常式指派給同一個 Instance.Event 參考。</span><span class="sxs-lookup"><span data-stu-id="28f50-111">You can use `Handles` to assign more than one handler to the same *Instance.Event*reference.</span></span> <span data-ttu-id="28f50-112">不要為 `Handles` 參考中指定處理常式的順序指派任何重要性；您應該假設可以任何順序叫用處理同一個事件的處理常式。</span><span class="sxs-lookup"><span data-stu-id="28f50-112">Do not assign any importance to the order in which handlers are given in the `Handles` reference; you should assume that handlers that handle the same event can be invoked in any order.</span></span>  
  
 <span data-ttu-id="28f50-113">若要移除已加入的處理常式`Handles`在宣告中，您可以呼叫<xref:System.Windows.UIElement.RemoveHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="28f50-113">To remove a handler that was added with `Handles` in the declaration, you can call <xref:System.Windows.UIElement.RemoveHandler%2A>.</span></span>  
  
 <span data-ttu-id="28f50-114">您可以使用 `Handles` 來附加路由事件的處理常式，只要您將處理常式附加至會在其成員資料表中定義要處理事件的執行個體。</span><span class="sxs-lookup"><span data-stu-id="28f50-114">You can use `Handles` to attach handlers for routed events, so long as you attach handlers to instances that define the event being handled in their members tables.</span></span> <span data-ttu-id="28f50-115">針對路由事件，以附加處理常式`Handles`做為附加處理常式一樣，遵循相同的路由規則[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]屬性，或使用的常見簽章<xref:System.Windows.UIElement.AddHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="28f50-115">For routed events, handlers that are attached with `Handles` follow the same routing rules as do handlers that are attached as [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] attributes, or with the common signature of <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="28f50-116">這表示，如果事件標示為已處理 (<xref:System.Windows.RoutedEventArgs.Handled%2A>事件資料中的屬性是`True`)，則處理常式附加`Handles`不會叫用該事件執行個體的回應。</span><span class="sxs-lookup"><span data-stu-id="28f50-116">This means that if the event is already marked handled (the <xref:System.Windows.RoutedEventArgs.Handled%2A> property in the event data is `True`), then handlers attached with `Handles` are not invoked in response to that event instance.</span></span> <span data-ttu-id="28f50-117">事件可能是透過路由中另一個元素上的執行個體處理常式標示為已處理，或是透過路由上目前元素或先前元素上所處理的類別來標示。</span><span class="sxs-lookup"><span data-stu-id="28f50-117">The event could be marked handled by instance handlers on another element in the route, or by class handling either on the current element or earlier elements along the route.</span></span> <span data-ttu-id="28f50-118">對於支援配對的通道/事件反昇事件的輸入事件，通道路由可能已將事件配對標示已處理。</span><span class="sxs-lookup"><span data-stu-id="28f50-118">For input events that support paired tunnel/bubble events, the tunneling route may have marked the event pair handled.</span></span> <span data-ttu-id="28f50-119">如需路由事件的詳細資訊，請參閱[路由事件概觀](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="28f50-119">For more information about routed events, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
## <a name="limitations-of-handles-for-adding-handlers"></a><span data-ttu-id="28f50-120">加入處理常式的「Handles」限制</span><span class="sxs-lookup"><span data-stu-id="28f50-120">Limitations of "Handles" for Adding Handlers</span></span>  
 `Handles` <span data-ttu-id="28f50-121">不能參考附加事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="28f50-121">cannot reference handlers for attached events.</span></span> <span data-ttu-id="28f50-122">您必須針對該附加事件使用 `add` 存取子方法，或 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中的 typename.eventname 事件屬性。</span><span class="sxs-lookup"><span data-stu-id="28f50-122">You must use the `add` accessor method for that attached event, or *typename.eventname* event attributes in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="28f50-123">如需詳細資訊，請參閱[路由事件概觀](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="28f50-123">For details, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="28f50-124">針對路由事件，您只能使用 `Handles` 來指派執行個體的處理常式，該事件存在於執行個體成員資料表中。</span><span class="sxs-lookup"><span data-stu-id="28f50-124">For routed events, you can only use `Handles` to assign handlers for instances where that event exists in the instance members table.</span></span> <span data-ttu-id="28f50-125">不過，透過路由事件，父元素通常可以是來自子元素之事件的接聽程式，即使父元素的成員資料表中沒有該事件也一樣。</span><span class="sxs-lookup"><span data-stu-id="28f50-125">However, with routed events in general, a parent element can be a listener for an event from child elements, even if the parent element does not have that event in its members table.</span></span> <span data-ttu-id="28f50-126">在屬性語法中，您可以透過 typename.membername 屬性格式來指定此動作，此格式會限定哪種類型實際上會定義您想要處理的事件。</span><span class="sxs-lookup"><span data-stu-id="28f50-126">In attribute syntax, you can specify this through a *typename.membername* attribute form that qualifies which type actually defines the event you want to handle.</span></span> <span data-ttu-id="28f50-127">比方說，父代`Page`(含`Click`定義的事件) 可以接聽按鈕 click 事件表單中的屬性處理常式，指派`Button.Click`。</span><span class="sxs-lookup"><span data-stu-id="28f50-127">For instance, a parent `Page` (with no `Click` event defined) can listen for button-click events by assigning an attribute handler in the form `Button.Click`.</span></span> <span data-ttu-id="28f50-128">但是 `Handles` 不支援 typename.membername 格式，因為它必須支援衝突的 Instance.Event 格式。</span><span class="sxs-lookup"><span data-stu-id="28f50-128">But `Handles` does not support the *typename.membername* form, because it must support a conflicting *Instance.Event* form.</span></span> <span data-ttu-id="28f50-129">如需詳細資訊，請參閱[路由事件概觀](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="28f50-129">For details, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 `Handles` <span data-ttu-id="28f50-130">無法附加叫用的已標記為已處理的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="28f50-130">cannot attach handlers that are invoked for events that are already marked handled.</span></span> <span data-ttu-id="28f50-131">相反地，您必須使用程式碼並呼叫`handledEventsToo`多載<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>。</span><span class="sxs-lookup"><span data-stu-id="28f50-131">Instead, you must use code and call the `handledEventsToo` overload of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28f50-132">請勿使用`Handles`Visual Basic 程式碼，當您在 XAML 中指定的相同事件的事件處理常式的語法。</span><span class="sxs-lookup"><span data-stu-id="28f50-132">Do not use the `Handles` syntax in Visual Basic code when you specify an event handler for the same event in XAML.</span></span> <span data-ttu-id="28f50-133">在這個情況下，會呼叫事件處理常式兩次。</span><span class="sxs-lookup"><span data-stu-id="28f50-133">In this case, the event handler is called twice.</span></span>  
  
## <a name="how-wpf-implements-handles-functionality"></a><span data-ttu-id="28f50-134">WPF 如何實作「Handles」功能</span><span class="sxs-lookup"><span data-stu-id="28f50-134">How WPF Implements "Handles" Functionality</span></span>  
 <span data-ttu-id="28f50-135">當[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]編譯頁面時，中繼檔案會宣告`Friend``WithEvents`頁面，其中包含每個項目參考<xref:System.Windows.FrameworkContentElement.Name%2A>屬性集 (或[X:name 指示詞](../../xaml-services/x-name-directive.md)宣告)。</span><span class="sxs-lookup"><span data-stu-id="28f50-135">When a [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] page is compiled, the intermediate file declares `Friend` `WithEvents` references to every element on the page that has a <xref:System.Windows.FrameworkContentElement.Name%2A> property set (or [x:Name Directive](../../xaml-services/x-name-directive.md) declared).</span></span> <span data-ttu-id="28f50-136">每個具名執行個體可能都是可透過 `Handles` 指派給處理常式的元素。</span><span class="sxs-lookup"><span data-stu-id="28f50-136">Each named instance is potentially an element that can be assigned to a handler through `Handles`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="28f50-137">在 [!INCLUDE[TLA#tla_visualstu](../../../../includes/tlasharptla-visualstu-md.md)] 內，[!INCLUDE[TLA2#tla_intellisense](../../../../includes/tla2sharptla-intellisense-md.md)] 可以顯示您已完成讓元素可供頁面中的 `Handles` 參考使用。</span><span class="sxs-lookup"><span data-stu-id="28f50-137">Within [!INCLUDE[TLA#tla_visualstu](../../../../includes/tlasharptla-visualstu-md.md)], [!INCLUDE[TLA2#tla_intellisense](../../../../includes/tla2sharptla-intellisense-md.md)] can show you completion for which elements are available for a `Handles` reference in a page.</span></span> <span data-ttu-id="28f50-138">不過，這可能需要採取一次編譯傳遞，讓中繼檔案可以填入所有的 `Friends` 參考。</span><span class="sxs-lookup"><span data-stu-id="28f50-138">However, this might take one compile pass so that the intermediate file can populate all the `Friends` references.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="28f50-139">另請參閱</span><span class="sxs-lookup"><span data-stu-id="28f50-139">See also</span></span>

- <xref:System.Windows.UIElement.AddHandler%2A>
- [<span data-ttu-id="28f50-140">將路由事件標記為已處理以及類別處理</span><span class="sxs-lookup"><span data-stu-id="28f50-140">Marking Routed Events as Handled, and Class Handling</span></span>](marking-routed-events-as-handled-and-class-handling.md)
- [<span data-ttu-id="28f50-141">路由事件概觀</span><span class="sxs-lookup"><span data-stu-id="28f50-141">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="28f50-142">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="28f50-142">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
