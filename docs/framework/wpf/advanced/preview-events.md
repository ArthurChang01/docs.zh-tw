---
title: 預覽事件
ms.date: 03/30/2017
helpviewer_keywords:
- Preview events [WPF]
- suppressing events [WPF]
- events [WPF], Preview
- events [WPF], suppressing
ms.assetid: b5032308-aa9c-4d02-af11-630ecec8df7e
ms.openlocfilehash: cebf5123ab6cdfff58a2e6a483af63f4215f8de2
ms.sourcegitcommit: facefcacd7ae2e5645e463bc841df213c505ffd4
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/05/2019
ms.locfileid: "55739523"
---
# <a name="preview-events"></a><span data-ttu-id="4b99a-102">預覽事件</span><span class="sxs-lookup"><span data-stu-id="4b99a-102">Preview Events</span></span>
<span data-ttu-id="4b99a-103">預覽事件，也就是通道事件，都是路由的事件的路由方向會從應用程式根目錄來引發事件，並報告為事件資料來源的項目傳送的位置。</span><span class="sxs-lookup"><span data-stu-id="4b99a-103">Preview events, also known as tunneling events, are routed events where the direction of the route travels from the application root towards the element that raised the event and is reported as the source in event data.</span></span> <span data-ttu-id="4b99a-104">並非所有的事件案例支援，或需要預覽事件;本主題描述的情況下，預覽事件存在，應用程式或元件應如何處理它們和建立自訂元件或類別中的預覽事件，可能適合的情況。</span><span class="sxs-lookup"><span data-stu-id="4b99a-104">Not all event scenarios support or require preview events; this topic describes the situations where preview events exist, how applications or components should handle them, and cases where creating preview events in custom components or classes might be appropriate.</span></span>  
  
## <a name="preview-events-and-input"></a><span data-ttu-id="4b99a-105">預覽事件和輸入</span><span class="sxs-lookup"><span data-stu-id="4b99a-105">Preview Events and Input</span></span>  
 <span data-ttu-id="4b99a-106">當您處理一般情況下，事件會謹慎的預覽將事件標記事件中處理資料。</span><span class="sxs-lookup"><span data-stu-id="4b99a-106">When you handle Preview events in general, be cautious about marking the events handled in the event data.</span></span> <span data-ttu-id="4b99a-107">以外的其他處理任何項目上的 Preview 事件引發 （報告為中的事件資料的來源項目） 的項目效果的機會先處理它所產生的事件時未提供項目。</span><span class="sxs-lookup"><span data-stu-id="4b99a-107">Handling a Preview event on any element other than the element that raised it (the element that is reported as the source in the event data) has the effect of not providing an element the opportunity to handle the event that it originated.</span></span> <span data-ttu-id="4b99a-108">有時候這是所要的結果，尤其是有問題的項目存在於控制項的複合關聯性。</span><span class="sxs-lookup"><span data-stu-id="4b99a-108">Sometimes this is the desired result, particularly if the elements in question exist in relationships within the compositing of a control.</span></span>  
  
 <span data-ttu-id="4b99a-109">輸入事件具體而言，預覽事件也共用事件資料執行個體與對等的事件反昇事件。</span><span class="sxs-lookup"><span data-stu-id="4b99a-109">For input events specifically, Preview events also share event data instances with the equivalent bubbling event.</span></span> <span data-ttu-id="4b99a-110">如果您使用預覽事件的類別處理常式來處理輸入的事件標記時，不會叫用事件反昇輸入的事件類別處理常式。</span><span class="sxs-lookup"><span data-stu-id="4b99a-110">If you use a Preview event class handler to mark the input event handled, the bubbling input event class handler will not be invoked.</span></span> <span data-ttu-id="4b99a-111">或者，如果您使用的預覽事件執行個體處理常式標記處理的事件，事件反昇事件的處理常式將會不通常會叫用。</span><span class="sxs-lookup"><span data-stu-id="4b99a-111">Or, if you use a Preview event instance handler to mark the event handled, handlers for the bubbling event will not typically be invoked.</span></span> <span data-ttu-id="4b99a-112">可以註冊類別處理常式或執行個體處理常式，或附加要叫用即使事件已標示為已處理，但該技術不常使用的選項。</span><span class="sxs-lookup"><span data-stu-id="4b99a-112">Class handlers or instance handlers can be registered or attached with an option to be invoked even if the event is marked handled, but that technique is not commonly used.</span></span>  
  
 <span data-ttu-id="4b99a-113">如需類別處理，以及它如何與預覽事件相關聯的詳細資訊，請參閱[路由事件標記為已處理以及類別處理](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="4b99a-113">For more information about class handling and how it relates to Preview events see [Marking Routed Events as Handled, and Class Handling](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="4b99a-114">處理控制項的事件隱藏項目</span><span class="sxs-lookup"><span data-stu-id="4b99a-114">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="4b99a-115">通常用預覽事件的一個案例是複合控制項的輸入事件的處理。</span><span class="sxs-lookup"><span data-stu-id="4b99a-115">One scenario where Preview events are commonly used is for composited control handling of input events.</span></span> <span data-ttu-id="4b99a-116">有時候，控制項作者隱藏特定事件來自從其控制，或許是為了替換成元件定義的事件，提供詳細資訊，或更具體的行為。</span><span class="sxs-lookup"><span data-stu-id="4b99a-116">Sometimes, the author of the control suppresses a certain event from originating from their control, perhaps in order to substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="4b99a-117">比方說， [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button>隱藏<xref:System.Windows.UIElement.MouseLeftButtonDown>並<xref:System.Windows.UIElement.MouseRightButtonDown>所引發的事件反昇事件<xref:System.Windows.Controls.Button>或複合項目以擷取滑鼠並引發<xref:System.Windows.Controls.Primitives.ButtonBase.Click>一律由所引發的事件<xref:System.Windows.Controls.Button>本身。</span><span class="sxs-lookup"><span data-stu-id="4b99a-117">For instance, a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseRightButtonDown> bubbling events raised by the <xref:System.Windows.Controls.Button> or its composite elements in favor of capturing the mouse and raising a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event that is always raised by the <xref:System.Windows.Controls.Button> itself.</span></span> <span data-ttu-id="4b99a-118">事件和其資料還是會繼續在路由中，但是由於<xref:System.Windows.Controls.Button>將做為事件資料標示<xref:System.Windows.RoutedEventArgs.Handled%2A>，特別指出應中之事件的處理常式`handledEventsToo`案例會叫用。</span><span class="sxs-lookup"><span data-stu-id="4b99a-118">The event and its data still continue along the route, but because the <xref:System.Windows.Controls.Button> marks the event data as <xref:System.Windows.RoutedEventArgs.Handled%2A>, only handlers for the event that specifically indicated they should act in the `handledEventsToo` case  are invoked.</span></span>  <span data-ttu-id="4b99a-119">針對您的應用程式的根目錄的其他項目仍然希望機會先處理控制隱藏的事件，有一個替代方法是附加的程式碼中的處理常式`handledEventsToo`指定為`true`。</span><span class="sxs-lookup"><span data-stu-id="4b99a-119">If other elements towards the root of your application still wanted an opportunity to handle a control-suppressed event, one alternative is to attach handlers in code with `handledEventsToo` specified as `true`.</span></span> <span data-ttu-id="4b99a-120">但通常較簡單的技術就是變更路由的方向，您可預覽對等的輸入事件的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="4b99a-120">But often a simpler technique is to change the routing direction you handle to be the Preview equivalent of an input event.</span></span> <span data-ttu-id="4b99a-121">比方說，如果控制項隱藏<xref:System.Windows.UIElement.MouseLeftButtonDown>，嘗試附加的處理常式<xref:System.Windows.UIElement.PreviewMouseLeftButtonDown>改。</span><span class="sxs-lookup"><span data-stu-id="4b99a-121">For instance, if a control suppresses <xref:System.Windows.UIElement.MouseLeftButtonDown>, try attaching a handler for <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> instead.</span></span> <span data-ttu-id="4b99a-122">這項技術僅適用於基底項目輸入事件這類<xref:System.Windows.UIElement.MouseLeftButtonDown>。</span><span class="sxs-lookup"><span data-stu-id="4b99a-122">This technique only works for base element input events such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="4b99a-123">這些輸入的事件使用通道/事件反昇組、 引發這兩個事件，並共用事件資料。</span><span class="sxs-lookup"><span data-stu-id="4b99a-123">These input events use tunnel/bubble pairs, raise both events, and share the event data.</span></span>  
  
 <span data-ttu-id="4b99a-124">每一種方法有副作用或限制。</span><span class="sxs-lookup"><span data-stu-id="4b99a-124">Each of these techniques has either side effects or limitations.</span></span> <span data-ttu-id="4b99a-125">處理將預覽事件的副作用是處理事件，此時可能會停用來處理事件反昇事件，預期的處理常式，因此其限制是，它通常不是個不錯的主意，處理而仍在 Previ 將事件標記路由的新功能組件。</span><span class="sxs-lookup"><span data-stu-id="4b99a-125">The side effect of handling the Preview event is that handling the event at that point might disable handlers that expect to handle the bubbling event, and therefore the limitation is that it is usually not a good idea to mark the event handled while it is still on the Preview part of the route.</span></span> <span data-ttu-id="4b99a-126">限制`handledEventsToo`技巧是，您無法指定`handledEventsToo`中的處理常式[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]做為屬性，您必須註冊事件處理常式程式碼中取得要附加的處理常式的所在的物件參考的項目之後。</span><span class="sxs-lookup"><span data-stu-id="4b99a-126">The limitation of the `handledEventsToo` technique is that you cannot specify a `handledEventsToo` handler in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] as an attribute, you must register the event handler in code after obtaining an object reference to the element where the handler is to be attached.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4b99a-127">另請參閱</span><span class="sxs-lookup"><span data-stu-id="4b99a-127">See also</span></span>
- [<span data-ttu-id="4b99a-128">將路由事件標記為已處理以及類別處理</span><span class="sxs-lookup"><span data-stu-id="4b99a-128">Marking Routed Events as Handled, and Class Handling</span></span>](../../../../docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)
- [<span data-ttu-id="4b99a-129">路由事件概觀</span><span class="sxs-lookup"><span data-stu-id="4b99a-129">Routed Events Overview</span></span>](../../../../docs/framework/wpf/advanced/routed-events-overview.md)
