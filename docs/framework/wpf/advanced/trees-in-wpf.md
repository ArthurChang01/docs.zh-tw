---
title: 樹木
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: 696772da1ebee405493f2ff0e1481daf93d08ec7
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187025"
---
# <a name="trees-in-wpf"></a><span data-ttu-id="3b29c-102">WPF 中的樹狀結構</span><span class="sxs-lookup"><span data-stu-id="3b29c-102">Trees in WPF</span></span>
<span data-ttu-id="3b29c-103">在許多技術中，元素和元件都會組織成樹狀結構，開發人員可直接管理樹狀結構中的物件節點來影響應用程式的轉譯或行為。</span><span class="sxs-lookup"><span data-stu-id="3b29c-103">In many technologies, elements and components are organized in a tree structure where developers directly manipulate the object nodes in the tree to affect the rendering or behavior of an application.</span></span> [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <span data-ttu-id="3b29c-104">也會使用數個樹狀結構比喻來定義程式元素之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="3b29c-104">also uses several tree structure metaphors to define relationships between program elements.</span></span> <span data-ttu-id="3b29c-105">在大部分情形下，WPF 開發人員在概念上思考物件樹狀結構比喻時，可以使用程式碼建立應用程式或使用 XAML 定義應用程式的部分，但將會呼叫特定的 API 或使用特定標記來進行這些作業，而不是使用某些一般的物件樹狀結構管理 API，就像您可能在 XML DOM 中使用的方式。</span><span class="sxs-lookup"><span data-stu-id="3b29c-105">For the most part WPF developers can create an application in code or define portions of the application in XAML while thinking conceptually about the object tree metaphor, but will be calling specific API or using specific markup to do so rather than some general object tree manipulation API such as you might use in XML DOM.</span></span> <span data-ttu-id="3b29c-106">WPF 公開兩個提供樹隱喻視圖的説明器類，<xref:System.Windows.LogicalTreeHelper>和<xref:System.Windows.Media.VisualTreeHelper>。</span><span class="sxs-lookup"><span data-stu-id="3b29c-106">WPF exposes two helper classes that provide a tree metaphor view, <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>.</span></span> <span data-ttu-id="3b29c-107">WPF 文件中也會使用視覺化樹狀結構和邏輯樹狀結構等詞彙，因為這些相同的樹狀結構在了解某些主要的 WPF 功能時非常好用。</span><span class="sxs-lookup"><span data-stu-id="3b29c-107">The terms visual tree and logical tree are also used in the WPF documentation because these same trees are useful for understanding the behavior of certain key WPF features.</span></span> <span data-ttu-id="3b29c-108">本主題定義視覺化樹和邏輯樹代表的內容，討論此類樹與整體物件樹概念的關係，並介紹<xref:System.Windows.LogicalTreeHelper>和。 <xref:System.Windows.Media.VisualTreeHelper></span><span class="sxs-lookup"><span data-stu-id="3b29c-108">This topic defines what the visual tree and logical tree represent, discusses how such trees relate to an overall object tree concept, and introduces <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>s.</span></span>  

<a name="element_tree"></a>
## <a name="trees-in-wpf"></a><span data-ttu-id="3b29c-109">WPF 中的樹狀結構</span><span class="sxs-lookup"><span data-stu-id="3b29c-109">Trees in WPF</span></span>  
 <span data-ttu-id="3b29c-110">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中最完整的樹狀結構就是物件樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="3b29c-110">The most complete tree structure in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the object tree.</span></span> <span data-ttu-id="3b29c-111">如果您以 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 定義應用程式頁面，然後載入 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]，則會依據標記中元素的巢狀關聯性來建立樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="3b29c-111">If you define an application page in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and then load the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], the tree structure is created based on the nesting relationships of the elements in the markup.</span></span> <span data-ttu-id="3b29c-112">如果您利用程式碼定義應用程式或應用程式的一部分，則會依據下列方式來建立樹狀結構：您如何針對用於實作指定物件之內容模型的屬性指派屬性值。</span><span class="sxs-lookup"><span data-stu-id="3b29c-112">If you define an application or a portion of the application in code, then the tree structure is created based on how you assign property values for properties that implement the content model for a given object.</span></span> <span data-ttu-id="3b29c-113">在 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中，將完整的物件樹狀結構概念化並可回報給其公用 API 的方式有兩種：當做邏輯樹狀結構，以及當做視覺化樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="3b29c-113">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], there are two ways that the complete object tree is conceptualized and can be reported to its public API: as the logical tree and as the visual tree.</span></span> <span data-ttu-id="3b29c-114">邏輯樹狀結構與視覺化樹狀結構之間的差異不一定很重要，但有時可能會導致某些 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 子系統發生問題，並影響您對於使用標記或程式碼的選擇。</span><span class="sxs-lookup"><span data-stu-id="3b29c-114">The distinctions between logical tree and visual tree are not always necessarily important, but they can occasionally cause issues with certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] subsystems and affect choices you make in markup or code.</span></span>  
  
 <span data-ttu-id="3b29c-115">即使您不一定會直接管理邏輯樹狀結構或視覺化樹狀結構，但了解這些樹狀結構的互動方式，將有助於對 WPF 這種技術的認識。</span><span class="sxs-lookup"><span data-stu-id="3b29c-115">Even though you do not always manipulate either the logical tree or the visual tree directly, understanding the concepts of how the trees interact is useful for understanding WPF as a technology.</span></span> <span data-ttu-id="3b29c-116">將 WPF 比喻為某種樹狀結構，對於了解 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中屬性繼承和事件路由的運作方式也很重要。</span><span class="sxs-lookup"><span data-stu-id="3b29c-116">Thinking of WPF as a tree metaphor of some kind is also crucial to understanding how property inheritance and event routing work in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3b29c-117">因為物件樹狀結構比較接近是個概念而非實際的 API，所以另一種想像這個概念的方式是當成物件圖形。</span><span class="sxs-lookup"><span data-stu-id="3b29c-117">Because the object tree is more of a concept than an actual API, another way to think of the concept is as an object graph.</span></span> <span data-ttu-id="3b29c-118">實際上，物件之間的關聯性在執行階段，可能會讓樹狀結構比喻失效。</span><span class="sxs-lookup"><span data-stu-id="3b29c-118">In practice, there are relationships between objects at run time where the tree metaphor will break down.</span></span> <span data-ttu-id="3b29c-119">不過，特別是對以 XAML 定義的 UI 而言，樹狀結構比喻仍算是恰當，因此大部分的 WPF 文件在提及這個一般概念時，將會使用物件樹狀結構一詞。</span><span class="sxs-lookup"><span data-stu-id="3b29c-119">Nevertheless, particularly with XAML-defined UI, the tree metaphor is relevant enough that most WPF documentation will use the term object tree when referencing this general concept.</span></span>  
  
<a name="logical_tree"></a>
## <a name="the-logical-tree"></a><span data-ttu-id="3b29c-120">邏輯樹狀結構</span><span class="sxs-lookup"><span data-stu-id="3b29c-120">The Logical Tree</span></span>  
 <span data-ttu-id="3b29c-121">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，您要將內容加入至 UI 元素，方法則是為支援這些元素的物件設定屬性。</span><span class="sxs-lookup"><span data-stu-id="3b29c-121">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], you add content to UI elements by setting properties of the objects that back those elements.</span></span> <span data-ttu-id="3b29c-122">例如，通過操作控制項<xref:System.Windows.Controls.ListBox><xref:System.Windows.Controls.ItemsControl.Items%2A>的屬性將項添加到控制項。</span><span class="sxs-lookup"><span data-stu-id="3b29c-122">For example, you add items to a <xref:System.Windows.Controls.ListBox> control by manipulating its <xref:System.Windows.Controls.ItemsControl.Items%2A> property.</span></span> <span data-ttu-id="3b29c-123">通過執行此操作，您將項放入屬性值<xref:System.Windows.Controls.ItemCollection>。 <xref:System.Windows.Controls.ItemsControl.Items%2A></span><span class="sxs-lookup"><span data-stu-id="3b29c-123">By doing this, you are placing items into the <xref:System.Windows.Controls.ItemCollection> that is the <xref:System.Windows.Controls.ItemsControl.Items%2A> property value.</span></span> <span data-ttu-id="3b29c-124">同樣，要向 中添加<xref:System.Windows.Controls.DockPanel>物件，可以操作<xref:System.Windows.Controls.Panel.Children%2A>其屬性值。</span><span class="sxs-lookup"><span data-stu-id="3b29c-124">Similarly, to add objects to a <xref:System.Windows.Controls.DockPanel>, you manipulate its <xref:System.Windows.Controls.Panel.Children%2A> property value.</span></span> <span data-ttu-id="3b29c-125">在這裡，您將物件添加到 。 <xref:System.Windows.Controls.UIElementCollection></span><span class="sxs-lookup"><span data-stu-id="3b29c-125">Here, you are adding objects to the <xref:System.Windows.Controls.UIElementCollection>.</span></span> <span data-ttu-id="3b29c-126">有關代碼示例，請參閱[如何：動態添加元素](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100))。</span><span class="sxs-lookup"><span data-stu-id="3b29c-126">For a code example, see [How to: Add an Element Dynamically](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ms752374(v=vs.100)).</span></span>  
  
 <span data-ttu-id="3b29c-127">在[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]<xref:System.Windows.Controls.ListBox>中，在 或 控制項或其他 UI 元素中<xref:System.Windows.Controls.DockPanel>放置清單項時，也會顯式<xref:System.Windows.Controls.ItemsControl.Items%2A>或<xref:System.Windows.Controls.Panel.Children%2A>隱式使用 和 屬性，如以下示例所示。</span><span class="sxs-lookup"><span data-stu-id="3b29c-127">In [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], when you place list items in a <xref:System.Windows.Controls.ListBox> or controls or other UI elements in a <xref:System.Windows.Controls.DockPanel>, you also use the <xref:System.Windows.Controls.ItemsControl.Items%2A> and <xref:System.Windows.Controls.Panel.Children%2A> properties, either explicitly or implicitly, as in the following example.</span></span>  
  
 [!code-xaml[TreeOvwsSupport#AllCode](~/samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 <span data-ttu-id="3b29c-128">如果您原本要處理這個 XAML 做為文件物件模型下的 XML，而且已包含註解化為隱含的標記 (這應該已合法)，則產生的 XML DOM 樹狀結構應該已包含 `<ListBox.Items>` 的元素及其他隱含項目。</span><span class="sxs-lookup"><span data-stu-id="3b29c-128">If you were to process this XAML as XML under a document object model, and if you had included the tags commented out as implicit (which would have been legal), then the resulting XML DOM tree would have included elements for `<ListBox.Items>` and the other implicit items.</span></span> <span data-ttu-id="3b29c-129">但是當您讀取標記並寫入至物件時，XAML 不會以該方式處理，因此，產生的物件圖形實際上不會包含 `ListBox.Items`。</span><span class="sxs-lookup"><span data-stu-id="3b29c-129">But XAML does not process that way when you read the markup and write to objects, the resulting object graph does not literally include `ListBox.Items`.</span></span> <span data-ttu-id="3b29c-130">但是，它確實有一<xref:System.Windows.Controls.ListBox>個屬性`Items`，該屬性名為<xref:System.Windows.Controls.ItemCollection>，其中包含<xref:System.Windows.Controls.ItemCollection>， 並且在處理<xref:System.Windows.Controls.ListBox>XAML 時初始化但為空。</span><span class="sxs-lookup"><span data-stu-id="3b29c-130">It does however have a <xref:System.Windows.Controls.ListBox> property named `Items` that contains a <xref:System.Windows.Controls.ItemCollection>, and that <xref:System.Windows.Controls.ItemCollection> is initialized but empty when the <xref:System.Windows.Controls.ListBox> XAML is processed.</span></span> <span data-ttu-id="3b29c-131">然後，作為 內容<xref:System.Windows.Controls.ListBox>存在的每個子物件元素將添加到<xref:System.Windows.Controls.ItemCollection>分析器調用`ItemCollection.Add`的 。</span><span class="sxs-lookup"><span data-stu-id="3b29c-131">Then, each child object element that exists as content for the <xref:System.Windows.Controls.ListBox> is added to the <xref:System.Windows.Controls.ItemCollection> by parser calls to `ItemCollection.Add`.</span></span> <span data-ttu-id="3b29c-132">目前為止，這個將 XAML 處理到物件樹狀結構中的範例，看起來很像所建立物件樹狀結構基本上是邏輯樹狀結構的範例。</span><span class="sxs-lookup"><span data-stu-id="3b29c-132">This example of processing XAML into an object tree is so far seemingly an example where the created object tree is basically the logical tree.</span></span>  
  
 <span data-ttu-id="3b29c-133">但是，邏輯樹不是應用程式 UI 在運行時存在的整個物件圖，即使不考慮 XAML 隱式語法項也是如此。主要原因是視覺物件和範本。</span><span class="sxs-lookup"><span data-stu-id="3b29c-133">However, the logical tree is not the entire object graph that exists for your application UI at run time, even with the XAML implicit syntax items factored out. The main reason for this is visuals and templates.</span></span> <span data-ttu-id="3b29c-134">例如，請考慮 。 <xref:System.Windows.Controls.Button></span><span class="sxs-lookup"><span data-stu-id="3b29c-134">For example, consider the <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="3b29c-135">邏輯樹報告<xref:System.Windows.Controls.Button>物件及其字串`Content`。</span><span class="sxs-lookup"><span data-stu-id="3b29c-135">The logical tree reports the <xref:System.Windows.Controls.Button> object and also its string `Content`.</span></span> <span data-ttu-id="3b29c-136">但在執行階段的物件樹狀結構中，還有更多關於此按鈕的資訊。</span><span class="sxs-lookup"><span data-stu-id="3b29c-136">But there is more to this button in the run-time object tree.</span></span> <span data-ttu-id="3b29c-137">特別是，該按鈕僅以它的方式出現在螢幕上，因為應用了特定的<xref:System.Windows.Controls.Button>控制項範本。</span><span class="sxs-lookup"><span data-stu-id="3b29c-137">In particular, the button only appears on screen the way it does because a specific <xref:System.Windows.Controls.Button> control template was applied.</span></span> <span data-ttu-id="3b29c-138">來自應用範本的視覺化物件（如視覺按鈕周圍的深灰色範本定義<xref:System.Windows.Controls.Border>）不會在邏輯樹中報告，即使您在運行時查看邏輯樹（例如處理來自可見 UI 的輸入事件，然後讀取邏輯樹）。</span><span class="sxs-lookup"><span data-stu-id="3b29c-138">The visuals that come from an applied template (such as the template-defined <xref:System.Windows.Controls.Border> of dark gray around the visual button) are not reported in the logical tree, even if you are looking at the logical tree during run time (such as handling an input event from the visible UI and then reading the logical tree).</span></span> <span data-ttu-id="3b29c-139">若要尋找範本視覺效果，您需要改為檢查視覺化樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="3b29c-139">To find the template visuals, you would instead need to examine the visual tree.</span></span>  
  
 <span data-ttu-id="3b29c-140">如需 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 語法與所建立物件圖形的對應方式以及 XAML 中隱含語法的詳細資訊，請參閱 [XAML 語法詳細資料](xaml-syntax-in-detail.md)或 [XAML 概觀 (WPF)](xaml-overview-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="3b29c-140">For more information about how [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax maps to the created object graph, and implicit syntax in XAML, see [XAML Syntax In Detail](xaml-syntax-in-detail.md) or [XAML Overview (WPF)](xaml-overview-wpf.md).</span></span>  
  
<a name="tree_property_inheritance_event_routing"></a>
### <a name="the-purpose-of-the-logical-tree"></a><span data-ttu-id="3b29c-141">邏輯樹狀結構的用途</span><span class="sxs-lookup"><span data-stu-id="3b29c-141">The Purpose of the Logical Tree</span></span>  
 <span data-ttu-id="3b29c-142">邏輯樹狀結構的存在，是要讓內容模型可立即逐一查看其可能的子物件，並使內容模型得以延伸。</span><span class="sxs-lookup"><span data-stu-id="3b29c-142">The logical tree exists so that content models can readily iterate over their possible child objects, and so that content models can be extensible.</span></span> <span data-ttu-id="3b29c-143">此外，邏輯樹狀結構也可提供某些通知適用的架構，例如，載入邏輯樹狀結構中的所有物件時。</span><span class="sxs-lookup"><span data-stu-id="3b29c-143">Also, the logical tree provides a framework for certain notifications, such as when all objects in the logical tree are loaded.</span></span> <span data-ttu-id="3b29c-144">基本上，邏輯樹狀結構近似於架構層級的執行階段物件圖形，其會排除視覺效果，但足以對您自己的執行階段應用程式組合進行許多查詢作業。</span><span class="sxs-lookup"><span data-stu-id="3b29c-144">Basically, the logical tree is an approximation of a run time object graph at the framework level, which excludes visuals, but is adequate for many querying operations against your own run time application's composition.</span></span>  
  
 <span data-ttu-id="3b29c-145">此外，靜態和動態資源引用都通過向上查看初始請求<xref:System.Windows.FrameworkElement.Resources%2A>物件集合的邏輯樹來解決，然後繼續邏輯樹並檢查每個<xref:System.Windows.FrameworkElement>（或<xref:System.Windows.FrameworkContentElement>） 另一`Resources`<xref:System.Windows.ResourceDictionary>個值，其中包含 可能包含該鍵。</span><span class="sxs-lookup"><span data-stu-id="3b29c-145">In addition, both static and dynamic resource references are resolved by looking upwards through the logical tree for <xref:System.Windows.FrameworkElement.Resources%2A> collections on the initial requesting object, and then continuing up the logical tree and checking each <xref:System.Windows.FrameworkElement> (or <xref:System.Windows.FrameworkContentElement>) for another `Resources` value that contains a <xref:System.Windows.ResourceDictionary>, possibly containing that key.</span></span> <span data-ttu-id="3b29c-146">當邏輯樹狀結構和視覺化樹狀結構同時存在時，資源查閱會使用邏輯樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="3b29c-146">The logical tree is used for resource lookup when both the logical tree and the visual tree are present.</span></span> <span data-ttu-id="3b29c-147">如需資源字典和查閱的詳細資訊，請參閱 [XAML 資源](../../../desktop-wpf/fundamentals/xaml-resources-define.md)。</span><span class="sxs-lookup"><span data-stu-id="3b29c-147">For more information on resource dictionaries and lookup, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>  
  
<a name="composition"></a>
### <a name="composition-of-the-logical-tree"></a><span data-ttu-id="3b29c-148">邏輯樹狀結構的組合</span><span class="sxs-lookup"><span data-stu-id="3b29c-148">Composition of the Logical Tree</span></span>  
 <span data-ttu-id="3b29c-149">邏輯樹在 WPF 框架級別定義，這意味著與邏輯樹操作最相關的 WPF 基元素是 或<xref:System.Windows.FrameworkElement><xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="3b29c-149">The logical tree is defined at the WPF framework-level, which means that the WPF base element that is most relevant for logical tree operations is either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="3b29c-150">但是，正如您所看到的是否實際使用 API<xref:System.Windows.LogicalTreeHelper>一樣，邏輯樹有時包含不是 或<xref:System.Windows.FrameworkElement><xref:System.Windows.FrameworkContentElement>的節點。</span><span class="sxs-lookup"><span data-stu-id="3b29c-150">However, as you can see if you actually use the <xref:System.Windows.LogicalTreeHelper> API, the logical tree sometimes contains nodes that are not either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="3b29c-151">例如，邏輯樹報告 的值<xref:System.Windows.Controls.TextBlock.Text%2A><xref:System.Windows.Controls.TextBlock>，該值是字串。</span><span class="sxs-lookup"><span data-stu-id="3b29c-151">For instance, the logical tree reports the <xref:System.Windows.Controls.TextBlock.Text%2A> value of a <xref:System.Windows.Controls.TextBlock>, which is a string.</span></span>  
  
<a name="override_logical_tree"></a>
### <a name="overriding-the-logical-tree"></a><span data-ttu-id="3b29c-152">覆寫邏輯樹狀結構</span><span class="sxs-lookup"><span data-stu-id="3b29c-152">Overriding the Logical Tree</span></span>  
 <span data-ttu-id="3b29c-153">高級控制項作者可以通過重寫幾個 API 來覆蓋邏輯樹，這些 API 定義常規物件或內容模型如何添加或刪除邏輯樹中的物件。</span><span class="sxs-lookup"><span data-stu-id="3b29c-153">Advanced control authors can override the logical tree by overriding several APIs that define how a general object or content model adds or removes objects within the logical tree.</span></span> <span data-ttu-id="3b29c-154">如需如何覆寫邏輯樹狀結構的範例，請參閱[覆寫邏輯樹狀結構](how-to-override-the-logical-tree.md)。</span><span class="sxs-lookup"><span data-stu-id="3b29c-154">For an example of how to override the logical tree, see [Override the Logical Tree](how-to-override-the-logical-tree.md).</span></span>  
  
<a name="pvi"></a>
### <a name="property-value-inheritance"></a><span data-ttu-id="3b29c-155">屬性值繼承</span><span class="sxs-lookup"><span data-stu-id="3b29c-155">Property Value Inheritance</span></span>  
 <span data-ttu-id="3b29c-156">屬性值繼承會透過混合式樹狀結構來進行。</span><span class="sxs-lookup"><span data-stu-id="3b29c-156">Property value inheritance operates through a hybrid tree.</span></span> <span data-ttu-id="3b29c-157">包含啟用屬性繼承<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>的屬性的實際中繼資料是 WPF 框架級<xref:System.Windows.FrameworkPropertyMetadata>類。</span><span class="sxs-lookup"><span data-stu-id="3b29c-157">The actual metadata that contains the <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property that enables property inheritance is the WPF framework-level <xref:System.Windows.FrameworkPropertyMetadata> class.</span></span> <span data-ttu-id="3b29c-158">因此，保存原始值的父項和繼承該值的子物件都必須為<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>，並且它們都必須是某個邏輯樹的一部分。</span><span class="sxs-lookup"><span data-stu-id="3b29c-158">Therefore, both the parent that holds the original value and the child object that inherits that value must both be <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, and they must both be part of some logical tree.</span></span> <span data-ttu-id="3b29c-159">不過，對於支援屬性繼承的現有 WPF 屬性而言，透過不在邏輯樹狀結構中的中間物件，屬性值繼承便能永遠存在。</span><span class="sxs-lookup"><span data-stu-id="3b29c-159">However, for existing WPF properties that support property inheritance, property value inheritance is able to perpetuate through an intervening object that is not in the logical tree.</span></span> <span data-ttu-id="3b29c-160">主要是因為這與讓範本元素使用任何繼承屬性值有關，這些值是設定於套用範本的執行個體上，或設定於比頁面層級組合還要更高的層級中，因而在邏輯樹狀結構中會比較高。</span><span class="sxs-lookup"><span data-stu-id="3b29c-160">Mainly this is relevant for having template elements use any inherited property values set either on the instance that is templated, or at still higher levels of page-level composition and therefore higher in the logical tree.</span></span> <span data-ttu-id="3b29c-161">為了使屬性值繼承能夠跨這類界限一致地運作，必須將繼承屬性註冊為附加屬性，而如果您想要利用屬性繼承行為來定義自訂的相依性屬性，則必須遵循這個模式。</span><span class="sxs-lookup"><span data-stu-id="3b29c-161">In order for property value inheritance to work consistently across such a boundary, the inheriting property must be registered as an attached property, and you should follow this pattern if you intend to define a custom dependency property with property inheritance behavior.</span></span> <span data-ttu-id="3b29c-162">Helper 類別公用程式方法完全無法預期屬性繼承所使用的實際樹狀結構，即使在執行階段也一樣。</span><span class="sxs-lookup"><span data-stu-id="3b29c-162">The exact tree used for property inheritance cannot be entirely anticipated by a helper class utility method, even at run time.</span></span> <span data-ttu-id="3b29c-163">如需詳細資訊，請參閱[屬性值繼承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="3b29c-163">For more information, see [Property Value Inheritance](property-value-inheritance.md).</span></span>  
  
<a name="two_trees"></a>
## <a name="the-visual-tree"></a><span data-ttu-id="3b29c-164">視覺化樹狀結構</span><span class="sxs-lookup"><span data-stu-id="3b29c-164">The Visual Tree</span></span>  
 <span data-ttu-id="3b29c-165">除了邏輯樹狀結構的概念，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中還有視覺化樹狀結構的概念。</span><span class="sxs-lookup"><span data-stu-id="3b29c-165">In addition to the concept of the logical tree, there is also the concept of the visual tree in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="3b29c-166">視覺化樹描述可視物件的結構，如<xref:System.Windows.Media.Visual>基類表示。</span><span class="sxs-lookup"><span data-stu-id="3b29c-166">The visual tree describes the structure of visual objects, as represented by the <xref:System.Windows.Media.Visual> base class.</span></span> <span data-ttu-id="3b29c-167">當您撰寫控制項的範本時，就是在定義或重新定義適用於該控制項的視覺化樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="3b29c-167">When you write a template for a control, you are defining or redefining the visual tree that applies for that control.</span></span> <span data-ttu-id="3b29c-168">視覺化樹狀結構也可引起開發人員的關注，讓想要對繪製作業採取低階控制的開發人員，能夠改善效能並進行最佳化。</span><span class="sxs-lookup"><span data-stu-id="3b29c-168">The visual tree is also of interest to developers who want lower-level control over drawing for performance and optimization reasons.</span></span> <span data-ttu-id="3b29c-169">通常在進行 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 應用程式程式設計時，公開視覺化樹狀結構的方式之一，就是路由事件的事件在路由傳送時大多會沿著視覺化樹狀結構進行周遊，而非邏輯樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="3b29c-169">One exposure of the visual tree as part of conventional [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application programming is that event routes for a routed event mostly travel along the visual tree, not the logical tree.</span></span> <span data-ttu-id="3b29c-170">除非您是控制項作者，否則不容易立即察覺到此路由事件行為的細微差異。</span><span class="sxs-lookup"><span data-stu-id="3b29c-170">This subtlety of routed event behavior might not be immediately apparent unless you are a control author.</span></span> <span data-ttu-id="3b29c-171">透過視覺化樹狀結構路由傳送事件，就能讓在視覺化層級中實作組合的控制項處理事件或建立事件 setter。</span><span class="sxs-lookup"><span data-stu-id="3b29c-171">Routing events through the visual tree enables controls that implement composition at the visual level to handle events or create event setters.</span></span>  
  
<a name="trees_content"></a>
## <a name="trees-content-elements-and-content-hosts"></a><span data-ttu-id="3b29c-172">樹狀結構、內容項目元素及內容主機</span><span class="sxs-lookup"><span data-stu-id="3b29c-172">Trees, Content Elements, and Content Hosts</span></span>  
 <span data-ttu-id="3b29c-173">內容元素（派生自 的<xref:System.Windows.ContentElement>類）不是視覺化樹的一部分;因此，內容元素（派生自 的類）不是視覺化樹的一部分。它們不繼承<xref:System.Windows.Media.Visual>，也沒有可視表示形式。</span><span class="sxs-lookup"><span data-stu-id="3b29c-173">Content elements (classes that derive from <xref:System.Windows.ContentElement>) are not part of the visual tree; they do not inherit from <xref:System.Windows.Media.Visual> and do not have a visual representation.</span></span> <span data-ttu-id="3b29c-174">為了在 UI 中顯示 ，<xref:System.Windows.ContentElement>必須在 既是<xref:System.Windows.Media.Visual>邏輯樹參與者的內容主機中託管的。</span><span class="sxs-lookup"><span data-stu-id="3b29c-174">In order to appear in a UI at all, a <xref:System.Windows.ContentElement> must be hosted in a content host that is both a <xref:System.Windows.Media.Visual> and a logical tree participant.</span></span> <span data-ttu-id="3b29c-175">通常這樣的物件是 。 <xref:System.Windows.FrameworkElement></span><span class="sxs-lookup"><span data-stu-id="3b29c-175">Usually such an object is a <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="3b29c-176">您可以將內容主機想像成某些像是內容「瀏覽器」的項目，並選擇如何在主機控制的螢幕區域內顯示該內容。</span><span class="sxs-lookup"><span data-stu-id="3b29c-176">You can conceptualize that the content host is somewhat like a "browser" for the content and chooses how to display that content within the screen region that the host controls.</span></span> <span data-ttu-id="3b29c-177">裝載內容之後，該內容就可成為某些樹狀結構處理序 (通常會與視覺化樹狀結構相關聯) 中的參與者。</span><span class="sxs-lookup"><span data-stu-id="3b29c-177">When the content is hosted, the content can be made a participant in certain tree processes that are normally associated with the visual tree.</span></span> <span data-ttu-id="3b29c-178">通常，<xref:System.Windows.FrameworkElement>主機類包括實現代碼，該代碼通過內容<xref:System.Windows.ContentElement>邏輯樹的子節點將任何託管添加到事件路由，即使託管內容不是真正視覺化樹的一部分。</span><span class="sxs-lookup"><span data-stu-id="3b29c-178">Generally, the <xref:System.Windows.FrameworkElement> host class includes implementation code that adds any hosted <xref:System.Windows.ContentElement> to the event route through subnodes of the content logical tree, even though the hosted content is not part of the true visual tree.</span></span> <span data-ttu-id="3b29c-179">這是必要的，以便 可以<xref:System.Windows.ContentElement>源路由到任何元素（而不是其自身）的路由事件。</span><span class="sxs-lookup"><span data-stu-id="3b29c-179">This is necessary so that a <xref:System.Windows.ContentElement> can source a routed event that routes to any element other than itself.</span></span>  
  
<a name="tree_traversal"></a>
## <a name="tree-traversal"></a><span data-ttu-id="3b29c-180">樹狀周遊</span><span class="sxs-lookup"><span data-stu-id="3b29c-180">Tree Traversal</span></span>  
 <span data-ttu-id="3b29c-181">類<xref:System.Windows.LogicalTreeHelper>提供<xref:System.Windows.LogicalTreeHelper.GetChildren%2A><xref:System.Windows.LogicalTreeHelper.GetParent%2A>邏輯樹遍歷<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>的 和 方法。</span><span class="sxs-lookup"><span data-stu-id="3b29c-181">The <xref:System.Windows.LogicalTreeHelper> class provides the <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, and <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> methods for logical tree traversal.</span></span> <span data-ttu-id="3b29c-182">在大部分情況下，您應該不需要周遊現有控制項的邏輯樹狀結構，因為這些控制項幾乎都會將其邏輯子元素公開為專用的集合屬性，以支援集合存取，例如 `Add`、索引子等等。</span><span class="sxs-lookup"><span data-stu-id="3b29c-182">In most cases, you should not have to traverse the logical tree of existing controls, because these controls almost always expose their logical child elements as a dedicated collection property that supports collection access such as `Add`, an indexer, and so on.</span></span> <span data-ttu-id="3b29c-183">樹遍歷主要是一種方案，由選擇不從預期控制模式（如已定義集合屬性）或<xref:System.Windows.Controls.ItemsControl><xref:System.Windows.Controls.Panel>已定義集合屬性或打算提供自己的集合屬性支援的控制項作者使用的方案。</span><span class="sxs-lookup"><span data-stu-id="3b29c-183">Tree traversal is mainly a scenario that is used by control authors who choose not to derive from intended control patterns such as <xref:System.Windows.Controls.ItemsControl> or <xref:System.Windows.Controls.Panel> where collection properties are already defined, and who intend to provide their own collection property support.</span></span>  
  
 <span data-ttu-id="3b29c-184">視覺化樹還支援視覺化樹遍歷的説明器類<xref:System.Windows.Media.VisualTreeHelper>。</span><span class="sxs-lookup"><span data-stu-id="3b29c-184">The visual tree also supports a helper class for visual tree traversal, <xref:System.Windows.Media.VisualTreeHelper>.</span></span> <span data-ttu-id="3b29c-185">視覺化樹不會通過特定于控制項的屬性輕易公開，因此，如果程式設計方案需要，<xref:System.Windows.Media.VisualTreeHelper>則建議使用該類遍歷視覺化樹。</span><span class="sxs-lookup"><span data-stu-id="3b29c-185">The visual tree is not exposed as conveniently through control-specific properties, so the <xref:System.Windows.Media.VisualTreeHelper> class is the recommended way to traverse the visual tree if that is necessary for your programming scenario.</span></span> <span data-ttu-id="3b29c-186">如需詳細資訊，請參閱 [WPF 圖形轉譯概觀](../graphics-multimedia/wpf-graphics-rendering-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="3b29c-186">For more information, see [WPF Graphics Rendering Overview](../graphics-multimedia/wpf-graphics-rendering-overview.md).</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3b29c-187">有時必須檢查所套用範本的視覺化樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="3b29c-187">Sometimes it is necessary to examine the visual tree of an applied template.</span></span> <span data-ttu-id="3b29c-188">您應該謹慎使用此技術。</span><span class="sxs-lookup"><span data-stu-id="3b29c-188">You should be careful when using this technique.</span></span> <span data-ttu-id="3b29c-189">即使您正在遍歷控制項的視覺化樹，並且控制項的消費者始終可以通過在實例上設置<xref:System.Windows.Controls.Control.Template%2A>該屬性來更改範本，甚至最終使用者也可以通過更改系統主題來影回應用的範本。</span><span class="sxs-lookup"><span data-stu-id="3b29c-189">Even if you are traversing a visual tree for a control where you define the template, consumers of your control can always change the template by setting the <xref:System.Windows.Controls.Control.Template%2A> property on instances, and even the end user can influence the applied template by changing the system theme.</span></span>  
  
<a name="routes"></a>
## <a name="routes-for-routed-events-as-a-tree"></a><span data-ttu-id="3b29c-190">路由事件的樹狀結構路由</span><span class="sxs-lookup"><span data-stu-id="3b29c-190">Routes for Routed Events as a "Tree"</span></span>  
 <span data-ttu-id="3b29c-191">如前所述，任何指定路由事件的路由是在樹狀結構中沿著預先決定的單一路徑來周遊，該樹狀結構是視覺化樹狀結構和邏輯樹狀結構表示法的混合。</span><span class="sxs-lookup"><span data-stu-id="3b29c-191">As mentioned before, the route of any given routed event travels along a single and predetermined path of a tree that is a hybrid of the visual and logical tree representations.</span></span> <span data-ttu-id="3b29c-192">依據事件路由為通道或事件反昇的路由事件而定，其會在樹狀結構內向上或向下進行周遊。</span><span class="sxs-lookup"><span data-stu-id="3b29c-192">The event route can travel either in the up or down directions within the tree depending on whether it is a tunneling or bubbling routed event.</span></span> <span data-ttu-id="3b29c-193">事件路由概念沒有直接支援的 Helper 類別可用來在事件路由上「前進」，而不管是否會引發實際路由傳送的事件。</span><span class="sxs-lookup"><span data-stu-id="3b29c-193">The event route concept does not have a directly supporting helper class that could be used to "walk" the event route independently of raising an event that actually routes.</span></span> <span data-ttu-id="3b29c-194">有一個類表示路由，<xref:System.Windows.EventRoute>但該類的方法通常僅供內部使用。</span><span class="sxs-lookup"><span data-stu-id="3b29c-194">There is a class that represents the route, <xref:System.Windows.EventRoute>, but the methods of that class are generally for internal use only.</span></span>  
  
<a name="resourcesandtrees"></a>
## <a name="resource-dictionaries-and-trees"></a><span data-ttu-id="3b29c-195">資源字典和樹狀目錄</span><span class="sxs-lookup"><span data-stu-id="3b29c-195">Resource Dictionaries and Trees</span></span>  
 <span data-ttu-id="3b29c-196">對於頁面中定義的所有 `Resources` 的資源字典查閱，基本上會周遊邏輯樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="3b29c-196">Resource dictionary lookup for all `Resources` defined in a page traverses basically the logical tree.</span></span> <span data-ttu-id="3b29c-197">不在邏輯樹狀結構中的物件可以參考具有索引鍵的資源，但資源查閱序列是從物件連接到邏輯樹狀結構的點開始。</span><span class="sxs-lookup"><span data-stu-id="3b29c-197">Objects that are not in the logical tree can reference keyed resources, but the resource lookup sequence begins at the point where that object is connected to the logical tree.</span></span> <span data-ttu-id="3b29c-198">在 WPF 中，只有邏輯樹節點`Resources`可以具有包含 的屬性<xref:System.Windows.ResourceDictionary>，因此遍歷可視樹以查找 摳資源沒有好處<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="3b29c-198">In WPF, only logical tree nodes can have a `Resources` property that contains a <xref:System.Windows.ResourceDictionary>, therefore there is no benefit in traversing the visual tree looking for keyed resources from a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="3b29c-199">不過，資源查閱也可以延伸至目前邏輯樹狀結構以外的地方。</span><span class="sxs-lookup"><span data-stu-id="3b29c-199">However, resource lookup can also extend beyond the immediate logical tree.</span></span> <span data-ttu-id="3b29c-200">對於應用程式標記，資源查閱可接著繼續前進到應用程式層級的資源字典，然後到做為靜態屬性或索引鍵加以參考的佈景主題支援和系統值。</span><span class="sxs-lookup"><span data-stu-id="3b29c-200">For application markup, the resource lookup can then continue onward to application-level resource dictionaries and then to theme support and system values that are referenced as static properties or keys.</span></span> <span data-ttu-id="3b29c-201">如果資源參考是動態的，則佈景主題本身也可以參考佈景主題邏輯樹狀結構以外的系統值。</span><span class="sxs-lookup"><span data-stu-id="3b29c-201">Themes themselves can also reference system values outside of the theme logical tree if the resource references are dynamic.</span></span> <span data-ttu-id="3b29c-202">如需資源字典和查閱邏輯的詳細資訊，請參閱 [XAML 資源](../../../desktop-wpf/fundamentals/xaml-resources-define.md)。</span><span class="sxs-lookup"><span data-stu-id="3b29c-202">For more information on resource dictionaries and the lookup logic, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3b29c-203">另請參閱</span><span class="sxs-lookup"><span data-stu-id="3b29c-203">See also</span></span>

- [<span data-ttu-id="3b29c-204">輸入概觀</span><span class="sxs-lookup"><span data-stu-id="3b29c-204">Input Overview</span></span>](input-overview.md)
- [<span data-ttu-id="3b29c-205">WPF 圖形轉譯概觀</span><span class="sxs-lookup"><span data-stu-id="3b29c-205">WPF Graphics Rendering Overview</span></span>](../graphics-multimedia/wpf-graphics-rendering-overview.md)
- [<span data-ttu-id="3b29c-206">路由事件概觀</span><span class="sxs-lookup"><span data-stu-id="3b29c-206">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="3b29c-207">初始化物件樹狀結構以外的物件項目</span><span class="sxs-lookup"><span data-stu-id="3b29c-207">Initialization for Object Elements Not in an Object Tree</span></span>](initialization-for-object-elements-not-in-an-object-tree.md)
- [<span data-ttu-id="3b29c-208">WPF 架構</span><span class="sxs-lookup"><span data-stu-id="3b29c-208">WPF Architecture</span></span>](wpf-architecture.md)
