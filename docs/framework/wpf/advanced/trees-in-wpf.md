---
title: WPF 中的樹狀結構
ms.date: 03/30/2017
helpviewer_keywords:
- logical tree [WPF]
- element tree [WPF]
- visual tree [WPF]
ms.assetid: e83f25e5-d66b-4fc7-92d2-50130c9a6649
ms.openlocfilehash: e6173916ad64a60d3727b5d35bb2a2302b881b38
ms.sourcegitcommit: a885cc8c3e444ca6471348893d5373c6e9e49a47
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/06/2018
ms.locfileid: "44037304"
---
# <a name="trees-in-wpf"></a><span data-ttu-id="34031-102">WPF 中的樹狀結構</span><span class="sxs-lookup"><span data-stu-id="34031-102">Trees in WPF</span></span>
<span data-ttu-id="34031-103">在許多技術中，元素和元件都會組織成樹狀結構，開發人員可直接管理樹狀結構中的物件節點來影響應用程式的轉譯或行為。</span><span class="sxs-lookup"><span data-stu-id="34031-103">In many technologies, elements and components are organized in a tree structure where developers directly manipulate the object nodes in the tree to affect the rendering or behavior of an application.</span></span> [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]<span data-ttu-id="34031-104"> 也會使用數個樹狀結構比喻來定義程式元素之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="34031-104"> also uses several tree structure metaphors to define relationships between program elements.</span></span> <span data-ttu-id="34031-105">在大部分情形下，WPF 開發人員在概念上思考物件樹狀結構比喻時，可以使用程式碼建立應用程式或使用 XAML 定義應用程式的部分，但將會呼叫特定的 API 或使用特定標記來進行這些作業，而不是使用某些一般的物件樹狀結構管理 API，就像您可能在 XML DOM 中使用的方式。</span><span class="sxs-lookup"><span data-stu-id="34031-105">For the most part WPF developers can create an application in code or define portions of the application in XAML while thinking conceptually about the object tree metaphor, but will be calling specific API or using specific markup to do so rather than some general object tree manipulation API such as you might use in XML DOM.</span></span> <span data-ttu-id="34031-106">WPF 會公開兩個協助程式類別提供樹狀結構比喻檢視<xref:System.Windows.LogicalTreeHelper>和<xref:System.Windows.Media.VisualTreeHelper>。</span><span class="sxs-lookup"><span data-stu-id="34031-106">WPF exposes two helper classes that provide a tree metaphor view, <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>.</span></span> <span data-ttu-id="34031-107">WPF 文件中也會使用視覺化樹狀結構和邏輯樹狀結構等詞彙，因為這些相同的樹狀結構在了解某些主要的 WPF 功能時非常好用。</span><span class="sxs-lookup"><span data-stu-id="34031-107">The terms visual tree and logical tree are also used in the WPF documentation because these same trees are useful for understanding the behavior of certain key WPF features.</span></span> <span data-ttu-id="34031-108">本主題定義代表什麼意義的視覺化樹狀結構和邏輯樹狀結構、 討論這類樹狀結構與整體的物件樹狀結構概念，並介紹<xref:System.Windows.LogicalTreeHelper>和<xref:System.Windows.Media.VisualTreeHelper>s。</span><span class="sxs-lookup"><span data-stu-id="34031-108">This topic defines what the visual tree and logical tree represent, discusses how such trees relate to an overall object tree concept, and introduces <xref:System.Windows.LogicalTreeHelper> and <xref:System.Windows.Media.VisualTreeHelper>s.</span></span>  
  

  
<a name="element_tree"></a>   
## <a name="trees-in-wpf"></a><span data-ttu-id="34031-109">WPF 中的樹狀結構</span><span class="sxs-lookup"><span data-stu-id="34031-109">Trees in WPF</span></span>  
 <span data-ttu-id="34031-110">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中最完整的樹狀結構就是物件樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="34031-110">The most complete tree structure in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is the object tree.</span></span> <span data-ttu-id="34031-111">如果您以 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 定義應用程式頁面，然後載入 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]，則會依據標記中元素的巢狀關聯性來建立樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="34031-111">If you define an application page in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and then load the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], the tree structure is created based on the nesting relationships of the elements in the markup.</span></span> <span data-ttu-id="34031-112">如果您利用程式碼定義應用程式或應用程式的一部分，則會依據下列方式來建立樹狀結構：您如何針對用於實作指定物件之內容模型的屬性指派屬性值。</span><span class="sxs-lookup"><span data-stu-id="34031-112">If you define an application or a portion of the application in code, then the tree structure is created based on how you assign property values for properties that implement the content model for a given object.</span></span> <span data-ttu-id="34031-113">在 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中，將完整的物件樹狀結構概念化並可回報給其公用 API 的方式有兩種：當做邏輯樹狀結構，以及當做視覺化樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="34031-113">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], there are two ways that the complete object tree is conceptualized and can be reported to its public API: as the logical tree and as the visual tree.</span></span> <span data-ttu-id="34031-114">邏輯樹狀結構與視覺化樹狀結構之間的差異不一定很重要，但有時可能會導致某些 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 子系統發生問題，並影響您對於使用標記或程式碼的選擇。</span><span class="sxs-lookup"><span data-stu-id="34031-114">The distinctions between logical tree and visual tree are not always necessarily important, but they can occasionally cause issues with certain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] subsystems and affect choices you make in markup or code.</span></span>  
  
 <span data-ttu-id="34031-115">即使您不一定會直接管理邏輯樹狀結構或視覺化樹狀結構，但了解這些樹狀結構的互動方式，將有助於對 WPF 這種技術的認識。</span><span class="sxs-lookup"><span data-stu-id="34031-115">Even though you do not always manipulate either the logical tree or the visual tree directly, understanding the concepts of how the trees interact is useful for understanding WPF as a technology.</span></span> <span data-ttu-id="34031-116">將 WPF 比喻為某種樹狀結構，對於了解 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中屬性繼承和事件路由的運作方式也很重要。</span><span class="sxs-lookup"><span data-stu-id="34031-116">Thinking of WPF as a tree metaphor of some kind is also crucial to understanding how property inheritance and event routing work in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="34031-117">因為物件樹狀結構比較接近是個概念而非實際的 API，所以另一種想像這個概念的方式是當成物件圖形。</span><span class="sxs-lookup"><span data-stu-id="34031-117">Because the object tree is more of a concept than an actual API, another way to think of the concept is as an object graph.</span></span> <span data-ttu-id="34031-118">實際上，物件之間的關聯性在執行階段，可能會讓樹狀結構比喻失效。</span><span class="sxs-lookup"><span data-stu-id="34031-118">In practice, there are relationships between objects at run time where the tree metaphor will break down.</span></span> <span data-ttu-id="34031-119">不過，特別是對以 XAML 定義的 UI 而言，樹狀結構比喻仍算是恰當，因此大部分的 WPF 文件在提及這個一般概念時，將會使用物件樹狀結構一詞。</span><span class="sxs-lookup"><span data-stu-id="34031-119">Nevertheless, particularly with XAML-defined UI, the tree metaphor is relevant enough that most WPF documentation will use the term object tree when referencing this general concept.</span></span>  
  
<a name="logical_tree"></a>   
## <a name="the-logical-tree"></a><span data-ttu-id="34031-120">邏輯樹狀結構</span><span class="sxs-lookup"><span data-stu-id="34031-120">The Logical Tree</span></span>  
 <span data-ttu-id="34031-121">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，您要將內容加入至 UI 元素，方法則是為支援這些元素的物件設定屬性。</span><span class="sxs-lookup"><span data-stu-id="34031-121">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], you add content to UI elements by setting properties of the objects that back those elements.</span></span> <span data-ttu-id="34031-122">例如，您將項目加入<xref:System.Windows.Controls.ListBox>藉由操作的控制項及其<xref:System.Windows.Controls.ItemsControl.Items%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="34031-122">For example, you add items to a <xref:System.Windows.Controls.ListBox> control by manipulating its <xref:System.Windows.Controls.ItemsControl.Items%2A> property.</span></span> <span data-ttu-id="34031-123">如此一來，您會將項目置於<xref:System.Windows.Controls.ItemCollection>也就是<xref:System.Windows.Controls.ItemsControl.Items%2A>屬性值。</span><span class="sxs-lookup"><span data-stu-id="34031-123">By doing this, you are placing items into the <xref:System.Windows.Controls.ItemCollection> that is the <xref:System.Windows.Controls.ItemsControl.Items%2A> property value.</span></span> <span data-ttu-id="34031-124">同樣地，將物件加入<xref:System.Windows.Controls.DockPanel>，您操作其<xref:System.Windows.Controls.Panel.Children%2A>屬性值。</span><span class="sxs-lookup"><span data-stu-id="34031-124">Similarly, to add objects to a <xref:System.Windows.Controls.DockPanel>, you manipulate its <xref:System.Windows.Controls.Panel.Children%2A> property value.</span></span> <span data-ttu-id="34031-125">在這裡，您會將物件新增至<xref:System.Windows.Controls.UIElementCollection>。</span><span class="sxs-lookup"><span data-stu-id="34031-125">Here, you are adding objects to the <xref:System.Windows.Controls.UIElementCollection>.</span></span> <span data-ttu-id="34031-126">如需程式碼範例，請參閱[以動態方式加入元素](https://msdn.microsoft.com/library/d00f258a-7973-4de7-bc54-a3fc1f638419)。</span><span class="sxs-lookup"><span data-stu-id="34031-126">For a code example, see [Add an Element Dynamically](https://msdn.microsoft.com/library/d00f258a-7973-4de7-bc54-a3fc1f638419).</span></span>  
  
 <span data-ttu-id="34031-127">中[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]，當您將清單中的項目<xref:System.Windows.Controls.ListBox>控制項或其他 UI 元素置於<xref:System.Windows.Controls.DockPanel>，您也使用<xref:System.Windows.Controls.ItemsControl.Items%2A>和<xref:System.Windows.Controls.Panel.Children%2A>屬性，明確或隱含，如下列範例所示。</span><span class="sxs-lookup"><span data-stu-id="34031-127">In [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)], when you place list items in a <xref:System.Windows.Controls.ListBox> or controls or other UI elements in a <xref:System.Windows.Controls.DockPanel>, you also use the <xref:System.Windows.Controls.ItemsControl.Items%2A> and <xref:System.Windows.Controls.Panel.Children%2A> properties, either explicitly or implicitly, as in the following example.</span></span>  
  
 [!code-xaml[TreeOvwsSupport#AllCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/TreeOvwsSupport/CS/page1.xaml#allcode)]  
  
 <span data-ttu-id="34031-128">如果您原本要處理這個 XAML 做為文件物件模型下的 XML，而且已包含註解化為隱含的標記 (這應該已合法)，則產生的 XML DOM 樹狀結構應該已包含 `<ListBox.Items>` 的元素及其他隱含項目。</span><span class="sxs-lookup"><span data-stu-id="34031-128">If you were to process this XAML as XML under a document object model, and if you had included the tags commented out as implicit (which would have been legal), then the resulting XML DOM tree would have included elements for `<ListBox.Items>` and the other implicit items.</span></span> <span data-ttu-id="34031-129">但是當您讀取標記並寫入至物件時，XAML 不會以該方式處理，因此，產生的物件圖形實際上不會包含 `ListBox.Items`。</span><span class="sxs-lookup"><span data-stu-id="34031-129">But XAML does not process that way when you read the markup and write to objects, the resulting object graph does not literally include `ListBox.Items`.</span></span> <span data-ttu-id="34031-130">不過沒有<xref:System.Windows.Controls.ListBox>名為屬性`Items`，其中包含<xref:System.Windows.Controls.ItemCollection>，且<xref:System.Windows.Controls.ItemCollection>已初始化但其為空白時<xref:System.Windows.Controls.ListBox>處理 XAML 時。</span><span class="sxs-lookup"><span data-stu-id="34031-130">It does however have a <xref:System.Windows.Controls.ListBox> property named `Items` that contains a <xref:System.Windows.Controls.ItemCollection>, and that <xref:System.Windows.Controls.ItemCollection> is initialized but empty when the <xref:System.Windows.Controls.ListBox> XAML is processed.</span></span> <span data-ttu-id="34031-131">然後，每個子物件項目作為內容存在於<xref:System.Windows.Controls.ListBox>新增至<xref:System.Windows.Controls.ItemCollection>藉由剖析器呼叫`ItemCollection.Add`。</span><span class="sxs-lookup"><span data-stu-id="34031-131">Then, each child object element that exists as content for the <xref:System.Windows.Controls.ListBox> is added to the <xref:System.Windows.Controls.ItemCollection> by parser calls to `ItemCollection.Add`.</span></span> <span data-ttu-id="34031-132">目前為止，這個將 XAML 處理到物件樹狀結構中的範例，看起來很像所建立物件樹狀結構基本上是邏輯樹狀結構的範例。</span><span class="sxs-lookup"><span data-stu-id="34031-132">This example of processing XAML into an object tree is so far seemingly an example where the created object tree is basically the logical tree.</span></span>  
  
 <span data-ttu-id="34031-133">不過，即使去除 XAML 隱含語法項目的因素，邏輯樹狀結構並不是會在執行階段針對應用程式 UI 存在的完整物件圖形。針對這點的主要原因是視覺效果和範本。</span><span class="sxs-lookup"><span data-stu-id="34031-133">However, the logical tree is not the entire object graph that exists for your application UI at run time, even with the XAML implicit syntax items factored out. The main reason for this is visuals and templates.</span></span> <span data-ttu-id="34031-134">例如，假設<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="34031-134">For example, consider the <xref:System.Windows.Controls.Button>.</span></span> <span data-ttu-id="34031-135">邏輯樹狀結構的報表<xref:System.Windows.Controls.Button>物件以及其字串`Content`。</span><span class="sxs-lookup"><span data-stu-id="34031-135">The logical tree reports the <xref:System.Windows.Controls.Button> object and also its string `Content`.</span></span> <span data-ttu-id="34031-136">但在執行階段的物件樹狀結構中，還有更多關於此按鈕的資訊。</span><span class="sxs-lookup"><span data-stu-id="34031-136">But there is more to this button in the run-time object tree.</span></span> <span data-ttu-id="34031-137">特別是，按鈕才會出現在畫面上的方式，是因為會在特定<xref:System.Windows.Controls.Button>套用控制項範本。</span><span class="sxs-lookup"><span data-stu-id="34031-137">In particular, the button only appears on screen the way it does because a specific <xref:System.Windows.Controls.Button> control template was applied.</span></span> <span data-ttu-id="34031-138">來自已套用範本的視覺效果 (例如範本定義<xref:System.Windows.Controls.Border>位於視覺化按鈕周圍深灰色框線) 不會報告在邏輯樹狀結構中，即使您在執行階段查看邏輯樹狀結構 (例如處理的輸入的事件顯示 UI，然後讀取邏輯樹狀結構）。</span><span class="sxs-lookup"><span data-stu-id="34031-138">The visuals that come from an applied template (such as the template-defined <xref:System.Windows.Controls.Border> of dark gray around the visual button) are not reported in the logical tree, even if you are looking at the logical tree during run time (such as handling an input event from the visible UI and then reading the logical tree).</span></span> <span data-ttu-id="34031-139">若要尋找範本視覺效果，您需要改為檢查視覺化樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="34031-139">To find the template visuals, you would instead need to examine the visual tree.</span></span>  
  
 <span data-ttu-id="34031-140">如需 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 語法與所建立物件圖形的對應方式以及 XAML 中隱含語法的詳細資訊，請參閱 [XAML 語法詳細資料](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md)或 [XAML 概觀 (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="34031-140">For more information about how [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax maps to the created object graph, and implicit syntax in XAML, see [XAML Syntax In Detail](../../../../docs/framework/wpf/advanced/xaml-syntax-in-detail.md) or [XAML Overview (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).</span></span>  
  
<a name="tree_property_inheritance_event_routing"></a>   
### <a name="the-purpose-of-the-logical-tree"></a><span data-ttu-id="34031-141">邏輯樹狀結構的用途</span><span class="sxs-lookup"><span data-stu-id="34031-141">The Purpose of the Logical Tree</span></span>  
 <span data-ttu-id="34031-142">邏輯樹狀結構的存在，是要讓內容模型可立即逐一查看其可能的子物件，並使內容模型得以延伸。</span><span class="sxs-lookup"><span data-stu-id="34031-142">The logical tree exists so that content models can readily iterate over their possible child objects, and so that content models can be extensible.</span></span> <span data-ttu-id="34031-143">此外，邏輯樹狀結構也可提供某些通知適用的架構，例如，載入邏輯樹狀結構中的所有物件時。</span><span class="sxs-lookup"><span data-stu-id="34031-143">Also, the logical tree provides a framework for certain notifications, such as when all objects in the logical tree are loaded.</span></span> <span data-ttu-id="34031-144">基本上，邏輯樹狀結構近似於架構層級的執行階段物件圖形，其會排除視覺效果，但足以對您自己的執行階段應用程式組合進行許多查詢作業。</span><span class="sxs-lookup"><span data-stu-id="34031-144">Basically, the logical tree is an approximation of a run time object graph at the framework level, which excludes visuals, but is adequate for many querying operations against your own run time application's composition.</span></span>  
  
 <span data-ttu-id="34031-145">此外，將這兩個靜態和動態資源參考解析透過向上查看邏輯樹狀結構<xref:System.Windows.FrameworkElement.Resources%2A>上初始要求的物件，然後繼續在邏輯樹狀結構並檢查每個集合<xref:System.Windows.FrameworkElement>（或<xref:System.Windows.FrameworkContentElement>)另外`Resources`值，其中包含<xref:System.Windows.ResourceDictionary>，可能包含該索引鍵。</span><span class="sxs-lookup"><span data-stu-id="34031-145">In addition, both static and dynamic resource references are resolved by looking upwards through the logical tree for <xref:System.Windows.FrameworkElement.Resources%2A> collections on the initial requesting object, and then continuing up the logical tree and checking each <xref:System.Windows.FrameworkElement> (or <xref:System.Windows.FrameworkContentElement>) for another `Resources` value that contains a <xref:System.Windows.ResourceDictionary>, possibly containing that key.</span></span> <span data-ttu-id="34031-146">當邏輯樹狀結構和視覺化樹狀結構同時存在時，資源查閱會使用邏輯樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="34031-146">The logical tree is used for resource lookup when both the logical tree and the visual tree are present.</span></span> <span data-ttu-id="34031-147">如需資源字典和查閱的詳細資訊，請參閱 [XAML 資源](../../../../docs/framework/wpf/advanced/xaml-resources.md)。</span><span class="sxs-lookup"><span data-stu-id="34031-147">For more information on resource dictionaries and lookup, see [XAML Resources](../../../../docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
<a name="composition"></a>   
### <a name="composition-of-the-logical-tree"></a><span data-ttu-id="34031-148">邏輯樹狀結構的組合</span><span class="sxs-lookup"><span data-stu-id="34031-148">Composition of the Logical Tree</span></span>  
 <span data-ttu-id="34031-149">邏輯樹狀結構定義於 WPF 架構層級，這表示，邏輯樹狀結構作業最相關的 WPF 基底項目是<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="34031-149">The logical tree is defined at the WPF framework-level, which means that the WPF base element that is most relevant for logical tree operations is either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="34031-150">不過，您可以看到是否您實際使用<xref:System.Windows.LogicalTreeHelper>API，邏輯樹狀結構有時包含的節點，不是單選題<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="34031-150">However, as you can see if you actually use the <xref:System.Windows.LogicalTreeHelper> API, the logical tree sometimes contains nodes that are not either <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>.</span></span> <span data-ttu-id="34031-151">比方說，邏輯樹狀結構會報告<xref:System.Windows.Controls.TextBlock.Text%2A>的值<xref:System.Windows.Controls.TextBlock>，這是字串。</span><span class="sxs-lookup"><span data-stu-id="34031-151">For instance, the logical tree reports the <xref:System.Windows.Controls.TextBlock.Text%2A> value of a <xref:System.Windows.Controls.TextBlock>, which is a string.</span></span>  
  
<a name="override_logical_tree"></a>   
### <a name="overriding-the-logical-tree"></a><span data-ttu-id="34031-152">覆寫邏輯樹狀結構</span><span class="sxs-lookup"><span data-stu-id="34031-152">Overriding the Logical Tree</span></span>  
 <span data-ttu-id="34031-153">資深的控制項作者可藉由覆寫數個用來定義一般物件或內容模型如何在邏輯樹狀結構內加入或移除物件的 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]，來覆寫邏輯樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="34031-153">Advanced control authors can override the logical tree by overriding several [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] that define how a general object or content model adds or removes objects within the logical tree.</span></span> <span data-ttu-id="34031-154">如需如何覆寫邏輯樹狀結構的範例，請參閱[覆寫邏輯樹狀結構](../../../../docs/framework/wpf/advanced/how-to-override-the-logical-tree.md)。</span><span class="sxs-lookup"><span data-stu-id="34031-154">For an example of how to override the logical tree, see [Override the Logical Tree](../../../../docs/framework/wpf/advanced/how-to-override-the-logical-tree.md).</span></span>  
  
<a name="pvi"></a>   
### <a name="property-value-inheritance"></a><span data-ttu-id="34031-155">屬性值繼承</span><span class="sxs-lookup"><span data-stu-id="34031-155">Property Value Inheritance</span></span>  
 <span data-ttu-id="34031-156">屬性值繼承會透過混合式樹狀結構來進行。</span><span class="sxs-lookup"><span data-stu-id="34031-156">Property value inheritance operates through a hybrid tree.</span></span> <span data-ttu-id="34031-157">包含的實際中繼資料<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>啟用屬性繼承的屬性是 WPF 架構層級<xref:System.Windows.FrameworkPropertyMetadata>類別。</span><span class="sxs-lookup"><span data-stu-id="34031-157">The actual metadata that contains the <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property that enables property inheritance is the WPF framework-level <xref:System.Windows.FrameworkPropertyMetadata> class.</span></span> <span data-ttu-id="34031-158">因此，同時保留原始值的父代和子物件繼承該值必須同時<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>，而且必須是某個邏輯樹狀結構的一部分。</span><span class="sxs-lookup"><span data-stu-id="34031-158">Therefore, both the parent that holds the original value and the child object that inherits that value must both be <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, and they must both be part of some logical tree.</span></span> <span data-ttu-id="34031-159">不過，對於支援屬性繼承的現有 WPF 屬性而言，透過不在邏輯樹狀結構中的中間物件，屬性值繼承便能永遠存在。</span><span class="sxs-lookup"><span data-stu-id="34031-159">However, for existing WPF properties that support property inheritance, property value inheritance is able to perpetuate through an intervening object that is not in the logical tree.</span></span> <span data-ttu-id="34031-160">主要是因為這與讓範本元素使用任何繼承屬性值有關，這些值是設定於套用範本的執行個體上，或設定於比頁面層級組合還要更高的層級中，因而在邏輯樹狀結構中會比較高。</span><span class="sxs-lookup"><span data-stu-id="34031-160">Mainly this is relevant for having template elements use any inherited property values set either on the instance that is templated, or at still higher levels of page-level composition and therefore higher in the logical tree.</span></span> <span data-ttu-id="34031-161">為了使屬性值繼承能夠跨這類界限一致地運作，必須將繼承屬性註冊為附加屬性，而如果您想要利用屬性繼承行為來定義自訂的相依性屬性，則必須遵循這個模式。</span><span class="sxs-lookup"><span data-stu-id="34031-161">In order for property value inheritance to work consistently across such a boundary, the inheriting property must be registered as an attached property, and you should follow this pattern if you intend to define a custom dependency property with property inheritance behavior.</span></span> <span data-ttu-id="34031-162">Helper 類別公用程式方法完全無法預期屬性繼承所使用的實際樹狀結構，即使在執行階段也一樣。</span><span class="sxs-lookup"><span data-stu-id="34031-162">The exact tree used for property inheritance cannot be entirely anticipated by a helper class utility method, even at run time.</span></span> <span data-ttu-id="34031-163">如需詳細資訊，請參閱[屬性值繼承](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="34031-163">For more information, see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
<a name="two_trees"></a>   
## <a name="the-visual-tree"></a><span data-ttu-id="34031-164">視覺化樹狀結構</span><span class="sxs-lookup"><span data-stu-id="34031-164">The Visual Tree</span></span>  
 <span data-ttu-id="34031-165">除了邏輯樹狀結構的概念，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中還有視覺化樹狀結構的概念。</span><span class="sxs-lookup"><span data-stu-id="34031-165">In addition to the concept of the logical tree, there is also the concept of the visual tree in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="34031-166">視覺化樹狀結構描述的視覺物件，結構，表示的<xref:System.Windows.Media.Visual>基底類別。</span><span class="sxs-lookup"><span data-stu-id="34031-166">The visual tree describes the structure of visual objects, as represented by the <xref:System.Windows.Media.Visual> base class.</span></span> <span data-ttu-id="34031-167">當您撰寫控制項的範本時，就是在定義或重新定義適用於該控制項的視覺化樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="34031-167">When you write a template for a control, you are defining or redefining the visual tree that applies for that control.</span></span> <span data-ttu-id="34031-168">視覺化樹狀結構也可引起開發人員的關注，讓想要對繪製作業採取低階控制的開發人員，能夠改善效能並進行最佳化。</span><span class="sxs-lookup"><span data-stu-id="34031-168">The visual tree is also of interest to developers who want lower-level control over drawing for performance and optimization reasons.</span></span> <span data-ttu-id="34031-169">通常在進行 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 應用程式程式設計時，公開視覺化樹狀結構的方式之一，就是路由事件的事件在路由傳送時大多會沿著視覺化樹狀結構進行周遊，而非邏輯樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="34031-169">One exposure of the visual tree as part of conventional [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] application programming is that event routes for a routed event mostly travel along the visual tree, not the logical tree.</span></span> <span data-ttu-id="34031-170">除非您是控制項作者，否則不容易立即察覺到此路由事件行為的細微差異。</span><span class="sxs-lookup"><span data-stu-id="34031-170">This subtlety of routed event behavior might not be immediately apparent unless you are a control author.</span></span> <span data-ttu-id="34031-171">透過視覺化樹狀結構路由傳送事件，就能讓在視覺化層級中實作組合的控制項處理事件或建立事件 setter。</span><span class="sxs-lookup"><span data-stu-id="34031-171">Routing events through the visual tree enables controls that implement composition at the visual level to handle events or create event setters.</span></span>  
  
<a name="trees_content"></a>   
## <a name="trees-content-elements-and-content-hosts"></a><span data-ttu-id="34031-172">樹狀結構、內容項目元素及內容主機</span><span class="sxs-lookup"><span data-stu-id="34031-172">Trees, Content Elements, and Content Hosts</span></span>  
 <span data-ttu-id="34031-173">內容項目 (衍生自類別<xref:System.Windows.ContentElement>) 不是視覺化樹狀結構的一部分; 它們不是繼承自<xref:System.Windows.Media.Visual>並沒有視覺表示法。</span><span class="sxs-lookup"><span data-stu-id="34031-173">Content elements (classes that derive from <xref:System.Windows.ContentElement>) are not part of the visual tree; they do not inherit from <xref:System.Windows.Media.Visual> and do not have a visual representation.</span></span> <span data-ttu-id="34031-174">為了能確實出現在 UI 中，<xref:System.Windows.ContentElement>必須是兩者的內容主機中裝載<xref:System.Windows.Media.Visual>和邏輯樹狀結構參與者。</span><span class="sxs-lookup"><span data-stu-id="34031-174">In order to appear in a UI at all, a <xref:System.Windows.ContentElement> must be hosted in a content host that is both a <xref:System.Windows.Media.Visual> and a logical tree participant.</span></span> <span data-ttu-id="34031-175">這類物件通常是<xref:System.Windows.FrameworkElement>。</span><span class="sxs-lookup"><span data-stu-id="34031-175">Usually such an object is a <xref:System.Windows.FrameworkElement>.</span></span> <span data-ttu-id="34031-176">您可以將內容主機想像成某些像是內容「瀏覽器」的項目，並選擇如何在主機控制的螢幕區域內顯示該內容。</span><span class="sxs-lookup"><span data-stu-id="34031-176">You can conceptualize that the content host is somewhat like a "browser" for the content and chooses how to display that content within the screen region that the host controls.</span></span> <span data-ttu-id="34031-177">裝載內容之後，該內容就可成為某些樹狀結構處理序 (通常會與視覺化樹狀結構相關聯) 中的參與者。</span><span class="sxs-lookup"><span data-stu-id="34031-177">When the content is hosted, the content can be made a participant in certain tree processes that are normally associated with the visual tree.</span></span> <span data-ttu-id="34031-178">一般而言，<xref:System.Windows.FrameworkElement>裝載類別包含實作程式碼，將任何裝載<xref:System.Windows.ContentElement>透過內容邏輯樹狀結構的子節點的事件路由，即使裝載的內容不是，則為 true 的視覺化樹狀結構的一部分。</span><span class="sxs-lookup"><span data-stu-id="34031-178">Generally, the <xref:System.Windows.FrameworkElement> host class includes implementation code that adds any hosted <xref:System.Windows.ContentElement> to the event route through subnodes of the content logical tree, even though the hosted content is not part of the true visual tree.</span></span> <span data-ttu-id="34031-179">這是必要的讓<xref:System.Windows.ContentElement>可路由傳送至本身以外的任何項目路由的事件資料來源。</span><span class="sxs-lookup"><span data-stu-id="34031-179">This is necessary so that a <xref:System.Windows.ContentElement> can source a routed event that routes to any element other than itself.</span></span>  
  
<a name="tree_traversal"></a>   
## <a name="tree-traversal"></a><span data-ttu-id="34031-180">樹狀周遊</span><span class="sxs-lookup"><span data-stu-id="34031-180">Tree Traversal</span></span>  
 <span data-ttu-id="34031-181"><xref:System.Windows.LogicalTreeHelper>類別會提供<xref:System.Windows.LogicalTreeHelper.GetChildren%2A>， <xref:System.Windows.LogicalTreeHelper.GetParent%2A>，和<xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A>周遊邏輯樹狀結構的方法。</span><span class="sxs-lookup"><span data-stu-id="34031-181">The <xref:System.Windows.LogicalTreeHelper> class provides the <xref:System.Windows.LogicalTreeHelper.GetChildren%2A>, <xref:System.Windows.LogicalTreeHelper.GetParent%2A>, and <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> methods for logical tree traversal.</span></span> <span data-ttu-id="34031-182">在大部分情況下，您應該不需要周遊現有控制項的邏輯樹狀結構，因為這些控制項幾乎都會將其邏輯子元素公開為專用的集合屬性，以支援集合存取，例如 `Add`、索引子等等。</span><span class="sxs-lookup"><span data-stu-id="34031-182">In most cases, you should not have to traverse the logical tree of existing controls, because these controls almost always expose their logical child elements as a dedicated collection property that supports collection access such as `Add`, an indexer, and so on.</span></span> <span data-ttu-id="34031-183">樹狀周遊是主要的案例，以供選擇不要將這類衍生自適用的控制項模式的控制項作者<xref:System.Windows.Controls.ItemsControl>或<xref:System.Windows.Controls.Panel>其中已經定義集合屬性，以及想要提供自己的集合屬性的支援。</span><span class="sxs-lookup"><span data-stu-id="34031-183">Tree traversal is mainly a scenario that is used by control authors who choose not to derive from intended control patterns such as <xref:System.Windows.Controls.ItemsControl> or <xref:System.Windows.Controls.Panel> where collection properties are already defined, and who intend to provide their own collection property support.</span></span>  
  
 <span data-ttu-id="34031-184">視覺化樹狀結構也支援視覺化樹狀結構周遊的 helper 類別<xref:System.Windows.Media.VisualTreeHelper>。</span><span class="sxs-lookup"><span data-stu-id="34031-184">The visual tree also supports a helper class for visual tree traversal, <xref:System.Windows.Media.VisualTreeHelper>.</span></span> <span data-ttu-id="34031-185">視覺化樹狀結構不會公開為方便地透過控制項特定屬性，因此<xref:System.Windows.Media.VisualTreeHelper>類別是周遊視覺化樹狀結構，如果是您的程式設計案例所需的建議的方式。</span><span class="sxs-lookup"><span data-stu-id="34031-185">The visual tree is not exposed as conveniently through control-specific properties, so the <xref:System.Windows.Media.VisualTreeHelper> class is the recommended way to traverse the visual tree if that is necessary for your programming scenario.</span></span> <span data-ttu-id="34031-186">如需詳細資訊，請參閱 [WPF 圖形轉譯概觀](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="34031-186">For more information, see [WPF Graphics Rendering Overview](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="34031-187">有時必須檢查所套用範本的視覺化樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="34031-187">Sometimes it is necessary to examine the visual tree of an applied template.</span></span> <span data-ttu-id="34031-188">您應該謹慎使用此技術。</span><span class="sxs-lookup"><span data-stu-id="34031-188">You should be careful when using this technique.</span></span> <span data-ttu-id="34031-189">即使您周遊的視覺化樹狀結構的控制項，您在其中定義範本，您的控制項的取用者永遠可以變更範本藉由設定<xref:System.Windows.Controls.Control.Template%2A>屬性執行個體，以及甚至使用者也可以藉由變更會影響套用的範本系統佈景主題。</span><span class="sxs-lookup"><span data-stu-id="34031-189">Even if you are traversing a visual tree for a control where you define the template, consumers of your control can always change the template by setting the <xref:System.Windows.Controls.Control.Template%2A> property on instances, and even the end user can influence the applied template by changing the system theme.</span></span>  
  
<a name="routes"></a>   
## <a name="routes-for-routed-events-as-a-tree"></a><span data-ttu-id="34031-190">路由事件的樹狀結構路由</span><span class="sxs-lookup"><span data-stu-id="34031-190">Routes for Routed Events as a "Tree"</span></span>  
 <span data-ttu-id="34031-191">如前所述，任何指定路由事件的路由是在樹狀結構中沿著預先決定的單一路徑來周遊，該樹狀結構是視覺化樹狀結構和邏輯樹狀結構表示法的混合。</span><span class="sxs-lookup"><span data-stu-id="34031-191">As mentioned before, the route of any given routed event travels along a single and predetermined path of a tree that is a hybrid of the visual and logical tree representations.</span></span> <span data-ttu-id="34031-192">依據事件路由為通道或事件反昇的路由事件而定，其會在樹狀結構內向上或向下進行周遊。</span><span class="sxs-lookup"><span data-stu-id="34031-192">The event route can travel either in the up or down directions within the tree depending on whether it is a tunneling or bubbling routed event.</span></span> <span data-ttu-id="34031-193">事件路由概念沒有直接支援的 Helper 類別可用來在事件路由上「前進」，而不管是否會引發實際路由傳送的事件。</span><span class="sxs-lookup"><span data-stu-id="34031-193">The event route concept does not have a directly supporting helper class that could be used to "walk" the event route independently of raising an event that actually routes.</span></span> <span data-ttu-id="34031-194">為代表路由的類別<xref:System.Windows.EventRoute>，但該類別的方法通常僅供內部使用。</span><span class="sxs-lookup"><span data-stu-id="34031-194">There is a class that represents the route, <xref:System.Windows.EventRoute>, but the methods of that class are generally for internal use only.</span></span>  
  
<a name="resourcesandtrees"></a>   
## <a name="resource-dictionaries-and-trees"></a><span data-ttu-id="34031-195">資源字典和樹狀目錄</span><span class="sxs-lookup"><span data-stu-id="34031-195">Resource Dictionaries and Trees</span></span>  
 <span data-ttu-id="34031-196">對於頁面中定義的所有 `Resources` 的資源字典查閱，基本上會周遊邏輯樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="34031-196">Resource dictionary lookup for all `Resources` defined in a page traverses basically the logical tree.</span></span> <span data-ttu-id="34031-197">不在邏輯樹狀結構中的物件可以參考具有索引鍵的資源，但資源查閱序列是從物件連接到邏輯樹狀結構的點開始。</span><span class="sxs-lookup"><span data-stu-id="34031-197">Objects that are not in the logical tree can reference keyed resources, but the resource lookup sequence begins at the point where that object is connected to the logical tree.</span></span> <span data-ttu-id="34031-198">在 WPF 中，只有邏輯樹狀結構節點可以有`Resources`屬性，其中包含<xref:System.Windows.ResourceDictionary>，因此沒有任何好處中周遊視覺化樹狀結構以尋找索引鍵的資源，從<xref:System.Windows.ResourceDictionary>。</span><span class="sxs-lookup"><span data-stu-id="34031-198">In WPF, only logical tree nodes can have a `Resources` property that contains a <xref:System.Windows.ResourceDictionary>, therefore there is no benefit in traversing the visual tree looking for keyed resources from a <xref:System.Windows.ResourceDictionary>.</span></span>  
  
 <span data-ttu-id="34031-199">不過，資源查閱也可以延伸至目前邏輯樹狀結構以外的地方。</span><span class="sxs-lookup"><span data-stu-id="34031-199">However, resource lookup can also extend beyond the immediate logical tree.</span></span> <span data-ttu-id="34031-200">對於應用程式標記，資源查閱可接著繼續前進到應用程式層級的資源字典，然後到做為靜態屬性或索引鍵加以參考的佈景主題支援和系統值。</span><span class="sxs-lookup"><span data-stu-id="34031-200">For application markup, the resource lookup can then continue onward to application-level resource dictionaries and then to theme support and system values that are referenced as static properties or keys.</span></span> <span data-ttu-id="34031-201">如果資源參考是動態的，則佈景主題本身也可以參考佈景主題邏輯樹狀結構以外的系統值。</span><span class="sxs-lookup"><span data-stu-id="34031-201">Themes themselves can also reference system values outside of the theme logical tree if the resource references are dynamic.</span></span> <span data-ttu-id="34031-202">如需資源字典和查閱邏輯的詳細資訊，請參閱 [XAML 資源](../../../../docs/framework/wpf/advanced/xaml-resources.md)。</span><span class="sxs-lookup"><span data-stu-id="34031-202">For more information on resource dictionaries and the lookup logic, see [XAML Resources](../../../../docs/framework/wpf/advanced/xaml-resources.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="34031-203">另請參閱</span><span class="sxs-lookup"><span data-stu-id="34031-203">See Also</span></span>  
 [<span data-ttu-id="34031-204">輸入概觀</span><span class="sxs-lookup"><span data-stu-id="34031-204">Input Overview</span></span>](../../../../docs/framework/wpf/advanced/input-overview.md)  
 [<span data-ttu-id="34031-205">WPF 圖形轉譯概觀</span><span class="sxs-lookup"><span data-stu-id="34031-205">WPF Graphics Rendering Overview</span></span>](../../../../docs/framework/wpf/graphics-multimedia/wpf-graphics-rendering-overview.md)  
 [<span data-ttu-id="34031-206">路由事件概觀</span><span class="sxs-lookup"><span data-stu-id="34031-206">Routed Events Overview</span></span>](../../../../docs/framework/wpf/advanced/routed-events-overview.md)  
 [<span data-ttu-id="34031-207">初始化物件樹狀結構以外的物件項目</span><span class="sxs-lookup"><span data-stu-id="34031-207">Initialization for Object Elements Not in an Object Tree</span></span>](../../../../docs/framework/wpf/advanced/initialization-for-object-elements-not-in-an-object-tree.md)  
 [<span data-ttu-id="34031-208">WPF 架構</span><span class="sxs-lookup"><span data-stu-id="34031-208">WPF Architecture</span></span>](../../../../docs/framework/wpf/advanced/wpf-architecture.md)
