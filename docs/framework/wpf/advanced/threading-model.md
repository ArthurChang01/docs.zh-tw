---
title: 執行緒模型
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: c74d76cf7c216ed1d4d5c0741ed0ca4f651543e0
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/28/2019
ms.locfileid: "64598629"
---
# <a name="threading-model"></a><span data-ttu-id="2949e-102">執行緒模型</span><span class="sxs-lookup"><span data-stu-id="2949e-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <span data-ttu-id="2949e-103">是設計來避免開發人員遇到執行緒的難題。</span><span class="sxs-lookup"><span data-stu-id="2949e-103">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="2949e-104">如此一來，大部分的[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]開發人員不需要撰寫介面來使用多個執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="2949e-105">由於多執行緒的程式非常複雜且很難偵錯，因此，若有單一執行緒解決方案，就應避免使用多執行緒程式。</span><span class="sxs-lookup"><span data-stu-id="2949e-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>  
  
 <span data-ttu-id="2949e-106">不論多麼完善，不過，沒有[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]framework 以往都能夠提供單一執行緒解決方案，每種問題。</span><span class="sxs-lookup"><span data-stu-id="2949e-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="2949e-107">幾乎就能做到的但仍有多個執行緒，改善的情況下[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]回應或應用程式的效能。</span><span class="sxs-lookup"><span data-stu-id="2949e-107">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="2949e-108">討論一些背景資料之後，本文將說明這其中的一些情況，然後以一些較低層級詳細資訊的討論來做出結論。</span><span class="sxs-lookup"><span data-stu-id="2949e-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>  

> [!NOTE]
>  <span data-ttu-id="2949e-109">本主題討論使用執行緒<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>非同步呼叫的方法。</span><span class="sxs-lookup"><span data-stu-id="2949e-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="2949e-110">您也可以進行非同步呼叫，藉由呼叫<xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>方法，這個方法會採用<xref:System.Action>或<xref:System.Func%601>做為參數。</span><span class="sxs-lookup"><span data-stu-id="2949e-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="2949e-111"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A>方法會傳回<xref:System.Windows.Threading.DispatcherOperation>或是<xref:System.Windows.Threading.DispatcherOperation%601>，其中包含<xref:System.Windows.Threading.DispatcherOperation.Task%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="2949e-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="2949e-112">您可以使用`await`使用關鍵字<xref:System.Windows.Threading.DispatcherOperation>或相關聯<xref:System.Threading.Tasks.Task>。</span><span class="sxs-lookup"><span data-stu-id="2949e-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="2949e-113">如果您需要同步等候<xref:System.Threading.Tasks.Task>傳回的<xref:System.Windows.Threading.DispatcherOperation>或是<xref:System.Windows.Threading.DispatcherOperation%601>，呼叫<xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A>擴充方法。</span><span class="sxs-lookup"><span data-stu-id="2949e-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="2949e-114">呼叫<xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType>會導致死結。</span><span class="sxs-lookup"><span data-stu-id="2949e-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="2949e-115">如需有關使用<xref:System.Threading.Tasks.Task>執行非同步作業，請參閱 < 工作平行處理原則。</span><span class="sxs-lookup"><span data-stu-id="2949e-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="2949e-116"><xref:System.Windows.Threading.Dispatcher.Invoke%2A>方法也會有多載<xref:System.Action>或<xref:System.Func%601>做為參數。</span><span class="sxs-lookup"><span data-stu-id="2949e-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="2949e-117">您可以使用<xref:System.Windows.Threading.Dispatcher.Invoke%2A>設為同步的方法會呼叫委派，傳入<xref:System.Action>或<xref:System.Func%601>。</span><span class="sxs-lookup"><span data-stu-id="2949e-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>  
  
<a name="threading_overview"></a>   
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="2949e-118">概觀和發送器</span><span class="sxs-lookup"><span data-stu-id="2949e-118">Overview and the Dispatcher</span></span>  
 <span data-ttu-id="2949e-119">通常[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]應用程式的開頭的兩個執行緒： 一個用來處理轉譯，另一個用於管理[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="2949e-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="2949e-120">呈現執行緒實際上會隱藏執行背景工作，而在[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒會接收輸入、 處理事件、 繪製畫面，並執行應用程式程式碼。</span><span class="sxs-lookup"><span data-stu-id="2949e-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="2949e-121">大部分的應用程式使用單一[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒，但在某些情況下最好是使用數種。</span><span class="sxs-lookup"><span data-stu-id="2949e-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="2949e-122">我們稍後將使用範例來討論這一點。</span><span class="sxs-lookup"><span data-stu-id="2949e-122">We’ll discuss this with an example later.</span></span>  
  
 <span data-ttu-id="2949e-123">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒佇列工作呼叫的物件內的項目<xref:System.Windows.Threading.Dispatcher>。</span><span class="sxs-lookup"><span data-stu-id="2949e-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="2949e-124"><xref:System.Windows.Threading.Dispatcher> 會依優先權選取工作項目，並逐一執行以完成每個工作項目。</span><span class="sxs-lookup"><span data-stu-id="2949e-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="2949e-125">每隔[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒必須至少一個<xref:System.Windows.Threading.Dispatcher>，而且每個<xref:System.Windows.Threading.Dispatcher>可以在一個執行緒中執行的工作項目。</span><span class="sxs-lookup"><span data-stu-id="2949e-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>  
  
 <span data-ttu-id="2949e-126">建置回應靈敏且容易使用的應用程式的技巧是要最大化<xref:System.Windows.Threading.Dispatcher>輸送量保留小的工作項目。</span><span class="sxs-lookup"><span data-stu-id="2949e-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="2949e-127">此方法的項目永遠不會取得過時坐在<xref:System.Windows.Threading.Dispatcher>佇列等候處理。</span><span class="sxs-lookup"><span data-stu-id="2949e-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="2949e-128">輸入與回應之間任何可察覺到的延遲都能讓使用者感到挫折。</span><span class="sxs-lookup"><span data-stu-id="2949e-128">Any perceivable delay between input and response can frustrate a user.</span></span>  
  
 <span data-ttu-id="2949e-129">如何則[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]應用程式應該要處理大量作業？</span><span class="sxs-lookup"><span data-stu-id="2949e-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="2949e-130">如果您的程式碼牽涉到大型計算，或需要查詢某些遠端伺服器上的資料庫，又該怎麼做？</span><span class="sxs-lookup"><span data-stu-id="2949e-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="2949e-131">通常，答案是處理大型作業，在個別的執行緒，離開[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒可用來照料中的項目<xref:System.Windows.Threading.Dispatcher>佇列。</span><span class="sxs-lookup"><span data-stu-id="2949e-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="2949e-132">完成大型作業時，它可以報告其結果傳回給[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]顯示的執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>  
  
 <span data-ttu-id="2949e-133">在過去，[!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)]可讓[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]只能由建立它們的執行緒存取的項目。</span><span class="sxs-lookup"><span data-stu-id="2949e-133">Historically, [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="2949e-134">這表示負責某些長時間執行工作的背景執行緒無法在完成時更新文字方塊。</span><span class="sxs-lookup"><span data-stu-id="2949e-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] <span data-ttu-id="2949e-135">這麼做以確保完整性[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]元件。</span><span class="sxs-lookup"><span data-stu-id="2949e-135">does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="2949e-136">如果背景執行緒已在繪製期間更新了清單方塊的內容，則該清單方塊看起來可能很奇怪。</span><span class="sxs-lookup"><span data-stu-id="2949e-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="2949e-137">有個內建的互斥機制，會強制執行這項協調。</span><span class="sxs-lookup"><span data-stu-id="2949e-137">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="2949e-138">中的大部分類別[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]衍生自<xref:System.Windows.Threading.DispatcherObject>。</span><span class="sxs-lookup"><span data-stu-id="2949e-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="2949e-139">在建構，<xref:System.Windows.Threading.DispatcherObject>儲存的參考<xref:System.Windows.Threading.Dispatcher>連結至目前執行的執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="2949e-140">實際上，<xref:System.Windows.Threading.DispatcherObject>與建立它的執行緒產生關聯。</span><span class="sxs-lookup"><span data-stu-id="2949e-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="2949e-141">在程式執行期間<xref:System.Windows.Threading.DispatcherObject>可以呼叫其公用<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="2949e-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="2949e-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 會檢查<xref:System.Windows.Threading.Dispatcher>與目前執行緒相關聯，並比較它<xref:System.Windows.Threading.Dispatcher>建構期間儲存的參考。</span><span class="sxs-lookup"><span data-stu-id="2949e-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="2949e-143">如果兩者不符，<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A>擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="2949e-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="2949e-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 要在屬於每個方法的開頭呼叫<xref:System.Windows.Threading.DispatcherObject>。</span><span class="sxs-lookup"><span data-stu-id="2949e-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>  
  
 <span data-ttu-id="2949e-145">如果只有一個執行緒可以修改[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]，如何執行背景執行緒與使用者互動？</span><span class="sxs-lookup"><span data-stu-id="2949e-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="2949e-146">背景執行緒可以要求[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行的作業，其代表的執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="2949e-147">其運作方式是註冊的工作項目<xref:System.Windows.Threading.Dispatcher>的[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="2949e-148"><xref:System.Windows.Threading.Dispatcher>類別提供兩種方法來註冊工作項目：<xref:System.Windows.Threading.Dispatcher.Invoke%2A>和<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</span><span class="sxs-lookup"><span data-stu-id="2949e-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="2949e-149">這兩種方法都會排程要執行的委派。</span><span class="sxs-lookup"><span data-stu-id="2949e-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="2949e-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步呼叫 – 也就是它不會傳回之前[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒實際完成執行委派。</span><span class="sxs-lookup"><span data-stu-id="2949e-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="2949e-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 為非同步作業，並立即傳回。</span><span class="sxs-lookup"><span data-stu-id="2949e-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>  
  
 <span data-ttu-id="2949e-152"><xref:System.Windows.Threading.Dispatcher>依優先順序排序其佇列中的項目。</span><span class="sxs-lookup"><span data-stu-id="2949e-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="2949e-153">有可能會將元素加入時指定的十個層級<xref:System.Windows.Threading.Dispatcher>佇列。</span><span class="sxs-lookup"><span data-stu-id="2949e-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="2949e-154">這些優先順序會保存在<xref:System.Windows.Threading.DispatcherPriority>列舉型別。</span><span class="sxs-lookup"><span data-stu-id="2949e-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="2949e-155">詳細資訊<xref:System.Windows.Threading.DispatcherPriority>層級可在[!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)]文件。</span><span class="sxs-lookup"><span data-stu-id="2949e-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the [!INCLUDE[TLA2#tla_winfxsdk](../../../../includes/tla2sharptla-winfxsdk-md.md)] documentation.</span></span>  
  
<a name="samples"></a>   
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="2949e-156">執行中的執行緒：範例</span><span class="sxs-lookup"><span data-stu-id="2949e-156">Threads in Action: The Samples</span></span>  
  
<a name="prime_number"></a>   
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="2949e-157">單一執行緒應用程式與長時間執行的計算</span><span class="sxs-lookup"><span data-stu-id="2949e-157">A Single-Threaded Application with a Long-Running Calculation</span></span>  
 <span data-ttu-id="2949e-158">大部分[!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)]花費相當可觀的時間處於閒置狀態，等待為了回應使用者互動所產生的事件。</span><span class="sxs-lookup"><span data-stu-id="2949e-158">Most [!INCLUDE[TLA#tla_gui#plural](../../../../includes/tlasharptla-guisharpplural-md.md)] spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="2949e-159">透過嚴謹的程式設計此閒置的時間可以使用具建設性的方式，而不會影響的回應能力[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="2949e-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="2949e-160">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]執行緒模型不允許輸入中斷中所發生的作業[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="2949e-161">這表示您必須確定以返回<xref:System.Windows.Threading.Dispatcher>定期至暫止的變過時之前的輸入事件的處理序。</span><span class="sxs-lookup"><span data-stu-id="2949e-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>  
  
 <span data-ttu-id="2949e-162">參考下列範例：</span><span class="sxs-lookup"><span data-stu-id="2949e-162">Consider the following example:</span></span>  
  
 ![如果螢幕擷取畫面顯示質數的執行緒。](./media/threading-model/threading-prime-numbers.png)  
  
 <span data-ttu-id="2949e-164">這個簡單的應用程式會從三開始向上計算，以搜尋質數。</span><span class="sxs-lookup"><span data-stu-id="2949e-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="2949e-165">當使用者按一下**啟動** 按鈕，開始搜尋。</span><span class="sxs-lookup"><span data-stu-id="2949e-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="2949e-166">當程式找到質數時，會使用它的發現來更新使用者介面。</span><span class="sxs-lookup"><span data-stu-id="2949e-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="2949e-167">使用者隨時都能停止搜尋。</span><span class="sxs-lookup"><span data-stu-id="2949e-167">At any point, the user can stop the search.</span></span>  
  
 <span data-ttu-id="2949e-168">雖然夠簡單，但質數搜尋會永無止盡的繼續執行，其中會遇到一些難題。</span><span class="sxs-lookup"><span data-stu-id="2949e-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="2949e-169">如果我們處理整個搜尋按鈕的 click 事件處理常式內，我們永遠不會想讓[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒有機會處理其他事件。</span><span class="sxs-lookup"><span data-stu-id="2949e-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="2949e-170">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]無法輸入或處理回應訊息。</span><span class="sxs-lookup"><span data-stu-id="2949e-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="2949e-171">它永遠不會重新繪製，而且永遠不會回應按鈕 Click。</span><span class="sxs-lookup"><span data-stu-id="2949e-171">It would never repaint and never respond to button clicks.</span></span>  
  
 <span data-ttu-id="2949e-172">我們可以在個別執行緒中管理質數搜尋，但接著需要處理同步問題。</span><span class="sxs-lookup"><span data-stu-id="2949e-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="2949e-173">使用單一執行緒的方法，我們可以直接更新標籤，以列出所找到的最大質數。</span><span class="sxs-lookup"><span data-stu-id="2949e-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>  
  
 <span data-ttu-id="2949e-174">如果我們分解成可管理的區塊的計算的工作時，我們可以定期返回<xref:System.Windows.Threading.Dispatcher>和處理事件。</span><span class="sxs-lookup"><span data-stu-id="2949e-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="2949e-175">我們可以提供給[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]有機會重新繪製並處理輸入。</span><span class="sxs-lookup"><span data-stu-id="2949e-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>  
  
 <span data-ttu-id="2949e-176">若要計算和事件處理之間分割處理時間，最好是管理計算從<xref:System.Windows.Threading.Dispatcher>。</span><span class="sxs-lookup"><span data-stu-id="2949e-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="2949e-177">藉由使用<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>方法中，我們可以排程質數檢查，在相同佇列[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]取自 < 事件。</span><span class="sxs-lookup"><span data-stu-id="2949e-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="2949e-178">在範例中，我們一次只會排程單一質數檢查。</span><span class="sxs-lookup"><span data-stu-id="2949e-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="2949e-179">質數檢查完成之後，我們會立即排程下次檢查。</span><span class="sxs-lookup"><span data-stu-id="2949e-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="2949e-180">這項檢查之後才會繼續暫止[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]已處理事件。</span><span class="sxs-lookup"><span data-stu-id="2949e-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>  
  
 ![如果螢幕擷取畫面顯示發送器佇列。](./media/threading-model/threading-dispatcher-queue.png)  
  
 [!INCLUDE[TLA#tla_word](../../../../includes/tlasharptla-word-md.md)] <span data-ttu-id="2949e-182">會使用這項機制來完成拼字檢查。</span><span class="sxs-lookup"><span data-stu-id="2949e-182">accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="2949e-183">拼字檢查是在背景中使用的閒置時間[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="2949e-184">讓我們看看程式碼。</span><span class="sxs-lookup"><span data-stu-id="2949e-184">Let's take a look at the code.</span></span>  
  
 <span data-ttu-id="2949e-185">下列範例顯示建立使用者介面的 XAML。</span><span class="sxs-lookup"><span data-stu-id="2949e-185">The following example shows the XAML that creates the user interface.</span></span>  
  
 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]  
  
 <span data-ttu-id="2949e-186">下列範例顯示程式碼後置。</span><span class="sxs-lookup"><span data-stu-id="2949e-186">The following example shows the code-behind.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]  
  
 <span data-ttu-id="2949e-187">下列範例顯示的事件處理常式<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="2949e-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]  
  
 <span data-ttu-id="2949e-188">除了上更新的文字<xref:System.Windows.Controls.Button>，此處理常式會負責排程第一個質數檢查加入的委派<xref:System.Windows.Threading.Dispatcher>佇列。</span><span class="sxs-lookup"><span data-stu-id="2949e-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="2949e-189">有時之後這個事件處理常式已完成其工作，,<xref:System.Windows.Threading.Dispatcher>會選擇執行這個委派。</span><span class="sxs-lookup"><span data-stu-id="2949e-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>  
  
 <span data-ttu-id="2949e-190">如稍早所述<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>是<xref:System.Windows.Threading.Dispatcher>成員用來排程執行的委派。</span><span class="sxs-lookup"><span data-stu-id="2949e-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="2949e-191">在此情況下，我們選擇<xref:System.Windows.Threading.DispatcherPriority.SystemIdle>優先順序。</span><span class="sxs-lookup"><span data-stu-id="2949e-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="2949e-192"><xref:System.Windows.Threading.Dispatcher>只時沒有任何重要的事件處理時，才會執行這個委派。</span><span class="sxs-lookup"><span data-stu-id="2949e-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] <span data-ttu-id="2949e-193">回應性比數字檢查更重要。</span><span class="sxs-lookup"><span data-stu-id="2949e-193">responsiveness is more important than number checking.</span></span> <span data-ttu-id="2949e-194">我們也會傳遞新的委派來代表數字檢查常式。</span><span class="sxs-lookup"><span data-stu-id="2949e-194">We also pass a new delegate representing the number-checking routine.</span></span>  
  
 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]  
  
 <span data-ttu-id="2949e-195">這個方法會檢查下一個奇數是否為質數。</span><span class="sxs-lookup"><span data-stu-id="2949e-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="2949e-196">如果是質數，此方法來直接更新`bigPrime`<xref:System.Windows.Controls.TextBlock>以反映它的發現。</span><span class="sxs-lookup"><span data-stu-id="2949e-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="2949e-197">由於計算會發生在用來建立元件的相同執行緒中，因此我們可以執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="2949e-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="2949e-198">我們已選擇使用個別的執行緒進行計算，我們必須使用更複雜的同步處理機制，並執行中的更新[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="2949e-199">接下來我們將示範這種情況。</span><span class="sxs-lookup"><span data-stu-id="2949e-199">We’ll demonstrate this situation next.</span></span>  
  
 <span data-ttu-id="2949e-200">此範例的完整原始程式碼，請參閱[單一執行緒應用程式與長時間執行的計算範例](https://go.microsoft.com/fwlink/?LinkID=160038)</span><span class="sxs-lookup"><span data-stu-id="2949e-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://go.microsoft.com/fwlink/?LinkID=160038)</span></span>  
  
<a name="weather_sim"></a>   
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="2949e-201">利用背景執行緒處理封鎖作業</span><span class="sxs-lookup"><span data-stu-id="2949e-201">Handling a Blocking Operation with a Background Thread</span></span>  
 <span data-ttu-id="2949e-202">處理圖形應用程式中的封鎖作業可能很困難。</span><span class="sxs-lookup"><span data-stu-id="2949e-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="2949e-203">我們不想從事件處理常式中呼叫封鎖方法，因為應用程式將呈現凍結狀態。</span><span class="sxs-lookup"><span data-stu-id="2949e-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="2949e-204">我們可以使用個別的執行緒來處理這些作業，但是當我們完成時，我們有與同步處理[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒因為我們無法直接修改[!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)]從背景工作執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the [!INCLUDE[TLA2#tla_gui](../../../../includes/tla2sharptla-gui-md.md)] from our worker thread.</span></span> <span data-ttu-id="2949e-205">我們可以使用<xref:System.Windows.Threading.Dispatcher.Invoke%2A>或是<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>插入到委派<xref:System.Windows.Threading.Dispatcher>的[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="2949e-206">最後，這些委派將會執行與修改權限[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]項目。</span><span class="sxs-lookup"><span data-stu-id="2949e-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>  
  
 <span data-ttu-id="2949e-207">在此範例中，我們模仿遠端程序呼叫來擷取氣象預報。</span><span class="sxs-lookup"><span data-stu-id="2949e-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="2949e-208">我們使用不同的背景工作執行緒來執行此呼叫中，和我們排程更新方法中的<xref:System.Windows.Threading.Dispatcher>的[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒完成時。</span><span class="sxs-lookup"><span data-stu-id="2949e-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>  
  
 ![如果螢幕擷取畫面顯示天氣 UI。](./media/threading-model/threading-weather-ui.png)  
  
 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]  
  
 <span data-ttu-id="2949e-210">以下是一些要注意的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="2949e-210">The following are some of the details to be noted.</span></span>  
  
- <span data-ttu-id="2949e-211">建立按鈕處理常式</span><span class="sxs-lookup"><span data-stu-id="2949e-211">Creating the Button Handler</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]  
  
 <span data-ttu-id="2949e-212">按一下按鈕時，我們會顯示時鐘圖案並開始以動畫顯示它。</span><span class="sxs-lookup"><span data-stu-id="2949e-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="2949e-213">我們停用按鈕。</span><span class="sxs-lookup"><span data-stu-id="2949e-213">We disable the button.</span></span> <span data-ttu-id="2949e-214">我們叫用`FetchWeatherFromServer`方法，在新的執行緒，然後傳回，讓<xref:System.Windows.Threading.Dispatcher>處理事件，同時等候收集氣象預報。</span><span class="sxs-lookup"><span data-stu-id="2949e-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>  
  
- <span data-ttu-id="2949e-215">擷取氣象</span><span class="sxs-lookup"><span data-stu-id="2949e-215">Fetching the Weather</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]  
  
 <span data-ttu-id="2949e-216">為了簡單起見，我們並未在此範例中實際使用任何網路程式碼。</span><span class="sxs-lookup"><span data-stu-id="2949e-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="2949e-217">相反地，我們讓新的執行緒進入睡眠狀態 4 秒，藉以模擬網路存取延遲。</span><span class="sxs-lookup"><span data-stu-id="2949e-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="2949e-218">在此期間，原始[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒仍執行和回應事件。</span><span class="sxs-lookup"><span data-stu-id="2949e-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="2949e-219">為了顯示此情況，我們讓動畫持續執行，並讓最小化及最大化按鈕也能繼續運作。</span><span class="sxs-lookup"><span data-stu-id="2949e-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>  
  
 <span data-ttu-id="2949e-220">當延遲完成時，我們已隨機選取氣象預報，是時候回報給[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="2949e-221">執行此作業，排程呼叫`UpdateUserInterface`中[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]使用該執行緒的執行緒<xref:System.Windows.Threading.Dispatcher>。</span><span class="sxs-lookup"><span data-stu-id="2949e-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="2949e-222">我們將描述氣象的字串傳遞到這個排程的方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="2949e-222">We pass a string describing the weather to this scheduled method call.</span></span>  
  
- <span data-ttu-id="2949e-223">正在更新 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="2949e-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>  
  
     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]  
  
 <span data-ttu-id="2949e-224">當<xref:System.Windows.Threading.Dispatcher>中[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒有時間時，它會執行排程的呼叫`UpdateUserInterface`。</span><span class="sxs-lookup"><span data-stu-id="2949e-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="2949e-225">這個方法會停止時鐘動畫，並選擇影像來說明氣象。</span><span class="sxs-lookup"><span data-stu-id="2949e-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="2949e-226">它會顯示此影像，並還原 [Fetch Forecast (擷取預報)] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="2949e-226">It displays this image and restores the "fetch forecast" button.</span></span>  
  
<a name="multi_browser"></a>   
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="2949e-227">多個視窗，多個執行緒</span><span class="sxs-lookup"><span data-stu-id="2949e-227">Multiple Windows, Multiple Threads</span></span>  
 <span data-ttu-id="2949e-228">某些[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]應用程式需要多個最上層視窗。</span><span class="sxs-lookup"><span data-stu-id="2949e-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="2949e-229">它是完全可接受的一個執行緒 /<xref:System.Windows.Threading.Dispatcher>組合來管理多個視窗，但有時也有數個執行緒工作表現較佳。</span><span class="sxs-lookup"><span data-stu-id="2949e-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="2949e-230">如果有可能發生某一個視窗將獨佔執行緒的情況，這特別適用。</span><span class="sxs-lookup"><span data-stu-id="2949e-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>  
  
 [!INCLUDE[TLA#tla_mswin](../../../../includes/tlasharptla-mswin-md.md)] <span data-ttu-id="2949e-231">檔案總管會以這種方式運作。</span><span class="sxs-lookup"><span data-stu-id="2949e-231">Explorer works in this fashion.</span></span> <span data-ttu-id="2949e-232">每個新的檔案總管視窗都屬於原始的程序，但會在獨立執行緒的控制下建立它。</span><span class="sxs-lookup"><span data-stu-id="2949e-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>  
  
 <span data-ttu-id="2949e-233">藉由使用[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame>控制項，即可顯示網頁。</span><span class="sxs-lookup"><span data-stu-id="2949e-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="2949e-234">我們可以輕鬆地建立簡單[!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)]取代。</span><span class="sxs-lookup"><span data-stu-id="2949e-234">We can easily create a simple [!INCLUDE[TLA2#tla_ie](../../../../includes/tla2sharptla-ie-md.md)] substitute.</span></span> <span data-ttu-id="2949e-235">我們從一個重要功能開始︰開啟新檔案總管視窗的能力。</span><span class="sxs-lookup"><span data-stu-id="2949e-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="2949e-236">當使用者按一下 [New Window (新視窗)] 按鈕時，我們會在另一個執行緒中啟動視窗複本。</span><span class="sxs-lookup"><span data-stu-id="2949e-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="2949e-237">如此一來，在其中一個視窗中長時間執行或封鎖的作業就不會鎖定所有其他視窗。</span><span class="sxs-lookup"><span data-stu-id="2949e-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>  
  
 <span data-ttu-id="2949e-238">事實上，網頁瀏覽器模型有它自己的複雜執行緒模型。</span><span class="sxs-lookup"><span data-stu-id="2949e-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="2949e-239">我們選擇它是因為大多數讀者應該都已熟悉它。</span><span class="sxs-lookup"><span data-stu-id="2949e-239">We’ve chosen it because it should be familiar to most readers.</span></span>  
  
 <span data-ttu-id="2949e-240">下列範例顯示此程式碼。</span><span class="sxs-lookup"><span data-stu-id="2949e-240">The following example shows the code.</span></span>  
  
 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]  
  
 <span data-ttu-id="2949e-241">此程式碼的下列執行緒區段是我們在此內容中最感興趣的部分：</span><span class="sxs-lookup"><span data-stu-id="2949e-241">The following threading segments of this code are the most interesting to us in this context:</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]  
  
 <span data-ttu-id="2949e-242">按下 [New Window (新視窗)] 按鈕時會呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="2949e-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="2949e-243">它會建立新的執行緒，並以非同步方式啟動它。</span><span class="sxs-lookup"><span data-stu-id="2949e-243">It creates a new thread and starts it asynchronously.</span></span>  
  
 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]  
  
 <span data-ttu-id="2949e-244">這個方法是新執行緒的起點。</span><span class="sxs-lookup"><span data-stu-id="2949e-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="2949e-245">我們在此執行緒的控制下建立新視窗。</span><span class="sxs-lookup"><span data-stu-id="2949e-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="2949e-246">自動建立新<xref:System.Windows.Threading.Dispatcher>來管理新的執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-246">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="2949e-247">我們要如何讓視窗運作是開始<xref:System.Windows.Threading.Dispatcher>。</span><span class="sxs-lookup"><span data-stu-id="2949e-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>  
  
<a name="stumbling_points"></a>   
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="2949e-248">技術詳細資料與困難點</span><span class="sxs-lookup"><span data-stu-id="2949e-248">Technical Details and Stumbling Points</span></span>  
  
### <a name="writing-components-using-threading"></a><span data-ttu-id="2949e-249">使用執行緒撰寫元件</span><span class="sxs-lookup"><span data-stu-id="2949e-249">Writing Components Using Threading</span></span>  
 <span data-ttu-id="2949e-250">Microsoft.NET Framework 開發人員指南 》 說明元件如何公開給其用戶端的非同步行為的模式 (請參閱[事件架構非同步模式概觀](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md))。</span><span class="sxs-lookup"><span data-stu-id="2949e-250">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="2949e-251">比方說，假設您想要封裝`FetchWeatherFromServer`成可重複使用的非圖形元件的方法。</span><span class="sxs-lookup"><span data-stu-id="2949e-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="2949e-252">下列標準的 Microsoft.NET Framework 模式，這看起來像下面這樣。</span><span class="sxs-lookup"><span data-stu-id="2949e-252">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]  
  
 <span data-ttu-id="2949e-253">`GetWeatherAsync` 會使用上述其中一種技術 (例如建立背景執行緒)，以非同步方式執行工作，而不需封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>  
  
 <span data-ttu-id="2949e-254">其中最重要的組件，此模式會呼叫*MethodName* `Completed`方法呼叫的相同執行緒上*MethodName* `Async`開頭的方法。</span><span class="sxs-lookup"><span data-stu-id="2949e-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="2949e-255">您可以使用執行此[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]相當輕鬆地透過儲存<xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>— 但再接下來非圖形元件可能只可用於[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]應用程式，不是在[!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)]或[!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)]程式。</span><span class="sxs-lookup"><span data-stu-id="2949e-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] programs.</span></span>  
  
 <span data-ttu-id="2949e-256"><xref:System.Windows.Threading.DispatcherSynchronizationContext>類別會處理這項需求，把它想成一個簡化版的<xref:System.Windows.Threading.Dispatcher>適用於其他[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]以及架構。</span><span class="sxs-lookup"><span data-stu-id="2949e-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>  
  
 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]  
  
### <a name="nested-pumping"></a><span data-ttu-id="2949e-257">巢狀提取</span><span class="sxs-lookup"><span data-stu-id="2949e-257">Nested Pumping</span></span>  
 <span data-ttu-id="2949e-258">有時不可行完全鎖[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="2949e-259">我們來看一下<xref:System.Windows.MessageBox.Show%2A>方法的<xref:System.Windows.MessageBox>類別。</span><span class="sxs-lookup"><span data-stu-id="2949e-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="2949e-260"><xref:System.Windows.MessageBox.Show%2A> 不會傳回，直到使用者按一下 [確定] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="2949e-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="2949e-261">不過，它會建立必須有訊息迴圈才能互動的視窗。</span><span class="sxs-lookup"><span data-stu-id="2949e-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="2949e-262">雖然我們正在等待使用者按下 [OK (確定)]，但原始的應用程式視窗並不會回應使用者輸入。</span><span class="sxs-lookup"><span data-stu-id="2949e-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="2949e-263">不過，它會繼續處理繪製訊息。</span><span class="sxs-lookup"><span data-stu-id="2949e-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="2949e-264">原始視窗會在涵蓋並顯示時自行重新繪製。</span><span class="sxs-lookup"><span data-stu-id="2949e-264">The original window redraws itself when covered and revealed.</span></span>  
  
 ![顯示 [確定] 按鈕的 MessageBox 螢幕擷取畫面](./media/threading-model/threading-message-loop.png)  
  
 <span data-ttu-id="2949e-266">有些執行緒必須負責訊息方塊視窗。</span><span class="sxs-lookup"><span data-stu-id="2949e-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="2949e-267">只會針對訊息方塊視窗建立新的執行緒，但這個執行緒無法在原始視窗中繪製已停用的元素 (請記住先前討論過的互斥)。</span><span class="sxs-lookup"><span data-stu-id="2949e-267">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="2949e-268">相反地，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]使用巢狀的訊息處理系統。</span><span class="sxs-lookup"><span data-stu-id="2949e-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="2949e-269"><xref:System.Windows.Threading.Dispatcher>類別包含呼叫的特殊方法<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>，這會將儲存應用程式的目前執行點再開始新的訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="2949e-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="2949e-270">巢狀的訊息迴圈完成時，原始之後繼續執行<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>呼叫。</span><span class="sxs-lookup"><span data-stu-id="2949e-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>  
  
 <span data-ttu-id="2949e-271">在此情況下，<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>維護程式內容，在對<xref:System.Windows.MessageBox>。<xref:System.Windows.MessageBox.Show%2A>，然後啟動新的訊息迴圈，以重新繪製背景視窗，並處理輸入訊息方塊視窗。</span><span class="sxs-lookup"><span data-stu-id="2949e-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox>.<xref:System.Windows.MessageBox.Show%2A>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="2949e-272">當使用者按一下 [確定]，並清除快顯視窗中時，巢狀的迴圈會結束作業，並在呼叫之後，繼續控制<xref:System.Windows.MessageBox.Show%2A>。</span><span class="sxs-lookup"><span data-stu-id="2949e-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>  
  
### <a name="stale-routed-events"></a><span data-ttu-id="2949e-273">過時的路由事件</span><span class="sxs-lookup"><span data-stu-id="2949e-273">Stale Routed Events</span></span>  
 <span data-ttu-id="2949e-274">中的路由的事件系統[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]引發事件時通知整個樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="2949e-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>  
  
 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]  
  
 <span data-ttu-id="2949e-275">當在橢圓形上按下滑鼠左的按鈕`handler2`執行。</span><span class="sxs-lookup"><span data-stu-id="2949e-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="2949e-276">在後`handler2`完成時，事件傳遞到<xref:System.Windows.Controls.Canvas>物件，它會使用`handler1`來處理它。</span><span class="sxs-lookup"><span data-stu-id="2949e-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="2949e-277">只有當此時`handler2`未明確地將標記事件的物件為已處理。</span><span class="sxs-lookup"><span data-stu-id="2949e-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>  
  
 <span data-ttu-id="2949e-278">可能的`handler2`需要大量時間來處理此事件。</span><span class="sxs-lookup"><span data-stu-id="2949e-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="2949e-279">`handler2` 可能會使用<xref:System.Windows.Threading.Dispatcher.PushFrame%2A>開始小時不會傳回巢狀的訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="2949e-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="2949e-280">如果`handler2`未的標記的事件處理此訊息迴圈完成，即使它已經很舊樹狀結構中向上傳遞事件。</span><span class="sxs-lookup"><span data-stu-id="2949e-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>  
  
### <a name="reentrancy-and-locking"></a><span data-ttu-id="2949e-281">重新進入和鎖定</span><span class="sxs-lookup"><span data-stu-id="2949e-281">Reentrancy and Locking</span></span>  
 <span data-ttu-id="2949e-282">鎖定機制的[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]不一樣人們想像; 人們可能預期執行緒要求鎖定時完全停止作業。</span><span class="sxs-lookup"><span data-stu-id="2949e-282">The locking mechanism of the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="2949e-283">實際上，執行緒會繼續接收和處理高優先順序的訊息。</span><span class="sxs-lookup"><span data-stu-id="2949e-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="2949e-284">這有助於防止發生鎖死，並讓介面進行最低限度的回應，但它也會造成發生輕微 Bug 的可能性。</span><span class="sxs-lookup"><span data-stu-id="2949e-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="2949e-285">大部分的時間，您不需要知道的任何項目，這個問題，但在罕見的情況下 (通常涉及[!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)]視窗訊息或 COM STA 元件) 這很值得一提。</span><span class="sxs-lookup"><span data-stu-id="2949e-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving [!INCLUDE[TLA2#tla_win32](../../../../includes/tla2sharptla-win32-md.md)] window messages or COM STA components) this can be worth knowing.</span></span>  
  
 <span data-ttu-id="2949e-286">因為開發人員在工作時假設不大部分介面建立的執行緒安全，記住，[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]永遠不會由多個執行緒存取。</span><span class="sxs-lookup"><span data-stu-id="2949e-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="2949e-287">在此情況下，單一執行緒，可能會非預期的時間進行環境變更導致這些格式不會影響，<xref:System.Windows.Threading.DispatcherObject>互斥機制應解決。</span><span class="sxs-lookup"><span data-stu-id="2949e-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="2949e-288">請考慮下列虛擬程式碼：</span><span class="sxs-lookup"><span data-stu-id="2949e-288">Consider the following pseudocode:</span></span>  
  
 <span data-ttu-id="2949e-289">![以圖表顯示執行緒重新進入。](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="2949e-289">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>  
  
 <span data-ttu-id="2949e-290">大部分的情況，是正確的但有些時候在[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]其中這類未預期的重新進入真正會造成問題。</span><span class="sxs-lookup"><span data-stu-id="2949e-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="2949e-291">因此，在某些關鍵的時間[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]呼叫<xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>，如此會變更使用該執行緒的鎖定指示[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]重新進入的鎖定，而非平常[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]鎖定。</span><span class="sxs-lookup"><span data-stu-id="2949e-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] lock.</span></span>  
  
 <span data-ttu-id="2949e-292">那麼，為什麼未[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]小組選擇這種行為？</span><span class="sxs-lookup"><span data-stu-id="2949e-292">So why did the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team choose this behavior?</span></span> <span data-ttu-id="2949e-293">它必須使用 STA COM 物件和完成項執行緒來執行。</span><span class="sxs-lookup"><span data-stu-id="2949e-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="2949e-294">當物件回收時，其`Finalize`方法是在執行緒上執行專屬的完成項，不[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="2949e-295">其中發生了問題，因為 COM STA 物件上建立[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒只上加以處置[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒。</span><span class="sxs-lookup"><span data-stu-id="2949e-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="2949e-296">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]相當於<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>(在此情況下使用 Win32 的`SendMessage`)。</span><span class="sxs-lookup"><span data-stu-id="2949e-296">The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="2949e-297">但是如果[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]執行緒正忙著、 完成項執行緒已停止和 COM STA 物件無法處置，它會建立嚴重的記憶體流失。</span><span class="sxs-lookup"><span data-stu-id="2949e-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="2949e-298">因此[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]小組做出了艱難的進行鎖定的運作方式一樣。</span><span class="sxs-lookup"><span data-stu-id="2949e-298">So the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] team made the tough call to make locks work the way they do.</span></span>  
  
 <span data-ttu-id="2949e-299">工作[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]是為了避免非預期的重新進入沒有引入記憶體流失，這就是為什麼我們不會封鎖所有位置的重新進入。</span><span class="sxs-lookup"><span data-stu-id="2949e-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="2949e-300">另請參閱</span><span class="sxs-lookup"><span data-stu-id="2949e-300">See also</span></span>

- [<span data-ttu-id="2949e-301">單一執行緒應用程式與長期執行的計算範例</span><span class="sxs-lookup"><span data-stu-id="2949e-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://go.microsoft.com/fwlink/?LinkID=160038)
