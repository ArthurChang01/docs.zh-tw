---
title: 執行緒模型
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- text on buttons [WPF], updating
- message processing [WPF], nested
- blocking operations [WPF]
- Common Language Runtime (CLR), locking mechanism
- locking mechanism of Common Language Runtime (CLR)
- threading model [WPF]
- Word [WPF], spelling checking
- button text [WPF], updating
- spelling checking in Word [WPF]
- asynchronous behavior [WPF], exposing
- nested message processing [WPF]
- reentrancy [WPF]
ms.assetid: 02d8fd00-8d7c-4604-874c-58e40786770b
ms.openlocfilehash: 87dcfa22bcce730c5a9b61721c3a846a08146475
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/09/2020
ms.locfileid: "77094497"
---
# <a name="threading-model"></a><span data-ttu-id="0f532-102">執行緒模型</span><span class="sxs-lookup"><span data-stu-id="0f532-102">Threading Model</span></span>
[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <span data-ttu-id="0f532-103">是設計來避免開發人員遇到執行緒的難題。</span><span class="sxs-lookup"><span data-stu-id="0f532-103">is designed to save developers from the difficulties of threading.</span></span> <span data-ttu-id="0f532-104">因此，大部分的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 開發人員都不需要撰寫使用一個以上執行緒的介面。</span><span class="sxs-lookup"><span data-stu-id="0f532-104">As a result, the majority of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] developers won't have to write an interface that uses more than one thread.</span></span> <span data-ttu-id="0f532-105">由於多執行緒的程式非常複雜且很難偵錯，因此，若有單一執行緒解決方案，就應避免使用多執行緒程式。</span><span class="sxs-lookup"><span data-stu-id="0f532-105">Because multithreaded programs are complex and difficult to debug, they should be avoided when single-threaded solutions exist.</span></span>

 <span data-ttu-id="0f532-106">不過，無論架構的結構如何，都不 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 架構也能夠為每種問題提供單一執行緒的解決方案。</span><span class="sxs-lookup"><span data-stu-id="0f532-106">No matter how well architected, however, no [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] framework will ever be able to provide a single-threaded solution for every sort of problem.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="0f532-107">已關閉，但仍有多個執行緒改善 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] 回應性或應用程式效能的情況。</span><span class="sxs-lookup"><span data-stu-id="0f532-107">comes close, but there are still situations where multiple threads improve [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] responsiveness or application performance.</span></span> <span data-ttu-id="0f532-108">討論一些背景資料之後，本文將說明這其中的一些情況，然後以一些較低層級詳細資訊的討論來做出結論。</span><span class="sxs-lookup"><span data-stu-id="0f532-108">After discussing some background material, this paper explores some of these situations and then concludes with a discussion of some lower-level details.</span></span>

> [!NOTE]
> <span data-ttu-id="0f532-109">本主題將討論使用 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 方法進行非同步呼叫的執行緒。</span><span class="sxs-lookup"><span data-stu-id="0f532-109">This topic discusses threading by using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method for asynchronous calls.</span></span> <span data-ttu-id="0f532-110">您也可以呼叫 <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> 方法來進行非同步呼叫，這會採用 <xref:System.Action> 或 <xref:System.Func%601> 做為參數。</span><span class="sxs-lookup"><span data-stu-id="0f532-110">You can also make asynchronous calls by calling the <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method, which take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="0f532-111"><xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> 方法會傳回具有 <xref:System.Windows.Threading.DispatcherOperation.Task%2A> 屬性的 <xref:System.Windows.Threading.DispatcherOperation> 或 <xref:System.Windows.Threading.DispatcherOperation%601>。</span><span class="sxs-lookup"><span data-stu-id="0f532-111">The <xref:System.Windows.Threading.Dispatcher.InvokeAsync%2A> method returns a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, which has a <xref:System.Windows.Threading.DispatcherOperation.Task%2A> property.</span></span> <span data-ttu-id="0f532-112">您可以使用 `await` 關鍵字搭配 <xref:System.Windows.Threading.DispatcherOperation> 或相關聯的 <xref:System.Threading.Tasks.Task>。</span><span class="sxs-lookup"><span data-stu-id="0f532-112">You can use the `await` keyword with either the <xref:System.Windows.Threading.DispatcherOperation> or the associated <xref:System.Threading.Tasks.Task>.</span></span> <span data-ttu-id="0f532-113">如果您需要以同步方式等候 <xref:System.Windows.Threading.DispatcherOperation> 或 <xref:System.Windows.Threading.DispatcherOperation%601>所傳回的 <xref:System.Threading.Tasks.Task>，請呼叫 <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> 擴充方法。</span><span class="sxs-lookup"><span data-stu-id="0f532-113">If you need to wait synchronously for the <xref:System.Threading.Tasks.Task> that is returned by a <xref:System.Windows.Threading.DispatcherOperation> or <xref:System.Windows.Threading.DispatcherOperation%601>, call the <xref:System.Windows.Threading.TaskExtensions.DispatcherOperationWait%2A> extension method.</span></span>  <span data-ttu-id="0f532-114">呼叫 <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> 將會導致鎖死。</span><span class="sxs-lookup"><span data-stu-id="0f532-114">Calling <xref:System.Threading.Tasks.Task.Wait%2A?displayProperty=nameWithType> will result in a deadlock.</span></span> <span data-ttu-id="0f532-115">如需使用 <xref:System.Threading.Tasks.Task> 執行非同步作業的詳細資訊，請參閱工作平行處理原則。</span><span class="sxs-lookup"><span data-stu-id="0f532-115">For more information about using a <xref:System.Threading.Tasks.Task> to perform asynchronous operations, see Task Parallelism.</span></span>  <span data-ttu-id="0f532-116"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> 方法也具有可接受 <xref:System.Action> 或 <xref:System.Func%601> 作為參數的多載。</span><span class="sxs-lookup"><span data-stu-id="0f532-116">The <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method also has overloads that take an <xref:System.Action> or <xref:System.Func%601> as a parameter.</span></span>  <span data-ttu-id="0f532-117">您可以使用 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 方法，藉由傳入委派、<xref:System.Action> 或 <xref:System.Func%601>來進行同步呼叫。</span><span class="sxs-lookup"><span data-stu-id="0f532-117">You can use the <xref:System.Windows.Threading.Dispatcher.Invoke%2A> method to make synchronous calls by passing in a delegate, <xref:System.Action> or <xref:System.Func%601>.</span></span>

<a name="threading_overview"></a>
## <a name="overview-and-the-dispatcher"></a><span data-ttu-id="0f532-118">概觀和發送器</span><span class="sxs-lookup"><span data-stu-id="0f532-118">Overview and the Dispatcher</span></span>
 <span data-ttu-id="0f532-119">一般來說，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 應用程式會從兩個執行緒開始：一個用於處理轉譯，另一個則用於管理 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="0f532-119">Typically, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications start with two threads: one for handling rendering and another for managing the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="0f532-120">轉譯執行緒會在背景中有效地執行，而 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒會接收輸入、處理事件、繪製螢幕，以及執行應用程式程式碼。</span><span class="sxs-lookup"><span data-stu-id="0f532-120">The rendering thread effectively runs hidden in the background while the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread receives input, handles events, paints the screen, and runs application code.</span></span> <span data-ttu-id="0f532-121">大部分的應用程式都使用單一 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒，不過在某些情況下，最好是使用數個。</span><span class="sxs-lookup"><span data-stu-id="0f532-121">Most applications use a single [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread, although in some situations it is best to use several.</span></span> <span data-ttu-id="0f532-122">我們稍後將使用範例來討論這一點。</span><span class="sxs-lookup"><span data-stu-id="0f532-122">We’ll discuss this with an example later.</span></span>

 <span data-ttu-id="0f532-123">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒會將名為 <xref:System.Windows.Threading.Dispatcher>之物件內的工作專案排入佇列。</span><span class="sxs-lookup"><span data-stu-id="0f532-123">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread queues work items inside an object called a <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="0f532-124"><xref:System.Windows.Threading.Dispatcher> 會依優先權選取工作項目，並逐一執行以完成每個工作項目。</span><span class="sxs-lookup"><span data-stu-id="0f532-124">The <xref:System.Windows.Threading.Dispatcher> selects work items on a priority basis and runs each one to completion.</span></span>  <span data-ttu-id="0f532-125">每個 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒都必須至少有一個 <xref:System.Windows.Threading.Dispatcher>，而且每個 <xref:System.Windows.Threading.Dispatcher> 只能在一個執行緒中執行工作專案。</span><span class="sxs-lookup"><span data-stu-id="0f532-125">Every [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread must have at least one <xref:System.Windows.Threading.Dispatcher>, and each <xref:System.Windows.Threading.Dispatcher> can execute work items in exactly one thread.</span></span>

 <span data-ttu-id="0f532-126">建立回應式且方便使用的應用程式的訣竅，是讓工作專案保持在最大的 <xref:System.Windows.Threading.Dispatcher> 輸送量。</span><span class="sxs-lookup"><span data-stu-id="0f532-126">The trick to building responsive, user-friendly applications is to maximize the <xref:System.Windows.Threading.Dispatcher> throughput by keeping the work items small.</span></span> <span data-ttu-id="0f532-127">如此一來，在等候處理的 <xref:System.Windows.Threading.Dispatcher> 佇列中，專案永遠不會過時。</span><span class="sxs-lookup"><span data-stu-id="0f532-127">This way items never get stale sitting in the <xref:System.Windows.Threading.Dispatcher> queue waiting for processing.</span></span> <span data-ttu-id="0f532-128">輸入與回應之間任何可察覺到的延遲都能讓使用者感到挫折。</span><span class="sxs-lookup"><span data-stu-id="0f532-128">Any perceivable delay between input and response can frustrate a user.</span></span>

 <span data-ttu-id="0f532-129">那麼，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 應用程式應該如何處理大型作業呢？</span><span class="sxs-lookup"><span data-stu-id="0f532-129">How then are [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications supposed to handle big operations?</span></span> <span data-ttu-id="0f532-130">如果您的程式碼牽涉到大型計算，或需要查詢某些遠端伺服器上的資料庫，又該怎麼做？</span><span class="sxs-lookup"><span data-stu-id="0f532-130">What if your code involves a large calculation or needs to query a database on some remote server?</span></span> <span data-ttu-id="0f532-131">通常，答案是在不同的執行緒中處理 big 作業，讓 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒可以自由地在 <xref:System.Windows.Threading.Dispatcher> 佇列中的專案上運作。</span><span class="sxs-lookup"><span data-stu-id="0f532-131">Usually, the answer is to handle the big operation in a separate thread, leaving the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread free to tend to items in the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="0f532-132">當 big 作業完成時，它可以將其結果回報給 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 的執行緒以供顯示。</span><span class="sxs-lookup"><span data-stu-id="0f532-132">When the big operation is complete, it can report its result back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread for display.</span></span>

 <span data-ttu-id="0f532-133">在過去，Windows 只允許透過建立 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 專案的執行緒來存取這些專案。</span><span class="sxs-lookup"><span data-stu-id="0f532-133">Historically, Windows allows [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements to be accessed only by the thread that created them.</span></span> <span data-ttu-id="0f532-134">這表示負責某些長時間執行工作的背景執行緒無法在完成時更新文字方塊。</span><span class="sxs-lookup"><span data-stu-id="0f532-134">This means that a background thread in charge of some long-running task cannot update a text box when it is finished.</span></span> <span data-ttu-id="0f532-135">Windows 會執行此工作，以確保 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 元件的完整性。</span><span class="sxs-lookup"><span data-stu-id="0f532-135">Windows does this to ensure the integrity of [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] components.</span></span> <span data-ttu-id="0f532-136">如果背景執行緒已在繪製期間更新了清單方塊的內容，則該清單方塊看起來可能很奇怪。</span><span class="sxs-lookup"><span data-stu-id="0f532-136">A list box could look strange if its contents were updated by a background thread during painting.</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="0f532-137">有個內建的互斥機制，會強制執行這項協調。</span><span class="sxs-lookup"><span data-stu-id="0f532-137">has a built-in mutual exclusion mechanism that enforces this coordination.</span></span> <span data-ttu-id="0f532-138">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的大部分類別都是衍生自 <xref:System.Windows.Threading.DispatcherObject>。</span><span class="sxs-lookup"><span data-stu-id="0f532-138">Most classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>.</span></span> <span data-ttu-id="0f532-139">在結構上，<xref:System.Windows.Threading.DispatcherObject> 會儲存連結至目前執行中線程之 <xref:System.Windows.Threading.Dispatcher> 的參考。</span><span class="sxs-lookup"><span data-stu-id="0f532-139">At construction, a <xref:System.Windows.Threading.DispatcherObject> stores a reference to the <xref:System.Windows.Threading.Dispatcher> linked to the currently running thread.</span></span> <span data-ttu-id="0f532-140">實際上，<xref:System.Windows.Threading.DispatcherObject> 會與建立它的執行緒產生關聯。</span><span class="sxs-lookup"><span data-stu-id="0f532-140">In effect, the <xref:System.Windows.Threading.DispatcherObject> associates with the thread that creates it.</span></span> <span data-ttu-id="0f532-141">在程式執行期間，<xref:System.Windows.Threading.DispatcherObject> 可以呼叫其公用 <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="0f532-141">During program execution, a <xref:System.Windows.Threading.DispatcherObject> can call its public <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> method.</span></span> <span data-ttu-id="0f532-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 檢查與目前線程相關聯的 <xref:System.Windows.Threading.Dispatcher>，並將其與在結構中儲存的 <xref:System.Windows.Threading.Dispatcher> 參考進行比較。</span><span class="sxs-lookup"><span data-stu-id="0f532-142"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> examines the <xref:System.Windows.Threading.Dispatcher> associated with the current thread and compares it to the <xref:System.Windows.Threading.Dispatcher> reference stored during construction.</span></span> <span data-ttu-id="0f532-143">如果兩者不相符，<xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 會擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="0f532-143">If they don’t match, <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> throws an exception.</span></span> <span data-ttu-id="0f532-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> 的目的是要在每個屬於 <xref:System.Windows.Threading.DispatcherObject>的方法開頭進行呼叫。</span><span class="sxs-lookup"><span data-stu-id="0f532-144"><xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> is intended to be called at the beginning of every method belonging to a <xref:System.Windows.Threading.DispatcherObject>.</span></span>

 <span data-ttu-id="0f532-145">如果只有一個執行緒可以修改 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]，背景執行緒如何與使用者互動？</span><span class="sxs-lookup"><span data-stu-id="0f532-145">If only one thread can modify the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)], how do background threads interact with the user?</span></span> <span data-ttu-id="0f532-146">背景執行緒可以要求 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒代表它執行作業。</span><span class="sxs-lookup"><span data-stu-id="0f532-146">A background thread can ask the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread to perform an operation on its behalf.</span></span> <span data-ttu-id="0f532-147">其方式是向 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒的 <xref:System.Windows.Threading.Dispatcher> 註冊工作專案。</span><span class="sxs-lookup"><span data-stu-id="0f532-147">It does this by registering a work item with the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="0f532-148"><xref:System.Windows.Threading.Dispatcher> 類別提供兩種註冊工作專案的方法： <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 和 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>。</span><span class="sxs-lookup"><span data-stu-id="0f532-148">The <xref:System.Windows.Threading.Dispatcher> class provides two methods for registering work items: <xref:System.Windows.Threading.Dispatcher.Invoke%2A> and <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>.</span></span> <span data-ttu-id="0f532-149">這兩種方法都會排程要執行的委派。</span><span class="sxs-lookup"><span data-stu-id="0f532-149">Both methods schedule a delegate for execution.</span></span> <span data-ttu-id="0f532-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> 是同步呼叫，也就是說，在 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒實際完成執行委派之前，它不會傳回。</span><span class="sxs-lookup"><span data-stu-id="0f532-150"><xref:System.Windows.Threading.Dispatcher.Invoke%2A> is a synchronous call – that is, it doesn’t return until the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread actually finishes executing the delegate.</span></span> <span data-ttu-id="0f532-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 是非同步，而且會立即傳回。</span><span class="sxs-lookup"><span data-stu-id="0f532-151"><xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is asynchronous and returns immediately.</span></span>

 <span data-ttu-id="0f532-152"><xref:System.Windows.Threading.Dispatcher> 依優先順序排序其佇列中的元素。</span><span class="sxs-lookup"><span data-stu-id="0f532-152">The <xref:System.Windows.Threading.Dispatcher> orders the elements in its queue by priority.</span></span> <span data-ttu-id="0f532-153">將專案新增至 <xref:System.Windows.Threading.Dispatcher> 的佇列時，可以指定十個層級。</span><span class="sxs-lookup"><span data-stu-id="0f532-153">There are ten levels that may be specified when adding an element to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="0f532-154">這些優先順序會在 <xref:System.Windows.Threading.DispatcherPriority> 列舉中維護。</span><span class="sxs-lookup"><span data-stu-id="0f532-154">These priorities are maintained in the <xref:System.Windows.Threading.DispatcherPriority> enumeration.</span></span> <span data-ttu-id="0f532-155"><xref:System.Windows.Threading.DispatcherPriority> 層級的詳細資訊可在 Windows SDK 檔中找到。</span><span class="sxs-lookup"><span data-stu-id="0f532-155">Detailed information about <xref:System.Windows.Threading.DispatcherPriority> levels can be found in the Windows SDK documentation.</span></span>

<a name="samples"></a>
## <a name="threads-in-action-the-samples"></a><span data-ttu-id="0f532-156">執行中的執行緒︰範例</span><span class="sxs-lookup"><span data-stu-id="0f532-156">Threads in Action: The Samples</span></span>

<a name="prime_number"></a>
### <a name="a-single-threaded-application-with-a-long-running-calculation"></a><span data-ttu-id="0f532-157">單一執行緒應用程式與長時間執行的計算</span><span class="sxs-lookup"><span data-stu-id="0f532-157">A Single-Threaded Application with a Long-Running Calculation</span></span>
 <span data-ttu-id="0f532-158">大部分的圖形化使用者介面（Gui）都會在等候使用者互動時所產生的事件時，花費大量時間閒置的部分。</span><span class="sxs-lookup"><span data-stu-id="0f532-158">Most graphical user interfaces (GUIs) spend a large portion of their time idle while waiting for events that are generated in response to user interactions.</span></span> <span data-ttu-id="0f532-159">有了謹慎的程式設計，就可以建設性使用此閒置時間，而不會影響 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]的回應能力。</span><span class="sxs-lookup"><span data-stu-id="0f532-159">With careful programming this idle time can be used constructively, without affecting the responsiveness of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)].</span></span> <span data-ttu-id="0f532-160">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 執行緒模型不允許輸入中斷 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒中發生的作業。</span><span class="sxs-lookup"><span data-stu-id="0f532-160">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] threading model doesn’t allow input to interrupt an operation happening in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="0f532-161">這表示您必須務必定期返回 <xref:System.Windows.Threading.Dispatcher>，以處理擱置中的輸入事件，然後才會過時。</span><span class="sxs-lookup"><span data-stu-id="0f532-161">This means you must be sure to return to the <xref:System.Windows.Threading.Dispatcher> periodically to process pending input events before they get stale.</span></span>

 <span data-ttu-id="0f532-162">請考慮下列範例：</span><span class="sxs-lookup"><span data-stu-id="0f532-162">Consider the following example:</span></span>

 ![顯示質數執行緒的螢幕擷取畫面。](./media/threading-model/threading-prime-numbers.png)

 <span data-ttu-id="0f532-164">這個簡單的應用程式會從三開始向上計算，以搜尋質數。</span><span class="sxs-lookup"><span data-stu-id="0f532-164">This simple application counts upwards from three, searching for prime numbers.</span></span> <span data-ttu-id="0f532-165">當使用者按一下 [**開始**] 按鈕時，就會開始搜尋。</span><span class="sxs-lookup"><span data-stu-id="0f532-165">When the user clicks the **Start** button, the search begins.</span></span> <span data-ttu-id="0f532-166">當程式找到質數時，會使用它的發現來更新使用者介面。</span><span class="sxs-lookup"><span data-stu-id="0f532-166">When the program finds a prime, it updates the user interface with its discovery.</span></span> <span data-ttu-id="0f532-167">使用者隨時都能停止搜尋。</span><span class="sxs-lookup"><span data-stu-id="0f532-167">At any point, the user can stop the search.</span></span>

 <span data-ttu-id="0f532-168">雖然夠簡單，但質數搜尋會永無止盡的繼續執行，其中會遇到一些難題。</span><span class="sxs-lookup"><span data-stu-id="0f532-168">Although simple enough, the prime number search could go on forever, which presents some difficulties.</span></span>  <span data-ttu-id="0f532-169">如果我們在按鈕的 click 事件處理常式內處理整個搜尋，就不會讓 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒有機會處理其他事件。</span><span class="sxs-lookup"><span data-stu-id="0f532-169">If we handled the entire search inside of the click event handler of the button, we would never give the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread a chance to handle other events.</span></span> <span data-ttu-id="0f532-170">[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 將無法回應輸入或處理訊息。</span><span class="sxs-lookup"><span data-stu-id="0f532-170">The [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] would be unable to respond to input or process messages.</span></span> <span data-ttu-id="0f532-171">它永遠不會重新繪製，而且永遠不會回應按鈕 Click。</span><span class="sxs-lookup"><span data-stu-id="0f532-171">It would never repaint and never respond to button clicks.</span></span>

 <span data-ttu-id="0f532-172">我們可以在個別執行緒中管理質數搜尋，但接著需要處理同步問題。</span><span class="sxs-lookup"><span data-stu-id="0f532-172">We could conduct the prime number search in a separate thread, but then we would need to deal with synchronization issues.</span></span> <span data-ttu-id="0f532-173">使用單一執行緒的方法，我們可以直接更新標籤，以列出所找到的最大質數。</span><span class="sxs-lookup"><span data-stu-id="0f532-173">With a single-threaded approach, we can directly update the label that lists the largest prime found.</span></span>

 <span data-ttu-id="0f532-174">如果我們將計算的工作分解成可管理的區塊，我們可以定期返回 <xref:System.Windows.Threading.Dispatcher> 和處理事件。</span><span class="sxs-lookup"><span data-stu-id="0f532-174">If we break up the task of calculation into manageable chunks, we can periodically return to the <xref:System.Windows.Threading.Dispatcher> and process events.</span></span> <span data-ttu-id="0f532-175">我們可以讓 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 重新繪製和處理輸入的機會。</span><span class="sxs-lookup"><span data-stu-id="0f532-175">We can give [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] an opportunity to repaint and process input.</span></span>

 <span data-ttu-id="0f532-176">在計算與事件處理之間分割處理時間的最佳方式，是從 <xref:System.Windows.Threading.Dispatcher>管理計算。</span><span class="sxs-lookup"><span data-stu-id="0f532-176">The best way to split processing time between calculation and event handling is to manage calculation from the <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="0f532-177">藉由使用 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 方法，我們可以在 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 事件繪製所在的相同佇列中排程質數檢查。</span><span class="sxs-lookup"><span data-stu-id="0f532-177">By using the <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> method, we can schedule prime number checks in the same queue that [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events are drawn from.</span></span> <span data-ttu-id="0f532-178">在範例中，我們一次只會排程單一質數檢查。</span><span class="sxs-lookup"><span data-stu-id="0f532-178">In our example, we schedule only a single prime number check at a time.</span></span> <span data-ttu-id="0f532-179">質數檢查完成之後，我們會立即排程下次檢查。</span><span class="sxs-lookup"><span data-stu-id="0f532-179">After the prime number check is complete, we schedule the next check immediately.</span></span> <span data-ttu-id="0f532-180">只有在處理暫止的 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 事件之後，才會進行這種檢查。</span><span class="sxs-lookup"><span data-stu-id="0f532-180">This check proceeds only after pending [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] events have been handled.</span></span>

 ![顯示發送器佇列的螢幕擷取畫面。](./media/threading-model/threading-dispatcher-queue.png)

 <span data-ttu-id="0f532-182">Microsoft Word 會使用此機制來完成拼寫檢查。</span><span class="sxs-lookup"><span data-stu-id="0f532-182">Microsoft Word accomplishes spell checking using this mechanism.</span></span> <span data-ttu-id="0f532-183">拼寫檢查會在背景中使用 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒的閒置時間來完成。</span><span class="sxs-lookup"><span data-stu-id="0f532-183">Spell checking is done in the background using the idle time of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="0f532-184">讓我們看看程式碼。</span><span class="sxs-lookup"><span data-stu-id="0f532-184">Let's take a look at the code.</span></span>

 <span data-ttu-id="0f532-185">下列範例顯示建立使用者介面的 XAML。</span><span class="sxs-lookup"><span data-stu-id="0f532-185">The following example shows the XAML that creates the user interface.</span></span>

 [!code-xaml[ThreadingPrimeNumbers#ThreadingPrimeNumberXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml#threadingprimenumberxaml)]

 <span data-ttu-id="0f532-186">下列範例顯示程式碼後置。</span><span class="sxs-lookup"><span data-stu-id="0f532-186">The following example shows the code-behind.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumbercodebehind)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumbercodebehind)]

 <span data-ttu-id="0f532-187">下列範例會顯示 <xref:System.Windows.Controls.Button>的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="0f532-187">The following example shows the event handler for the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberstartorstop)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberStartOrStop](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberstartorstop)]

 <span data-ttu-id="0f532-188">除了更新 <xref:System.Windows.Controls.Button>上的文字，此處理程式還會負責將委派加入至 <xref:System.Windows.Threading.Dispatcher> 佇列，以排程第一個質數檢查。</span><span class="sxs-lookup"><span data-stu-id="0f532-188">Besides updating the text on the <xref:System.Windows.Controls.Button>, this handler is responsible for scheduling the first prime number check by adding a delegate to the <xref:System.Windows.Threading.Dispatcher> queue.</span></span> <span data-ttu-id="0f532-189">在此事件處理常式完成其工作之後，<xref:System.Windows.Threading.Dispatcher> 將會選取此委派以進行執行。</span><span class="sxs-lookup"><span data-stu-id="0f532-189">Sometime after this event handler has completed its work, the <xref:System.Windows.Threading.Dispatcher> will select this delegate for execution.</span></span>

 <span data-ttu-id="0f532-190">如先前所述，<xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> 是用來排程執行委派的 <xref:System.Windows.Threading.Dispatcher> 成員。</span><span class="sxs-lookup"><span data-stu-id="0f532-190">As we mentioned earlier, <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> is the <xref:System.Windows.Threading.Dispatcher> member used to schedule a delegate for execution.</span></span> <span data-ttu-id="0f532-191">在此情況下，我們會選擇 <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> 優先權。</span><span class="sxs-lookup"><span data-stu-id="0f532-191">In this case, we choose the <xref:System.Windows.Threading.DispatcherPriority.SystemIdle> priority.</span></span> <span data-ttu-id="0f532-192">只有在沒有要處理的重要事件時，<xref:System.Windows.Threading.Dispatcher> 才會執行此委派。</span><span class="sxs-lookup"><span data-stu-id="0f532-192">The <xref:System.Windows.Threading.Dispatcher> will execute this delegate only when there are no important events to process.</span></span> [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] <span data-ttu-id="0f532-193">回應性比數字檢查更重要。</span><span class="sxs-lookup"><span data-stu-id="0f532-193">responsiveness is more important than number checking.</span></span> <span data-ttu-id="0f532-194">我們也會傳遞新的委派來代表數字檢查常式。</span><span class="sxs-lookup"><span data-stu-id="0f532-194">We also pass a new delegate representing the number-checking routine.</span></span>

 [!code-csharp[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingPrimeNumbers/CSharp/Window1.xaml.cs#threadingprimenumberchecknextnumber)]
 [!code-vb[ThreadingPrimeNumbers#ThreadingPrimeNumberCheckNextNumber](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingPrimeNumbers/visualbasic/mainwindow.xaml.vb#threadingprimenumberchecknextnumber)]

 <span data-ttu-id="0f532-195">這個方法會檢查下一個奇數是否為質數。</span><span class="sxs-lookup"><span data-stu-id="0f532-195">This method checks if the next odd number is prime.</span></span> <span data-ttu-id="0f532-196">如果是質數，方法會直接更新 `bigPrime`<xref:System.Windows.Controls.TextBlock> 以反映其探索。</span><span class="sxs-lookup"><span data-stu-id="0f532-196">If it is prime, the method directly updates the `bigPrime`<xref:System.Windows.Controls.TextBlock> to reflect its discovery.</span></span> <span data-ttu-id="0f532-197">由於計算會發生在用來建立元件的相同執行緒中，因此我們可以執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="0f532-197">We can do this because the calculation is occurring in the same thread that was used to create the component.</span></span> <span data-ttu-id="0f532-198">我們已選擇使用個別的執行緒來進行計算，我們必須使用更複雜的同步處理機制，並在 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒中執行更新。</span><span class="sxs-lookup"><span data-stu-id="0f532-198">Had we chosen to use a separate thread for the calculation, we would have to use a more complicated synchronization mechanism and execute the update in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="0f532-199">接下來我們將示範這種情況。</span><span class="sxs-lookup"><span data-stu-id="0f532-199">We’ll demonstrate this situation next.</span></span>

 <span data-ttu-id="0f532-200">如需此範例的完整原始程式碼，請參閱[具有長時間執行計算範例的單一執行緒應用程式](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)</span><span class="sxs-lookup"><span data-stu-id="0f532-200">For the complete source code for this sample, see the [Single-Threaded Application with Long-Running Calculation Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)</span></span>

<a name="weather_sim"></a>
### <a name="handling-a-blocking-operation-with-a-background-thread"></a><span data-ttu-id="0f532-201">利用背景執行緒處理封鎖作業</span><span class="sxs-lookup"><span data-stu-id="0f532-201">Handling a Blocking Operation with a Background Thread</span></span>
 <span data-ttu-id="0f532-202">處理圖形應用程式中的封鎖作業可能很困難。</span><span class="sxs-lookup"><span data-stu-id="0f532-202">Handling blocking operations in a graphical application can be difficult.</span></span> <span data-ttu-id="0f532-203">我們不想從事件處理常式中呼叫封鎖方法，因為應用程式將呈現凍結狀態。</span><span class="sxs-lookup"><span data-stu-id="0f532-203">We don’t want to call blocking methods from event handlers because the application will appear to freeze up.</span></span> <span data-ttu-id="0f532-204">我們可以使用個別的執行緒來處理這些作業，但當我們完成時，我們必須與 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒同步，因為我們無法直接從背景工作執行緒修改 GUI。</span><span class="sxs-lookup"><span data-stu-id="0f532-204">We can use a separate thread to handle these operations, but when we’re done, we have to synchronize with the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread because we can’t directly modify the GUI from our worker thread.</span></span> <span data-ttu-id="0f532-205">我們可以使用 <xref:System.Windows.Threading.Dispatcher.Invoke%2A> 或 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A>，將委派插入 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒的 <xref:System.Windows.Threading.Dispatcher> 中。</span><span class="sxs-lookup"><span data-stu-id="0f532-205">We can use <xref:System.Windows.Threading.Dispatcher.Invoke%2A> or <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> to insert delegates into the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="0f532-206">最後，這些委派將會執行，並具有修改 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 元素的許可權。</span><span class="sxs-lookup"><span data-stu-id="0f532-206">Eventually, these delegates will be executed with permission to modify [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] elements.</span></span>

 <span data-ttu-id="0f532-207">在此範例中，我們模仿遠端程序呼叫來擷取氣象預報。</span><span class="sxs-lookup"><span data-stu-id="0f532-207">In this example, we mimic a remote procedure call that retrieves a weather forecast.</span></span> <span data-ttu-id="0f532-208">我們會使用個別的背景工作執行緒來執行此呼叫，並在完成時，在 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒的 <xref:System.Windows.Threading.Dispatcher> 中排程更新方法。</span><span class="sxs-lookup"><span data-stu-id="0f532-208">We use a separate worker thread to execute this call, and we schedule an update method in the <xref:System.Windows.Threading.Dispatcher> of the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread when we’re finished.</span></span>

 ![顯示天氣 UI 的螢幕擷取畫面。](./media/threading-model/threading-weather-ui.png)

 [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweathercodebehind)]
 [!code-vb[ThreadingWeatherForecast#ThreadingWeatherCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweathercodebehind)]

 <span data-ttu-id="0f532-210">以下是一些要注意的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="0f532-210">The following are some of the details to be noted.</span></span>

- <span data-ttu-id="0f532-211">建立按鈕處理常式</span><span class="sxs-lookup"><span data-stu-id="0f532-211">Creating the Button Handler</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherbuttonhandler)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherButtonHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherbuttonhandler)]

 <span data-ttu-id="0f532-212">按一下按鈕時，我們會顯示時鐘圖案並開始以動畫顯示它。</span><span class="sxs-lookup"><span data-stu-id="0f532-212">When the button is clicked, we display the clock drawing and start animating it.</span></span> <span data-ttu-id="0f532-213">我們停用按鈕。</span><span class="sxs-lookup"><span data-stu-id="0f532-213">We disable the button.</span></span> <span data-ttu-id="0f532-214">我們會在新的執行緒中叫用 `FetchWeatherFromServer` 方法，然後傳回，讓 <xref:System.Windows.Threading.Dispatcher> 在等候收集氣象預報時處理事件。</span><span class="sxs-lookup"><span data-stu-id="0f532-214">We invoke the `FetchWeatherFromServer` method in a new thread, and then we return, allowing the <xref:System.Windows.Threading.Dispatcher> to process events while we wait to collect the weather forecast.</span></span>

- <span data-ttu-id="0f532-215">擷取氣象</span><span class="sxs-lookup"><span data-stu-id="0f532-215">Fetching the Weather</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherfetchweather)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherFetchWeather](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherfetchweather)]

 <span data-ttu-id="0f532-216">為了簡單起見，我們並未在此範例中實際使用任何網路程式碼。</span><span class="sxs-lookup"><span data-stu-id="0f532-216">To keep things simple, we don’t actually have any networking code in this example.</span></span> <span data-ttu-id="0f532-217">相反地，我們讓新的執行緒進入睡眠狀態 4 秒，藉以模擬網路存取延遲。</span><span class="sxs-lookup"><span data-stu-id="0f532-217">Instead, we simulate the delay of network access by putting our new thread to sleep for four seconds.</span></span> <span data-ttu-id="0f532-218">此時，原始 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒仍在執行中，並回應事件。</span><span class="sxs-lookup"><span data-stu-id="0f532-218">In this time, the original [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is still running and responding to events.</span></span> <span data-ttu-id="0f532-219">為了顯示此情況，我們讓動畫持續執行，並讓最小化及最大化按鈕也能繼續運作。</span><span class="sxs-lookup"><span data-stu-id="0f532-219">To show this, we’ve left an animation running, and the minimize and maximize buttons also continue to work.</span></span>

 <span data-ttu-id="0f532-220">當延遲完成，而且我們隨機選取了氣象預報之後，就可以向後回報到 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 的往來文章。</span><span class="sxs-lookup"><span data-stu-id="0f532-220">When the delay is finished, and we’ve randomly selected our weather forecast, it’s time to report back to the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="0f532-221">我們的作法是使用該執行緒的 <xref:System.Windows.Threading.Dispatcher>來排程 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒中 `UpdateUserInterface` 的呼叫。</span><span class="sxs-lookup"><span data-stu-id="0f532-221">We do this by scheduling a call to `UpdateUserInterface` in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread using that thread’s <xref:System.Windows.Threading.Dispatcher>.</span></span> <span data-ttu-id="0f532-222">我們將描述氣象的字串傳遞到這個排程的方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="0f532-222">We pass a string describing the weather to this scheduled method call.</span></span>

- <span data-ttu-id="0f532-223">更新 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span><span class="sxs-lookup"><span data-stu-id="0f532-223">Updating the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]</span></span>

     [!code-csharp[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingWeatherForecast/CSharp/Window1.xaml.cs#threadingweatherupdateui)]
     [!code-vb[ThreadingWeatherForecast#ThreadingWeatherUpdateUI](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingWeatherForecast/visualbasic/window1.xaml.vb#threadingweatherupdateui)]

 <span data-ttu-id="0f532-224">當 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒中的 <xref:System.Windows.Threading.Dispatcher> 有時間時，它會對 `UpdateUserInterface`執行排程的呼叫。</span><span class="sxs-lookup"><span data-stu-id="0f532-224">When the <xref:System.Windows.Threading.Dispatcher> in the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread has time, it executes the scheduled call to `UpdateUserInterface`.</span></span> <span data-ttu-id="0f532-225">這個方法會停止時鐘動畫，並選擇影像來說明氣象。</span><span class="sxs-lookup"><span data-stu-id="0f532-225">This method stops the clock animation and chooses an image to describe the weather.</span></span> <span data-ttu-id="0f532-226">它會顯示此影像，並還原 [Fetch Forecast (擷取預報)] 按鈕。</span><span class="sxs-lookup"><span data-stu-id="0f532-226">It displays this image and restores the "fetch forecast" button.</span></span>

<a name="multi_browser"></a>
### <a name="multiple-windows-multiple-threads"></a><span data-ttu-id="0f532-227">多個視窗，多個執行緒</span><span class="sxs-lookup"><span data-stu-id="0f532-227">Multiple Windows, Multiple Threads</span></span>
 <span data-ttu-id="0f532-228">某些 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 應用程式需要多個最上層視窗。</span><span class="sxs-lookup"><span data-stu-id="0f532-228">Some [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications require multiple top-level windows.</span></span> <span data-ttu-id="0f532-229">一個執行緒/<xref:System.Windows.Threading.Dispatcher> 組合可以完全接受，以管理多個視窗，但有時候有數個執行緒會有更好的工作。</span><span class="sxs-lookup"><span data-stu-id="0f532-229">It is perfectly acceptable for one Thread/<xref:System.Windows.Threading.Dispatcher> combination to manage multiple windows, but sometimes several threads do a better job.</span></span> <span data-ttu-id="0f532-230">如果有可能發生某一個視窗將獨佔執行緒的情況，這特別適用。</span><span class="sxs-lookup"><span data-stu-id="0f532-230">This is especially true if there is any chance that one of the windows will monopolize the thread.</span></span>

 <span data-ttu-id="0f532-231">Windows Explorer 以這種方式運作。</span><span class="sxs-lookup"><span data-stu-id="0f532-231">Windows Explorer works in this fashion.</span></span> <span data-ttu-id="0f532-232">每個新的檔案總管視窗都屬於原始的程序，但會在獨立執行緒的控制下建立它。</span><span class="sxs-lookup"><span data-stu-id="0f532-232">Each new Explorer window belongs to the original process, but it is created under the control of an independent thread.</span></span>

 <span data-ttu-id="0f532-233">藉由使用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> 控制項，我們可以顯示網頁。</span><span class="sxs-lookup"><span data-stu-id="0f532-233">By using a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<xref:System.Windows.Controls.Frame> control, we can display Web pages.</span></span> <span data-ttu-id="0f532-234">我們可以輕鬆地建立簡單的 Internet Explorer 替代方案。</span><span class="sxs-lookup"><span data-stu-id="0f532-234">We can easily create a simple Internet Explorer substitute.</span></span> <span data-ttu-id="0f532-235">我們從一個重要功能開始︰開啟新檔案總管視窗的能力。</span><span class="sxs-lookup"><span data-stu-id="0f532-235">We start with an important feature: the ability to open a new explorer window.</span></span> <span data-ttu-id="0f532-236">當使用者按一下 [New Window (新視窗)] 按鈕時，我們會在另一個執行緒中啟動視窗複本。</span><span class="sxs-lookup"><span data-stu-id="0f532-236">When the user clicks the "new window" button, we launch a copy of our window in a separate thread.</span></span> <span data-ttu-id="0f532-237">如此一來，在其中一個視窗中長時間執行或封鎖的作業就不會鎖定所有其他視窗。</span><span class="sxs-lookup"><span data-stu-id="0f532-237">This way, long-running or blocking operations in one of the windows won’t lock all the other windows.</span></span>

 <span data-ttu-id="0f532-238">事實上，網頁瀏覽器模型有它自己的複雜執行緒模型。</span><span class="sxs-lookup"><span data-stu-id="0f532-238">In reality, the Web browser model has its own complicated threading model.</span></span> <span data-ttu-id="0f532-239">我們選擇它是因為大多數讀者應該都已熟悉它。</span><span class="sxs-lookup"><span data-stu-id="0f532-239">We’ve chosen it because it should be familiar to most readers.</span></span>

 <span data-ttu-id="0f532-240">下列範例顯示此程式碼。</span><span class="sxs-lookup"><span data-stu-id="0f532-240">The following example shows the code.</span></span>

 [!code-xaml[ThreadingMultipleBrowsers#ThreadingMultiBrowserXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml#threadingmultibrowserxaml)]

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsercodebehind)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsercodebehind)]

 <span data-ttu-id="0f532-241">此程式碼的下列執行緒區段是我們在此內容中最感興趣的部分：</span><span class="sxs-lookup"><span data-stu-id="0f532-241">The following threading segments of this code are the most interesting to us in this context:</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowsernewwindow)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserNewWindow](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowsernewwindow)]

 <span data-ttu-id="0f532-242">按下 [New Window (新視窗)] 按鈕時會呼叫此方法。</span><span class="sxs-lookup"><span data-stu-id="0f532-242">This method is called when the "new window" button is clicked.</span></span> <span data-ttu-id="0f532-243">它會建立新的執行緒，並以非同步方式啟動它。</span><span class="sxs-lookup"><span data-stu-id="0f532-243">It creates a new thread and starts it asynchronously.</span></span>

 [!code-csharp[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/csharp/VS_Snippets_Wpf/ThreadingMultipleBrowsers/CSharp/Window1.xaml.cs#threadingmultibrowserthreadstart)]
 [!code-vb[ThreadingMultipleBrowsers#ThreadingMultiBrowserThreadStart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ThreadingMultipleBrowsers/VisualBasic/Window1.xaml.vb#threadingmultibrowserthreadstart)]

 <span data-ttu-id="0f532-244">這個方法是新執行緒的起點。</span><span class="sxs-lookup"><span data-stu-id="0f532-244">This method is the starting point for the new thread.</span></span> <span data-ttu-id="0f532-245">我們在此執行緒的控制下建立新視窗。</span><span class="sxs-lookup"><span data-stu-id="0f532-245">We create a new window under the control of this thread.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="0f532-246">會自動建立新的 <xref:System.Windows.Threading.Dispatcher> 來管理新的執行緒。</span><span class="sxs-lookup"><span data-stu-id="0f532-246">automatically creates a new <xref:System.Windows.Threading.Dispatcher> to manage the new thread.</span></span> <span data-ttu-id="0f532-247">為了讓視窗發揮作用，我們只需要啟動 <xref:System.Windows.Threading.Dispatcher>。</span><span class="sxs-lookup"><span data-stu-id="0f532-247">All we have to do to make the window functional is to start the <xref:System.Windows.Threading.Dispatcher>.</span></span>

<a name="stumbling_points"></a>
## <a name="technical-details-and-stumbling-points"></a><span data-ttu-id="0f532-248">技術詳細資料與困難點</span><span class="sxs-lookup"><span data-stu-id="0f532-248">Technical Details and Stumbling Points</span></span>

### <a name="writing-components-using-threading"></a><span data-ttu-id="0f532-249">使用執行緒撰寫元件</span><span class="sxs-lookup"><span data-stu-id="0f532-249">Writing Components Using Threading</span></span>
 <span data-ttu-id="0f532-250">《 Microsoft .NET Framework 開發人員指南》會說明元件如何將非同步行為公開給其用戶端的模式（請參閱[事件架構非同步模式總覽](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)）。</span><span class="sxs-lookup"><span data-stu-id="0f532-250">The Microsoft .NET Framework Developer's Guide describes a pattern for how a component can expose asynchronous behavior to its clients (see [Event-based Asynchronous Pattern Overview](../../../standard/asynchronous-programming-patterns/event-based-asynchronous-pattern-overview.md)).</span></span> <span data-ttu-id="0f532-251">比方說，假設我們想要將 `FetchWeatherFromServer` 方法封裝成可重複使用的 nongraphical 元件。</span><span class="sxs-lookup"><span data-stu-id="0f532-251">For instance, suppose we wanted to package the `FetchWeatherFromServer` method into a reusable, nongraphical component.</span></span> <span data-ttu-id="0f532-252">遵循標準的 Microsoft .NET Framework 模式，這看起來會像下面這樣。</span><span class="sxs-lookup"><span data-stu-id="0f532-252">Following the standard Microsoft .NET Framework pattern, this would look something like the following.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent1)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent1)]

 <span data-ttu-id="0f532-253">`GetWeatherAsync` 會使用上述其中一種技術 (例如建立背景執行緒)，以非同步方式執行工作，而不需封鎖呼叫執行緒。</span><span class="sxs-lookup"><span data-stu-id="0f532-253">`GetWeatherAsync` would use one of the techniques described earlier, such as creating a background thread, to do the work asynchronously, not blocking the calling thread.</span></span>

 <span data-ttu-id="0f532-254">此模式最重要的部分之一，就是在呼叫*方法`Async`* 方法的相同執行緒上呼叫*方法`Completed` 方法*，以開始使用。</span><span class="sxs-lookup"><span data-stu-id="0f532-254">One of the most important parts of this pattern is calling the *MethodName*`Completed` method on the same thread that called the *MethodName*`Async` method to begin with.</span></span> <span data-ttu-id="0f532-255">您可以透過儲存 <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>，輕鬆地使用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]，但 nongraphical 元件只能用在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 應用程式中，而不能用於 Windows Forms 或 ASP.NET 程式中。</span><span class="sxs-lookup"><span data-stu-id="0f532-255">You could do this using [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] fairly easily, by storing <xref:System.Windows.Threading.Dispatcher.CurrentDispatcher%2A>—but then the nongraphical component could only be used in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, not in Windows Forms or ASP.NET programs.</span></span>

 <span data-ttu-id="0f532-256"><xref:System.Windows.Threading.DispatcherSynchronizationContext> 類別可以滿足這項需求，也就是可與其他 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 架構搭配使用的簡化版 <xref:System.Windows.Threading.Dispatcher>。</span><span class="sxs-lookup"><span data-stu-id="0f532-256">The <xref:System.Windows.Threading.DispatcherSynchronizationContext> class addresses this need—think of it as a simplified version of <xref:System.Windows.Threading.Dispatcher> that works with other [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] frameworks as well.</span></span>

 [!code-csharp[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#threadingarticleweathercomponent2)]
 [!code-vb[CommandingOverviewSnippets#ThreadingArticleWeatherComponent2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#threadingarticleweathercomponent2)]

### <a name="nested-pumping"></a><span data-ttu-id="0f532-257">巢狀提取</span><span class="sxs-lookup"><span data-stu-id="0f532-257">Nested Pumping</span></span>
 <span data-ttu-id="0f532-258">有時候，完全鎖定 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒並不可行。</span><span class="sxs-lookup"><span data-stu-id="0f532-258">Sometimes it is not feasible to completely lock up the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="0f532-259">讓我們考慮 <xref:System.Windows.MessageBox> 類別的 <xref:System.Windows.MessageBox.Show%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="0f532-259">Let’s consider the <xref:System.Windows.MessageBox.Show%2A> method of the <xref:System.Windows.MessageBox> class.</span></span> <span data-ttu-id="0f532-260">在使用者按一下 [確定] 按鈕之前，<xref:System.Windows.MessageBox.Show%2A> 不會傳回。</span><span class="sxs-lookup"><span data-stu-id="0f532-260"><xref:System.Windows.MessageBox.Show%2A> doesn’t return until the user clicks the OK button.</span></span> <span data-ttu-id="0f532-261">不過，它會建立必須有訊息迴圈才能互動的視窗。</span><span class="sxs-lookup"><span data-stu-id="0f532-261">It does, however, create a window that must have a message loop in order to be interactive.</span></span> <span data-ttu-id="0f532-262">雖然我們正在等待使用者按下 [OK (確定)]，但原始的應用程式視窗並不會回應使用者輸入。</span><span class="sxs-lookup"><span data-stu-id="0f532-262">While we are waiting for the user to click OK, the original application window does not respond to user input.</span></span> <span data-ttu-id="0f532-263">不過，它會繼續處理繪製訊息。</span><span class="sxs-lookup"><span data-stu-id="0f532-263">It does, however, continue to process paint messages.</span></span> <span data-ttu-id="0f532-264">原始視窗會在涵蓋並顯示時自行重新繪製。</span><span class="sxs-lookup"><span data-stu-id="0f532-264">The original window redraws itself when covered and revealed.</span></span>

 ![顯示含有 [確定] 按鈕之 MessageBox 的螢幕擷取畫面](./media/threading-model/threading-message-loop.png)

 <span data-ttu-id="0f532-266">有些執行緒必須負責訊息方塊視窗。</span><span class="sxs-lookup"><span data-stu-id="0f532-266">Some thread must be in charge of the message box window.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="0f532-267">只會針對訊息方塊視窗建立新的執行緒，但這個執行緒無法在原始視窗中繪製已停用的元素 (請記住先前討論過的互斥)。</span><span class="sxs-lookup"><span data-stu-id="0f532-267">could create a new thread just for the message box window, but this thread would be unable to paint the disabled elements in the original window (remember the earlier discussion of mutual exclusion).</span></span> <span data-ttu-id="0f532-268">相反地，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 會使用嵌套的訊息處理系統。</span><span class="sxs-lookup"><span data-stu-id="0f532-268">Instead, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses a nested message processing system.</span></span> <span data-ttu-id="0f532-269"><xref:System.Windows.Threading.Dispatcher> 類別包含稱為 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>的特殊方法，它會儲存應用程式的目前執行點，然後開始新的訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="0f532-269">The <xref:System.Windows.Threading.Dispatcher> class includes a special method called <xref:System.Windows.Threading.Dispatcher.PushFrame%2A>, which stores an application’s current execution point then begins a new message loop.</span></span> <span data-ttu-id="0f532-270">當 nested 訊息迴圈完成時，會在原始 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> 呼叫之後繼續執行。</span><span class="sxs-lookup"><span data-stu-id="0f532-270">When the nested message loop finishes, execution resumes after the original <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> call.</span></span>

 <span data-ttu-id="0f532-271">在此情況下，<xref:System.Windows.Threading.Dispatcher.PushFrame%2A> 會在呼叫 <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>時維護程式內容，並啟動新的訊息迴圈來重新繪製背景視窗，並處理訊息方塊視窗的輸入。</span><span class="sxs-lookup"><span data-stu-id="0f532-271">In this case, <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> maintains the program context at the call to <xref:System.Windows.MessageBox.Show%2A?displayProperty=nameWithType>, and it starts a new message loop to repaint the background window and handle input to the message box window.</span></span> <span data-ttu-id="0f532-272">當使用者按一下 [確定] 並清除快顯視窗時，嵌套的迴圈會結束，並在 <xref:System.Windows.MessageBox.Show%2A>的呼叫之後繼續控制。</span><span class="sxs-lookup"><span data-stu-id="0f532-272">When the user clicks OK and clears the pop-up window, the nested loop exits and control resumes after the call to <xref:System.Windows.MessageBox.Show%2A>.</span></span>

### <a name="stale-routed-events"></a><span data-ttu-id="0f532-273">過時的路由事件</span><span class="sxs-lookup"><span data-stu-id="0f532-273">Stale Routed Events</span></span>
 <span data-ttu-id="0f532-274">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的路由事件系統會在引發事件時通知整個樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="0f532-274">The routed event system in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] notifies entire trees when events are raised.</span></span>

 [!code-xaml[InputOvw#ThreadingArticleStaticRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#threadingarticlestaticroutedevent)]

 <span data-ttu-id="0f532-275">在橢圓形上按下滑鼠左鍵時，會執行 `handler2`。</span><span class="sxs-lookup"><span data-stu-id="0f532-275">When the left mouse button is pressed over the ellipse, `handler2` is executed.</span></span> <span data-ttu-id="0f532-276">在 `handler2` 完成之後，事件會傳遞到 <xref:System.Windows.Controls.Canvas> 物件，而此物件會使用 `handler1` 來處理它。</span><span class="sxs-lookup"><span data-stu-id="0f532-276">After `handler2` finishes, the event is passed along to the <xref:System.Windows.Controls.Canvas> object, which uses `handler1` to process it.</span></span> <span data-ttu-id="0f532-277">只有當 `handler2` 未明確地將事件物件標示為已處理時，才會發生這種情況。</span><span class="sxs-lookup"><span data-stu-id="0f532-277">This happens only if `handler2` does not explicitly mark the event object as handled.</span></span>

 <span data-ttu-id="0f532-278">`handler2` 可能需要大量時間來處理此事件。</span><span class="sxs-lookup"><span data-stu-id="0f532-278">It’s possible that `handler2` will take a great deal of time processing this event.</span></span> <span data-ttu-id="0f532-279">`handler2` 可能會使用 <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> 來開始不會傳回小時的嵌套訊息迴圈。</span><span class="sxs-lookup"><span data-stu-id="0f532-279">`handler2` might use <xref:System.Windows.Threading.Dispatcher.PushFrame%2A> to begin a nested message loop that doesn’t return for hours.</span></span> <span data-ttu-id="0f532-280">如果 `handler2` 不會在此訊息迴圈完成時將事件標示為已處理，則會將事件傳遞到樹狀結構中，即使它非常舊也一樣。</span><span class="sxs-lookup"><span data-stu-id="0f532-280">If `handler2` does not mark the event as handled when this message loop is complete, the event is passed up the tree even though it is very old.</span></span>

### <a name="reentrancy-and-locking"></a><span data-ttu-id="0f532-281">重新進入和鎖定</span><span class="sxs-lookup"><span data-stu-id="0f532-281">Reentrancy and Locking</span></span>
 <span data-ttu-id="0f532-282">通用語言執行時間（CLR）的鎖定機制，其行為不會與想像的完全相同;要求鎖定時，可能會預期執行緒完全停止作業。</span><span class="sxs-lookup"><span data-stu-id="0f532-282">The locking mechanism of the common language runtime (CLR) doesn’t behave exactly as one might imagine; one might expect a thread to cease operation completely when requesting a lock.</span></span> <span data-ttu-id="0f532-283">實際上，執行緒會繼續接收和處理高優先順序的訊息。</span><span class="sxs-lookup"><span data-stu-id="0f532-283">In actuality, the thread continues to receive and process high-priority messages.</span></span> <span data-ttu-id="0f532-284">這有助於防止發生鎖死，並讓介面進行最低限度的回應，但它也會造成發生輕微 Bug 的可能性。</span><span class="sxs-lookup"><span data-stu-id="0f532-284">This helps prevent deadlocks and make interfaces minimally responsive, but it introduces the possibility for subtle bugs.</span></span>  <span data-ttu-id="0f532-285">在大部分的情況下，您不需要知道這方面的任何內容，但在罕見的情況下（通常牽涉到 Win32 視窗訊息或 COM STA 元件），這很值得了解。</span><span class="sxs-lookup"><span data-stu-id="0f532-285">The vast majority of the time you don’t need to know anything about this, but under rare circumstances (usually involving Win32 window messages or COM STA components) this can be worth knowing.</span></span>

 <span data-ttu-id="0f532-286">大部分介面不是以執行緒安全的方式建立的，因為開發人員會在假設沒有一個以上的執行緒存取 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 的情況下工作。</span><span class="sxs-lookup"><span data-stu-id="0f532-286">Most interfaces are not built with thread safety in mind because developers work under the assumption that a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] is never accessed by more than one thread.</span></span> <span data-ttu-id="0f532-287">在此情況下，該單一執行緒可能會在非預期的時間進行環境變更，而導致 <xref:System.Windows.Threading.DispatcherObject> 相互排除機制應該會解決這些不正確的影響。</span><span class="sxs-lookup"><span data-stu-id="0f532-287">In this case, that single thread may make environmental changes at unexpected times, causing those ill effects that the <xref:System.Windows.Threading.DispatcherObject> mutual exclusion mechanism is supposed to solve.</span></span> <span data-ttu-id="0f532-288">請考慮下列虛擬程式碼：</span><span class="sxs-lookup"><span data-stu-id="0f532-288">Consider the following pseudocode:</span></span>

 <span data-ttu-id="0f532-289">![顯示執行緒重新進入的圖表。](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span><span class="sxs-lookup"><span data-stu-id="0f532-289">![Diagram that shows threading reentrancy.](./media/threading-model/threading-reentrancy.png "ThreadingReentrancy")</span></span>

 <span data-ttu-id="0f532-290">在大部分的情況下，這是正確的事，但有時 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 這類非預期的重新進入可能會造成問題。</span><span class="sxs-lookup"><span data-stu-id="0f532-290">Most of the time that’s the right thing, but there are times in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] where such unexpected reentrancy can really cause problems.</span></span> <span data-ttu-id="0f532-291">因此，在某些索引鍵的時間，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 會呼叫 <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>，這會變更該執行緒的鎖定指令，以使用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 的重新進入免費鎖定，而不是一般的 CLR 鎖定。</span><span class="sxs-lookup"><span data-stu-id="0f532-291">So, at certain key times, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] calls <xref:System.Windows.Threading.Dispatcher.DisableProcessing%2A>, which changes the lock instruction for that thread to use the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] reentrancy-free lock, instead of the usual CLR lock.</span></span>

 <span data-ttu-id="0f532-292">那麼，為什麼 CLR 小組選擇此行為呢？</span><span class="sxs-lookup"><span data-stu-id="0f532-292">So why did the CLR team choose this behavior?</span></span> <span data-ttu-id="0f532-293">它必須使用 STA COM 物件和完成項執行緒來執行。</span><span class="sxs-lookup"><span data-stu-id="0f532-293">It had to do with COM STA objects and the finalization thread.</span></span> <span data-ttu-id="0f532-294">當物件進行垃圾收集時，其 `Finalize` 方法會在專用的完成項執行緒上執行，而不是在 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 的執行緒上執行。</span><span class="sxs-lookup"><span data-stu-id="0f532-294">When an object is garbage collected, its `Finalize` method is run on the dedicated finalizer thread, not the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="0f532-295">而這就是問題所在，因為在 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒上建立的 COM STA 物件只能在 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒上處置。</span><span class="sxs-lookup"><span data-stu-id="0f532-295">And therein lies the problem, because a COM STA object that was created on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread can only be disposed on the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread.</span></span> <span data-ttu-id="0f532-296">CLR 會執行對等的 <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> （在此案例中使用 Win32 `SendMessage`）。</span><span class="sxs-lookup"><span data-stu-id="0f532-296">The CLR does the equivalent of a <xref:System.Windows.Threading.Dispatcher.BeginInvoke%2A> (in this case using Win32’s `SendMessage`).</span></span> <span data-ttu-id="0f532-297">但是，如果 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 執行緒忙碌中，完成項執行緒就會停止，而且無法處置 COM STA 物件，這會造成嚴重的記憶體流失。</span><span class="sxs-lookup"><span data-stu-id="0f532-297">But if the [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] thread is busy, the finalizer thread is stalled and the COM STA object can’t be disposed, which creates a serious memory leak.</span></span> <span data-ttu-id="0f532-298">因此，CLR 小組進行了很難的呼叫，讓鎖定的執行方式。</span><span class="sxs-lookup"><span data-stu-id="0f532-298">So the CLR team made the tough call to make locks work the way they do.</span></span>

 <span data-ttu-id="0f532-299">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 的工作是避免非預期的重新進入，而不重新介紹基於記憶體流失，這就是為什麼我們不會封鎖任何地方的重新進入。</span><span class="sxs-lookup"><span data-stu-id="0f532-299">The task for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is to avoid unexpected reentrancy without reintroducing the memory leak, which is why we don’t block reentrancy everywhere.</span></span>

## <a name="see-also"></a><span data-ttu-id="0f532-300">另請參閱</span><span class="sxs-lookup"><span data-stu-id="0f532-300">See also</span></span>

- [<span data-ttu-id="0f532-301">單一執行緒應用程式與長期執行的計算範例</span><span class="sxs-lookup"><span data-stu-id="0f532-301">Single-Threaded Application with Long-Running Calculation Sample</span></span>](https://github.com/Microsoft/WPF-Samples/tree/master/Threading/SingleThreadedApplication)
