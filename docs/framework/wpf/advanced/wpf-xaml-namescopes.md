---
title: WPF XAML 名稱範圍
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: a46942188fd417b46ba4feb44d436800e1362098
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/08/2019
ms.locfileid: "59225790"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="47b31-102">WPF XAML 名稱範圍</span><span class="sxs-lookup"><span data-stu-id="47b31-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="47b31-103">XAML 名稱範圍是識別 XAML 中所定義物件的概念。</span><span class="sxs-lookup"><span data-stu-id="47b31-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="47b31-104">XAML 名稱範圍中的名稱可以用來建立物件的 XAML 定義名稱與其在物件樹狀結構中的執行個體對等項目之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="47b31-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="47b31-105">一般而言，載入 XAML 應用程式的個別 XAML 頁面根時，會建立 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Managed 程式碼中的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="47b31-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="47b31-106">作為程式設計物件的 XAML 名稱範圍由<xref:System.Windows.Markup.INameScope>介面，並由實際的類別也會實作<xref:System.Windows.NameScope>。</span><span class="sxs-lookup"><span data-stu-id="47b31-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="47b31-107">所載入 XAML 應用程式中的名稱範圍</span><span class="sxs-lookup"><span data-stu-id="47b31-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="47b31-108">在更廣泛的程式設計或電腦科學內容中，程式設計概念通常包括可用來存取物件之唯一識別碼或名稱的原則。</span><span class="sxs-lookup"><span data-stu-id="47b31-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="47b31-109">針對使用識別碼或名稱的系統，在要求該名稱的物件時，名稱範圍會定義程序或技術將在其內搜尋的界限，或是在其中強制執行識別名稱唯一性的界限。</span><span class="sxs-lookup"><span data-stu-id="47b31-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="47b31-110">這些一般原則適用於 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="47b31-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="47b31-111">在 WPF 中，載入 XAML 頁面時，會在頁面的根項目上建立 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="47b31-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="47b31-112">在頁面根開始之 XAML 頁面內所指定的每個名稱都會新增至適當的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="47b31-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="47b31-113">在 WPF XAML，屬於常見的根元素的項目 (例如<xref:System.Windows.Controls.Page>，和<xref:System.Windows.Window>) 一律會控制 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="47b31-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="47b31-114">如果這類項目<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>是在標記中，頁面的根項目[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]處理器加入<xref:System.Windows.Controls.Page>隱含根以便<xref:System.Windows.Controls.Page>可以提供工作的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="47b31-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="47b31-115">WPF 建置動作會針對 XAML 生產來建立 XAML 名稱範圍，即使未在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 標記的任何項目上定義 `Name` 或 `x:Name` 屬性也是一樣。</span><span class="sxs-lookup"><span data-stu-id="47b31-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="47b31-116">如果您嘗試在任何 XAML 名稱範圍中使用相同的名稱兩次，則會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="47b31-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="47b31-117">針對具有程式碼後置且為已編譯應用程式一部分的 WPF XAML，在初始標記編譯期間建立頁面的已產生類別時，WPF 建置動作會在建置期間引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="47b31-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="47b31-118">針對未透過任何建置動作進行標記編譯的 XAML，在載入 XAML 時，可能會引發 XAML 名稱範圍問題的相關例外狀況。</span><span class="sxs-lookup"><span data-stu-id="47b31-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="47b31-119">XAML 設計工具也可能預期會在設計階段發生 XAML 名稱範圍問題。</span><span class="sxs-lookup"><span data-stu-id="47b31-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="47b31-120">將物件新增至執行階段物件樹狀結構</span><span class="sxs-lookup"><span data-stu-id="47b31-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="47b31-121">剖析 XAML 的時間點代表建立和定義 WPF XAML 名稱範圍的時間點。</span><span class="sxs-lookup"><span data-stu-id="47b31-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="47b31-122">如果您在剖析已產生該樹狀結構的 XAML 之後的某個時間點，將物件新增至物件樹狀結構，則新物件上的 `Name` 或 `x:Name` 值不會自動更新 XAML 名稱範圍中的資訊。</span><span class="sxs-lookup"><span data-stu-id="47b31-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="47b31-123">載入 XAML 之後，請將物件的名稱新增至 WPF XAML 名稱範圍，您必須呼叫的適當實作<xref:System.Windows.Markup.INameScope.RegisterName%2A>上定義的 XAML 名稱範圍的物件，通常是 XAML 頁面根。</span><span class="sxs-lookup"><span data-stu-id="47b31-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="47b31-124">如果未註冊名稱，加入的物件無法依名稱來參考方法透過例如<xref:System.Windows.FrameworkElement.FindName%2A>，而且您無法使用該名稱作為動畫目標。</span><span class="sxs-lookup"><span data-stu-id="47b31-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="47b31-125">應用程式開發人員最常見的案例是，您將使用<xref:System.Windows.FrameworkElement.RegisterName%2A>將名稱註冊到目前頁面根目錄上的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="47b31-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <xref:System.Windows.FrameworkElement.RegisterName%2A> <span data-ttu-id="47b31-126">該動畫的目標物件是分鏡腳本的重要案例的一部分。</span><span class="sxs-lookup"><span data-stu-id="47b31-126">is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="47b31-127">如需詳細資訊，請參閱[分鏡腳本概觀](../graphics-multimedia/storyboards-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="47b31-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="47b31-128">如果您呼叫<xref:System.Windows.FrameworkElement.RegisterName%2A>以外的物件，定義 XAML 名稱範圍的物件，在名稱仍註冊內，保存呼叫物件的 XAML 名稱範圍視為已呼叫<xref:System.Windows.FrameworkElement.RegisterName%2A>上定義物件的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="47b31-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="47b31-129">程式碼中的 XAML 名稱範圍</span><span class="sxs-lookup"><span data-stu-id="47b31-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="47b31-130">您可以在程式碼中建立 XAML 名稱範圍後來加以使用。</span><span class="sxs-lookup"><span data-stu-id="47b31-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="47b31-131">甚至針對純程式碼用法，與 XAML 名稱範圍建立有關的 API 和概念也會相同，因為 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 的 XAML 處理器在處理 XAML 本身時會使用這些 API 和概念。</span><span class="sxs-lookup"><span data-stu-id="47b31-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="47b31-132">概念和 API 的存在目的主要是可以依名稱在物件樹狀結構內找到物件，而物件樹狀結構一般是在 XAML 中部分或完整定義。</span><span class="sxs-lookup"><span data-stu-id="47b31-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="47b31-133">以程式設計方式建立的應用程式，而不是從載入的 XAML，定義 XAML 名稱範圍的物件必須實作<xref:System.Windows.Markup.INameScope>，或者是<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>衍生類別，才能支援建立 XAML 名稱範圍，在其執行個體。</span><span class="sxs-lookup"><span data-stu-id="47b31-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="47b31-134">此外，針對 XAML 處理器未載入和處理的任何項目，預設都不會建立或初始化物件的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="47b31-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="47b31-135">您必須針對任何您要註冊名稱的物件，明確建立新的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="47b31-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="47b31-136">若要建立 XAML 名稱範圍，您可以呼叫靜態<xref:System.Windows.NameScope.SetNameScope%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="47b31-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="47b31-137">指定將擁有它做為物件`dependencyObject`參數，而且新<xref:System.Windows.NameScope.%23ctor%2A>做為建構函式呼叫`value`參數。</span><span class="sxs-lookup"><span data-stu-id="47b31-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="47b31-138">如果物件提供作為`dependencyObject`for<xref:System.Windows.NameScope.SetNameScope%2A>不是<xref:System.Windows.Markup.INameScope>實作中，<xref:System.Windows.FrameworkElement>或<xref:System.Windows.FrameworkContentElement>，則呼叫<xref:System.Windows.FrameworkElement.RegisterName%2A>上任何子系項目會有任何作用。</span><span class="sxs-lookup"><span data-stu-id="47b31-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="47b31-139">如果您無法明確地建立新的 XAML 名稱範圍，然後呼叫<xref:System.Windows.FrameworkElement.RegisterName%2A>會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="47b31-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="47b31-140">如需在程式碼中使用 XAML 名稱範圍 API 的範例，請參閱[定義名稱範圍](../graphics-multimedia/how-to-define-a-name-scope.md)。</span><span class="sxs-lookup"><span data-stu-id="47b31-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="47b31-141">樣式和範本中的 XAML 名稱範圍</span><span class="sxs-lookup"><span data-stu-id="47b31-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="47b31-142">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的樣式和範本可以用更簡單的方式重複使用和重新套用內容。</span><span class="sxs-lookup"><span data-stu-id="47b31-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="47b31-143">不過，樣式和範本可能也包括具有範本層級所定義之 XAML 名稱的項目。</span><span class="sxs-lookup"><span data-stu-id="47b31-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="47b31-144">可能會在頁面中多次使用這個相同的範本。</span><span class="sxs-lookup"><span data-stu-id="47b31-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="47b31-145">因此，樣式和範本都會定義其專屬 XAML 名稱範圍，這與物件樹狀結構中套用樣式或範本的位置無關。</span><span class="sxs-lookup"><span data-stu-id="47b31-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="47b31-146">參考下列範例：</span><span class="sxs-lookup"><span data-stu-id="47b31-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="47b31-147">在這裡，相同的範本會套用至兩個不同的按鈕。</span><span class="sxs-lookup"><span data-stu-id="47b31-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="47b31-148">如果範本沒有離散 XAML 名稱範圍，則範本中所使用的 `TheBorder` 名稱會導致 XAML 名稱範圍中的名稱衝突。</span><span class="sxs-lookup"><span data-stu-id="47b31-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="47b31-149">範本的每個具現化都有其專屬的 XAML 名稱範圍；因此，在此範例中，每個具現化範本的 XAML 名稱範圍都只會包含一個名稱。</span><span class="sxs-lookup"><span data-stu-id="47b31-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="47b31-150">樣式也會定義其專屬的 XAML 名稱範圍；因此，分鏡腳本的各部分一般可以獲指派特定名稱。</span><span class="sxs-lookup"><span data-stu-id="47b31-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="47b31-151">即使已在控制項自訂時重新定義範本，這些名稱還是可以啟用將目標設為該名稱之項目的控制項特定行為。</span><span class="sxs-lookup"><span data-stu-id="47b31-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="47b31-152">因為不同的 XAML 名稱範圍，所以在範本中尋找具名項目會比在頁面中尋找非範本具名項目更具挑戰。</span><span class="sxs-lookup"><span data-stu-id="47b31-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="47b31-153">您必須先決定套用的範本，藉由取得<xref:System.Windows.Controls.Control.Template%2A>套用範本之控制項的屬性值。</span><span class="sxs-lookup"><span data-stu-id="47b31-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="47b31-154">然後，您可以呼叫的範本版本<xref:System.Windows.FrameworkTemplate.FindName%2A>，將控制項傳遞已套用範本做為第二個參數。</span><span class="sxs-lookup"><span data-stu-id="47b31-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="47b31-155">如果您是控制項作者，而且您要產生的特定具名已套用範本中的項目所在的目標由控制項本身所定義的行為的慣例，您可以使用<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>從控制項實作程式碼的方法。</span><span class="sxs-lookup"><span data-stu-id="47b31-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="47b31-156"><xref:System.Windows.FrameworkElement.GetTemplateChild%2A>方法受到保護，因此只有控制項作者可存取它。</span><span class="sxs-lookup"><span data-stu-id="47b31-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="47b31-157">如果您使用範本，以及為取得 XAML 名稱範圍套用範本，取得的值<xref:System.Windows.FrameworkElement.TemplatedParent%2A>，然後呼叫<xref:System.Windows.FrameworkElement.FindName%2A>那里。</span><span class="sxs-lookup"><span data-stu-id="47b31-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="47b31-158">在範本內運作的範例就是您要撰寫事件處理常式實作，其中，將從已套用範本中的項目引發事件。</span><span class="sxs-lookup"><span data-stu-id="47b31-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="47b31-159">XAML 名稱範圍和名稱相關 API</span><span class="sxs-lookup"><span data-stu-id="47b31-159">XAML Namescopes and Name-related APIs</span></span>  
 <xref:System.Windows.FrameworkElement> <span data-ttu-id="47b31-160">已<xref:System.Windows.FrameworkElement.FindName%2A>，<xref:System.Windows.FrameworkElement.RegisterName%2A>和<xref:System.Windows.FrameworkElement.UnregisterName%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="47b31-160">has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="47b31-161">如果您在其上呼叫這些方法的物件擁有 XAML 名稱範圍，則方法會呼叫相關 XAML 名稱範圍的方法。</span><span class="sxs-lookup"><span data-stu-id="47b31-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="47b31-162">否則，會檢查父項目，確認它是否擁有 XAML 名稱範圍，而且此程序會遞迴地執行，直到找到 XAML 名稱範圍 (因為 XAML 處理器行為，所以根一定會有 XAML 名稱範圍)。</span><span class="sxs-lookup"><span data-stu-id="47b31-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <xref:System.Windows.FrameworkContentElement> <span data-ttu-id="47b31-163">具有類似的行為，與例外狀況，任何<xref:System.Windows.FrameworkContentElement>會擁有 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="47b31-163">has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="47b31-164">這些方法存在於<xref:System.Windows.FrameworkContentElement>這樣的呼叫可以轉送至最終<xref:System.Windows.FrameworkElement>父項目。</span><span class="sxs-lookup"><span data-stu-id="47b31-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <xref:System.Windows.NameScope.SetNameScope%2A> <span data-ttu-id="47b31-165">用來將新的 XAML 名稱範圍對應至現有的物件。</span><span class="sxs-lookup"><span data-stu-id="47b31-165">is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="47b31-166">您可以呼叫<xref:System.Windows.NameScope.SetNameScope%2A>多次來重設或清除 XAML 名稱範圍，但不是常見的用法。</span><span class="sxs-lookup"><span data-stu-id="47b31-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="47b31-167">此外，<xref:System.Windows.NameScope.GetNameScope%2A>通常不會使用從程式碼。</span><span class="sxs-lookup"><span data-stu-id="47b31-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="47b31-168">XAML 名稱範圍實作</span><span class="sxs-lookup"><span data-stu-id="47b31-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="47b31-169">下列類別會實作<xref:System.Windows.Markup.INameScope>直接：</span><span class="sxs-lookup"><span data-stu-id="47b31-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
-   <xref:System.Windows.NameScope>  
  
-   <xref:System.Windows.Style>  
  
-   <xref:System.Windows.ResourceDictionary>  
  
-   <xref:System.Windows.FrameworkTemplate>  
  
 <xref:System.Windows.ResourceDictionary> <span data-ttu-id="47b31-170">不使用 XAML 名稱範圍;它會改用索引鍵，因為它是一個字典實作。</span><span class="sxs-lookup"><span data-stu-id="47b31-170">does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="47b31-171">唯一原因<xref:System.Windows.ResourceDictionary>會實作<xref:System.Windows.Markup.INameScope>是讓它可以引發例外狀況給使用者程式碼協助釐清，則為 true 的 XAML 名稱範圍之間的差異，以及如何<xref:System.Windows.ResourceDictionary>處理按鍵，並也確保 XAML 名稱範圍不會套用至<xref:System.Windows.ResourceDictionary>父項目。</span><span class="sxs-lookup"><span data-stu-id="47b31-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <xref:System.Windows.FrameworkTemplate> <span data-ttu-id="47b31-172">並<xref:System.Windows.Style>實作<xref:System.Windows.Markup.INameScope>透過明確介面定義。</span><span class="sxs-lookup"><span data-stu-id="47b31-172">and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="47b31-173">明確的實作可讓運作存取透過時這些 XAML 名稱範圍<xref:System.Windows.Markup.INameScope>介面，也就是如何把傳達 XAML 名稱範圍的[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]內部處理程序。</span><span class="sxs-lookup"><span data-stu-id="47b31-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="47b31-174">明確介面定義不是傳統 API 介面的一部分，但是<xref:System.Windows.FrameworkTemplate>並<xref:System.Windows.Style>，因為您很少需要呼叫<xref:System.Windows.Markup.INameScope>上的方法<xref:System.Windows.FrameworkTemplate>和<xref:System.Windows.Style>直接，並改為使用其他 API這類<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>。</span><span class="sxs-lookup"><span data-stu-id="47b31-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="47b31-175">下列類別定義其專屬 XAML 名稱範圍中，使用<xref:System.Windows.NameScope?displayProperty=nameWithType>協助程式類別，並連接到它的 XAML 名稱範圍實作透過<xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType>附加屬性：</span><span class="sxs-lookup"><span data-stu-id="47b31-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
-   <xref:System.Windows.FrameworkElement>  
  
-   <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="47b31-176">另請參閱</span><span class="sxs-lookup"><span data-stu-id="47b31-176">See also</span></span>

- [<span data-ttu-id="47b31-177">WPF XAML 的 XAML 命名空間和命名空間對應</span><span class="sxs-lookup"><span data-stu-id="47b31-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="47b31-178">x:Name 指示詞</span><span class="sxs-lookup"><span data-stu-id="47b31-178">x:Name Directive</span></span>](../../xaml-services/x-name-directive.md)
