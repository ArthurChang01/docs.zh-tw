---
title: XAML 命名範圍
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: f9d4439c6b102d0d430b5201e3649985daee0b7f
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186279"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="858f1-102">WPF XAML 名稱範圍</span><span class="sxs-lookup"><span data-stu-id="858f1-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="858f1-103">XAML 名稱範圍是識別 XAML 中所定義物件的概念。</span><span class="sxs-lookup"><span data-stu-id="858f1-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="858f1-104">XAML 名稱範圍中的名稱可以用來建立物件的 XAML 定義名稱與其在物件樹狀結構中的執行個體對等項目之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="858f1-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="858f1-105">一般而言，載入 XAML 應用程式的個別 XAML 頁面根時，會建立 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] Managed 程式碼中的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="858f1-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="858f1-106">XAML名稱範圍作為程式設計物件由<xref:System.Windows.Markup.INameScope>介面定義，也由實用類<xref:System.Windows.NameScope>實現。</span><span class="sxs-lookup"><span data-stu-id="858f1-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="858f1-107">所載入 XAML 應用程式中的名稱範圍</span><span class="sxs-lookup"><span data-stu-id="858f1-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="858f1-108">在更廣泛的程式設計或電腦科學內容中，程式設計概念通常包括可用來存取物件之唯一識別碼或名稱的原則。</span><span class="sxs-lookup"><span data-stu-id="858f1-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="858f1-109">針對使用識別碼或名稱的系統，在要求該名稱的物件時，名稱範圍會定義程序或技術將在其內搜尋的界限，或是在其中強制執行識別名稱唯一性的界限。</span><span class="sxs-lookup"><span data-stu-id="858f1-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="858f1-110">這些一般原則適用於 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="858f1-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="858f1-111">在 WPF 中，載入 XAML 頁面時，會在頁面的根項目上建立 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="858f1-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="858f1-112">在頁面根開始之 XAML 頁面內所指定的每個名稱都會新增至適當的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="858f1-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="858f1-113">在 WPF XAML 中，作為公共根項目的元素<xref:System.Windows.Controls.Page>（如<xref:System.Windows.Window>和 ） 始終控制 XAML 命名範圍。</span><span class="sxs-lookup"><span data-stu-id="858f1-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="858f1-114">如果元素<xref:System.Windows.FrameworkElement>（如 或<xref:System.Windows.FrameworkContentElement>是標記中頁面的根項目），[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]則處理器隱式添加<xref:System.Windows.Controls.Page>根，以便<xref:System.Windows.Controls.Page>可以提供有效的 XAML 命名範圍。</span><span class="sxs-lookup"><span data-stu-id="858f1-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="858f1-115">WPF 建置動作會針對 XAML 生產來建立 XAML 名稱範圍，即使未在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 標記的任何項目上定義 `Name` 或 `x:Name` 屬性也是一樣。</span><span class="sxs-lookup"><span data-stu-id="858f1-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="858f1-116">如果您嘗試在任何 XAML 名稱範圍中使用相同的名稱兩次，則會引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="858f1-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="858f1-117">針對具有程式碼後置且為已編譯應用程式一部分的 WPF XAML，在初始標記編譯期間建立頁面的已產生類別時，WPF 建置動作會在建置期間引發例外狀況。</span><span class="sxs-lookup"><span data-stu-id="858f1-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="858f1-118">針對未透過任何建置動作進行標記編譯的 XAML，在載入 XAML 時，可能會引發 XAML 名稱範圍問題的相關例外狀況。</span><span class="sxs-lookup"><span data-stu-id="858f1-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="858f1-119">XAML 設計工具也可能預期會在設計階段發生 XAML 名稱範圍問題。</span><span class="sxs-lookup"><span data-stu-id="858f1-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="858f1-120">將物件新增至執行階段物件樹狀結構</span><span class="sxs-lookup"><span data-stu-id="858f1-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="858f1-121">剖析 XAML 的時間點代表建立和定義 WPF XAML 名稱範圍的時間點。</span><span class="sxs-lookup"><span data-stu-id="858f1-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="858f1-122">如果您在剖析已產生該樹狀結構的 XAML 之後的某個時間點，將物件新增至物件樹狀結構，則新物件上的 `Name` 或 `x:Name` 值不會自動更新 XAML 名稱範圍中的資訊。</span><span class="sxs-lookup"><span data-stu-id="858f1-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="858f1-123">要在載入 XAML 後將物件的名稱添加到 WPF XAML 命名範圍中，必須在定義 XAML 名稱範圍的物件<xref:System.Windows.Markup.INameScope.RegisterName%2A>上調用相應的實現，該名稱範圍通常是 XAML 頁面根。</span><span class="sxs-lookup"><span data-stu-id="858f1-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="858f1-124">如果未註冊該名稱，則無法通過 方法（如<xref:System.Windows.FrameworkElement.FindName%2A>） 引用添加的物件，也不能將該名稱用於動畫定位。</span><span class="sxs-lookup"><span data-stu-id="858f1-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="858f1-125">對於應用程式開發人員來說，最常見的方案是，您將使用<xref:System.Windows.FrameworkElement.RegisterName%2A>在頁面當前根目錄上的 XAML 命名範圍中註冊名稱。</span><span class="sxs-lookup"><span data-stu-id="858f1-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="858f1-126"><xref:System.Windows.FrameworkElement.RegisterName%2A>是面向動畫物件的分鏡腳本的重要方案的一部分。</span><span class="sxs-lookup"><span data-stu-id="858f1-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="858f1-127">如需詳細資訊，請參閱[分鏡腳本概觀](../graphics-multimedia/storyboards-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="858f1-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="858f1-128">如果對定義<xref:System.Windows.FrameworkElement.RegisterName%2A>XAML 名稱範圍的物件以外的物件進行調用，則該名稱仍註冊到調用物件所持有的 XAML 命名範圍，就像調用 XAML<xref:System.Windows.FrameworkElement.RegisterName%2A>命名物件一樣。</span><span class="sxs-lookup"><span data-stu-id="858f1-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="858f1-129">程式碼中的 XAML 名稱範圍</span><span class="sxs-lookup"><span data-stu-id="858f1-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="858f1-130">您可以在程式碼中建立 XAML 名稱範圍後來加以使用。</span><span class="sxs-lookup"><span data-stu-id="858f1-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="858f1-131">甚至針對純程式碼用法，與 XAML 名稱範圍建立有關的 API 和概念也會相同，因為 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 的 XAML 處理器在處理 XAML 本身時會使用這些 API 和概念。</span><span class="sxs-lookup"><span data-stu-id="858f1-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="858f1-132">概念和 API 的存在目的主要是可以依名稱在物件樹狀結構內找到物件，而物件樹狀結構一般是在 XAML 中部分或完整定義。</span><span class="sxs-lookup"><span data-stu-id="858f1-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="858f1-133">對於以程式設計方式創建而不是從載入的 XAML 創建的應用程式，定義 XAML 名稱範圍的物件必須實現<xref:System.Windows.Markup.INameScope>或 或<xref:System.Windows.FrameworkElement><xref:System.Windows.FrameworkContentElement>派生類，以支援在其實例上創建 XAML 命名範圍。</span><span class="sxs-lookup"><span data-stu-id="858f1-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="858f1-134">此外，針對 XAML 處理器未載入和處理的任何項目，預設都不會建立或初始化物件的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="858f1-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="858f1-135">您必須針對任何您要註冊名稱的物件，明確建立新的 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="858f1-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="858f1-136">要創建 XAML 命名範圍，請調用靜態<xref:System.Windows.NameScope.SetNameScope%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="858f1-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="858f1-137">指定將具有該物件為`dependencyObject`參數的物件，並將新的<xref:System.Windows.NameScope.%23ctor%2A>建構函式調用作為`value`參數。</span><span class="sxs-lookup"><span data-stu-id="858f1-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="858f1-138">如果所`dependencyObject`<xref:System.Windows.NameScope.SetNameScope%2A>提供的物件<xref:System.Windows.Markup.INameScope>不是實現，<xref:System.Windows.FrameworkElement>或者<xref:System.Windows.FrameworkContentElement>調用<xref:System.Windows.FrameworkElement.RegisterName%2A>任何子項目將不起作用。</span><span class="sxs-lookup"><span data-stu-id="858f1-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="858f1-139">如果無法顯式創建新的 XAML 命名範圍，則調用 將<xref:System.Windows.FrameworkElement.RegisterName%2A>引發異常。</span><span class="sxs-lookup"><span data-stu-id="858f1-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="858f1-140">如需在程式碼中使用 XAML 名稱範圍 API 的範例，請參閱[定義名稱範圍](../graphics-multimedia/how-to-define-a-name-scope.md)。</span><span class="sxs-lookup"><span data-stu-id="858f1-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="858f1-141">樣式和範本中的 XAML 名稱範圍</span><span class="sxs-lookup"><span data-stu-id="858f1-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="858f1-142">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的樣式和範本可以用更簡單的方式重複使用和重新套用內容。</span><span class="sxs-lookup"><span data-stu-id="858f1-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="858f1-143">不過，樣式和範本可能也包括具有範本層級所定義之 XAML 名稱的項目。</span><span class="sxs-lookup"><span data-stu-id="858f1-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="858f1-144">可能會在頁面中多次使用這個相同的範本。</span><span class="sxs-lookup"><span data-stu-id="858f1-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="858f1-145">因此，樣式和範本都會定義其專屬 XAML 名稱範圍，這與物件樹狀結構中套用樣式或範本的位置無關。</span><span class="sxs-lookup"><span data-stu-id="858f1-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="858f1-146">請考慮下列範例：</span><span class="sxs-lookup"><span data-stu-id="858f1-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="858f1-147">在這裡，相同的範本會套用至兩個不同的按鈕。</span><span class="sxs-lookup"><span data-stu-id="858f1-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="858f1-148">如果範本沒有離散 XAML 名稱範圍，則範本中所使用的 `TheBorder` 名稱會導致 XAML 名稱範圍中的名稱衝突。</span><span class="sxs-lookup"><span data-stu-id="858f1-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="858f1-149">範本的每個具現化都有其專屬的 XAML 名稱範圍；因此，在此範例中，每個具現化範本的 XAML 名稱範圍都只會包含一個名稱。</span><span class="sxs-lookup"><span data-stu-id="858f1-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="858f1-150">樣式也會定義其專屬的 XAML 名稱範圍；因此，分鏡腳本的各部分一般可以獲指派特定名稱。</span><span class="sxs-lookup"><span data-stu-id="858f1-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="858f1-151">即使已在控制項自訂時重新定義範本，這些名稱還是可以啟用將目標設為該名稱之項目的控制項特定行為。</span><span class="sxs-lookup"><span data-stu-id="858f1-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="858f1-152">因為不同的 XAML 名稱範圍，所以在範本中尋找具名項目會比在頁面中尋找非範本具名項目更具挑戰。</span><span class="sxs-lookup"><span data-stu-id="858f1-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="858f1-153">首先需要通過獲取應用範本的控制項<xref:System.Windows.Controls.Control.Template%2A>的屬性值來確定應用的範本。</span><span class="sxs-lookup"><span data-stu-id="858f1-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="858f1-154">然後，調用 的<xref:System.Windows.FrameworkTemplate.FindName%2A>範本版本，傳遞作為第二個參數應用範本的控制項。</span><span class="sxs-lookup"><span data-stu-id="858f1-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="858f1-155">如果您是控制項作者，並且正在生成一個約定，其中應用範本中的特定命名元素是控制項本身定義的行為的目標，則可以使用控制項實現代碼中<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>的方法。</span><span class="sxs-lookup"><span data-stu-id="858f1-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="858f1-156">該方法<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>受到保護，因此只有控制項作者才能訪問它。</span><span class="sxs-lookup"><span data-stu-id="858f1-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="858f1-157">如果您正在範本內工作，並且需要訪問應用範本的 XAML 名稱範圍，請獲取 的值<xref:System.Windows.FrameworkElement.TemplatedParent%2A>，然後調用<xref:System.Windows.FrameworkElement.FindName%2A>該值。</span><span class="sxs-lookup"><span data-stu-id="858f1-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="858f1-158">在範本內運作的範例就是您要撰寫事件處理常式實作，其中，將從已套用範本中的項目引發事件。</span><span class="sxs-lookup"><span data-stu-id="858f1-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="858f1-159">XAML 名稱範圍和名稱相關 API</span><span class="sxs-lookup"><span data-stu-id="858f1-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="858f1-160"><xref:System.Windows.FrameworkElement>有<xref:System.Windows.FrameworkElement.FindName%2A> <xref:System.Windows.FrameworkElement.RegisterName%2A> ，<xref:System.Windows.FrameworkElement.UnregisterName%2A>和方法。</span><span class="sxs-lookup"><span data-stu-id="858f1-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="858f1-161">如果您在其上呼叫這些方法的物件擁有 XAML 名稱範圍，則方法會呼叫相關 XAML 名稱範圍的方法。</span><span class="sxs-lookup"><span data-stu-id="858f1-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="858f1-162">否則，會檢查父項目，確認它是否擁有 XAML 名稱範圍，而且此程序會遞迴地執行，直到找到 XAML 名稱範圍 (因為 XAML 處理器行為，所以根一定會有 XAML 名稱範圍)。</span><span class="sxs-lookup"><span data-stu-id="858f1-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="858f1-163"><xref:System.Windows.FrameworkContentElement>具有類似行為，但沒有任何<xref:System.Windows.FrameworkContentElement>人擁有 XAML 名稱範圍。</span><span class="sxs-lookup"><span data-stu-id="858f1-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="858f1-164">這些方法存在，<xref:System.Windows.FrameworkContentElement>以便最終可以將調用轉發到<xref:System.Windows.FrameworkElement>父元素。</span><span class="sxs-lookup"><span data-stu-id="858f1-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="858f1-165"><xref:System.Windows.NameScope.SetNameScope%2A>用於將新的 XAML 命名範圍映射到現有物件。</span><span class="sxs-lookup"><span data-stu-id="858f1-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="858f1-166">您可以多次調用<xref:System.Windows.NameScope.SetNameScope%2A>以重置或清除 XAML 名稱範圍，但這不是常見用法。</span><span class="sxs-lookup"><span data-stu-id="858f1-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="858f1-167">此外，<xref:System.Windows.NameScope.GetNameScope%2A>通常不從代碼中使用。</span><span class="sxs-lookup"><span data-stu-id="858f1-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="858f1-168">XAML 名稱範圍實作</span><span class="sxs-lookup"><span data-stu-id="858f1-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="858f1-169">以下類直接實現<xref:System.Windows.Markup.INameScope>：</span><span class="sxs-lookup"><span data-stu-id="858f1-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
- <xref:System.Windows.NameScope>  
  
- <xref:System.Windows.Style>  
  
- <xref:System.Windows.ResourceDictionary>  
  
- <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="858f1-170"><xref:System.Windows.ResourceDictionary>不使用 XAML 名稱或名稱範圍;它使用鍵，因為它是字典實現。</span><span class="sxs-lookup"><span data-stu-id="858f1-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="858f1-171">實現<xref:System.Windows.ResourceDictionary><xref:System.Windows.Markup.INameScope>的唯一原因是，它可以對使用者代碼引發異常，以説明闡明真正的 XAML 命名範圍與<xref:System.Windows.ResourceDictionary>處理金鑰的方式之間的區別，並確保 XAML 命名碼不<xref:System.Windows.ResourceDictionary>應用於父元素。</span><span class="sxs-lookup"><span data-stu-id="858f1-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="858f1-172"><xref:System.Windows.FrameworkTemplate>並通過<xref:System.Windows.Style>顯式<xref:System.Windows.Markup.INameScope>介面定義實現。</span><span class="sxs-lookup"><span data-stu-id="858f1-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="858f1-173">顯式實現允許這些 XAML 命名範圍在通過<xref:System.Windows.Markup.INameScope>介面訪問時按常規方式執行，這是[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]內部進程傳達 XAML 名稱範圍的方式。</span><span class="sxs-lookup"><span data-stu-id="858f1-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="858f1-174">但是顯式介面定義不是<xref:System.Windows.FrameworkTemplate>和<xref:System.Windows.Style>的常規 API 表面的一部分，因為您很少需要直接調用<xref:System.Windows.Markup.INameScope>方法<xref:System.Windows.FrameworkTemplate><xref:System.Windows.Style>，而是使用其他 API（如<xref:System.Windows.FrameworkElement.GetTemplateChild%2A>）。</span><span class="sxs-lookup"><span data-stu-id="858f1-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="858f1-175">以下類通過使用<xref:System.Windows.NameScope?displayProperty=nameWithType>説明器類並通過<xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType>附加屬性連接到其 XAML 命名範圍實現，定義它們自己的 XAML 命名範圍：</span><span class="sxs-lookup"><span data-stu-id="858f1-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
- <xref:System.Windows.FrameworkElement>  
  
- <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="858f1-176">另請參閱</span><span class="sxs-lookup"><span data-stu-id="858f1-176">See also</span></span>

- [<span data-ttu-id="858f1-177">WPF XAML 的 XAML 命名空間和命名空間對應</span><span class="sxs-lookup"><span data-stu-id="858f1-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="858f1-178">x:Name 指示詞</span><span class="sxs-lookup"><span data-stu-id="858f1-178">x:Name Directive</span></span>](../../../desktop-wpf/xaml-services/xname-directive.md)
