---
title: WPF 架構
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: 7214304d8575fb6ef8774d55eaf29ad714235123
ms.sourcegitcommit: 6b308cf6d627d78ee36dbbae8972a310ac7fd6c8
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 01/23/2019
ms.locfileid: "54634580"
---
# <a name="wpf-architecture"></a><span data-ttu-id="4e707-102">WPF 架構</span><span class="sxs-lookup"><span data-stu-id="4e707-102">WPF Architecture</span></span>
<span data-ttu-id="4e707-103">本主題提供 Windows Presentation Foundation (WPF) 的類別階層架構的導覽。</span><span class="sxs-lookup"><span data-stu-id="4e707-103">This topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy.</span></span> <span data-ttu-id="4e707-104">它涵蓋大部分的 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 主要子系統，並描述其互動方式。</span><span class="sxs-lookup"><span data-stu-id="4e707-104">It covers most of the major subsystems of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], and describes how they interact.</span></span> <span data-ttu-id="4e707-105">它也會詳述 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 架構設計人員所進行的一些選擇。</span><span class="sxs-lookup"><span data-stu-id="4e707-105">It also details some of the choices made by the architects of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span>  
  
  
<a name="System_Object"></a>   
## <a name="systemobject"></a><span data-ttu-id="4e707-106">System.Object</span><span class="sxs-lookup"><span data-stu-id="4e707-106">System.Object</span></span>  
 <span data-ttu-id="4e707-107">主要 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 程式設計模型是透過 Managed 程式碼所公開。</span><span class="sxs-lookup"><span data-stu-id="4e707-107">The primary [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] programming model is exposed through managed code.</span></span> <span data-ttu-id="4e707-108">在 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 設計階段早期，有關應該在系統的 Managed 元件與 Unmanaged 元件之間繪製線條的位置有許多爭論。</span><span class="sxs-lookup"><span data-stu-id="4e707-108">Early in the design phase of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones.</span></span> <span data-ttu-id="4e707-109">[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 提供許多功能，讓開發更具生產力且更穩固 (包括記憶體管理、錯誤處理、一般類型系統等)，但都需要付出代價。</span><span class="sxs-lookup"><span data-stu-id="4e707-109">The [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.</span></span>  
  
 <span data-ttu-id="4e707-110">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的主要元件如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="4e707-110">The major components of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] are illustrated in the figure below.</span></span> <span data-ttu-id="4e707-111">圖表的紅色區段 (PresentationFramework、PresentationCore 和 milcore) 是 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的主要程式碼部分。</span><span class="sxs-lookup"><span data-stu-id="4e707-111">The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="4e707-112">其中只有一種是 Unmanaged 元件：milcore。</span><span class="sxs-lookup"><span data-stu-id="4e707-112">Of these, only one is an unmanaged component – milcore.</span></span> <span data-ttu-id="4e707-113">milcore 是使用 Unmanaged 程式碼所撰寫，以啟用與 [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)] 的緊密整合。</span><span class="sxs-lookup"><span data-stu-id="4e707-113">Milcore is written in unmanaged code in order to enable tight integration with [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)].</span></span> <span data-ttu-id="4e707-114">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中的所有顯示都是透過 [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)] 引擎所完成，以允許有效率的硬體和軟體轉譯。</span><span class="sxs-lookup"><span data-stu-id="4e707-114">All display in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is done through the [!INCLUDE[TLA2#tla_dx](../../../../includes/tla2sharptla-dx-md.md)] engine, allowing for efficient hardware and software rendering.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="4e707-115">也需要記憶體和執行的良好控制。</span><span class="sxs-lookup"><span data-stu-id="4e707-115">also required fine control over memory and execution.</span></span> <span data-ttu-id="4e707-116">milcore 中的組合引擎對於效能異常敏感，而且需要犧牲許多 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 優點才能獲得效能。</span><span class="sxs-lookup"><span data-stu-id="4e707-116">The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] to gain performance.</span></span>  
  
 <span data-ttu-id="4e707-117">![WPF 在 .NET Framework 中的位置。](../../../../docs/framework/wpf/advanced/media/wpf-architect1.PNG "wpf_architect1")</span><span class="sxs-lookup"><span data-stu-id="4e707-117">![The position of WPF within the .NET Framework.](../../../../docs/framework/wpf/advanced/media/wpf-architect1.PNG "wpf_architect1")</span></span>  
  
 <span data-ttu-id="4e707-118">本主題稍後會討論 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的 Managed 與 Unmanaged 部分之間的通訊。</span><span class="sxs-lookup"><span data-stu-id="4e707-118">Communication between the managed and unmanaged portions of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is discussed later in this topic.</span></span> <span data-ttu-id="4e707-119">Managed 程式設計模型的其餘部分說明如下。</span><span class="sxs-lookup"><span data-stu-id="4e707-119">The remainder of the managed programming model is described below.</span></span>  
  
<a name="System_Threading_DispatcherObject"></a>   
## <a name="systemthreadingdispatcherobject"></a><span data-ttu-id="4e707-120">System.Threading.DispatcherObject</span><span class="sxs-lookup"><span data-stu-id="4e707-120">System.Threading.DispatcherObject</span></span>  
 <span data-ttu-id="4e707-121">中的大部分物件[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]衍生自<xref:System.Windows.Threading.DispatcherObject>，可用於處理並行和執行緒處理的基本建構。</span><span class="sxs-lookup"><span data-stu-id="4e707-121">Most objects in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="4e707-122">是根據發送器所實作的訊息系統。</span><span class="sxs-lookup"><span data-stu-id="4e707-122">is based on a messaging system implemented by the dispatcher.</span></span> <span data-ttu-id="4e707-123">此運作方式很像熟悉的 [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] 訊息提取；事實上，[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 發送器使用 User32 訊息來執行跨執行緒呼叫。</span><span class="sxs-lookup"><span data-stu-id="4e707-123">This works much like the familiar [!INCLUDE[TLA#tla_win32](../../../../includes/tlasharptla-win32-md.md)] message pump; in fact, the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] dispatcher uses User32 messages for performing cross thread calls.</span></span>  
  
 <span data-ttu-id="4e707-124">討論 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中的並行時，實際上需要了解兩個核心概念：發送器和執行緒相似性。</span><span class="sxs-lookup"><span data-stu-id="4e707-124">There are really two core concepts to understand when discussing concurrency in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – the dispatcher and thread affinity.</span></span>  
  
 <span data-ttu-id="4e707-125">在 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的設計階段期間，目的是要移至單一執行的執行緒，而非執行緒「親和性」模型。</span><span class="sxs-lookup"><span data-stu-id="4e707-125">During the design phase of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], the goal was to move to a single thread of execution, but a non-thread "affinitized" model.</span></span> <span data-ttu-id="4e707-126">元件使用執行中執行緒的身分識別來儲存某些類型的狀態時，會發生執行緒親和性。</span><span class="sxs-lookup"><span data-stu-id="4e707-126">Thread affinity happens when a component uses the identity of the executing thread to store some type of state.</span></span> <span data-ttu-id="4e707-127">這最常見的形式是使用執行緒本機存放區 (TLS) 來儲存狀態。</span><span class="sxs-lookup"><span data-stu-id="4e707-127">The most common form of this is to use the thread local store (TLS) to store state.</span></span> <span data-ttu-id="4e707-128">執行緒親和性需要作業系統中只有一個實體執行緒擁有每個邏輯執行的執行緒，而這樣可能會耗用大量記憶體。</span><span class="sxs-lookup"><span data-stu-id="4e707-128">Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive.</span></span> <span data-ttu-id="4e707-129">最後，透過執行緒親和性，WPF 的執行緒模型會與單一執行緒執行作業的現有 User32 執行緒模型同步。</span><span class="sxs-lookup"><span data-stu-id="4e707-129">In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity.</span></span> <span data-ttu-id="4e707-130">這個的主要原因是交互操作性；[!INCLUDE[TLA2#tla_ole2.0](../../../../includes/tla2sharptla-ole2-0-md.md)] 這類系統、剪貼簿和 Internet Explorer 都需要單一執行緒親和性 (STA) 執行。</span><span class="sxs-lookup"><span data-stu-id="4e707-130">The primary reason for this was interoperability – systems like [!INCLUDE[TLA2#tla_ole2.0](../../../../includes/tla2sharptla-ole2-0-md.md)], the clipboard, and Internet Explorer all require single thread affinity (STA) execution.</span></span>  
  
 <span data-ttu-id="4e707-131">假設您的物件具有 STA 執行緒，則您需要執行緒之間的通訊方法，並驗證您位於正確的執行緒。</span><span class="sxs-lookup"><span data-stu-id="4e707-131">Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread.</span></span> <span data-ttu-id="4e707-132">其中具有發送器的角色。</span><span class="sxs-lookup"><span data-stu-id="4e707-132">Herein lies the role of the dispatcher.</span></span> <span data-ttu-id="4e707-133">發送器是基本訊息發送系統，具有多個已設定優先權的佇列。</span><span class="sxs-lookup"><span data-stu-id="4e707-133">The dispatcher is a basic message dispatching system, with multiple prioritized queues.</span></span> <span data-ttu-id="4e707-134">訊息範例包括未經處理的輸入通知 (滑鼠移動)、架構功能 (版面配置) 或使用者命令 (執行此方法)。</span><span class="sxs-lookup"><span data-stu-id="4e707-134">Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method).</span></span> <span data-ttu-id="4e707-135">藉由衍生自<xref:System.Windows.Threading.DispatcherObject>，您建立[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]物件具有 STA 行為，並指定指標給發送器在建立時。</span><span class="sxs-lookup"><span data-stu-id="4e707-135">By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] object that has STA behavior, and will be given a pointer to a dispatcher at creation time.</span></span>  
  
<a name="System_Windows_DependencyObject"></a>   
## <a name="systemwindowsdependencyobject"></a><span data-ttu-id="4e707-136">System.Windows.DependencyObject</span><span class="sxs-lookup"><span data-stu-id="4e707-136">System.Windows.DependencyObject</span></span>  
 <span data-ttu-id="4e707-137">建置 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 時所使用的其中一個主要架構原理是方法或事件的屬性喜好設定。</span><span class="sxs-lookup"><span data-stu-id="4e707-137">One of the primary architectural philosophies used in building [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] was a preference for properties over methods or events.</span></span> <span data-ttu-id="4e707-138">屬性是宣告式，可讓您更輕鬆地指定意圖，而不是動作。</span><span class="sxs-lookup"><span data-stu-id="4e707-138">Properties are declarative and allow you to more easily specify intent instead of action.</span></span> <span data-ttu-id="4e707-139">這也支援用於顯示使用者介面內容的模型驅動或資料驅動系統。</span><span class="sxs-lookup"><span data-stu-id="4e707-139">This also supported a model driven, or data driven, system for displaying user interface content.</span></span> <span data-ttu-id="4e707-140">此原理的預期效果是建立多個可繫結的屬性，以進一步控制應用程式的行為。</span><span class="sxs-lookup"><span data-stu-id="4e707-140">This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.</span></span>  
  
 <span data-ttu-id="4e707-141">若要讓屬性驅動多個系統，則需要比 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 所提供的屬性系統更豐富的屬性系統。</span><span class="sxs-lookup"><span data-stu-id="4e707-141">In order to have more of the system driven by properties, a richer property system than what the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] provides was needed.</span></span> <span data-ttu-id="4e707-142">這項豐富性的簡單範例是變更通知。</span><span class="sxs-lookup"><span data-stu-id="4e707-142">A simple example of this richness is change notifications.</span></span> <span data-ttu-id="4e707-143">若要啟用雙向繫結，您需要繫結兩端都支援變更通知。</span><span class="sxs-lookup"><span data-stu-id="4e707-143">In order to enable two way binding, you need both sides of the bind to support change notification.</span></span> <span data-ttu-id="4e707-144">若要讓行為繫結至屬性值，您需要在屬性值變更時收到通知。</span><span class="sxs-lookup"><span data-stu-id="4e707-144">In order to have behavior tied to property values, you need to be notified when the property value changes.</span></span> <span data-ttu-id="4e707-145">Microsoft.NET Framework 有介面**INotifyPropertyChange**，可讓物件發行變更通知，不過它是選擇性。</span><span class="sxs-lookup"><span data-stu-id="4e707-145">The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional.</span></span>  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="4e707-146">提供更豐富的屬性系統，衍生自<xref:System.Windows.DependencyObject>型別。</span><span class="sxs-lookup"><span data-stu-id="4e707-146">provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type.</span></span> <span data-ttu-id="4e707-147">屬性系統實際上是「相依性」屬性系統，因此它會追蹤屬性運算式之間的相依性，並在相依性變更時自動重新驗證屬性值。</span><span class="sxs-lookup"><span data-stu-id="4e707-147">The property system is truly a "dependency" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change.</span></span> <span data-ttu-id="4e707-148">例如，如果您有繼承的屬性 (例如<xref:System.Windows.Controls.Control.FontSize%2A>)，如果在屬性變更的父代繼承值的項目上，系統會自動更新。</span><span class="sxs-lookup"><span data-stu-id="4e707-148">For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value.</span></span>  
  
 <span data-ttu-id="4e707-149">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 屬性系統的基礎是屬性運算式的概念。</span><span class="sxs-lookup"><span data-stu-id="4e707-149">The foundation of the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] property system is the concept of a property expression.</span></span> <span data-ttu-id="4e707-150">在這個第一版 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中，已關閉屬性運算式系統，而且運算式都會提供為架構的一部分。</span><span class="sxs-lookup"><span data-stu-id="4e707-150">In this first release of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], the property expression system is closed, and the expressions are all provided as part of the framework.</span></span> <span data-ttu-id="4e707-151">運算式是屬性系統沒有資料繫結、樣式或繼承硬式編碼，而是由架構內的稍後層級所提供的原因。</span><span class="sxs-lookup"><span data-stu-id="4e707-151">Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.</span></span>  
  
 <span data-ttu-id="4e707-152">屬性系統也會提供屬性值的疏鬆儲存體。</span><span class="sxs-lookup"><span data-stu-id="4e707-152">The property system also provides for sparse storage of property values.</span></span> <span data-ttu-id="4e707-153">因為物件可以有數十個 (甚至數百個) 屬性，所以大部分的值都處於其預設狀態 (繼承、透過樣式設定等等)，而且並非物件的每個執行個體都需要有其上定義之每個屬性的完整加權。</span><span class="sxs-lookup"><span data-stu-id="4e707-153">Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.</span></span>  
  
 <span data-ttu-id="4e707-154">屬性系統的最終新功能是附加屬性概念。</span><span class="sxs-lookup"><span data-stu-id="4e707-154">The final new feature of the property system is the notion of attached properties.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="4e707-155">項目的建置基礎是組合和元件重複使用的原則。</span><span class="sxs-lookup"><span data-stu-id="4e707-155">elements are built on the principle of composition and component reuse.</span></span> <span data-ttu-id="4e707-156">它通常是後者，有些包含項目 (例如<xref:System.Windows.Controls.Grid>版面配置項目) 需要在子項目，來控制其行為 （例如資料列/資料行資訊） 上的其他資料。</span><span class="sxs-lookup"><span data-stu-id="4e707-156">It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information).</span></span> <span data-ttu-id="4e707-157">允許任何物件提供所有其他物件的屬性定義，而不是建立所有這些屬性與每個項目的關聯。</span><span class="sxs-lookup"><span data-stu-id="4e707-157">Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object.</span></span> <span data-ttu-id="4e707-158">這與 JavaScript 的 "expando" 功能類似。</span><span class="sxs-lookup"><span data-stu-id="4e707-158">This is similar to the "expando" features of JavaScript.</span></span>  
  
<a name="System_Windows_Media_Visual"></a>   
## <a name="systemwindowsmediavisual"></a><span data-ttu-id="4e707-159">System.Windows.Media.Visual</span><span class="sxs-lookup"><span data-stu-id="4e707-159">System.Windows.Media.Visual</span></span>  
 <span data-ttu-id="4e707-160">定義系統之後，下一個步驟是將像素繪製到螢幕。</span><span class="sxs-lookup"><span data-stu-id="4e707-160">With a system defined, the next step is getting pixels drawn to the screen.</span></span> <span data-ttu-id="4e707-161"><xref:System.Windows.Media.Visual>類別提供建置樹狀目錄中的視覺物件，都會選擇性地包含繪圖指示以及如何轉譯這些指示 （裁剪、 轉換等等） 的相關中繼資料。</span><span class="sxs-lookup"><span data-stu-id="4e707-161">The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.).</span></span> <span data-ttu-id="4e707-162"><xref:System.Windows.Media.Visual> 設計為非常輕量且具有彈性，因此大部分的功能不有任何公用[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]曝光並大量依賴受保護的回呼函式。</span><span class="sxs-lookup"><span data-stu-id="4e707-162"><xref:System.Windows.Media.Visual> is designed to be extremely lightweight and flexible, so most of the features have no public [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] exposure and rely heavily on protected callback functions.</span></span>  
  
 <span data-ttu-id="4e707-163"><xref:System.Windows.Media.Visual> 其實是進入點[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]撰寫系統。</span><span class="sxs-lookup"><span data-stu-id="4e707-163"><xref:System.Windows.Media.Visual> is really the entry point to the [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] composition system.</span></span> <span data-ttu-id="4e707-164"><xref:System.Windows.Media.Visual> 是的這些兩個子系統，managed 之間的連接點[!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)]和 unmanaged 的 milcore。</span><span class="sxs-lookup"><span data-stu-id="4e707-164"><xref:System.Windows.Media.Visual> is the point of connection between these two subsystems, the managed [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] and the unmanaged milcore.</span></span>  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="4e707-165">透過周遊 milcore 所管理的 Unmanaged 資料結構來顯示資料。</span><span class="sxs-lookup"><span data-stu-id="4e707-165">displays data by traversing the unmanaged data structures managed by the milcore.</span></span> <span data-ttu-id="4e707-166">這些結構稱為組合節點，代表具有每個節點之轉譯指示的階層式顯示樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="4e707-166">These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node.</span></span> <span data-ttu-id="4e707-167">下圖右側所說明的這個樹狀結構只能透過訊息通訊協定進行存取。</span><span class="sxs-lookup"><span data-stu-id="4e707-167">This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.</span></span>  
  
 <span data-ttu-id="4e707-168">當程式設計[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]，您建立<xref:System.Windows.Media.Visual>項目，並在內部與複合樹狀結構，透過此傳訊通訊協定進行通訊的衍生型別。</span><span class="sxs-lookup"><span data-stu-id="4e707-168">When programming [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol.</span></span> <span data-ttu-id="4e707-169">每個<xref:System.Windows.Media.Visual>在[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]可能會建立一個、 none、 或數個組合節點。</span><span class="sxs-lookup"><span data-stu-id="4e707-169">Each <xref:System.Windows.Media.Visual> in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] may create one, none, or several composition nodes.</span></span>  
  
 <span data-ttu-id="4e707-170">![Windows Presentation Foundation 視覺化樹狀結構。](../../../../docs/framework/wpf/advanced/media/wpf-architecture2.PNG "wpf_architecture2")</span><span class="sxs-lookup"><span data-stu-id="4e707-170">![The Windows Presentation Foundation Visual Tree.](../../../../docs/framework/wpf/advanced/media/wpf-architecture2.PNG "wpf_architecture2")</span></span>  
  
 <span data-ttu-id="4e707-171">這裡需要注意一個極為重要的架構詳細資料：會快取視覺效果的整個樹狀結構以及繪圖指示。</span><span class="sxs-lookup"><span data-stu-id="4e707-171">There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached.</span></span> <span data-ttu-id="4e707-172">就圖形來說，[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 會使用保留轉譯系統。</span><span class="sxs-lookup"><span data-stu-id="4e707-172">In graphics terms, [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] uses a retained rendering system.</span></span> <span data-ttu-id="4e707-173">這可讓系統以高重新整理速率重繪，而組合系統不會封鎖使用者程式碼的回呼。</span><span class="sxs-lookup"><span data-stu-id="4e707-173">This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code.</span></span> <span data-ttu-id="4e707-174">這有助於防止出現沒有回應的應用程式。</span><span class="sxs-lookup"><span data-stu-id="4e707-174">This helps prevent the appearance of an unresponsive application.</span></span>  
  
 <span data-ttu-id="4e707-175">圖表中實際上不大明顯的另一個重要詳細資料是系統如何實際執行組合。</span><span class="sxs-lookup"><span data-stu-id="4e707-175">Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.</span></span>  
  
 <span data-ttu-id="4e707-176">在 User32 和 [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)] 中，系統會在即時模式裁剪系統上運作。</span><span class="sxs-lookup"><span data-stu-id="4e707-176">In User32 and [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)], the system works on an immediate mode clipping system.</span></span> <span data-ttu-id="4e707-177">需要轉譯元件時，系統會建立不允許元件接觸像素的外部裁剪界限，接著要求元件在該方塊中繪製像素。</span><span class="sxs-lookup"><span data-stu-id="4e707-177">When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box.</span></span> <span data-ttu-id="4e707-178">此系統非常適合在記憶體受限系統中運作，因為內容變更時，您只需要接觸受影響元件；沒有兩個元件會形成單一像素的色彩。</span><span class="sxs-lookup"><span data-stu-id="4e707-178">This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.</span></span>  
  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="4e707-179">使用「繪製器的演算法」繪製模型。</span><span class="sxs-lookup"><span data-stu-id="4e707-179">uses a "painter's algorithm" painting model.</span></span> <span data-ttu-id="4e707-180">這表示，會要求每個元件從後到前轉譯顯示，而不是裁剪每個元件。</span><span class="sxs-lookup"><span data-stu-id="4e707-180">This means that instead of clipping each component, each component is asked to render from the back to the front of the display.</span></span> <span data-ttu-id="4e707-181">這可在前一個元件的顯示上方繪製每個元件。</span><span class="sxs-lookup"><span data-stu-id="4e707-181">This allows each component to paint over the previous component's display.</span></span> <span data-ttu-id="4e707-182">此模型的優點在於您可以有複雜且部分透明的圖形。</span><span class="sxs-lookup"><span data-stu-id="4e707-182">The advantage of this model is that you can have complex, partially transparent shapes.</span></span> <span data-ttu-id="4e707-183">此模型運用現今的現代圖形硬體，因此相當快速 (建立 User32/[!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)] 時則否)。</span><span class="sxs-lookup"><span data-stu-id="4e707-183">With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ [!INCLUDE[TLA2#tla_gdi](../../../../includes/tla2sharptla-gdi-md.md)] were created).</span></span>  
  
 <span data-ttu-id="4e707-184">如前所述，[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的核心原理是移至更具宣告性且「以屬性為主」的程式設計模型。</span><span class="sxs-lookup"><span data-stu-id="4e707-184">As mentioned previously, a core philosophy of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is to move to a more declarative, "property centric" model of programming.</span></span> <span data-ttu-id="4e707-185">在視覺物件系統中，這出現在幾個有趣的地方。</span><span class="sxs-lookup"><span data-stu-id="4e707-185">In the visual system, this shows up in a couple of interesting places.</span></span>  
  
 <span data-ttu-id="4e707-186">首先，如果您考慮使用保留的模式圖形系統，則這真地會從命令式 DrawLine/DrawLine 類型模型移至資料導向模型：新的 Line()/新的 Line()。</span><span class="sxs-lookup"><span data-stu-id="4e707-186">First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line().</span></span> <span data-ttu-id="4e707-187">這項移至資料驅動轉譯作業允許使用屬性來表示繪圖指示上的複雜作業。</span><span class="sxs-lookup"><span data-stu-id="4e707-187">This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties.</span></span> <span data-ttu-id="4e707-188">衍生自類型<xref:System.Windows.Media.Drawing>都是有效的轉譯物件模型。</span><span class="sxs-lookup"><span data-stu-id="4e707-188">The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering.</span></span>  
  
 <span data-ttu-id="4e707-189">其次，如果您評估動畫系統，則會看到它幾乎完全是宣告式。</span><span class="sxs-lookup"><span data-stu-id="4e707-189">Second, if you evaluate the animation system, you'll see that it is almost completely declarative.</span></span> <span data-ttu-id="4e707-190">您可以將動畫表示為動畫物件的一組屬性，而不需要開發人員計算下一個位置或下一個色彩。</span><span class="sxs-lookup"><span data-stu-id="4e707-190">Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object.</span></span> <span data-ttu-id="4e707-191">這些動畫接著可以表示開發人員或設計人員的意圖 (在 5 秒內，將此按鈕從這裡移至目的地)，而且系統可以判斷完成該作業的最有效方式。</span><span class="sxs-lookup"><span data-stu-id="4e707-191">These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.</span></span>  
  
<a name="System_Windows_UIElement"></a>   
## <a name="systemwindowsuielement"></a><span data-ttu-id="4e707-192">System.Windows.UIElement</span><span class="sxs-lookup"><span data-stu-id="4e707-192">System.Windows.UIElement</span></span>  
 <span data-ttu-id="4e707-193"><xref:System.Windows.UIElement> 定義核心子系統，包括版面配置、 Input 和 Events。</span><span class="sxs-lookup"><span data-stu-id="4e707-193"><xref:System.Windows.UIElement> defines core subsystems including Layout, Input, and Events.</span></span>  
  
 <span data-ttu-id="4e707-194">版面配置是 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中的核心概念。</span><span class="sxs-lookup"><span data-stu-id="4e707-194">Layout is a core concept in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="4e707-195">在許多系統中，會有固定一組版面配置模型 (HTML 支援三種版面配置模型：非固定、絕對和資料表) 或沒有版面配置模型 (User32 實際上只支援絕對定位)。</span><span class="sxs-lookup"><span data-stu-id="4e707-195">In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning).</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="4e707-196">一開始的假設是開發人員和設計人員想要具彈性且可擴充的版面配置模型，而此模型可透過屬性值驅動，而非命令式邏輯。</span><span class="sxs-lookup"><span data-stu-id="4e707-196">started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic.</span></span> <span data-ttu-id="4e707-197">在<xref:System.Windows.UIElement>導入的層級，版面配置的基本合約是 – 的兩階段模型<xref:System.Windows.UIElement.Measure%2A>和<xref:System.Windows.UIElement.Arrange%2A>傳遞。</span><span class="sxs-lookup"><span data-stu-id="4e707-197">At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes.</span></span>  
  
 <span data-ttu-id="4e707-198"><xref:System.Windows.UIElement.Measure%2A> 可讓元件決定它想要採取的大小。</span><span class="sxs-lookup"><span data-stu-id="4e707-198"><xref:System.Windows.UIElement.Measure%2A> allows a component to determine how much size it would like to take.</span></span> <span data-ttu-id="4e707-199">這是從不同的階段<xref:System.Windows.UIElement.Arrange%2A>因為有許多情況下，父項目會在其中詢問子系測量數次，以決定其最理想的位置和大小。</span><span class="sxs-lookup"><span data-stu-id="4e707-199">This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size.</span></span> <span data-ttu-id="4e707-200">父項目要求子項目進行測量的事實示範 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的另一個重要原理：內容大小。</span><span class="sxs-lookup"><span data-stu-id="4e707-200">The fact that parent elements ask child elements to measure demonstrates another key philosophy of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – size to content.</span></span> <span data-ttu-id="4e707-201">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中的所有控制項都支援調整成其內容原本大小的能力。</span><span class="sxs-lookup"><span data-stu-id="4e707-201">All controls in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] support the ability to size to the natural size of their content.</span></span> <span data-ttu-id="4e707-202">這會讓當地語系化更為簡單，並在調整事物時允許動態配置項目。</span><span class="sxs-lookup"><span data-stu-id="4e707-202">This makes localization much easier, and allows for dynamic layout of elements as things resize.</span></span> <span data-ttu-id="4e707-203"><xref:System.Windows.UIElement.Arrange%2A>階段可讓父代定位和決定每個子系的最終大小。</span><span class="sxs-lookup"><span data-stu-id="4e707-203">The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child.</span></span>  
  
 <span data-ttu-id="4e707-204">很多時間通常會花談論的輸出端[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]–<xref:System.Windows.Media.Visual>和相關物件。</span><span class="sxs-lookup"><span data-stu-id="4e707-204">A lot of time is often spent talking about the output side of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – <xref:System.Windows.Media.Visual> and related objects.</span></span> <span data-ttu-id="4e707-205">不過，輸入端上也會進行極大的創新。</span><span class="sxs-lookup"><span data-stu-id="4e707-205">However there is a tremendous amount of innovation on the input side as well.</span></span> <span data-ttu-id="4e707-206">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 輸入模型的最基本變更可能是一致模型，而使用此模型，即可透過系統來路由傳送輸入事件。</span><span class="sxs-lookup"><span data-stu-id="4e707-206">Probably the most fundamental change in the input model for [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is the consistent model by which input events are routed through the system.</span></span>  
  
 <span data-ttu-id="4e707-207">輸入來源是核心模式裝置驅動程式上的訊號，並且透過包含 Windows 核心和 User32 的複雜處理序路由傳送至正確的處理序和執行緒。</span><span class="sxs-lookup"><span data-stu-id="4e707-207">Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32.</span></span> <span data-ttu-id="4e707-208">對應至輸入的 User32 訊息在路由傳送至 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 之後，會轉換為 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 未經處理的輸入訊息，並傳送至發送器。</span><span class="sxs-lookup"><span data-stu-id="4e707-208">Once the User32 message corresponding to the input is routed to [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], it is converted into a [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] raw input message and sent to the dispatcher.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="4e707-209">允許將未經處理的輸入事件轉換為多個實際事件，方法是在具有保證傳遞之系統的低層級實作 "MouseEnter" 這類功能。</span><span class="sxs-lookup"><span data-stu-id="4e707-209">allows for raw input events to be converted to multiple actual events, enabling features like "MouseEnter" to be implemented at a low level of the system with guaranteed delivery.</span></span>  
  
 <span data-ttu-id="4e707-210">每個輸入事件都會轉換成至少兩個事件：「預覽」事件和實際事件。</span><span class="sxs-lookup"><span data-stu-id="4e707-210">Each input event is converted to at least two events – a "preview" event and the actual event.</span></span> <span data-ttu-id="4e707-211">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中的所有事件都有透過項目樹狀結構進行路由傳送的概念。</span><span class="sxs-lookup"><span data-stu-id="4e707-211">All events in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] have a notion of routing through the element tree.</span></span> <span data-ttu-id="4e707-212">事件則稱為 「 事件反昇 」，如果使用者從樹狀結構的目標周遊至根目錄，並會說 「 通道 」，如果它們在根目錄中啟動，並周遊到目標。</span><span class="sxs-lookup"><span data-stu-id="4e707-212">Events are said to "bubble" if they traverse from a target up the tree to the root, and are said to "tunnel" if they start at the root and traverse down to a target.</span></span> <span data-ttu-id="4e707-213">輸入預覽事件通道，讓樹狀結構中的任何項目有機會進行篩選或對事件採取動作。</span><span class="sxs-lookup"><span data-stu-id="4e707-213">Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event.</span></span> <span data-ttu-id="4e707-214">一般 (非預覽) 事件接著會從目標往上反昇到根。</span><span class="sxs-lookup"><span data-stu-id="4e707-214">The regular (non-preview) events then bubble from the target up to the root.</span></span>  
  
 <span data-ttu-id="4e707-215">通道與事件反昇階段之間的這項分割可讓鍵盤快速鍵這類功能的實作在複合情況下以一致的方式運作。</span><span class="sxs-lookup"><span data-stu-id="4e707-215">This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world.</span></span> <span data-ttu-id="4e707-216">在 User32 中，您將實作鍵盤快速鍵，方法是具有包含所有您要支援之快速鍵的單一全域資料表 (Ctrl+N 對應至 "New")。</span><span class="sxs-lookup"><span data-stu-id="4e707-216">In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to "New").</span></span> <span data-ttu-id="4e707-217">在應用程式的發送器中，您會呼叫可發覺 User32 中輸入訊息的 **TranslateAccelerator**，並判斷是否有任何快速鍵符合已註冊的快速鍵。</span><span class="sxs-lookup"><span data-stu-id="4e707-217">In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator.</span></span> <span data-ttu-id="4e707-218">在 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中，這不會運作，因為系統為完全「可組合」：任何項目都可以處理和使用任何鍵盤快速鍵。</span><span class="sxs-lookup"><span data-stu-id="4e707-218">In [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] this wouldn’t work because the system is fully "composable" – any element can handle and use any keyboard accelerator.</span></span> <span data-ttu-id="4e707-219">具有這個兩階段輸入模型可讓元件實作其專屬 "TranslateAccelerator"。</span><span class="sxs-lookup"><span data-stu-id="4e707-219">Having this two phase model for input allows components to implement their own "TranslateAccelerator".</span></span>  
  
 <span data-ttu-id="4e707-220">若要進一步此步驟，<xref:System.Windows.UIElement>也導入 CommandBindings 概念。</span><span class="sxs-lookup"><span data-stu-id="4e707-220">To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings.</span></span> <span data-ttu-id="4e707-221">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]命令系統可讓開發人員內容定義命令結束點 – 方面的功能實作<xref:System.Windows.Input.ICommand>。</span><span class="sxs-lookup"><span data-stu-id="4e707-221">The [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>.</span></span> <span data-ttu-id="4e707-222">命令繫結可讓項目定義輸入手勢 (Ctrl+N) 與命令 (New) 之間的對應。</span><span class="sxs-lookup"><span data-stu-id="4e707-222">Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New).</span></span> <span data-ttu-id="4e707-223">輸入手勢和命令定義都是可以擴充的，而且可以在使用階段連接在一起。</span><span class="sxs-lookup"><span data-stu-id="4e707-223">Both the input gestures and command definitions are extensible, and can be wired together at usage time.</span></span> <span data-ttu-id="4e707-224">例如，這會讓允許使用者自訂其想要在應用程式內使用的重要繫結變得簡單。</span><span class="sxs-lookup"><span data-stu-id="4e707-224">This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.</span></span>  
  
 <span data-ttu-id="4e707-225">在本主題中，到目前為止，[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的「核心」功能是 PresentationCore 組件中所實作的功能，已經是焦點。</span><span class="sxs-lookup"><span data-stu-id="4e707-225">To this point in the topic, "core" features of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] – features implemented in the PresentationCore assembly, have been the focus.</span></span> <span data-ttu-id="4e707-226">建置時[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]的基礎部分之間的完全分隔 (例如版面配置與合約**量值**和**排列**) 與架構部分 （例如特定的實作配置，例如<xref:System.Windows.Controls.Grid>) 是所要的結果。</span><span class="sxs-lookup"><span data-stu-id="4e707-226">When building [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome.</span></span> <span data-ttu-id="4e707-227">目標是提供堆疊低層的擴充點，以讓外部開發人員視需要建立其專屬架構。</span><span class="sxs-lookup"><span data-stu-id="4e707-227">The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.</span></span>  
  
<a name="System_Windows_FrameworkElement"></a>   
## <a name="systemwindowsframeworkelement"></a><span data-ttu-id="4e707-228">System.Windows.FrameworkElement</span><span class="sxs-lookup"><span data-stu-id="4e707-228">System.Windows.FrameworkElement</span></span>  
 <span data-ttu-id="4e707-229"><xref:System.Windows.FrameworkElement> 可以查看兩個不同的方式。</span><span class="sxs-lookup"><span data-stu-id="4e707-229"><xref:System.Windows.FrameworkElement> can be looked at in two different ways.</span></span> <span data-ttu-id="4e707-230">它在 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 低層級所引進的子系統上引進一組原則和自訂。</span><span class="sxs-lookup"><span data-stu-id="4e707-230">It introduces a set of policies and customizations on the subsystems introduced in lower layers of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="4e707-231">它同時引進一組新的子系統。</span><span class="sxs-lookup"><span data-stu-id="4e707-231">It also introduces a set of new subsystems.</span></span>  
  
 <span data-ttu-id="4e707-232">所導入的主要原則近似<xref:System.Windows.FrameworkElement>應用程式版面配置。</span><span class="sxs-lookup"><span data-stu-id="4e707-232">The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout.</span></span> <span data-ttu-id="4e707-233"><xref:System.Windows.FrameworkElement> 根據所引進的基本版面配置合約<xref:System.Windows.UIElement>並新增版面配置，輕鬆地讓版面配置作者，有一組一致的屬性驅動版面配置語意的 「 位置 」 的概念。</span><span class="sxs-lookup"><span data-stu-id="4e707-233"><xref:System.Windows.FrameworkElement> builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout "slot" that makes it easier for layout authors to have a consistent set of property driven layout semantics.</span></span> <span data-ttu-id="4e707-234">屬性，例如<xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>， <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>， <xref:System.Windows.FrameworkElement.MinWidth%2A>，以及<xref:System.Windows.FrameworkElement.Margin%2A>（以等等） 提供衍生自的所有元件<xref:System.Windows.FrameworkElement>版面配置容器內有一致的行為。</span><span class="sxs-lookup"><span data-stu-id="4e707-234">Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers.</span></span>  
  
 <span data-ttu-id="4e707-235"><xref:System.Windows.FrameworkElement> 也提供更容易[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]暴露於許多功能位於核心層級[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="4e707-235"><xref:System.Windows.FrameworkElement> also provides easier [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] exposure to many features found in the core layers of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)].</span></span> <span data-ttu-id="4e707-236">例如，<xref:System.Windows.FrameworkElement>提供直接存取動畫透過<xref:System.Windows.FrameworkElement.BeginStoryboard%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4e707-236">For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method.</span></span> <span data-ttu-id="4e707-237">A<xref:System.Windows.Media.Animation.Storyboard>可用來針對一組屬性的多個動畫的指令碼。</span><span class="sxs-lookup"><span data-stu-id="4e707-237">A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties.</span></span>  
  
 <span data-ttu-id="4e707-238">兩個最重要的事項，<xref:System.Windows.FrameworkElement>導入了資料繫結和樣式。</span><span class="sxs-lookup"><span data-stu-id="4e707-238">The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles.</span></span>  
  
 <span data-ttu-id="4e707-239">使用 [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] 或 [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] 來建立應用程式 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] 的使用者，應該相當熟悉[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中的資料繫結子系統。</span><span class="sxs-lookup"><span data-stu-id="4e707-239">The data binding subsystem in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] should be relatively familiar to anyone that has used [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="4e707-240">在所有這些系統中，有一種簡單的方式可表示您想要一或多個屬性從指定的項目繫結至資料的某個部分。</span><span class="sxs-lookup"><span data-stu-id="4e707-240">In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data.</span></span> [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="4e707-241">完整支援屬性繫結、轉換和清單繫結。</span><span class="sxs-lookup"><span data-stu-id="4e707-241">has full support for property binding, transformation, and list binding.</span></span>  
  
 <span data-ttu-id="4e707-242">[!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中資料繫結的其中一個最有趣功能是引進資料範本。</span><span class="sxs-lookup"><span data-stu-id="4e707-242">One of the most interesting features of data binding in [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] is the introduction of data templates.</span></span> <span data-ttu-id="4e707-243">資料範本可讓您以宣告方式指定應該如何視覺化資料。</span><span class="sxs-lookup"><span data-stu-id="4e707-243">Data templates allow you to declaratively specify how a piece of data should be visualized.</span></span> <span data-ttu-id="4e707-244">您可以解決問題，並讓資料判斷將建立的顯示，而不是建立可繫結至資料的自訂使用者介面。</span><span class="sxs-lookup"><span data-stu-id="4e707-244">Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.</span></span>  
  
 <span data-ttu-id="4e707-245">樣式實際上是簡單形式的資料繫結。</span><span class="sxs-lookup"><span data-stu-id="4e707-245">Styling is really a lightweight form of data binding.</span></span> <span data-ttu-id="4e707-246">使用樣式，您可以將共用定義中的一組屬性繫結至項目的一或多個執行個體。</span><span class="sxs-lookup"><span data-stu-id="4e707-246">Using styling you can bind a set of properties from a shared definition to one or more instances of an element.</span></span> <span data-ttu-id="4e707-247">樣式會套用至項目是透過明確參考 (藉由設定<xref:System.Windows.FrameworkElement.Style%2A>屬性) 或隱含的關聯性與樣式[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]元素的類型。</span><span class="sxs-lookup"><span data-stu-id="4e707-247">Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] type of the element.</span></span>  
  
<a name="System_Windows_Controls_Control"></a>   
## <a name="systemwindowscontrolscontrol"></a><span data-ttu-id="4e707-248">System.Windows.Controls.Control</span><span class="sxs-lookup"><span data-stu-id="4e707-248">System.Windows.Controls.Control</span></span>  
 <span data-ttu-id="4e707-249">控制項的最重要功能是設定範本。</span><span class="sxs-lookup"><span data-stu-id="4e707-249">Control’s most significant feature is templating.</span></span> <span data-ttu-id="4e707-250">如果您將 WPF 的組合系統視為保留模式轉譯系統，則設定範本可讓控制項透過參數化宣告方式描述其轉譯。</span><span class="sxs-lookup"><span data-stu-id="4e707-250">If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner.</span></span> <span data-ttu-id="4e707-251">A<xref:System.Windows.Controls.ControlTemplate>其實不過是指令碼建立一組子系的項目，以繫結至控制項所提供的屬性。</span><span class="sxs-lookup"><span data-stu-id="4e707-251">A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.</span></span>  
  
 <span data-ttu-id="4e707-252"><xref:System.Windows.Controls.Control> 提供的內建屬性，一組<xref:System.Windows.Controls.Control.Foreground%2A>， <xref:System.Windows.Controls.Control.Background%2A>， <xref:System.Windows.Controls.Control.Padding%2A>、 等等，範本作者接著可以用來自訂控制項的顯示。</span><span class="sxs-lookup"><span data-stu-id="4e707-252"><xref:System.Windows.Controls.Control> provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control.</span></span> <span data-ttu-id="4e707-253">控制項的實作會提供資料模型和互動模型。</span><span class="sxs-lookup"><span data-stu-id="4e707-253">The implementation of a control provides a data model and interaction model.</span></span> <span data-ttu-id="4e707-254">互動模型定義一組命令 (例如視窗的 Close) 以及輸入手勢的繫結 (例如按一下視窗右上角的紅色 X)。</span><span class="sxs-lookup"><span data-stu-id="4e707-254">The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window).</span></span> <span data-ttu-id="4e707-255">資料模型提供一組屬性來自訂互動模型或是自訂顯示 (透過範本決定)。</span><span class="sxs-lookup"><span data-stu-id="4e707-255">The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).</span></span>  
  
 <span data-ttu-id="4e707-256">資料模型 (屬性)、互動模型 (命令和事件) 與顯示模型 (範本) 之間的這項分割可啟用控制項外觀和行為的完整自訂。</span><span class="sxs-lookup"><span data-stu-id="4e707-256">This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.</span></span>  
  
 <span data-ttu-id="4e707-257">控制項資料模型的一般層面是內容模型。</span><span class="sxs-lookup"><span data-stu-id="4e707-257">A common aspect of the data model of controls is the content model.</span></span> <span data-ttu-id="4e707-258">如果您查看控制項喜歡<xref:System.Windows.Controls.Button>，您會看到它有一個名為"Content"of type 屬性<xref:System.Object>。</span><span class="sxs-lookup"><span data-stu-id="4e707-258">If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named "Content" of type <xref:System.Object>.</span></span> <span data-ttu-id="4e707-259">在 [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] 和 [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] 中，這個屬性一般會是字串；不過，這會限制您可放入按鈕的內容類型。</span><span class="sxs-lookup"><span data-stu-id="4e707-259">In [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] and [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)], this property would typically be a string – however that limits the type of content you can put in a button.</span></span> <span data-ttu-id="4e707-260">按鈕的內容可以是簡單字串、複雜資料物件或整個項目樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="4e707-260">Content for a button can either be a simple string, a complex data object, or an entire element tree.</span></span> <span data-ttu-id="4e707-261">如果是資料物件，則使用資料範本來建構顯示。</span><span class="sxs-lookup"><span data-stu-id="4e707-261">In the case of a data object, the data template is used to construct a display.</span></span>  
  
<a name="Summary"></a>   
## <a name="summary"></a><span data-ttu-id="4e707-262">總結</span><span class="sxs-lookup"><span data-stu-id="4e707-262">Summary</span></span>  
 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] <span data-ttu-id="4e707-263">設計成讓您建立動態資料驅動的呈現系統。</span><span class="sxs-lookup"><span data-stu-id="4e707-263">is designed to allow you to create dynamic, data driven presentation systems.</span></span> <span data-ttu-id="4e707-264">系統的每個組件都是設計成透過可驅動行為的屬性集來建立物件。</span><span class="sxs-lookup"><span data-stu-id="4e707-264">Every part of the system is designed to create objects through property sets that drive behavior.</span></span> <span data-ttu-id="4e707-265">資料繫結是系統的基礎部分，並且在各層級進行整合。</span><span class="sxs-lookup"><span data-stu-id="4e707-265">Data binding is a fundamental part of the system, and is integrated at every layer.</span></span>  
  
 <span data-ttu-id="4e707-266">傳統應用程式會建立顯示，然後繫結至一些資料。</span><span class="sxs-lookup"><span data-stu-id="4e707-266">Traditional applications create a display and then bind to some data.</span></span> <span data-ttu-id="4e707-267">在 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 中，會由某種類型的資料繫結產生控制項的所有相關項目，即顯示的每個層面。</span><span class="sxs-lookup"><span data-stu-id="4e707-267">In [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], everything about the control, every aspect of the display, is generated by some type of data binding.</span></span> <span data-ttu-id="4e707-268">在按鈕內建立組合的控制項，並將其顯示繫結至按鈕的內容屬性，即會顯示在按鈕內找到的文字。</span><span class="sxs-lookup"><span data-stu-id="4e707-268">The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.</span></span>  
  
 <span data-ttu-id="4e707-269">當您開始開發 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 應用程式時，應該會覺得十分熟悉。</span><span class="sxs-lookup"><span data-stu-id="4e707-269">When you begin developing [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] based applications, it should feel very familiar.</span></span> <span data-ttu-id="4e707-270">設定屬性、使用物件和資料繫結的方式，大致與使用 [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] 或 [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)] 相同。</span><span class="sxs-lookup"><span data-stu-id="4e707-270">You can set properties, use objects, and data bind in much the same way that you can using [!INCLUDE[TLA#tla_winforms](../../../../includes/tlasharptla-winforms-md.md)] or [!INCLUDE[TLA#tla_aspnet](../../../../includes/tlasharptla-aspnet-md.md)].</span></span> <span data-ttu-id="4e707-271">更深入調查 [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)] 的架構，即會發現您可以建立更多的應用程式，而這些應用程式基本上會將資料視為應用程式的核心驅動程式。</span><span class="sxs-lookup"><span data-stu-id="4e707-271">With a deeper investigation into the architecture of [!INCLUDE[TLA2#tla_wpf](../../../../includes/tla2sharptla-wpf-md.md)], you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4e707-272">另請參閱</span><span class="sxs-lookup"><span data-stu-id="4e707-272">See also</span></span>
- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [<span data-ttu-id="4e707-273">資料繫結概觀</span><span class="sxs-lookup"><span data-stu-id="4e707-273">Data Binding Overview</span></span>](../../../../docs/framework/wpf/data/data-binding-overview.md)
- [<span data-ttu-id="4e707-274">版面配置</span><span class="sxs-lookup"><span data-stu-id="4e707-274">Layout</span></span>](../../../../docs/framework/wpf/advanced/layout.md)
- [<span data-ttu-id="4e707-275">動畫概觀</span><span class="sxs-lookup"><span data-stu-id="4e707-275">Animation Overview</span></span>](../../../../docs/framework/wpf/graphics-multimedia/animation-overview.md)
