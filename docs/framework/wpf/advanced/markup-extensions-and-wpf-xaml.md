---
title: 標記延伸和 WPF XAML
ms.date: 03/30/2017
helpviewer_keywords:
- brace character [WPF]
- Binding markup extensions [WPF]
- RelativeSource markup extensions [WPF]
- XAML [WPF], markup extensions
- markup extensions [WPF]
- nesting extension syntax [WPF]
- curly brace characters ({})
- TemplateBinding markup extensions [WPF]
- StaticResource markup extensions [WPF]
- literal curly brace characters ({})
- characters [WPF], curly brace
- DynamicResource markup extensions [WPF]
ms.assetid: 618dc745-8b14-4886-833f-486d2254bb78
ms.openlocfilehash: e2fb1e64f957b49743d8dfb19091bca50303e2d2
ms.sourcegitcommit: 43924acbdbb3981d103e11049bbe460457d42073
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/23/2018
---
# <a name="markup-extensions-and-wpf-xaml"></a><span data-ttu-id="4a71b-102">標記延伸和 WPF XAML</span><span class="sxs-lookup"><span data-stu-id="4a71b-102">Markup Extensions and WPF XAML</span></span>
<span data-ttu-id="4a71b-103">本主題介紹 XAML 標記延伸模組概念，包括其語法規則、用途，以及其根據的類別物件模型。</span><span class="sxs-lookup"><span data-stu-id="4a71b-103">This topic introduces the concept of markup extensions for XAML, including their syntax rules, purpose, and the class object model that underlies them.</span></span> <span data-ttu-id="4a71b-104">標記延伸模組是 XAML 語言的一般功能，以及 XAML 服務之 .NET 實作的一般功能。</span><span class="sxs-lookup"><span data-stu-id="4a71b-104">Markup extensions are a general feature of the XAML language and of the .NET implementation of XAML services.</span></span> <span data-ttu-id="4a71b-105">本主題會具體詳述 WPF XAML 中所使用的標記延伸模組。</span><span class="sxs-lookup"><span data-stu-id="4a71b-105">This topic specifically details markup extensions for use in WPF XAML.</span></span>  
  
  
<a name="XAML_Processors_and_Markup_Extensions"></a>   
## <a name="xaml-processors-and-markup-extensions"></a><span data-ttu-id="4a71b-106">XAML 處理器和標記延伸模組</span><span class="sxs-lookup"><span data-stu-id="4a71b-106">XAML Processors and Markup Extensions</span></span>  
 <span data-ttu-id="4a71b-107">一般而言，XAML 剖析器可以將屬性值解譯為可轉換成基本項目的常值字串，或透過一些方法將它轉換成物件。</span><span class="sxs-lookup"><span data-stu-id="4a71b-107">Generally speaking, a XAML parser can either interpret an attribute value as a literal string that can be converted to a primitive, or convert it to an object by some means.</span></span> <span data-ttu-id="4a71b-108">其中一種這類方式是透過參考類型轉換子；這記錄於 [TypeConverters 和 XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md) 主題。</span><span class="sxs-lookup"><span data-stu-id="4a71b-108">One such means is by referencing a type converter; this is documented in the topic [TypeConverters and XAML](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md).</span></span> <span data-ttu-id="4a71b-109">不過，有些情況需要不同的行為。</span><span class="sxs-lookup"><span data-stu-id="4a71b-109">However, there are scenarios where different behavior is required.</span></span> <span data-ttu-id="4a71b-110">例如，可以向 XAML 處理器指示，屬性的值不應該導致物件圖形中的新物件。</span><span class="sxs-lookup"><span data-stu-id="4a71b-110">For example, a XAML processor can be instructed that a value of an attribute should not result in a new object in the object graph.</span></span> <span data-ttu-id="4a71b-111">相反地，此屬性應該會產生參考圖形另一個組件中的已建構物件或靜態物件的物件圖表。</span><span class="sxs-lookup"><span data-stu-id="4a71b-111">Instead, the attribute should result in an object graph that makes a reference to an already constructed object in another part of the graph, or a static object.</span></span> <span data-ttu-id="4a71b-112">另一個情況是可以指示 XAML 處理器使用將非預設引數提供給物件建構函式的語法。</span><span class="sxs-lookup"><span data-stu-id="4a71b-112">Another scenario is that a XAML processor can be instructed to use a syntax that provides non-default arguments to the constructor of an object.</span></span> <span data-ttu-id="4a71b-113">這些是標記延伸模組可提供解決方案的案例類型。</span><span class="sxs-lookup"><span data-stu-id="4a71b-113">These are the types of scenarios where a markup extension can provide the solution.</span></span>  
  
<a name="Basic_Markup_Extension_Syntax"></a>   
## <a name="basic-markup-extension-syntax"></a><span data-ttu-id="4a71b-114">基本標記延伸模組語法</span><span class="sxs-lookup"><span data-stu-id="4a71b-114">Basic Markup Extension Syntax</span></span>  
 <span data-ttu-id="4a71b-115">可以實作標記延伸模組，以提供屬性 (attribute) 用法中的屬性 (property) 值、屬性 (property) 項目用法中的屬性 (property)，或兩者。</span><span class="sxs-lookup"><span data-stu-id="4a71b-115">A markup extension can be implemented to provide values for properties in an attribute usage, properties in a property element usage, or both.</span></span>  
  
 <span data-ttu-id="4a71b-116">用來提供屬性值時，可區分 XAML 處理器之標記延伸模組序列的語法是存在左右大括號 ({ 和 })。</span><span class="sxs-lookup"><span data-stu-id="4a71b-116">When used to provide an attribute value, the syntax that distinguishes a markup extension sequence to a XAML processor is the presence of the opening and closing curly braces ({ and }).</span></span> <span data-ttu-id="4a71b-117">標記延伸模組的類型則是透過緊接在左大括號後面的字串語彙基元所識別。</span><span class="sxs-lookup"><span data-stu-id="4a71b-117">The type of markup extension is then identified by the string token immediately following the opening curly brace.</span></span>  
  
 <span data-ttu-id="4a71b-118">在屬性項目語法中使用時，標記延伸模組在視覺上與任何其他用來提供屬性項目值的項目相同︰將標記延伸模組類別參考為以角括弧括住 (<>) 之項目的 XAML 項目宣告。</span><span class="sxs-lookup"><span data-stu-id="4a71b-118">When used in property element syntax, a markup extension is visually the same as any other element used to provide a property element value: a XAML element declaration that references the markup extension class as an element, enclosed within angle brackets (<>).</span></span>  
  
<a name="XAML_Defined_Markup_Extensions"></a>   
## <a name="xaml-defined-markup-extensions"></a><span data-ttu-id="4a71b-119">已定義 XAML 的標記延伸</span><span class="sxs-lookup"><span data-stu-id="4a71b-119">XAML-Defined Markup Extensions</span></span>  
 <span data-ttu-id="4a71b-120">數個標記延伸模組不是 XAML 的 WPF 實作所特有，而是作為語言之 XAML 的內建功能或功能實作。</span><span class="sxs-lookup"><span data-stu-id="4a71b-120">Several markup extensions exist that are not specific to the WPF implementation of XAML, but are instead implementations of intrinsics or features of XAML as a language.</span></span> <span data-ttu-id="4a71b-121">這些標記延伸模組在 System.Xaml 組件中實作為一般 .NET Framework XAML 服務的一部分，並且位在 XAML 語言 XAML 命名空間內。</span><span class="sxs-lookup"><span data-stu-id="4a71b-121">These markup extensions are implemented in the System.Xaml assembly as part of the general .NET Framework XAML services, and are within the XAML language XAML namespace.</span></span> <span data-ttu-id="4a71b-122">根據常見標記用法，這些標記延伸模組通常可以透過用法中的 `x:` 前置詞進行識別。</span><span class="sxs-lookup"><span data-stu-id="4a71b-122">In terms of common markup usage, these markup extensions are typically identifiable by the `x:` prefix in the usage.</span></span> <span data-ttu-id="4a71b-123"><xref:System.Windows.Markup.MarkupExtension> （也定義於 System.Xaml 中） 的基底類別提供為了支援 XAML 讀取器和 XAML 寫入器，包括 WPF XAML 中應該使用的所有標記延伸的模式。</span><span class="sxs-lookup"><span data-stu-id="4a71b-123">The <xref:System.Windows.Markup.MarkupExtension> base class (also defined in System.Xaml) provides the pattern that all markup extensions should use in order to be supported in XAML readers and XAML writers, including in WPF XAML.</span></span>  
  
-   <span data-ttu-id="4a71b-124">`x:Type` 提供具名類型的 <xref:System.Type> 物件。</span><span class="sxs-lookup"><span data-stu-id="4a71b-124">`x:Type` supplies the <xref:System.Type> object for the named type.</span></span> <span data-ttu-id="4a71b-125">這項工具最常用於樣式和範本。</span><span class="sxs-lookup"><span data-stu-id="4a71b-125">This facility is used most frequently in styles and templates.</span></span> <span data-ttu-id="4a71b-126">如需詳細資訊，請參閱 [x:Type 標記延伸模組](../../../../docs/framework/xaml-services/x-type-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-126">For details, see [x:Type Markup Extension](../../../../docs/framework/xaml-services/x-type-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="4a71b-127">`x:Static` 會產生靜態值。</span><span class="sxs-lookup"><span data-stu-id="4a71b-127">`x:Static` produces static values.</span></span> <span data-ttu-id="4a71b-128">值來自實值類型程式碼實體，而此實體不是直接為目標屬性值類型，但可以評估為該類型。</span><span class="sxs-lookup"><span data-stu-id="4a71b-128">The values come from value-type code entities that are not directly the type of a target property's value, but can be evaluated to that type.</span></span> <span data-ttu-id="4a71b-129">如需詳細資訊，請參閱 [x:Static 標記延伸模組](../../../../docs/framework/xaml-services/x-static-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-129">For details, see [x:Static Markup Extension](../../../../docs/framework/xaml-services/x-static-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="4a71b-130">`x:Null` 指定 `null` 作為屬性的值，而且可以用於屬性 (attribute) 或屬性 (property) 項目值。</span><span class="sxs-lookup"><span data-stu-id="4a71b-130">`x:Null` specifies `null` as a value for a property and can be used either for attributes or property element values.</span></span> <span data-ttu-id="4a71b-131">如需詳細資訊，請參閱 [x:Null 標記延伸模組](../../../../docs/framework/xaml-services/x-null-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-131">For details, see [x:Null Markup Extension](../../../../docs/framework/xaml-services/x-null-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="4a71b-132">如果故意不使用 WPF 基底項目和控制項模型所提供的集合支援，則 `x:Array` 支援使用 XAML 語法來建立一般陣列。</span><span class="sxs-lookup"><span data-stu-id="4a71b-132">`x:Array` provides support for creation of general arrays in XAML syntax, for cases where the collection support provided by WPF base elements and control models is deliberately not used.</span></span> <span data-ttu-id="4a71b-133">如需詳細資訊，請參閱 [x:Array 標記延伸模組](../../../../docs/framework/xaml-services/x-array-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-133">For details, see [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4a71b-134">`x:` 前置詞用於 XAML 檔案或生產的根項目中 XAML 語言內建功能的一般 XAML 命名空間對應。</span><span class="sxs-lookup"><span data-stu-id="4a71b-134">The `x:` prefix is used for the typical XAML namespace mapping of the XAML language intrinsics, in the root element of a XAML file or production.</span></span> <span data-ttu-id="4a71b-135">例如，WPF 應用程式的 Visual Studio 範本起始 XAML 檔案，使用這個`x:`對應。</span><span class="sxs-lookup"><span data-stu-id="4a71b-135">For example, the Visual Studio templates for WPF applications initiate a XAML file using this `x:` mapping.</span></span> <span data-ttu-id="4a71b-136">您可以選擇專屬 XAML 命名空間對應中的不同前置詞語彙基元，但是這份文件將假設使用預設 `x:` 對應來識別這些是 XAML 語言 XAML 命名空間之已定義部分的實體，而非與特定架構無關的 WPF 預設命名空間或其他 XML 命名空間。</span><span class="sxs-lookup"><span data-stu-id="4a71b-136">You could choose a different prefix token in your own XAML namespace mapping, but this documentation will assume the default `x:` mapping as a means of identifying those entities that are a defined part of the XAML namespace for the XAML language, as opposed to the WPF default namespace or other XAML namespaces not related to a specific framework.</span></span>  
  
<a name="WPF_Specific_Markup_Extensions"></a>   
## <a name="wpf-specific-markup-extensions"></a><span data-ttu-id="4a71b-137">WPF 特定標記延伸模組</span><span class="sxs-lookup"><span data-stu-id="4a71b-137">WPF-Specific Markup Extensions</span></span>  
 <span data-ttu-id="4a71b-138">WPF 程式設計中所使用的最常見標記延伸模組是支援資源參考的標記延伸模組 (`StaticResource` 和 `DynamicResource`)，以及支援資料繫結的標記延伸模組 (`Binding`)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-138">The most common markup extensions used in WPF programming are those that support resource references (`StaticResource` and `DynamicResource`), and those that support data binding (`Binding`).</span></span>  
  
-   <span data-ttu-id="4a71b-139">`StaticResource` 會替代已定義資源的值，來提供屬性的值。</span><span class="sxs-lookup"><span data-stu-id="4a71b-139">`StaticResource` provides a value for a property by substituting the value of an already defined resource.</span></span> <span data-ttu-id="4a71b-140">`StaticResource` 評估最終會在 XAML 載入期間進行，而且無法在執行階段存取物件圖形。</span><span class="sxs-lookup"><span data-stu-id="4a71b-140">A `StaticResource` evaluation is ultimately made at XAML load time and does not have access to the object graph at run time.</span></span> <span data-ttu-id="4a71b-141">如需詳細資訊，請參閱 [StaticResource 標記延伸模組](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-141">For details, see [StaticResource Markup Extension](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="4a71b-142">`DynamicResource` 會針對屬性提供一個值，方式是延後該值，使其變成資源的執行階段參考。</span><span class="sxs-lookup"><span data-stu-id="4a71b-142">`DynamicResource` provides a value for a property by deferring that value to be a run-time reference to a resource.</span></span> <span data-ttu-id="4a71b-143">動態資源參考可在每次存取這類資源時強制執行新的查閱作業，而且可以在執行階段存取物件圖形。</span><span class="sxs-lookup"><span data-stu-id="4a71b-143">A dynamic resource reference forces a new lookup each time that such a resource is accessed and has access to the object graph at run time.</span></span> <span data-ttu-id="4a71b-144">若要取得這項存取，WPF 屬性系統中的相依性屬性以及評估過的運算式都支援 `DynamicResource` 概念。</span><span class="sxs-lookup"><span data-stu-id="4a71b-144">In order to get this access, `DynamicResource` concept is supported by dependency properties in the WPF property system, and evaluated expressions.</span></span> <span data-ttu-id="4a71b-145">因此，您只能針對相依性屬性目標使用 `DynamicResource`。</span><span class="sxs-lookup"><span data-stu-id="4a71b-145">Therefore you can only use `DynamicResource` for a dependency property target.</span></span> <span data-ttu-id="4a71b-146">如需詳細資訊，請參閱 [DynamicResource 標記延伸模組](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-146">For details, see [DynamicResource Markup Extension](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="4a71b-147">`Binding` 使用在執行階段套用至父物件的資料內容，來提供屬性的資料繫結值。</span><span class="sxs-lookup"><span data-stu-id="4a71b-147">`Binding` provides a data bound value for a property, using the data context that applies to the parent object at run time.</span></span> <span data-ttu-id="4a71b-148">此標記延伸模組啟用用於指定資料繫結的重大內嵌語法，因此相當複雜。</span><span class="sxs-lookup"><span data-stu-id="4a71b-148">This markup extension is relatively complex, because it enables a substantial inline syntax for specifying a data binding.</span></span> <span data-ttu-id="4a71b-149">如需詳細資訊，請參閱[Binding 標記延伸模組](../../../../docs/framework/wpf/advanced/binding-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-149">For details, see [Binding Markup Extension](../../../../docs/framework/wpf/advanced/binding-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="4a71b-150">`RelativeSource` 提供的來源資訊<xref:System.Windows.Data.Binding>，可以瀏覽數個可能的關聯性在執行階段物件樹狀目錄中。</span><span class="sxs-lookup"><span data-stu-id="4a71b-150">`RelativeSource` provides source information for a <xref:System.Windows.Data.Binding> that can navigate several possible relationships in the run-time object tree.</span></span> <span data-ttu-id="4a71b-151">這會提供在多用途範本中所建立或使用程式碼所建立之繫結的特殊化來源，而不需要完全了解周圍物件樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="4a71b-151">This provides specialized sourcing for bindings that are created in multi-use templates or created in code without full knowledge of the surrounding object tree.</span></span> <span data-ttu-id="4a71b-152">如需詳細資訊，請參閱 [RelativeSource 標記延伸模組](../../../../docs/framework/wpf/advanced/relativesource-markupextension.md)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-152">For details, see [RelativeSource MarkupExtension](../../../../docs/framework/wpf/advanced/relativesource-markupextension.md).</span></span>  
  
-   <span data-ttu-id="4a71b-153">`TemplateBinding` 可讓控制項範本使用範本屬性的值，而範本屬性來自將使用範本之類別的物件模型定義屬性。</span><span class="sxs-lookup"><span data-stu-id="4a71b-153">`TemplateBinding` enables a control template to use values for templated properties that come from object-model-defined properties of the class that will use the template.</span></span> <span data-ttu-id="4a71b-154">換句話說，範本定義內的屬性可以存取只在套用範本後存在的內容。</span><span class="sxs-lookup"><span data-stu-id="4a71b-154">In other words, the property within the template definition can access a context that only exists once the template is applied.</span></span> <span data-ttu-id="4a71b-155">如需詳細資訊，請參閱 [TemplateBinding 標記延伸模組](../../../../docs/framework/wpf/advanced/templatebinding-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-155">For details, see [TemplateBinding Markup Extension](../../../../docs/framework/wpf/advanced/templatebinding-markup-extension.md).</span></span> <span data-ttu-id="4a71b-156">如需 `TemplateBinding` 實際使用的詳細資訊，請參閱 [Styling with ControlTemplates Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating) (使用 ControlTemplates 設定樣式範例)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-156">For more information on the practical use of `TemplateBinding`, see [Styling with ControlTemplates Sample](https://github.com/Microsoft/WPF-Samples/tree/master/Styles%20&%20Templates/IntroToStylingAndTemplating).</span></span>  
  
-   <span data-ttu-id="4a71b-157">`ColorConvertedBitmap` 支援一個相當進階的影像處理案例。</span><span class="sxs-lookup"><span data-stu-id="4a71b-157">`ColorConvertedBitmap` supports a relatively advanced imaging scenario.</span></span> <span data-ttu-id="4a71b-158">如需詳細資訊，請參閱 [ColorConvertedBitmap 標記延伸模組](../../../../docs/framework/wpf/advanced/colorconvertedbitmap-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-158">For details, see [ColorConvertedBitmap Markup Extension](../../../../docs/framework/wpf/advanced/colorconvertedbitmap-markup-extension.md).</span></span>  
  
-   <span data-ttu-id="4a71b-159">`ComponentResourceKey` 和 `ThemeDictionary` 支援資源查閱各層面，特別是針對與自訂控制項一起封裝的資源和主題。</span><span class="sxs-lookup"><span data-stu-id="4a71b-159">`ComponentResourceKey` and `ThemeDictionary` support aspects of resource lookup, particularly for resources and themes that are packaged with custom controls.</span></span> <span data-ttu-id="4a71b-160">如需詳細資訊，請參閱 [ComponentResourceKey 標記延伸模組](../../../../docs/framework/wpf/advanced/componentresourcekey-markup-extension.md)、[ThemeDictionary 標記延伸模組](../../../../docs/framework/wpf/advanced/themedictionary-markup-extension.md)或[控制項撰寫概觀](../../../../docs/framework/wpf/controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-160">For more information, see [ComponentResourceKey Markup Extension](../../../../docs/framework/wpf/advanced/componentresourcekey-markup-extension.md), [ThemeDictionary Markup Extension](../../../../docs/framework/wpf/advanced/themedictionary-markup-extension.md), or [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md).</span></span>  
  
<a name="StarExtension"></a>   
## <a name="extension-classes"></a><span data-ttu-id="4a71b-161">\*延伸模組類別</span><span class="sxs-lookup"><span data-stu-id="4a71b-161">\*Extension Classes</span></span>  
 <span data-ttu-id="4a71b-162">針對一般 XAML 語言和 WPF 專屬的標記延伸模組，透過是 XAML 處理器識別的每個標記延伸行為`*Extension`類別衍生自<xref:System.Windows.Markup.MarkupExtension>，並提供的實作<xref:System.Windows.Markup.StaticExtension.ProvideValue%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="4a71b-162">For both the general XAML language and WPF-specific markup extensions, the behavior of each markup extension is identified to a XAML processor through a `*Extension` class that derives from <xref:System.Windows.Markup.MarkupExtension>, and provides an implementation of the <xref:System.Windows.Markup.StaticExtension.ProvideValue%2A> method.</span></span> <span data-ttu-id="4a71b-163">每個延伸模組上的這個方法提供在評估標記延伸模組時所傳回的物件。</span><span class="sxs-lookup"><span data-stu-id="4a71b-163">This method on each extension provides the object that is returned when the markup extension is evaluated.</span></span> <span data-ttu-id="4a71b-164">所傳回的物件一般是根據傳遞至標記延伸模組的各種字串語彙基元所評估。</span><span class="sxs-lookup"><span data-stu-id="4a71b-164">The returned object is typically evaluated based on the various string tokens that are passed to the markup extension.</span></span>  
  
 <span data-ttu-id="4a71b-165">例如，<xref:System.Windows.StaticResourceExtension>類別會提供實際的資源查閱介面實作，讓其<xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>實作會傳回要求時，輸入要用於字串該特定實作的物件查閱的資源，由其`x:Key`。</span><span class="sxs-lookup"><span data-stu-id="4a71b-165">For example, the <xref:System.Windows.StaticResourceExtension> class provides the surface implementation of actual resource lookup so that its <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A> implementation returns the object that is requested, with the input of that particular implementation being a string that is used to look up the resource by its `x:Key`.</span></span> <span data-ttu-id="4a71b-166">如果您要使用現有的標記延伸模組，則此實作詳細資料大部分不重要。</span><span class="sxs-lookup"><span data-stu-id="4a71b-166">Much of this implementation detail is unimportant if you are using an existing markup extension.</span></span>  
  
 <span data-ttu-id="4a71b-167">某些標記延伸模組未使用字串語彙基元引數。</span><span class="sxs-lookup"><span data-stu-id="4a71b-167">Some markup extensions do not use string token arguments.</span></span> <span data-ttu-id="4a71b-168">這是因為它們會傳回靜態或一致值，或利用透過 `serviceProvider` 參數所傳遞的其中一個服務可以取得應該傳回值的內容。</span><span class="sxs-lookup"><span data-stu-id="4a71b-168">This is either because they return a static or consistent value, or because context for what value should be returned is available through one of the services passed through the `serviceProvider` parameter.</span></span>  
  
 <span data-ttu-id="4a71b-169">`*Extension` 命名模式是基於方便性和一致性。</span><span class="sxs-lookup"><span data-stu-id="4a71b-169">The `*Extension` naming pattern is for convenience and consistency.</span></span> <span data-ttu-id="4a71b-170">XAML 處理器將該類別識別為標記延伸模組支援，則不需要它。</span><span class="sxs-lookup"><span data-stu-id="4a71b-170">It is not necessary in order for a XAML processor to identify that class as support for a markup extension.</span></span> <span data-ttu-id="4a71b-171">只要程式碼基底包含 System.Xaml，並使用.NET Framework XAML 服務實作中，所有的才能辨識為 XAML 標記延伸是衍生自<xref:System.Windows.Markup.MarkupExtension>並支援建構語法。</span><span class="sxs-lookup"><span data-stu-id="4a71b-171">So long as your codebase includes System.Xaml and uses .NET Framework XAML Services implementations, all that is necessary to be recognized as a XAML markup extension is to derive from <xref:System.Windows.Markup.MarkupExtension> and to support a construction syntax.</span></span> <span data-ttu-id="4a71b-172">WPF 定義標記延伸模組啟用類別，請勿遵循`*Extension`命名模式，例如<xref:System.Windows.Data.Binding>。</span><span class="sxs-lookup"><span data-stu-id="4a71b-172">WPF defines markup extension-enabling classes that do not follow the `*Extension` naming pattern, for example <xref:System.Windows.Data.Binding>.</span></span> <span data-ttu-id="4a71b-173">通常這是因為此類別支援純標記延伸模組支援以外的案例。</span><span class="sxs-lookup"><span data-stu-id="4a71b-173">Typically the reason for this is that the class supports scenarios beyond pure markup extension support.</span></span> <span data-ttu-id="4a71b-174">如果是<xref:System.Windows.Data.Binding>，類別支援執行階段存取方法和物件的屬性，針對使用 XAML 無關的案例。</span><span class="sxs-lookup"><span data-stu-id="4a71b-174">In the case of <xref:System.Windows.Data.Binding>, that class supports run-time access to methods and properties of the object for scenarios that have nothing to do with XAML.</span></span>  
  
### <a name="extension-class-interpretation-of-initialization-text"></a><span data-ttu-id="4a71b-175">初始化文字的延伸模組類別解譯</span><span class="sxs-lookup"><span data-stu-id="4a71b-175">Extension Class Interpretation of Initialization Text</span></span>  
 <span data-ttu-id="4a71b-176">XAML 處理器會使用下列其中一種方式來解譯位在標記延伸模組名稱後面而且仍在大括弧內的字串語彙基元：</span><span class="sxs-lookup"><span data-stu-id="4a71b-176">The string tokens following the markup extension name and still within the braces are interpreted by a XAML processor in one of the following ways:</span></span>  
  
-   <span data-ttu-id="4a71b-177">逗號一律會代表個別語彙基元的分隔符號。</span><span class="sxs-lookup"><span data-stu-id="4a71b-177">A comma always represents the separator or delimiter of individual tokens.</span></span>  
  
-   <span data-ttu-id="4a71b-178">如果個別分隔的語彙基元未包含任何等號，則會將每個語彙基元視為建構函式引數。</span><span class="sxs-lookup"><span data-stu-id="4a71b-178">If the individual separated tokens do not contain any equals signs, each token is treated as a constructor argument.</span></span> <span data-ttu-id="4a71b-179">每個建構函式參數都必須指定為該簽章所預期的類型，並且為該簽章所預期的適當順序。</span><span class="sxs-lookup"><span data-stu-id="4a71b-179">Each constructor parameter must be given as the type expected by that signature, and in the proper order expected by that signature.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="4a71b-180">XAML 處理器必須呼叫建構函式，以與配對數目的引數計數相符。</span><span class="sxs-lookup"><span data-stu-id="4a71b-180">A XAML processor must call the constructor that matches the argument count of the number of pairs.</span></span> <span data-ttu-id="4a71b-181">因此，如果您要實作自訂標記延伸模組，請不要提供多個具有相同引數計數的參數。</span><span class="sxs-lookup"><span data-stu-id="4a71b-181">For this reason, if you are implementing a custom markup extension, do not provide multiple parameters with the same argument count.</span></span> <span data-ttu-id="4a71b-182">有多個具有相同參數計數的標記延伸模組建構函式路徑時，未定義 XAML 處理器運作方式的行為，但您應該預期在標記延伸模組類型定義發生此情況時，允許 XAML 處理器擲回用法例外狀況。</span><span class="sxs-lookup"><span data-stu-id="4a71b-182">The behavior for how a XAML processor behaves if more than one markup extension constructor path with the same parameter count exists is not defined, but you should anticipate that a XAML processor is permitted to throw an exception on usage if this situation exists in the markup extension type definitions.</span></span>  
  
-   <span data-ttu-id="4a71b-183">如果個別的分隔語彙基元包含等號，則 XAML 處理器會先呼叫標記延伸模組的預設建構函式。</span><span class="sxs-lookup"><span data-stu-id="4a71b-183">If the individual separated tokens contain equals signs, then a XAML processor first calls the default constructor for the markup extension.</span></span> <span data-ttu-id="4a71b-184">則每個「名稱=值」配對都會解譯為標記延伸模組上的屬性名稱，以及要指派給該屬性的值。</span><span class="sxs-lookup"><span data-stu-id="4a71b-184">Then, each name=value pair is interpreted as a property name that exists on the markup extension, and a value to assign to that property.</span></span>  
  
-   <span data-ttu-id="4a71b-185">如果建構函式行為與標記延伸模組中的屬性設定行為之間有平行結果，則所使用的行為就不重要。</span><span class="sxs-lookup"><span data-stu-id="4a71b-185">If there is a parallel result between the constructor behavior and the property setting behavior in a markup extension, it does not matter which behavior you use.</span></span> <span data-ttu-id="4a71b-186">如果只因為可讓您的標記更具意圖，而且您較不可能意外轉置建構函式參數，則較常見用法是使用有多個可設定屬性之標記延伸模組的「屬性」`=`「值」</span><span class="sxs-lookup"><span data-stu-id="4a71b-186">It is more common usage to use the *property*`=`*value* pairs for markup extensions that have more than one settable property, if only because it makes your markup more intentional and you are less likely to accidentally transpose constructor parameters.</span></span> <span data-ttu-id="4a71b-187">(當您指定「屬性=值」配對時，這些屬性可能是任意順序)。另外，不保證標記延伸模組提供可設定所有其可設定屬性的建構函式參數。</span><span class="sxs-lookup"><span data-stu-id="4a71b-187">(When you specify property=value pairs, those properties may be in any order.) Also, there is no guarantee that a markup extension supplies a constructor parameter that sets every one of its settable properties.</span></span> <span data-ttu-id="4a71b-188">例如，<xref:System.Windows.Data.Binding>是具有許多屬性都可透過 擴充功能中設定的標記延伸，*屬性*`=`*值*表單，但<xref:System.Windows.Data.Binding>只支援兩個建構函式： 預設建構函式，以及設定初始路徑。</span><span class="sxs-lookup"><span data-stu-id="4a71b-188">For example, <xref:System.Windows.Data.Binding> is a markup extension, with many properties that are settable through the extension in *property*`=`*value* form, but <xref:System.Windows.Data.Binding> only supports two constructors: a default constructor, and one that sets an initial path.</span></span>  
  
-   <span data-ttu-id="4a71b-189">必須逸出，才能將常值逗號傳遞給標記延伸模組。</span><span class="sxs-lookup"><span data-stu-id="4a71b-189">A literal comma cannot be passed to a markup extension without escapement.</span></span>  
  
<a name="EscapeSequences"></a>   
## <a name="escape-sequences-and-markup-extensions"></a><span data-ttu-id="4a71b-190">逸出序列和標記延伸模組</span><span class="sxs-lookup"><span data-stu-id="4a71b-190">Escape Sequences and Markup Extensions</span></span>  
 <span data-ttu-id="4a71b-191">XAML 處理器中的屬性處理使用大括號作為標記延伸模組序列的指標。</span><span class="sxs-lookup"><span data-stu-id="4a71b-191">Attribute handling in a XAML processor uses the curly braces as indicators of a markup extension sequence.</span></span> <span data-ttu-id="4a71b-192">此外，必要時，也可能產生常值大括號字元屬性值，方法是使用後接常值大括號的空大括號配對來輸入逸出序列。</span><span class="sxs-lookup"><span data-stu-id="4a71b-192">It is also possible to produce a literal curly brace character attribute value if necessary, by entering an escape sequence using an empty curly brace pair followed by the literal curly brace.</span></span> <span data-ttu-id="4a71b-193">請參閱[{}逸出序列的標記延伸](../../xaml-services/escape-sequence-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-193">See [{} Escape Sequence - Markup Extension](../../xaml-services/escape-sequence-markup-extension.md).</span></span>  
  
<a name="Nesting"></a>   
## <a name="nesting-markup-extensions-in-xaml-usage"></a><span data-ttu-id="4a71b-194">XAML 用法中的巢狀標記延伸模組</span><span class="sxs-lookup"><span data-stu-id="4a71b-194">Nesting Markup Extensions in XAML Usage</span></span>  
 <span data-ttu-id="4a71b-195">支援巢狀多個標記延伸模組，並且會先更深入地評估每個標記延伸模組。</span><span class="sxs-lookup"><span data-stu-id="4a71b-195">Nesting of multiple markup extensions is supported, and each markup extension will be evaluated deepest first.</span></span> <span data-ttu-id="4a71b-196">例如，請考慮下列用法：</span><span class="sxs-lookup"><span data-stu-id="4a71b-196">For example, consider the following usage:</span></span>  
  
```  
<Setter Property="Background"  
  Value="{DynamicResource {x:Static SystemColors.ControlBrushKey}}" />  
```  
  
 <span data-ttu-id="4a71b-197">在此用法中，會先評估 `x:Static` 陳述式，並傳回字串。</span><span class="sxs-lookup"><span data-stu-id="4a71b-197">In this usage, the `x:Static` statement is evaluated first and returns a string.</span></span> <span data-ttu-id="4a71b-198">該字串接著會用作 `DynamicResource` 的引數。</span><span class="sxs-lookup"><span data-stu-id="4a71b-198">That string is then used as the argument for `DynamicResource`.</span></span>  
  
## <a name="markup-extensions-and-property-element-syntax"></a><span data-ttu-id="4a71b-199">標記延伸模組和屬性項目語法</span><span class="sxs-lookup"><span data-stu-id="4a71b-199">Markup Extensions and Property Element Syntax</span></span>  
 <span data-ttu-id="4a71b-200">用作填入屬性項目值的物件項目時，無法從可在 XAML 中使用的一般類型支援物件項目來透過視覺方式區別標記延伸模組類別。</span><span class="sxs-lookup"><span data-stu-id="4a71b-200">When used as an object element that fills a property element value, a markup extension class is visually indistinguishable from a typical type-backed object element that can be used in XAML.</span></span> <span data-ttu-id="4a71b-201">一般物件項目與標記延伸模組的實際差異，在於標記延伸模組會評估為類型值或延後為運算式。</span><span class="sxs-lookup"><span data-stu-id="4a71b-201">The practical difference between a typical object element and a markup extension is that the markup extension is either evaluated to a typed value or deferred as an expression.</span></span> <span data-ttu-id="4a71b-202">因此，標記延伸模組之屬性值的任何可能類型錯誤的機制會不同，就像其他程式設計模型中處理晚期繫結屬性的方式一樣。</span><span class="sxs-lookup"><span data-stu-id="4a71b-202">Therefore the mechanisms for any possible type errors of property values for the markup extension will be different, similar to how a late-bound property is treated in other programming models.</span></span> <span data-ttu-id="4a71b-203">將會針對剖析 XAML 時所設定的目標屬性，評估一般物件項目的類型是否相符。</span><span class="sxs-lookup"><span data-stu-id="4a71b-203">An ordinary object element will be evaluated for type match against the target property it is setting when the XAML is parsed.</span></span>  
  
 <span data-ttu-id="4a71b-204">用於物件項目語法以填入屬性項目時，大部分標記延伸模組內不會有內容或任何進一步屬性項目語法。</span><span class="sxs-lookup"><span data-stu-id="4a71b-204">Most markup extensions, when used in object element syntax to fill a property element, would not have content or any further property element syntax within.</span></span> <span data-ttu-id="4a71b-205">因此，您可以關閉物件項目標記，且不提供任何子項目。</span><span class="sxs-lookup"><span data-stu-id="4a71b-205">Thus you would close the object element tag, and provide no child elements.</span></span> <span data-ttu-id="4a71b-206">只要 XAML 處理器遇到任何物件項目時，就會呼叫該類別的建構函式，以具現化從剖析的項目所建立的物件。</span><span class="sxs-lookup"><span data-stu-id="4a71b-206">Whenever any object element is encountered by a XAML processor, the constructor for that class is called, which instantiates the object created from the parsed element.</span></span> <span data-ttu-id="4a71b-207">標記延伸模組類別並無不同︰如果您想要標記延伸模組可用於物件項目語法，則必須提供預設建構函式。</span><span class="sxs-lookup"><span data-stu-id="4a71b-207">A markup extension class is no different: if you want your markup extension to be usable in object element syntax, you must provide a default constructor.</span></span> <span data-ttu-id="4a71b-208">某些現有標記延伸模組有至少一個必要屬性值，而且必須指定一個必要屬性值才能進行有效初始化。</span><span class="sxs-lookup"><span data-stu-id="4a71b-208">Some existing markup extensions have at least one required property value that must be specified for effective initialization.</span></span> <span data-ttu-id="4a71b-209">如果是這樣，該屬性值一般會指定為物件項目上屬性 (property) 的屬性 (attribute)。</span><span class="sxs-lookup"><span data-stu-id="4a71b-209">If so, that property value is typically given as a property attribute on the object element.</span></span> <span data-ttu-id="4a71b-210">在 [XAML 命名空間 (x:) 語言功能](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md)和 [WPF XAML 延伸功能](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md)參考頁面中，將會標註具有必要屬性 (和必要屬性的名稱) 的延伸模組。</span><span class="sxs-lookup"><span data-stu-id="4a71b-210">In the [XAML Namespace (x:) Language Features](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md) and [WPF XAML Extensions](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md) reference pages, markup extensions that have required properties (and the names of required properties) will be noted.</span></span> <span data-ttu-id="4a71b-211">參考頁面也會標註是否不允許特定標記延伸模組的物件項目語法或屬性語法。</span><span class="sxs-lookup"><span data-stu-id="4a71b-211">Reference pages will also note if either object element syntax or attribute syntax is disallowed for particular markup extensions.</span></span> <span data-ttu-id="4a71b-212">值得注意的案例是 [x:Array 標記延伸模組](../../../../docs/framework/xaml-services/x-array-markup-extension.md)，這無法支援屬性語法，因為必須在標記內將該陣列的內容指定為內容。</span><span class="sxs-lookup"><span data-stu-id="4a71b-212">A notable case is [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md), which cannot support attribute syntax because the contents of that array must be specified within the tagging as content.</span></span> <span data-ttu-id="4a71b-213">陣列內容會當成一般物件處理；因此，沒有屬性的預設類型轉換子是可行的。</span><span class="sxs-lookup"><span data-stu-id="4a71b-213">The array contents are handled as general objects, therefore no default type converter for the attribute is feasible.</span></span> <span data-ttu-id="4a71b-214">此外，[x:Array 標記延伸模組](../../../../docs/framework/xaml-services/x-array-markup-extension.md)需要 `type` 參數。</span><span class="sxs-lookup"><span data-stu-id="4a71b-214">Also, [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md) requires a `type` parameter.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="4a71b-215">另請參閱</span><span class="sxs-lookup"><span data-stu-id="4a71b-215">See Also</span></span>  
 [<span data-ttu-id="4a71b-216">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="4a71b-216">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="4a71b-217">XAML 命名空間 (x:) 語言功能</span><span class="sxs-lookup"><span data-stu-id="4a71b-217">XAML Namespace (x:) Language Features</span></span>](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md)  
 [<span data-ttu-id="4a71b-218">WPF XAML 延伸</span><span class="sxs-lookup"><span data-stu-id="4a71b-218">WPF XAML Extensions</span></span>](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md)  
 [<span data-ttu-id="4a71b-219">StaticResource 標記延伸</span><span class="sxs-lookup"><span data-stu-id="4a71b-219">StaticResource Markup Extension</span></span>](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md)  
 [<span data-ttu-id="4a71b-220">Binding 標記延伸</span><span class="sxs-lookup"><span data-stu-id="4a71b-220">Binding Markup Extension</span></span>](../../../../docs/framework/wpf/advanced/binding-markup-extension.md)  
 [<span data-ttu-id="4a71b-221">DynamicResource 標記延伸</span><span class="sxs-lookup"><span data-stu-id="4a71b-221">DynamicResource Markup Extension</span></span>](../../../../docs/framework/wpf/advanced/dynamicresource-markup-extension.md)  
 [<span data-ttu-id="4a71b-222">x:Type 標記延伸模組</span><span class="sxs-lookup"><span data-stu-id="4a71b-222">x:Type Markup Extension</span></span>](../../../../docs/framework/xaml-services/x-type-markup-extension.md)
