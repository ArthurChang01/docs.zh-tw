---
title: TypeConverter 和 XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: ec6eaadae1dd7a7db84538c24e396a14db1a65a4
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/23/2019
ms.locfileid: "62007292"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="8d0b2-102">TypeConverter 和 XAML</span><span class="sxs-lookup"><span data-stu-id="8d0b2-102">TypeConverters and XAML</span></span>
<span data-ttu-id="8d0b2-103">本主題介紹將字串的類型轉換當成一般 XAML 語言功能的目的。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="8d0b2-104">在.NET Framework 中，<xref:System.ComponentModel.TypeConverter>類別具有特殊用途的實作可用作 XAML 屬性使用方式中的屬性值的 managed 自訂類別的一部分。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="8d0b2-105">如果您撰寫自訂類別，而且您想要您的類別可用來做為 XAML 可設定的屬性值的執行個體，您可能需要套用<xref:System.ComponentModel.TypeConverterAttribute>至您的類別撰寫自訂<xref:System.ComponentModel.TypeConverter>類別，或兩者。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="8d0b2-106">類型轉換概念</span><span class="sxs-lookup"><span data-stu-id="8d0b2-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="8d0b2-107">XAML 和字串值</span><span class="sxs-lookup"><span data-stu-id="8d0b2-107">XAML and String Values</span></span>  
 <span data-ttu-id="8d0b2-108">在 XAML 檔案中設定屬性值時，該值的初始類型是純文字的字串。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="8d0b2-109">甚至，其他基本類型，例如<xref:System.Double>一開始是 XAML 處理器的文字字串。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="8d0b2-110">XAML 處理器需要兩項資訊才能處理屬性值。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="8d0b2-111">第一項資訊是正在設定之屬性的實值類型。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="8d0b2-112">任何定義屬性值並在 XAML 中處理的字串最後必須轉換或解析成該類型的值。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="8d0b2-113">如果值是 XAML 剖析器可理解的基本類型 (例如數值)，則會嘗試直接轉換字串。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="8d0b2-114">如果值是一個列舉，則用來檢查名稱的字串會符合該列舉中的具名常數。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="8d0b2-115">如果值不是剖析器所辨識的基本類型，也不是列舉，則上述類型必須能夠根據已轉換的字串提供類型的執行個體或值。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="8d0b2-116">您可以藉由指定類型轉換器類別來完成此動作。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="8d0b2-117">類型轉換子實際上是一個 Helper 類別，可用於提供另一個類別的值，這兩者均適用於 XAML 案例，可能也適用於利用 .NET 程式碼進行程式碼呼叫。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="8d0b2-118">在 XAML 中使用現有的類型轉換行為</span><span class="sxs-lookup"><span data-stu-id="8d0b2-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="8d0b2-119">根據您對基礎 XAML 概念的熟悉程度而定，您可能已經在基本應用程式 XAML 中使用類型轉換行為而不自知。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="8d0b2-120">比方說，WPF 會定義數百個採用型別值的屬性<xref:System.Windows.Point>。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="8d0b2-121">A<xref:System.Windows.Point>是描述二維座標空間中的座標值，而它其實只是有兩個重要屬性：<xref:System.Windows.Point.X%2A>和<xref:System.Windows.Point.Y%2A>。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="8d0b2-122">當您在 XAML 中指定某個點時，您指定它為含有分隔符號 （通常為逗號） 的字串之間<xref:System.Windows.Point.X%2A>和<xref:System.Windows.Point.Y%2A>您提供的值。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="8d0b2-123">例如：`<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="8d0b2-124">即使這個簡單類型的<xref:System.Windows.Point>，而且其簡單的使用方式，在 XAML 中包含的型別轉換子。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="8d0b2-125">在此情況下，是類別<xref:System.Windows.PointConverter>。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="8d0b2-126">類型轉換器<xref:System.Windows.Point>在類別層級可簡化定義採用的所有屬性的標記使用方式<xref:System.Windows.Point>。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="8d0b2-127">若未在此處使用類型轉換器，您就需要針對先前所示的同一個範例使用下列更多較為詳細的標記：</span><span class="sxs-lookup"><span data-stu-id="8d0b2-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="8d0b2-128">是否要使用類型轉換字串或較為詳細的對等語法，通常是編碼樣式的選擇。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="8d0b2-129">您的 XAML 工具工作流程可能也會影響值的設定方式。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="8d0b2-130">一些 XAML 工具傾向於發出最詳細格式的標記，因為較容易反覆存取設計工具檢視或它自己的序列化機制。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="8d0b2-131">現有的類型轉換器通常可在 WPF 和.NET Framework 型別上探索藉由檢查類別 （或屬性） 是否有套用<xref:System.ComponentModel.TypeConverterAttribute>。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="8d0b2-132">這個屬性將基於 XAML 用途以及其他可能的用途，針對該類型的值，為支援類型轉換器的類別命名。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="8d0b2-133">類型轉換器和標記延伸</span><span class="sxs-lookup"><span data-stu-id="8d0b2-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="8d0b2-134">標記延伸和類型轉換器會根據 XAML 處理器行為和套用它們的案例來填滿正交角色。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="8d0b2-135">儘管有適合標記延伸使用的內容，但標記延伸負責提供值的屬性類型轉換行為在標記延伸實作中通常不會遭到檢查。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="8d0b2-136">換句話說，即使標記延伸傳回文字字串做為其 `ProvideValue` 輸出，也不會在該字串上叫用套用至特定屬性或屬性值類型的類型轉換行為。一般來說，標記延伸的目的是在未涉及任何類型轉換器的情況下，處理字串並傳回物件。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="8d0b2-137">需要標記延伸而不是類型轉換器的一個常見情況是參考現有的物件。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="8d0b2-138">無狀態類型轉換器充其量只能產生新的執行個體，但這可能不是令人滿意的情況。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="8d0b2-139">如需標記延伸的詳細資訊，請參閱[標記延伸和 WPF XAML](markup-extensions-and-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="8d0b2-140">原生類型轉換器</span><span class="sxs-lookup"><span data-stu-id="8d0b2-140">Native Type Converters</span></span>  
 <span data-ttu-id="8d0b2-141">在 XAML 剖析器中的 WPF 和 .NET Framework 實作中，有些特定類型具有原生類型轉換處理，但卻不是依慣例會被視為基本類型的類型。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="8d0b2-142">這類類型的範例是 <xref:System.DateTime>。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="8d0b2-143">這根據.NET Framework 架構的運作方式： 類型<xref:System.DateTime>定義於 mscorlib，在.NET 中的最基本程式庫。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="8d0b2-144"><xref:System.DateTime> 不允許來自另一個引進相依性的組件的屬性化 (<xref:System.ComponentModel.TypeConverterAttribute>來自系統) 因此無法支援透過屬性設定的一般類型轉換器探索機制。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="8d0b2-145">而是 XAML 剖析器會有一份需要這類原生處理的類型清單，這些類型的處理方式會與真正基本類型的處理方式類似</span><span class="sxs-lookup"><span data-stu-id="8d0b2-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="8d0b2-146">(若是<xref:System.DateTime>這項作業包括呼叫<xref:System.DateTime.Parse%2A>。)</span><span class="sxs-lookup"><span data-stu-id="8d0b2-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>   
## <a name="implementing-a-type-converter"></a><span data-ttu-id="8d0b2-147">實作類型轉換器</span><span class="sxs-lookup"><span data-stu-id="8d0b2-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="8d0b2-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="8d0b2-148">TypeConverter</span></span>  
 <span data-ttu-id="8d0b2-149">在 <xref:System.Windows.Point>先前提供之類別的範例<xref:System.Windows.PointConverter>所述。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="8d0b2-150">針對 XAML 的.NET 實作，用於 XAML 用途的所有類型轉換器都是衍生自基底類別的類別<xref:System.ComponentModel.TypeConverter>。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="8d0b2-151"><xref:System.ComponentModel.TypeConverter>類別存在於.NET framework 出現之前的 XAML 的版本，其原始的使用方式的其中一個是提供視覺化設計工具中的屬性對話方塊的字串轉換。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="8d0b2-152">針對 XAML，所扮演的角色<xref:System.ComponentModel.TypeConverter>已擴展成包含在目標字串和來源字串的轉換，以便能夠剖析字串屬性值，並可能將特定物件屬性的執行階段值處理回字串的基底類別做為屬性的序列化。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="8d0b2-153"><xref:System.ComponentModel.TypeConverter> 定義四個成員與相關的轉換與基於 XAML 處理的字串：</span><span class="sxs-lookup"><span data-stu-id="8d0b2-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="8d0b2-154">其中，最重要的方法是<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="8d0b2-155">這個方法會將輸入字串轉換為所需的物件類型。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="8d0b2-156">嚴格來說，<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>無法實作方法，以更廣泛的型別轉換子的預定的目的地類型，並因此提供延伸超過 XAML，例如支援執行階段轉換，但基於 XAML 用途這是只可以處理的程式碼路徑<xref:System.String>很重要的輸入。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="8d0b2-157">下一個最重要的方法是<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="8d0b2-158">（比方說，如果它已儲存至 XAML 檔案），如果要應用程式轉換成標記呈現，<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>負責產生標記表示法。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="8d0b2-159">在此情況下，關係的 XAML 程式碼路徑時，您將傳遞`destinationType`的<xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="8d0b2-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 和 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 是服務查詢 <xref:System.ComponentModel.TypeConverter> 實作之功能時所使用的支援方法。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="8d0b2-161">您必須實作這些方法來傳回轉換器對等轉換方法所支援類型特有案例的 `true` 。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="8d0b2-162">基於 XAML，這通常表示 <xref:System.String> 類型。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="8d0b2-163">XAML 的文化特性資訊和類型轉換器</span><span class="sxs-lookup"><span data-stu-id="8d0b2-163">Culture Information and Type Converters for XAML</span></span>  
 <span data-ttu-id="8d0b2-164">每個<xref:System.ComponentModel.TypeConverter>實作可以有它自己對於什麼可替代轉換的有效字串的解譯，也可以使用或忽略傳遞為參數的類型描述。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="8d0b2-165">有一個關於文化特性和 XAML 類型轉換的重要考量。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="8d0b2-166">XAML 完全支援使用可當地語系化的字串做為屬性值。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="8d0b2-167">但不支援使用那個可當地語系化的字串做為具有特定文化特性需求的類型轉換器輸入，因為 XAML 屬性值的類型轉換器會使用 `en-US` 文化特性，來包含必然的固定語言剖析行為。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="8d0b2-168">如需這項限制之設計考量的詳細資訊，請參閱 XAML 語言規格 ([\[MS-XAML\] (英文)](https://go.microsoft.com/fwlink/?LinkId=114525))。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525)).</span></span>  
  
 <span data-ttu-id="8d0b2-169">在文化特性可能是問題的範例中，某些文化特性會使用逗號做為數字的小數點分隔符號。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="8d0b2-170">這將與許多 WPF XAML 類型轉換器所具備的行為相衝突，該行為是使用逗號做為分隔符號 (根據歷程的前置參照，例如，常見的 X,Y 格式或逗號分隔清單)。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="8d0b2-171">即使是在局部的 XAML 中傳遞文化特性 (將 `Language` 或 `xml:lang` 設為 `sl-SI` 文化特性，以這種方式使用逗號代表小數點的文化特性範例)，還是無法解決問題。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="8d0b2-172">實作 ConvertFrom</span><span class="sxs-lookup"><span data-stu-id="8d0b2-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="8d0b2-173">若要可做為支援 XAML 的 <xref:System.ComponentModel.TypeConverter> 實作來重複使用，該轉換器的 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 方法必須接受字串做為 `value` 參數。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="8d0b2-174">格式，並且可以將轉換是否為有效字串<xref:System.ComponentModel.TypeConverter>實作中，則傳回的物件必須支援轉型為屬性所預期的類型。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="8d0b2-175">否則， <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 實作必須傳回 `null`。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="8d0b2-176">每個<xref:System.ComponentModel.TypeConverter>實作可以有它自己對於什麼可替代轉換的有效字串的解譯，也可以使用或忽略傳遞為參數的類型描述或文化特性內容。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="8d0b2-177">不過，WPF XAML 處理可能不會在所有情況下都將值傳遞至類型描述內容，也可能不會根據 `xml:lang` 來傳遞文化特性。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8d0b2-178">請勿使用大括號字元 (特別是 {)做為字串格式的可能元素。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="8d0b2-179">這些字元保留做為標記延伸序列的進入及結束。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="8d0b2-180">實作 ConvertTo</span><span class="sxs-lookup"><span data-stu-id="8d0b2-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="8d0b2-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 可能用於序列化支援。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="8d0b2-182">透過自訂類型和其類型轉換器之 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> 的序列化支援不是絕對需求。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="8d0b2-183">不過，如果您正在實作控制項，或使用功能某部分的序列化或類別設計，則應該實作 <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="8d0b2-184">若要可以用作<xref:System.ComponentModel.TypeConverter>支援 XAML，實作<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>該轉換器的方法必須接受型別 （或值） 所支援的執行個體做為`value`參數。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="8d0b2-185">當`destinationType`參數為類型<xref:System.String>，則傳回的物件必須能夠轉型為<xref:System.String>。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="8d0b2-186">傳回的字串必須代表 `value` 的序列化值。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="8d0b2-187">在理想情況下，應該能夠產生相同的值，如果該字串傳遞給您選擇的序列化格式<xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>實作相同的轉換子，而不會明顯遺失資訊。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="8d0b2-188">如果無法序列化值，或轉換器不支援序列化<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>實作必須傳回`null`，而且能夠在此情況下擲回例外狀況。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="8d0b2-189">如果您未擲回例外狀況，您就應該報告無法使用該轉換的一部分，但您<xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>實作，讓檢查的最佳作法<xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>第一個支援以避免例外狀況。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="8d0b2-190">如果`destinationType`參數的型別不是<xref:System.String>，您可以選擇專屬轉換器處理。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="8d0b2-191">一般而言，您就會還原為基底實作處理，而在最基底<xref:System.ComponentModel.TypeConverter.ConvertTo%2A>引發特定例外狀況。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="8d0b2-192">實作 CanConvertTo</span><span class="sxs-lookup"><span data-stu-id="8d0b2-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="8d0b2-193">您的 <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> 實作應該傳回類型 `true` 之 `destinationType` 的 <xref:System.String>，否則會進行基底實作。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="8d0b2-194">實作 CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="8d0b2-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="8d0b2-195">您的 <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> 實作應該傳回類型 `true` 之 `sourceType` 的 <xref:System.String>，否則會進行基底實作。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>   
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="8d0b2-196">套用 TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="8d0b2-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="8d0b2-197">為了讓您自訂類型轉換器，以用做自訂類別的 XAML 處理器的型別轉換子，您必須套用[!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)]<xref:System.ComponentModel.TypeConverterAttribute>至類別定義。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="8d0b2-198">您透過屬性指定的 <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> 必須是您自訂類型轉換器的類型名稱。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="8d0b2-199">如果已套用這個屬性，當 XAML 處理器處理屬性類型使用您自訂類別類型的值時，就可以輸入字串並傳回物件執行個體。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="8d0b2-200">您也可以提供每個屬性的類型轉換器。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="8d0b2-201">將 [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> 套用至屬性定義 (主要定義，非其內的 `get`/`set` 實作)，而不是將它套用至類別定義。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-201">Instead of applying a [!INCLUDE[TLA#tla_netframewkattr](../../../../includes/tlasharptla-netframewkattr-md.md)] <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="8d0b2-202">屬性的類型必須符合您自訂類型轉換器所處理的類型。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="8d0b2-203">如果已套用這個屬性，在 XAML 處理器處理該屬性的值時，就可以處理輸入字串並傳回物件執行個體。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-203">With this attribute applied, when a XAMLprocessor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="8d0b2-204">每個屬性的類型轉換器技術是特別有用，如果您選擇使用來自 Microsoft.NET Framework 或某個其他程式庫，您無法控制類別定義，就無法套用的屬性類型<xref:System.ComponentModel.TypeConverterAttribute>那里。</span><span class="sxs-lookup"><span data-stu-id="8d0b2-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8d0b2-205">另請參閱</span><span class="sxs-lookup"><span data-stu-id="8d0b2-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="8d0b2-206">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="8d0b2-206">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="8d0b2-207">標記延伸和 WPF XAML</span><span class="sxs-lookup"><span data-stu-id="8d0b2-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="8d0b2-208">XAML 語法詳細資料</span><span class="sxs-lookup"><span data-stu-id="8d0b2-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
