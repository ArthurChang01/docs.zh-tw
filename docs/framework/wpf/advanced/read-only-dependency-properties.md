---
title: 唯讀相依性屬性
ms.date: 03/30/2017
helpviewer_keywords:
- dependency properties [WPF], read-only
- read-only dependency properties [WPF]
ms.assetid: f23d6ec9-3780-4c09-a2ff-b2f0a2deddf1
ms.openlocfilehash: 9aeeab95342bce94c53e89229003f55009118f96
ms.sourcegitcommit: 0c48191d6d641ce88d7510e319cf38c0e35697d0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/05/2019
ms.locfileid: "57379000"
---
# <a name="read-only-dependency-properties"></a><span data-ttu-id="c1b8a-102">唯讀相依性屬性</span><span class="sxs-lookup"><span data-stu-id="c1b8a-102">Read-Only Dependency Properties</span></span>
<span data-ttu-id="c1b8a-103">本主題說明唯讀相依性屬性，包括現有的唯讀相依性屬性，以及用於建立自訂唯讀相依性屬性的案例和技術。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-103">This topic describes read-only dependency properties, including existing read-only dependency properties and the scenarios and techniques for creating a custom read-only dependency property.</span></span>  
  

  
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="c1b8a-104">必要條件</span><span class="sxs-lookup"><span data-stu-id="c1b8a-104">Prerequisites</span></span>  
 <span data-ttu-id="c1b8a-105">本主題假設您已了解實作相依性屬性的基本案例，以及如何將中繼資料套用到自訂相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-105">This topic assumes that you understand the basic scenarios of implementing a dependency property, and how metadata is applied to a custom dependency property.</span></span> <span data-ttu-id="c1b8a-106">如需相關內容，請參閱[自訂相依性屬性](custom-dependency-properties.md)和[相依性屬性中繼資料](dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-106">See [Custom Dependency Properties](custom-dependency-properties.md) and [Dependency Property Metadata](dependency-property-metadata.md) for context.</span></span>  
  
<a name="existing"></a>   
## <a name="existing-read-only-dependency-properties"></a><span data-ttu-id="c1b8a-107">現有的唯讀相依性屬性</span><span class="sxs-lookup"><span data-stu-id="c1b8a-107">Existing Read-Only Dependency Properties</span></span>  
 <span data-ttu-id="c1b8a-108">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 架構中定義的一些相依性屬性為唯讀狀態。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-108">Some of the dependency properties defined in the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] framework are read-only.</span></span> <span data-ttu-id="c1b8a-109">指定唯讀相依性屬性的一般原因是，這些屬性應該用來判斷狀態，然而該狀態會受到許多因素影響，但從使用者介面設計觀點來看，只將屬性設為該狀態並不恰當。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-109">The typical reason for specifying a read-only dependency property is that these are properties that should be used for state determination, but where that state is influenced by a multitude of factors, but just setting the property to that state isn't desirable from a user interface design perspective.</span></span> <span data-ttu-id="c1b8a-110">例如，屬性<xref:System.Windows.UIElement.IsMouseOver%2A>其實只會呈現從滑鼠輸入所決定的狀態。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-110">For example, the property <xref:System.Windows.UIElement.IsMouseOver%2A> is really just surfacing state as determined from the mouse input.</span></span> <span data-ttu-id="c1b8a-111">藉由規避實際的滑鼠輸入，以程式設計方式設定此值的任何嘗試，都是無法預測且會導致不一致的情況。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-111">Any attempt to set this value programmatically by circumventing the true mouse input would be unpredictable and would cause inconsistency.</span></span>  
  
 <span data-ttu-id="c1b8a-112">由於是不可設定的，因此，唯讀相依性屬性不適合許多相依性屬性通常可提供解決方案 (也就是：資料繫結、可直接設定的樣式值、驗證、動畫、繼承) 的案例。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-112">By virtue of not being settable, read-only dependency properties aren't appropriate for many of the scenarios for which dependency properties normally offer a solution (namely: data binding, directly stylable to a value, validation, animation, inheritance).</span></span> <span data-ttu-id="c1b8a-113">儘管不可設定，唯讀相依性屬性仍然具有一些屬性系統中相依性屬性所支援的其他功能。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-113">Despite not being settable, read-only dependency properties still have some of the additional capabilities supported by dependency properties in the property system.</span></span> <span data-ttu-id="c1b8a-114">其餘最重要的功能是，唯讀相依性屬性仍可用來做為樣式中的屬性觸發程序。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-114">The most important remaining capability is that the read-only dependency property can still be used as a property trigger in a style.</span></span> <span data-ttu-id="c1b8a-115">您無法透過一般 [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] 屬性啟用觸發程序；它必須是相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-115">You can't enable triggers with a normal [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] property; it needs to be a dependency property.</span></span> <span data-ttu-id="c1b8a-116">上述<xref:System.Windows.UIElement.IsMouseOver%2A>屬性是完美的範例案例，其中可能會非常有用，其中有一些定義的樣式控制項，例如背景、 foreground 或類似的屬性中複合元素的 visible 屬性當使用者將滑鼠置於某些控制項的已定義區域的上方時，將會變更控制項。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-116">The aforementioned <xref:System.Windows.UIElement.IsMouseOver%2A> property is a perfect example of a scenario where it might be quite useful to define a style for a control, where some visible property such as a background, foreground, or similar properties of composited elements within the control will change when the user places a mouse over some defined region of your control.</span></span> <span data-ttu-id="c1b8a-117">屬性系統固有的失效處理序也可以偵測到並回報唯讀相依性屬性中的變更，這實際上可在內部支援屬性觸發程序功能。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-117">Changes in a read-only dependency property can also be detected and reported by the property system's inherent invalidation processes, and this in fact supports the property trigger functionality internally.</span></span>  
  
<a name="new"></a>   
## <a name="creating-custom-read-only-dependency-properties"></a><span data-ttu-id="c1b8a-118">建立自訂唯讀相依性屬性</span><span class="sxs-lookup"><span data-stu-id="c1b8a-118">Creating Custom Read-Only Dependency Properties</span></span>  
 <span data-ttu-id="c1b8a-119">請務必閱讀前一節，以了解為什麼唯讀相依性屬性不適用許多一般的相依性屬性案例。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-119">Make sure to read the section above regarding why read-only dependency properties won't work for many typical dependency-property scenarios.</span></span> <span data-ttu-id="c1b8a-120">但是，如果您有適當的案例，您可能想要建立自己的唯讀相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-120">But if you have an appropriate scenario, you may wish to create your own read-only dependency property.</span></span>  
  
 <span data-ttu-id="c1b8a-121">在建立唯讀相依性屬性的處理序中，許多部分與[自訂相依性屬性](custom-dependency-properties.md)和[實作相依性屬性](how-to-implement-a-dependency-property.md)主題中所述的相同。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-121">Much of the process of creating a read-only dependency property is the same as is described in the [Custom Dependency Properties](custom-dependency-properties.md) and [Implement a Dependency Property](how-to-implement-a-dependency-property.md) topics.</span></span> <span data-ttu-id="c1b8a-122">有三個重大差異：</span><span class="sxs-lookup"><span data-stu-id="c1b8a-122">There are three important differences:</span></span>  
  
-   <span data-ttu-id="c1b8a-123">當註冊您的屬性，呼叫<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>方法，而非標準<xref:System.Windows.DependencyProperty.Register%2A>屬性註冊的方法。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-123">When registering your property, call the <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> method instead of the normal <xref:System.Windows.DependencyProperty.Register%2A> method for property registration.</span></span>  
  
-   <span data-ttu-id="c1b8a-124">實作 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]「包裝函式」屬性，請確定包裝函式還沒有 set 實作，如此一來，就不會在您所公開之公用包裝函式的唯讀狀態中產生不一致的情況。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-124">When implementing the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "wrapper" property, make sure that the wrapper too doesn't have a set implementation, so that there is no inconsistency in read-only state for the public wrapper you expose.</span></span>  
  
-   <span data-ttu-id="c1b8a-125">唯讀註冊所傳回的物件是<xref:System.Windows.DependencyPropertyKey>而非<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-125">The object returned by the read-only registration is <xref:System.Windows.DependencyPropertyKey> rather than <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="c1b8a-126">您仍應將此欄位儲存為成員，但通常不需讓它成為類型的公用成員。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-126">You should still store this field as a member but typically you would not make it a public member of the type.</span></span>  
  
 <span data-ttu-id="c1b8a-127">不論您必須支援的私用欄位或值為何，當然都能使用您決定的任何邏輯完整寫入您的唯讀相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-127">Whatever private field or value you have backing your read-only dependency property can of course be fully writable using whatever logic you decide.</span></span> <span data-ttu-id="c1b8a-128">不過，設定屬性 (不論是一開始就設定或設為執行階段邏輯一部分) 的最簡單方式是使用屬性系統的 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]，而不是規避屬性系統來直接設定私用支援欄位。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-128">However, the most straightforward way to set the property either initially or as part of runtime logic is to use the property system's [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)], rather than circumventing the property system and setting the private backing field directly.</span></span> <span data-ttu-id="c1b8a-129">特別是，沒有簽章<xref:System.Windows.DependencyObject.SetValue%2A>它會接受類型參數的<xref:System.Windows.DependencyPropertyKey>。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-129">In particular, there is a signature of <xref:System.Windows.DependencyObject.SetValue%2A> that accepts a parameter of type <xref:System.Windows.DependencyPropertyKey>.</span></span> <span data-ttu-id="c1b8a-130">方式和位置您設定此值以程式設計方式在應用程式邏輯，會影響您可能想要如何設定存取<xref:System.Windows.DependencyPropertyKey>您第一次註冊相依性屬性時所建立。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-130">How and where you set this value programmatically within your application logic will affect how you may wish to set access on the <xref:System.Windows.DependencyPropertyKey> created when you first registered the dependency property.</span></span> <span data-ttu-id="c1b8a-131">如果您全都在類別內處理此邏輯，您可能會讓它成為私用，或者如果您需要從組件的其他部分設定它，則可能會將它設為內部。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-131">If you handle this logic all within the class you could make it private, or if you require it to be set from other portions of the assembly you might set it internal.</span></span> <span data-ttu-id="c1b8a-132">其中一個方法是呼叫<xref:System.Windows.DependencyObject.SetValue%2A>相關的事件，以通知類別執行個體的預存的屬性值變更時所需的類別事件處理常式內。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-132">One approach is to call <xref:System.Windows.DependencyObject.SetValue%2A> within a class event handler of a relevant event that informs a class instance that the stored property value needs to be changed.</span></span> <span data-ttu-id="c1b8a-133">另一種方法是將相依性屬性在一起的繫結使用配對<xref:System.Windows.PropertyChangedCallback>和<xref:System.Windows.CoerceValueCallback>回呼，註冊期間的那些屬性中繼資料的一部分。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-133">Another approach is to tie dependency properties together by using paired <xref:System.Windows.PropertyChangedCallback> and <xref:System.Windows.CoerceValueCallback> callbacks as part of those properties' metadata during registration.</span></span>  
  
 <span data-ttu-id="c1b8a-134">因為<xref:System.Windows.DependencyPropertyKey>屬私人性質，並且不會傳播屬性系統，您的程式碼之外，唯讀相依性屬性有更好設定安全性會比讀寫相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-134">Because the <xref:System.Windows.DependencyPropertyKey> is private, and is not propagated by the property system outside of your code, a read-only dependency property does have better setting security than a read-write dependency property.</span></span> <span data-ttu-id="c1b8a-135">針對讀寫相依性屬性，識別欄位是明確或隱含公開的，因此該屬性是可廣泛設定的。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-135">For a read-write dependency property, the identifying field is explicitly or implicitly public and thus the property is widely settable.</span></span> <span data-ttu-id="c1b8a-136">如需詳細資訊，請參閱[相依性屬性的安全性](dependency-property-security.md)。</span><span class="sxs-lookup"><span data-stu-id="c1b8a-136">For more specifics, see [Dependency Property Security](dependency-property-security.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c1b8a-137">另請參閱</span><span class="sxs-lookup"><span data-stu-id="c1b8a-137">See also</span></span>
- [<span data-ttu-id="c1b8a-138">相依性屬性概觀</span><span class="sxs-lookup"><span data-stu-id="c1b8a-138">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="c1b8a-139">自訂相依性屬性</span><span class="sxs-lookup"><span data-stu-id="c1b8a-139">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="c1b8a-140">樣式設定和範本化</span><span class="sxs-lookup"><span data-stu-id="c1b8a-140">Styling and Templating</span></span>](../controls/styling-and-templating.md)
