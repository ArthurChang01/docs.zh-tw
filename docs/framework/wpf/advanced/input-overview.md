---
title: 輸入概觀
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- commands [WPF]
- input [WPF], overview
- keyboard focus [WPF]
- keyboard input [WPF]
- touch events [WPF]
- event routing [WPF]
- touch input [WPF]
- manipulation [WPF]
- logical focus [WPF]
- stylus input [WPF]
- text input [WPF]
- input events [WPF], handling
- WPF [WPF], input overview
- manipulation events [WPF]
- mouse input [WPF]
- mouse capture [WPF]
- focus [WPF]
- mouse position [WPF]
ms.assetid: ee5258b7-6567-415a-9b1c-c0cbe46e79ef
ms.openlocfilehash: 6aae66de973c357b4b87578221a169bf750739fb
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/28/2019
ms.locfileid: "64599021"
---
# <a name="input-overview"></a><span data-ttu-id="830ae-102">輸入概觀</span><span class="sxs-lookup"><span data-stu-id="830ae-102">Input Overview</span></span>
<a name="introduction"></a> <span data-ttu-id="830ae-103">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]子系統提供一個功能強大[!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)]各式各樣的裝置取得輸入，包括滑鼠、 鍵盤、 觸控及手寫筆。</span><span class="sxs-lookup"><span data-stu-id="830ae-103">The [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] subsystem provides a powerful [!INCLUDE[TLA#tla_api](../../../../includes/tlasharptla-api-md.md)] for obtaining input from a variety of devices, including the mouse, keyboard, touch, and stylus.</span></span> <span data-ttu-id="830ae-104">本主題描述 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 所提供的服務，以及說明輸入系統的架構。</span><span class="sxs-lookup"><span data-stu-id="830ae-104">This topic describes the services provided by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and explains the architecture of the input systems.</span></span>

<a name="input_api"></a>
## <a name="input-api"></a><span data-ttu-id="830ae-105">輸入 API</span><span class="sxs-lookup"><span data-stu-id="830ae-105">Input API</span></span>
 <span data-ttu-id="830ae-106">主要的輸入[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]公開位於基底類別： <xref:System.Windows.UIElement>， <xref:System.Windows.ContentElement>， <xref:System.Windows.FrameworkElement>，和<xref:System.Windows.FrameworkContentElement>。</span><span class="sxs-lookup"><span data-stu-id="830ae-106">The primary input [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] exposure is found on the base element classes: <xref:System.Windows.UIElement>, <xref:System.Windows.ContentElement>, <xref:System.Windows.FrameworkElement>, and <xref:System.Windows.FrameworkContentElement>.</span></span>  <span data-ttu-id="830ae-107">如需基底項目的詳細資訊，請參閱[基底項目概觀](base-elements-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="830ae-107">For more information about the base elements, see [Base Elements Overview](base-elements-overview.md).</span></span>  <span data-ttu-id="830ae-108">這些類別提供按鍵動作、滑鼠按鈕、滑鼠滾輪、滑鼠移動、焦點管理和滑鼠捕捉等相關輸入事件的功能。</span><span class="sxs-lookup"><span data-stu-id="830ae-108">These classes provide functionality for input events related to key presses, mouse buttons, mouse wheel, mouse movement, focus management, and mouse capture, to name a few.</span></span> <span data-ttu-id="830ae-109">將輸入 [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] 放在基底項目上，而不是將所有輸入事件作為服務，輸入架構可讓輸入事件成為 UI 中的特定物件來源，以及支援事件路由傳送，進而讓多個項目可以處理輸入事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-109">By placing the input [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] on the base elements, rather than treating all input events as a service, the input architecture enables the input events to be sourced by a particular object in the UI, and to support an event routing scheme whereby more than one element has an opportunity to handle an input event.</span></span> <span data-ttu-id="830ae-110">許多輸入事件都有一組與其建立關聯的事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-110">Many input events have a pair of events associated with them.</span></span>  <span data-ttu-id="830ae-111">例如，按鍵事件相關聯<xref:System.Windows.Input.Keyboard.KeyDown>和<xref:System.Windows.Input.Keyboard.PreviewKeyDown>事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-111">For example, the key down event is associated with the <xref:System.Windows.Input.Keyboard.KeyDown> and <xref:System.Windows.Input.Keyboard.PreviewKeyDown> events.</span></span>  <span data-ttu-id="830ae-112">這些事件的差異在於如何將它們路由傳送至目標項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-112">The difference in these events is in how they are routed to the target element.</span></span>  <span data-ttu-id="830ae-113">預覽事件會從根項目到目標項目往下瀏覽通道項目樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="830ae-113">Preview events tunnel down the element tree from the root element to the target element.</span></span>  <span data-ttu-id="830ae-114">事件反昇事件會從目標項目往上反昇到根項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-114">Bubbling events bubble up from the target element to the root element.</span></span>  <span data-ttu-id="830ae-115">這個概觀和[路由事件概觀](routed-events-overview.md)稍後會更詳細討論 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的事件路由。</span><span class="sxs-lookup"><span data-stu-id="830ae-115">Event routing in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] is discussed in more detail later in this overview and in the [Routed Events Overview](routed-events-overview.md).</span></span>

### <a name="keyboard-and-mouse-classes"></a><span data-ttu-id="830ae-116">鍵盤和滑鼠類別</span><span class="sxs-lookup"><span data-stu-id="830ae-116">Keyboard and Mouse Classes</span></span>
 <span data-ttu-id="830ae-117">除了輸入[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]基底的項目類別，<xref:System.Windows.Input.Keyboard>類別和<xref:System.Windows.Input.Mouse>類別會提供其他[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]使用鍵盤和滑鼠輸入。</span><span class="sxs-lookup"><span data-stu-id="830ae-117">In addition to the input [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] on the base element classes, the <xref:System.Windows.Input.Keyboard> class and <xref:System.Windows.Input.Mouse> classes provide additional [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] for working with keyboard and mouse input.</span></span>

 <span data-ttu-id="830ae-118">輸入的範例[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]上<xref:System.Windows.Input.Keyboard>類別<xref:System.Windows.Input.Keyboard.Modifiers%2A>屬性，會傳回<xref:System.Windows.Input.ModifierKeys>目前已按下和<xref:System.Windows.Input.Keyboard.IsKeyDown%2A>方法，可判斷指定的索引鍵是否按下。</span><span class="sxs-lookup"><span data-stu-id="830ae-118">Examples of input [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] on the <xref:System.Windows.Input.Keyboard> class are the <xref:System.Windows.Input.Keyboard.Modifiers%2A> property, which returns the <xref:System.Windows.Input.ModifierKeys> currently pressed, and the <xref:System.Windows.Input.Keyboard.IsKeyDown%2A> method, which determines whether a specified key is pressed.</span></span>

 <span data-ttu-id="830ae-119">下列範例會使用<xref:System.Windows.Input.Keyboard.GetKeyStates%2A>方法，可判斷<xref:System.Windows.Input.Key>處於關閉狀態。</span><span class="sxs-lookup"><span data-stu-id="830ae-119">The following example uses the <xref:System.Windows.Input.Keyboard.GetKeyStates%2A> method to determine if a <xref:System.Windows.Input.Key> is in the down state.</span></span>

 [!code-csharp[keyargssnippetsample#KeyEventArgsKeyBoardGetKeyStates](~/samples/snippets/csharp/VS_Snippets_Wpf/KeyArgsSnippetSample/CSharp/Window1.xaml.cs#keyeventargskeyboardgetkeystates)]
 [!code-vb[keyargssnippetsample#KeyEventArgsKeyBoardGetKeyStates](~/samples/snippets/visualbasic/VS_Snippets_Wpf/KeyArgsSnippetSample/visualbasic/window1.xaml.vb#keyeventargskeyboardgetkeystates)]

 <span data-ttu-id="830ae-120">輸入的範例[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]上<xref:System.Windows.Input.Mouse>類別<xref:System.Windows.Input.Mouse.MiddleButton%2A>，取得滑鼠中鍵，狀態和<xref:System.Windows.Input.Mouse.DirectlyOver%2A>，此 cmdlet 會取得之項目的滑鼠指標目前位於上方。</span><span class="sxs-lookup"><span data-stu-id="830ae-120">Examples of input [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] on the <xref:System.Windows.Input.Mouse> class are <xref:System.Windows.Input.Mouse.MiddleButton%2A>, which obtains the state of the middle mouse button, and <xref:System.Windows.Input.Mouse.DirectlyOver%2A>, which gets the element the mouse pointer is currently over.</span></span>

 <span data-ttu-id="830ae-121">下列範例會判斷是否<xref:System.Windows.Input.Mouse.LeftButton%2A>滑鼠位於<xref:System.Windows.Input.MouseButtonState.Pressed>狀態。</span><span class="sxs-lookup"><span data-stu-id="830ae-121">The following example determines whether the <xref:System.Windows.Input.Mouse.LeftButton%2A> on the mouse is in the <xref:System.Windows.Input.MouseButtonState.Pressed> state.</span></span>

 [!code-csharp[mouserelatedsnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/csharp/VS_Snippets_Wpf/MouseRelatedSnippets/CSharp/Window1.xaml.cs#mouserelatedsnippetsgetleftbuttonmouse)]
 [!code-vb[mouserelatedsnippets#MouseRelatedSnippetsGetLeftButtonMouse](~/samples/snippets/visualbasic/VS_Snippets_Wpf/MouseRelatedSnippets/visualbasic/window1.xaml.vb#mouserelatedsnippetsgetleftbuttonmouse)]

 <span data-ttu-id="830ae-122"><xref:System.Windows.Input.Mouse>和<xref:System.Windows.Input.Keyboard>類別所述本概觀的所有詳細資料。</span><span class="sxs-lookup"><span data-stu-id="830ae-122">The <xref:System.Windows.Input.Mouse> and <xref:System.Windows.Input.Keyboard> classes are covered in more detail throughout this overview.</span></span>

### <a name="stylus-input"></a><span data-ttu-id="830ae-123">手寫筆輸入</span><span class="sxs-lookup"><span data-stu-id="830ae-123">Stylus Input</span></span>
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="830ae-124">已經整合的支援<xref:System.Windows.Input.Stylus>。</span><span class="sxs-lookup"><span data-stu-id="830ae-124">has integrated support for the <xref:System.Windows.Input.Stylus>.</span></span>  <span data-ttu-id="830ae-125"><xref:System.Windows.Input.Stylus>是所產生的熱門手寫筆輸入[!INCLUDE[TLA#tla_tpc](../../../../includes/tlasharptla-tpc-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="830ae-125">The <xref:System.Windows.Input.Stylus> is a pen input made popular by the [!INCLUDE[TLA#tla_tpc](../../../../includes/tlasharptla-tpc-md.md)].</span></span>  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="830ae-126">應用程式可以使用滑鼠 [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] 來將手寫筆視為滑鼠，但是 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 也會公開手寫筆裝置抽象概念，其使用的模型類似鍵盤和滑鼠。</span><span class="sxs-lookup"><span data-stu-id="830ae-126">applications can treat the stylus as a mouse by using the mouse [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)], but [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] also exposes a stylus device abstraction that use a model similar to the keyboard and mouse.</span></span>  <span data-ttu-id="830ae-127">所有手寫筆相關的 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] 都會包含 "Stylus" 這個單字。</span><span class="sxs-lookup"><span data-stu-id="830ae-127">All stylus-related [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] contain the word "Stylus".</span></span>

 <span data-ttu-id="830ae-128">因為手寫筆可以當作滑鼠，所以只支援滑鼠輸入的應用程式仍然可以自動取得某種程度的手寫筆支援。</span><span class="sxs-lookup"><span data-stu-id="830ae-128">Because the stylus can act as a mouse, applications that support only mouse input can still obtain some level of stylus support automatically.</span></span> <span data-ttu-id="830ae-129">以這種方式使用手寫筆時，應用程式可以處理適當的手寫筆事件，然後處理對應的滑鼠事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-129">When the stylus is used in such a manner, the application is given the opportunity to handle the appropriate stylus event and then handles the corresponding mouse event.</span></span> <span data-ttu-id="830ae-130">此外，還可以透過手寫筆裝置抽象概念來取得筆跡輸入這類較高階服務。</span><span class="sxs-lookup"><span data-stu-id="830ae-130">In addition, higher-level services such as ink input are also available through the stylus device abstraction.</span></span>  <span data-ttu-id="830ae-131">如需將筆跡作為輸入的詳細資訊，請參閱[筆跡入門](getting-started-with-ink.md)。</span><span class="sxs-lookup"><span data-stu-id="830ae-131">For more information about ink as input, see [Getting Started with Ink](getting-started-with-ink.md).</span></span>

<a name="event_routing"></a>
## <a name="event-routing"></a><span data-ttu-id="830ae-132">事件路由</span><span class="sxs-lookup"><span data-stu-id="830ae-132">Event Routing</span></span>
 <span data-ttu-id="830ae-133">A<xref:System.Windows.FrameworkElement>可以包含其他項目，為其內容模型中形成項目樹狀結構中的子項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-133">A <xref:System.Windows.FrameworkElement> can contain other elements as child elements in its content model, forming a tree of elements.</span></span>  <span data-ttu-id="830ae-134">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，父項目可以透過處理事件，來參與導向至其子項目或其他子系的輸入。</span><span class="sxs-lookup"><span data-stu-id="830ae-134">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], the parent element can participate in input directed to its child elements or other descendants by handing events.</span></span> <span data-ttu-id="830ae-135">這特別適用於透過較小的控制項來建置控制項，即稱為「控制項組合」或「組合」的程序。</span><span class="sxs-lookup"><span data-stu-id="830ae-135">This is especially useful for building controls out of smaller controls, a process known as "control composition" or "compositing."</span></span> <span data-ttu-id="830ae-136">如需項目樹狀結構以及項目樹狀結構與事件路由間之關聯性的詳細資訊，請參閱 [WPF 中的樹狀結構](trees-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="830ae-136">For more information about element trees and how element trees relate to event routes, see [Trees in WPF](trees-in-wpf.md).</span></span>

 <span data-ttu-id="830ae-137">事件路由是將事件轉遞至多個項目的程序，因此，沿著路由的特定物件或項目可以選擇將重大回應提供給不同項目可能設為來源的事件 (透過處理)。</span><span class="sxs-lookup"><span data-stu-id="830ae-137">Event routing is the process of forwarding events to multiple elements, so that a particular object or element along the route can choose to offer a significant response (through handling) to an event that might have been sourced by a different element.</span></span>  <span data-ttu-id="830ae-138">路由事件使用三種路由機制中的其中一種︰直接、事件反昇和通道。</span><span class="sxs-lookup"><span data-stu-id="830ae-138">Routed events use one of three routing mechanisms: direct, bubbling, and tunneling.</span></span>  <span data-ttu-id="830ae-139">在直接路由中，來源項目是唯一收到通知的項目，而且不會將事件路由傳送至任何其他項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-139">In direct routing, the source element is the only element notified, and the event is not routed to any other elements.</span></span> <span data-ttu-id="830ae-140">不過，直接路由事件仍會提供只有路由事件才能使用的一些額外功能，而不是標準 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-140">However, the direct routed event still offers some additional capabilities that are only present for routed events as opposed to standard [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] events.</span></span> <span data-ttu-id="830ae-141">事件反昇處理項目樹狀結構的方式是先通知將事件設為來源的項目，接著通知父項目，依此類推。</span><span class="sxs-lookup"><span data-stu-id="830ae-141">Bubbling works up the element tree by first notifying the element that sourced the event, then the parent element, and so on.</span></span>  <span data-ttu-id="830ae-142">通道會從項目樹狀結構的根項目開始，然後往下進行，並結束於原始來源項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-142">Tunneling starts at the root of the element tree and works down, ending with the original source element.</span></span>  <span data-ttu-id="830ae-143">如需路由事件的詳細資訊，請參閱[路由事件概觀](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="830ae-143">For more information about routed events, see [Routed Events Overview](routed-events-overview.md).</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="830ae-144">輸入事件一般會成對出現，而此配對包含通道事件和事件反昇事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-144">input events generally come in pairs that consists of a tunneling event and a bubbling event.</span></span>  <span data-ttu-id="830ae-145">通道事件與事件反昇事件的區別在於 "Preview" 前置詞。</span><span class="sxs-lookup"><span data-stu-id="830ae-145">Tunneling events are distinguished from bubbling events with the "Preview" prefix.</span></span>  <span data-ttu-id="830ae-146">比方說，<xref:System.Windows.Input.Mouse.PreviewMouseMove>是通道版本的滑鼠移動事件和<xref:System.Windows.Input.Mouse.MouseMove>是此事件的事件反昇版本。</span><span class="sxs-lookup"><span data-stu-id="830ae-146">For instance, <xref:System.Windows.Input.Mouse.PreviewMouseMove> is the tunneling version of a mouse move event and <xref:System.Windows.Input.Mouse.MouseMove> is the bubbling version of this event.</span></span> <span data-ttu-id="830ae-147">事件配對是一項在項目層級實作的慣例，而不是 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 事件系統的一項固有功能。</span><span class="sxs-lookup"><span data-stu-id="830ae-147">This event pairing is a convention that is implemented at the element level and is not an inherent capability of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="830ae-148">如需詳細資訊，請參閱[路由事件概觀](routed-events-overview.md)中的＜WPF 輸入事件＞一節。</span><span class="sxs-lookup"><span data-stu-id="830ae-148">For details, see the WPF Input Events section in [Routed Events Overview](routed-events-overview.md).</span></span>

<a name="handling_input_events"></a>
## <a name="handling-input-events"></a><span data-ttu-id="830ae-149">處理輸入事件</span><span class="sxs-lookup"><span data-stu-id="830ae-149">Handling Input Events</span></span>
 <span data-ttu-id="830ae-150">若要接收項目的輸入，事件處理常式必須與該特定事件建立關聯。</span><span class="sxs-lookup"><span data-stu-id="830ae-150">To receive input on an element, an event handler must be associated with that particular event.</span></span>  <span data-ttu-id="830ae-151">在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 中，這相當簡單︰您可以參考事件名稱作為將接聽此事件之項目的屬性。</span><span class="sxs-lookup"><span data-stu-id="830ae-151">In [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] this is straightforward: you reference the name of the event as an attribute of the element that will be listening for this event.</span></span>  <span data-ttu-id="830ae-152">然後，您可以根據委派，將屬性的值設定為您所定義之事件處理常式的名稱。</span><span class="sxs-lookup"><span data-stu-id="830ae-152">Then, you set the value of the attribute to the name of the event handler that you define, based on a delegate.</span></span>  <span data-ttu-id="830ae-153">事件處理常式必須以 C# 之類的程式碼撰寫，而且可以包含在程式碼後置檔案中。</span><span class="sxs-lookup"><span data-stu-id="830ae-153">The event handler must be written in code such as C# and can be included in a code-behind file.</span></span>

 <span data-ttu-id="830ae-154">作業系統報告在鍵盤焦點位於項目時所發生的按鍵動作時，會發生鍵盤事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-154">Keyboard events occur when the operating system reports key actions that occur while keyboard focus is on an element.</span></span> <span data-ttu-id="830ae-155">滑鼠和手寫筆事件各分為兩個分類︰報告相對於項目之指標位置變更的事件，以及報告裝置按鈕狀態變更的事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-155">Mouse and stylus events each fall into two categories: events that report changes in pointer position relative to the element, and events that report changes in the state of device buttons.</span></span>

### <a name="keyboard-input-event-example"></a><span data-ttu-id="830ae-156">鍵盤輸入事件範例</span><span class="sxs-lookup"><span data-stu-id="830ae-156">Keyboard Input Event Example</span></span>
 <span data-ttu-id="830ae-157">下列範例會接聽按下向左鍵作業。</span><span class="sxs-lookup"><span data-stu-id="830ae-157">The following example listens for a left arrow key press.</span></span>  <span data-ttu-id="830ae-158">A<xref:System.Windows.Controls.StackPanel>會建立具有<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="830ae-158">A <xref:System.Windows.Controls.StackPanel> is created that has a <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="830ae-159">事件處理常式來接聽按下向左鍵會附加至<xref:System.Windows.Controls.Button>執行個體。</span><span class="sxs-lookup"><span data-stu-id="830ae-159">An event handler to listen for the left arrow key press is attached to the <xref:System.Windows.Controls.Button> instance.</span></span>

 <span data-ttu-id="830ae-160">此範例的第一個區段會建立<xref:System.Windows.Controls.StackPanel>而<xref:System.Windows.Controls.Button>，並將附加事件處理常式，如<xref:System.Windows.UIElement.KeyDown>。</span><span class="sxs-lookup"><span data-stu-id="830ae-160">The first section of the example creates the <xref:System.Windows.Controls.StackPanel> and the <xref:System.Windows.Controls.Button> and attaches the event handler for the <xref:System.Windows.UIElement.KeyDown>.</span></span>

 [!code-xaml[InputOvw#Input_OvwKeyboardExampleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#input_ovwkeyboardexamplexaml)]

 [!code-csharp[InputOvw#Input_OvwKeyboardExampleUICodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwkeyboardexampleuicodebehind)]
 [!code-vb[InputOvw#Input_OvwKeyboardExampleUICodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwkeyboardexampleuicodebehind)]

 <span data-ttu-id="830ae-161">第二個區段是使用程式碼所撰寫，並定義事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="830ae-161">The second section is written in code and defines the event handler.</span></span>  <span data-ttu-id="830ae-162">按下向的左鍵時，<xref:System.Windows.Controls.Button>具有鍵盤焦點，執行處理常式和<xref:System.Windows.Controls.Control.Background%2A>色彩<xref:System.Windows.Controls.Button>變更。</span><span class="sxs-lookup"><span data-stu-id="830ae-162">When the left arrow key is pressed and the <xref:System.Windows.Controls.Button> has keyboard focus, the handler runs and the <xref:System.Windows.Controls.Control.Background%2A> color of the <xref:System.Windows.Controls.Button> is changed.</span></span>  <span data-ttu-id="830ae-163">如果按鍵，但它不是向的左鍵<xref:System.Windows.Controls.Control.Background%2A>色彩<xref:System.Windows.Controls.Button>變回其開始色彩。</span><span class="sxs-lookup"><span data-stu-id="830ae-163">If the key is pressed, but it is not the left arrow key, the <xref:System.Windows.Controls.Control.Background%2A> color of the <xref:System.Windows.Controls.Button> is changed back to its starting color.</span></span>

 [!code-csharp[InputOvw#Input_OvwKeyboardExampleHandlerCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwkeyboardexamplehandlercodebehind)]
 [!code-vb[InputOvw#Input_OvwKeyboardExampleHandlerCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwkeyboardexamplehandlercodebehind)]

### <a name="mouse-input-event-example"></a><span data-ttu-id="830ae-164">滑鼠輸入事件範例</span><span class="sxs-lookup"><span data-stu-id="830ae-164">Mouse Input Event Example</span></span>
 <span data-ttu-id="830ae-165">在下列範例中，<xref:System.Windows.Controls.Control.Background%2A>色彩<xref:System.Windows.Controls.Button>已變更時，滑鼠指標進入<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="830ae-165">In the following example, the <xref:System.Windows.Controls.Control.Background%2A> color of a <xref:System.Windows.Controls.Button> is changed when the mouse pointer enters the <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="830ae-166"><xref:System.Windows.Controls.Control.Background%2A>色彩就會在滑鼠離開時還原<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="830ae-166">The <xref:System.Windows.Controls.Control.Background%2A> color is restored when the mouse leaves the <xref:System.Windows.Controls.Button>.</span></span>

 <span data-ttu-id="830ae-167">此範例的第一個區段會建立<xref:System.Windows.Controls.StackPanel>和<xref:System.Windows.Controls.Button>控制，並將附加事件處理常式<xref:System.Windows.UIElement.MouseEnter>並<xref:System.Windows.UIElement.MouseLeave>事件<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="830ae-167">The first section of the example creates the <xref:System.Windows.Controls.StackPanel> and the <xref:System.Windows.Controls.Button> control and attaches the event handlers for the <xref:System.Windows.UIElement.MouseEnter> and <xref:System.Windows.UIElement.MouseLeave> events to the <xref:System.Windows.Controls.Button>.</span></span>

 [!code-xaml[InputOvw#Input_OvwMouseExampleXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#input_ovwmouseexamplexaml)]

 [!code-csharp[InputOvw#Input_OvwMouseExampleUICodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwmouseexampleuicodebehind)]
 [!code-vb[InputOvw#Input_OvwMouseExampleUICodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwmouseexampleuicodebehind)]

 <span data-ttu-id="830ae-168">此範例的第二個區段是使用程式碼所撰寫，並定義事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="830ae-168">The second section of the example is written in code and defines the event handlers.</span></span>  <span data-ttu-id="830ae-169">當滑鼠進入<xref:System.Windows.Controls.Button>，則<xref:System.Windows.Controls.Control.Background%2A>色彩<xref:System.Windows.Controls.Button>變更為<xref:System.Windows.Media.Brushes.SlateGray%2A>。</span><span class="sxs-lookup"><span data-stu-id="830ae-169">When the mouse enters the <xref:System.Windows.Controls.Button>, the <xref:System.Windows.Controls.Control.Background%2A> color of the <xref:System.Windows.Controls.Button> is changed to <xref:System.Windows.Media.Brushes.SlateGray%2A>.</span></span>  <span data-ttu-id="830ae-170">當滑鼠離開<xref:System.Windows.Controls.Button>，則<xref:System.Windows.Controls.Control.Background%2A>色彩<xref:System.Windows.Controls.Button>變回<xref:System.Windows.Media.Brushes.AliceBlue%2A>。</span><span class="sxs-lookup"><span data-stu-id="830ae-170">When the mouse leaves the <xref:System.Windows.Controls.Button>, the <xref:System.Windows.Controls.Control.Background%2A> color of the <xref:System.Windows.Controls.Button> is changed back to <xref:System.Windows.Media.Brushes.AliceBlue%2A>.</span></span>

 [!code-csharp[InputOvw#Input_OvwMouseExampleEneterHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwmouseexampleeneterhandler)]
 [!code-vb[InputOvw#Input_OvwMouseExampleEneterHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwmouseexampleeneterhandler)]

 [!code-csharp[InputOvw#Input_OvwMouseExampleLeaveHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwmouseexampleleavehandler)]
 [!code-vb[InputOvw#Input_OvwMouseExampleLeaveHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwmouseexampleleavehandler)]

<a name="text_input"></a>
## <a name="text-input"></a><span data-ttu-id="830ae-171">文字輸入</span><span class="sxs-lookup"><span data-stu-id="830ae-171">Text Input</span></span>
 <span data-ttu-id="830ae-172"><xref:System.Windows.ContentElement.TextInput>事件可讓您以與裝置無關的方式接聽文字輸入。</span><span class="sxs-lookup"><span data-stu-id="830ae-172">The <xref:System.Windows.ContentElement.TextInput> event enables you to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="830ae-173">鍵盤是文字輸入的主要方法，但是語音、手寫和其他輸入裝置也可以產生文字輸入。</span><span class="sxs-lookup"><span data-stu-id="830ae-173">The keyboard is the primary means of text input, but speech, handwriting, and other input devices can generate text input also.</span></span>

 <span data-ttu-id="830ae-174">針對鍵盤輸入[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]首先會傳送適當<xref:System.Windows.ContentElement.KeyDown> / <xref:System.Windows.ContentElement.KeyUp>事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-174">For keyboard input, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] first sends the appropriate <xref:System.Windows.ContentElement.KeyDown>/<xref:System.Windows.ContentElement.KeyUp> events.</span></span> <span data-ttu-id="830ae-175">如果未處理這些事件，而且按鍵是文字而不是 （例如方向性箭號控制鍵） 或功能鍵，則會顯示<xref:System.Windows.ContentElement.TextInput>就會引發事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-175">If those events are not handled and the key is textual (rather than a control key such as directional arrows or function keys), then a <xref:System.Windows.ContentElement.TextInput> event is raised.</span></span>  <span data-ttu-id="830ae-176">不一定都之間的簡單一對一對應<xref:System.Windows.ContentElement.KeyDown> / <xref:System.Windows.ContentElement.KeyUp>和<xref:System.Windows.ContentElement.TextInput>事件因為多個按鍵輸入可以產生文字輸入單一字元，而單一按鍵輸入可以產生多字元字串。</span><span class="sxs-lookup"><span data-stu-id="830ae-176">There is not always a simple one-to-one mapping between <xref:System.Windows.ContentElement.KeyDown>/<xref:System.Windows.ContentElement.KeyUp> and <xref:System.Windows.ContentElement.TextInput> events because multiple keystrokes can generate a single character of text input and single keystrokes can generate multi-character strings.</span></span>  <span data-ttu-id="830ae-177">這特別適用於中文、日文和韓文這類語言，而這類語言使用 [!INCLUDE[TLA#tla_ime#plural](../../../../includes/tlasharptla-imesharpplural-md.md)] 來產生其對應字母的數千個可能字元。</span><span class="sxs-lookup"><span data-stu-id="830ae-177">This is especially true for languages such as Chinese, Japanese, and Korean which use [!INCLUDE[TLA#tla_ime#plural](../../../../includes/tlasharptla-imesharpplural-md.md)] to generate the thousands of possible characters in their corresponding alphabets.</span></span>

 <span data-ttu-id="830ae-178">當[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]傳送<xref:System.Windows.ContentElement.KeyUp> / <xref:System.Windows.ContentElement.KeyDown>事件，<xref:System.Windows.Input.KeyEventArgs.Key%2A>設為<xref:System.Windows.Input.Key.System?displayProperty=nameWithType>如果按鍵動作可能會變得一部分<xref:System.Windows.ContentElement.TextInput>（ALT + S 按下時，例如） 的事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-178">When [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] sends a <xref:System.Windows.ContentElement.KeyUp>/<xref:System.Windows.ContentElement.KeyDown> event, <xref:System.Windows.Input.KeyEventArgs.Key%2A> is set to <xref:System.Windows.Input.Key.System?displayProperty=nameWithType> if the keystrokes could become part of a <xref:System.Windows.ContentElement.TextInput> event (if ALT+S is pressed, for example).</span></span> <span data-ttu-id="830ae-179">這可讓程式碼中的<xref:System.Windows.ContentElement.KeyDown>若要檢查的事件處理常式<xref:System.Windows.Input.Key.System?displayProperty=nameWithType>而且，如果找到，之後引發的處理常式處理<xref:System.Windows.ContentElement.TextInput>事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-179">This allows code in a <xref:System.Windows.ContentElement.KeyDown> event handler to check for <xref:System.Windows.Input.Key.System?displayProperty=nameWithType> and, if found, leave processing for the handler of the subsequently raised <xref:System.Windows.ContentElement.TextInput> event.</span></span> <span data-ttu-id="830ae-180">在這些情況下的各種屬性<xref:System.Windows.Input.TextCompositionEventArgs>引數可以用來判斷原始按鍵輸入。</span><span class="sxs-lookup"><span data-stu-id="830ae-180">In these cases, the various properties of the <xref:System.Windows.Input.TextCompositionEventArgs> argument can be used to determine the original keystrokes.</span></span> <span data-ttu-id="830ae-181">同樣地，如果[!INCLUDE[TLA2#tla_ime](../../../../includes/tla2sharptla-ime-md.md)]作用中<xref:System.Windows.Input.Key>的值為<xref:System.Windows.Input.Key.ImeProcessed?displayProperty=nameWithType>，和<xref:System.Windows.Input.KeyEventArgs.ImeProcessedKey%2A>提供原始的按鍵輸入。</span><span class="sxs-lookup"><span data-stu-id="830ae-181">Similarly, if an [!INCLUDE[TLA2#tla_ime](../../../../includes/tla2sharptla-ime-md.md)] is active, <xref:System.Windows.Input.Key> has the value of <xref:System.Windows.Input.Key.ImeProcessed?displayProperty=nameWithType>, and <xref:System.Windows.Input.KeyEventArgs.ImeProcessedKey%2A> gives the original keystroke or keystrokes.</span></span>

 <span data-ttu-id="830ae-182">下列範例會定義的處理常式<xref:System.Windows.Controls.Primitives.ButtonBase.Click>事件和處理常式<xref:System.Windows.UIElement.KeyDown>事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-182">The following example defines a handler for the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event and a handler for the <xref:System.Windows.UIElement.KeyDown> event.</span></span>

 <span data-ttu-id="830ae-183">程式碼或標記的第一個區段會建立使用者介面。</span><span class="sxs-lookup"><span data-stu-id="830ae-183">The first segment of code or markup creates the user interface.</span></span>

 [!code-xaml[InputOvw#Input_OvwTextInputXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml#input_ovwtextinputxaml)]

 [!code-csharp[InputOvw#Input_OvwTextInputUICodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwtextinputuicodebehind)]
 [!code-vb[InputOvw#Input_OvwTextInputUICodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwtextinputuicodebehind)]

 <span data-ttu-id="830ae-184">程式碼的第二個區段包含事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="830ae-184">The second segment of code contains the event handlers.</span></span>

 [!code-csharp[InputOvw#Input_OvwTextInputHandlersCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/InputOvw/CSharp/Page1.xaml.cs#input_ovwtextinputhandlerscodebehind)]
 [!code-vb[InputOvw#Input_OvwTextInputHandlersCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/InputOvw/VisualBasic/Page1.xaml.vb#input_ovwtextinputhandlerscodebehind)]

 <span data-ttu-id="830ae-185">輸入的事件反昇事件路由，因為<xref:System.Windows.Controls.StackPanel>接收的輸入不論哪個項目具有鍵盤焦點。</span><span class="sxs-lookup"><span data-stu-id="830ae-185">Because input events bubble up the event route, the <xref:System.Windows.Controls.StackPanel> receives the input regardless of which element has keyboard focus.</span></span> <span data-ttu-id="830ae-186"><xref:System.Windows.Controls.TextBox>先收到通知控制項和`OnTextInputKeyDown`才會呼叫處理常式<xref:System.Windows.Controls.TextBox>沒有處理輸入。</span><span class="sxs-lookup"><span data-stu-id="830ae-186">The <xref:System.Windows.Controls.TextBox> control is notified first and the `OnTextInputKeyDown` handler is called only if the <xref:System.Windows.Controls.TextBox> did not handle the input.</span></span> <span data-ttu-id="830ae-187">如果<xref:System.Windows.UIElement.PreviewKeyDown>而不是使用事件<xref:System.Windows.UIElement.KeyDown>事件，`OnTextInputKeyDown`第一次呼叫處理常式。</span><span class="sxs-lookup"><span data-stu-id="830ae-187">If the <xref:System.Windows.UIElement.PreviewKeyDown> event is used instead of the <xref:System.Windows.UIElement.KeyDown> event, the `OnTextInputKeyDown` handler is called first.</span></span>

 <span data-ttu-id="830ae-188">在此範例中，處理邏輯會撰寫兩次：一次針對 CTRL+O，一次則是針對按鈕的 Click 事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-188">In this example, the handling logic is written two times—one time for CTRL+O, and again for button's click event.</span></span> <span data-ttu-id="830ae-189">這可以使用命令進行簡化，而不是直接處理輸入事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-189">This can be simplified by using commands, instead of handling the input events directly.</span></span>  <span data-ttu-id="830ae-190">這個概觀和[命令概觀](commanding-overview.md)討論命令。</span><span class="sxs-lookup"><span data-stu-id="830ae-190">Commands are discussed in this overview and in [Commanding Overview](commanding-overview.md).</span></span>

<a name="touch_and_manipulation"></a>
## <a name="touch-and-manipulation"></a><span data-ttu-id="830ae-191">觸控和操作</span><span class="sxs-lookup"><span data-stu-id="830ae-191">Touch and Manipulation</span></span>
 <span data-ttu-id="830ae-192">Windows 7 作業系統中的新硬體和 API 讓應用程式可以同時接收來自多個觸控的輸入。</span><span class="sxs-lookup"><span data-stu-id="830ae-192">New hardware and API in the Windows 7 operating system provide applications the ability to receive input from multiple touches simultaneously.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="830ae-193">可讓應用程式在發生觸控時引發事件，以透過回應其他輸入 (例如滑鼠或鍵盤) 的類似方式來偵測和回應觸控。</span><span class="sxs-lookup"><span data-stu-id="830ae-193">enables applications to detect and respond to touch in a manner similar to responding to other input, such as the mouse or keyboard, by raising events when touch occurs.</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="830ae-194">會在觸控發生時公開兩種類型的事件︰觸控事件和操作事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-194">exposes two types of events when touch occurs: touch events and manipulation events.</span></span> <span data-ttu-id="830ae-195">觸控事件提供觸控式螢幕上每根手指的未經處理資料和其移動。</span><span class="sxs-lookup"><span data-stu-id="830ae-195">Touch events provide raw data about each finger on a touchscreen and its movement.</span></span> <span data-ttu-id="830ae-196">操作事件會將輸入解譯成特定動作。</span><span class="sxs-lookup"><span data-stu-id="830ae-196">Manipulation events interpret the input as certain actions.</span></span> <span data-ttu-id="830ae-197">本節討論這兩種類型的事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-197">Both types of events are discussed in this section.</span></span>

### <a name="prerequisites"></a><span data-ttu-id="830ae-198">必要條件</span><span class="sxs-lookup"><span data-stu-id="830ae-198">Prerequisites</span></span>
 <span data-ttu-id="830ae-199">您需要下列元件，才能開發回應觸控的應用程式。</span><span class="sxs-lookup"><span data-stu-id="830ae-199">You need the following components to develop an application that responds to touch.</span></span>

- <span data-ttu-id="830ae-200">Visual Studio 2010。</span><span class="sxs-lookup"><span data-stu-id="830ae-200">Visual Studio 2010.</span></span>

- <span data-ttu-id="830ae-201">Windows 7。</span><span class="sxs-lookup"><span data-stu-id="830ae-201">Windows 7.</span></span>

- <span data-ttu-id="830ae-202">支援 Windows Touch 的觸控式螢幕這類裝置。</span><span class="sxs-lookup"><span data-stu-id="830ae-202">A device, such as a touchscreen, that supports Windows Touch.</span></span>

### <a name="terminology"></a><span data-ttu-id="830ae-203">用語</span><span class="sxs-lookup"><span data-stu-id="830ae-203">Terminology</span></span>
 <span data-ttu-id="830ae-204">討論觸控時，會使用下列詞彙。</span><span class="sxs-lookup"><span data-stu-id="830ae-204">The following terms are used when touch is discussed.</span></span>

- <span data-ttu-id="830ae-205">**觸控**是 Windows 7 可辨識的一種使用者輸入類型。</span><span class="sxs-lookup"><span data-stu-id="830ae-205">**Touch** is a type of user input that is recognized by Windows 7.</span></span> <span data-ttu-id="830ae-206">通常，將手指放在觸控式螢幕上，就會起始觸控。</span><span class="sxs-lookup"><span data-stu-id="830ae-206">Usually, touch is initiated by putting fingers on a touch-sensitive screen.</span></span> <span data-ttu-id="830ae-207">請注意，如果裝置只會將手指的位置和移動轉換為滑鼠輸入，則膝上型電腦上常見的觸控板這類裝置不支援觸控。</span><span class="sxs-lookup"><span data-stu-id="830ae-207">Note that devices such as a touchpad that is common on laptop computers do not support touch if the device merely converts the finger's position and movement as mouse input.</span></span>

- <span data-ttu-id="830ae-208">**多點觸控**是同時從多點發生的觸控。</span><span class="sxs-lookup"><span data-stu-id="830ae-208">**Multitouch** is touch that occurs from more than one point simultaneously.</span></span> <span data-ttu-id="830ae-209">Windows 7 和 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 支援多點觸控。</span><span class="sxs-lookup"><span data-stu-id="830ae-209">Windows 7 and [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] supports multitouch.</span></span> <span data-ttu-id="830ae-210">只要 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 文件討論觸控，這些概念就適用於多點觸控。</span><span class="sxs-lookup"><span data-stu-id="830ae-210">Whenever touch is discussed in the documentation for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], the concepts apply to multitouch.</span></span>

- <span data-ttu-id="830ae-211">將觸控解譯為套用至物件的實體動作時，會發生**操作**。</span><span class="sxs-lookup"><span data-stu-id="830ae-211">A **manipulation** occurs when touch is interpreted as a physical action that is applied to an object.</span></span> <span data-ttu-id="830ae-212">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，操作事件會將輸入解譯為平移、擴充或旋轉操作。</span><span class="sxs-lookup"><span data-stu-id="830ae-212">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], manipulation events interpret input as a translation, expansion, or rotation manipulation.</span></span>

- <span data-ttu-id="830ae-213">`touch device` 所代表的裝置會產生觸控式螢幕上的一根手指這類觸控輸入。</span><span class="sxs-lookup"><span data-stu-id="830ae-213">A `touch device` represents a device that produces touch input, such as a single finger on a touchscreen.</span></span>

### <a name="controls-that-respond-to-touch"></a><span data-ttu-id="830ae-214">回應觸控的控制項</span><span class="sxs-lookup"><span data-stu-id="830ae-214">Controls that Respond to Touch</span></span>
 <span data-ttu-id="830ae-215">如果控制項具有可捲動到檢視外部的內容，則將手指拖曳過該控制項即可捲動下列控制項。</span><span class="sxs-lookup"><span data-stu-id="830ae-215">The following controls can be scrolled by dragging a finger across the control if it has content that is scrolled out of view.</span></span>

- <xref:System.Windows.Controls.ComboBox>

- <xref:System.Windows.Controls.ContextMenu>

- <xref:System.Windows.Controls.DataGrid>

- <xref:System.Windows.Controls.ListBox>

- <xref:System.Windows.Controls.ListView>

- <xref:System.Windows.Controls.MenuItem>

- <xref:System.Windows.Controls.TextBox>

- <xref:System.Windows.Controls.ToolBar>

- <xref:System.Windows.Controls.TreeView>

 <span data-ttu-id="830ae-216"><xref:System.Windows.Controls.ScrollViewer>定義<xref:System.Windows.Controls.ScrollViewer.PanningMode%2A?displayProperty=nameWithType>附加屬性，可讓您指定的觸控式移動瀏覽是否已啟用的水平、 垂直、 兩者皆非。</span><span class="sxs-lookup"><span data-stu-id="830ae-216">The <xref:System.Windows.Controls.ScrollViewer> defines the <xref:System.Windows.Controls.ScrollViewer.PanningMode%2A?displayProperty=nameWithType> attached property that enables you to specify whether touch panning is enabled horizontally, vertically, both, or neither.</span></span> <span data-ttu-id="830ae-217"><xref:System.Windows.Controls.ScrollViewer.PanningDeceleration%2A?displayProperty=nameWithType>屬性會指定如何快速捲動變慢時使用者將移開觸控螢幕手指。</span><span class="sxs-lookup"><span data-stu-id="830ae-217">The <xref:System.Windows.Controls.ScrollViewer.PanningDeceleration%2A?displayProperty=nameWithType> property specifies how quickly the scrolling slows down when the user lifts the finger from the touchscreen.</span></span> <span data-ttu-id="830ae-218"><xref:System.Windows.Controls.ScrollViewer.PanningRatio%2A?displayProperty=nameWithType>附加的屬性指定捲動位移對轉譯操作位移的比例。</span><span class="sxs-lookup"><span data-stu-id="830ae-218">The <xref:System.Windows.Controls.ScrollViewer.PanningRatio%2A?displayProperty=nameWithType> attached property specifies the ratio of scrolling offset to translate manipulation offset.</span></span>

### <a name="touch-events"></a><span data-ttu-id="830ae-219">觸控事件</span><span class="sxs-lookup"><span data-stu-id="830ae-219">Touch Events</span></span>
 <span data-ttu-id="830ae-220">基底類別中， <xref:System.Windows.UIElement>， <xref:System.Windows.UIElement3D>，和<xref:System.Windows.ContentElement>，定義您可以訂閱讓您的應用程式回應觸控的事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-220">The base classes, <xref:System.Windows.UIElement>, <xref:System.Windows.UIElement3D>, and <xref:System.Windows.ContentElement>, define events that you can subscribe to so your application will respond to touch.</span></span> <span data-ttu-id="830ae-221">您的應用程式將觸控解譯為非操作物件的動作時，觸控事件十分有用。</span><span class="sxs-lookup"><span data-stu-id="830ae-221">Touch events are useful when your application interprets touch as something other than manipulating an object.</span></span> <span data-ttu-id="830ae-222">例如，可讓使用者使用一或多根手指繪製的應用程式訂閱觸控事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-222">For example, an application that enables a user to draw with one or more fingers would subscribe to touch events.</span></span>

 <span data-ttu-id="830ae-223">不論定義類別為何，所有這三個類別都會定義下列行為類似的事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-223">All three classes define the following events, which behave similarly, regardless of the defining class.</span></span>

- <xref:System.Windows.UIElement.TouchDown>

- <xref:System.Windows.UIElement.TouchMove>

- <xref:System.Windows.UIElement.TouchUp>

- <xref:System.Windows.UIElement.TouchEnter>

- <xref:System.Windows.UIElement.TouchLeave>

- <xref:System.Windows.UIElement.PreviewTouchDown>

- <xref:System.Windows.UIElement.PreviewTouchMove>

- <xref:System.Windows.UIElement.PreviewTouchUp>

- <xref:System.Windows.UIElement.GotTouchCapture>

- <xref:System.Windows.UIElement.LostTouchCapture>

 <span data-ttu-id="830ae-224">與鍵盤和滑鼠事件類似，觸控事件都是路由事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-224">Like keyboard and mouse events, the touch events are routed events.</span></span> <span data-ttu-id="830ae-225">開頭為 `Preview` 的事件是通道事件，而開頭為 `Touch` 的事件是事件反昇事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-225">The events that begin with `Preview` are tunneling events and the events that begin with `Touch` are bubbling events.</span></span> <span data-ttu-id="830ae-226">如需路由事件的詳細資訊，請參閱[路由事件概觀](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="830ae-226">For more information about routed events, see [Routed Events Overview](routed-events-overview.md).</span></span> <span data-ttu-id="830ae-227">當您處理這些事件時，您可以取得位置的輸入，相對於任何項目，藉由呼叫<xref:System.Windows.Input.TouchEventArgs.GetTouchPoint%2A>或<xref:System.Windows.Input.TouchEventArgs.GetIntermediateTouchPoints%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="830ae-227">When you handle these events, you can get the position of the input, relative to any element, by calling the <xref:System.Windows.Input.TouchEventArgs.GetTouchPoint%2A> or <xref:System.Windows.Input.TouchEventArgs.GetIntermediateTouchPoints%2A> method.</span></span>

 <span data-ttu-id="830ae-228">若要了解觸控事件之間的互動，請考慮在使用者將一根手指放在項目上，並將手指移至項目中，然後將手指移開項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-228">To understand the interaction among the touch events, consider the scenario where a user puts one finger on an element, moves the finger in the element, and then lifts the finger from the element.</span></span> <span data-ttu-id="830ae-229">下圖顯示事件反昇事件的執行 (為求簡化，會省略通道事件)。</span><span class="sxs-lookup"><span data-stu-id="830ae-229">The following illustration shows the execution of the bubbling events (the tunneling events are omitted for simplicity).</span></span>

 <span data-ttu-id="830ae-230">![觸控事件的順序。](./media/ndp-touchevents.png "NDP_TouchEvents")觸控事件</span><span class="sxs-lookup"><span data-stu-id="830ae-230">![The sequence of touch events.](./media/ndp-touchevents.png "NDP_TouchEvents") Touch events</span></span>

 <span data-ttu-id="830ae-231">下列清單描述上圖中的事件順序。</span><span class="sxs-lookup"><span data-stu-id="830ae-231">The following list describes the sequence of the events in the preceding illustration.</span></span>

1. <span data-ttu-id="830ae-232"><xref:System.Windows.UIElement.TouchEnter>事件，就會發生一次，當使用者將手指放在項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-232">The <xref:System.Windows.UIElement.TouchEnter> event occurs one time when the user puts a finger on the element.</span></span>

2. <span data-ttu-id="830ae-233"><xref:System.Windows.UIElement.TouchDown>事件會發生一次。</span><span class="sxs-lookup"><span data-stu-id="830ae-233">The <xref:System.Windows.UIElement.TouchDown> event occurs one time.</span></span>

3. <span data-ttu-id="830ae-234"><xref:System.Windows.UIElement.TouchMove>事件會發生多次，當使用者移動手指在項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-234">The <xref:System.Windows.UIElement.TouchMove> event occurs multiple times as the user moves the finger within the element.</span></span>

4. <span data-ttu-id="830ae-235"><xref:System.Windows.UIElement.TouchUp>事件，就會發生一次，當使用者將手指從項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-235">The <xref:System.Windows.UIElement.TouchUp> event occurs one time when the user lifts the finger from the element.</span></span>

5. <span data-ttu-id="830ae-236"><xref:System.Windows.UIElement.TouchLeave>事件會發生一次。</span><span class="sxs-lookup"><span data-stu-id="830ae-236">The <xref:System.Windows.UIElement.TouchLeave> event occurs one time.</span></span>

 <span data-ttu-id="830ae-237">使用兩根以上的手指時，每根手指都會發生這些事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-237">When more than two fingers are used, the events occur for each finger.</span></span>

### <a name="manipulation-events"></a><span data-ttu-id="830ae-238">操作事件</span><span class="sxs-lookup"><span data-stu-id="830ae-238">Manipulation Events</span></span>
 <span data-ttu-id="830ae-239">應用程式可讓使用者操作物件，其中的情況下<xref:System.Windows.UIElement>類別會定義操作事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-239">For cases where an application enables a user to manipulate an object, the <xref:System.Windows.UIElement> class defines manipulation events.</span></span> <span data-ttu-id="830ae-240">與只會報告觸控位置的觸控事件不同，操作事件會報告輸入解譯方式。</span><span class="sxs-lookup"><span data-stu-id="830ae-240">Unlike the touch events that simply report the position of touch, the manipulation events report how the input can be interpreted.</span></span> <span data-ttu-id="830ae-241">操作有三種類型：平移、擴充和旋轉。</span><span class="sxs-lookup"><span data-stu-id="830ae-241">There are three types of manipulations, translation, expansion, and rotation.</span></span> <span data-ttu-id="830ae-242">下列清單描述如何叫用這三種類型的操作。</span><span class="sxs-lookup"><span data-stu-id="830ae-242">The following list describes how to invoke the three types of manipulations.</span></span>

- <span data-ttu-id="830ae-243">將手指放在物件上，然後將手指移過觸控式螢幕，以叫用轉譯操作。</span><span class="sxs-lookup"><span data-stu-id="830ae-243">Put a finger on an object and move the finger across the touchscreen to invoke a translation manipulation.</span></span> <span data-ttu-id="830ae-244">這通常會移動物件。</span><span class="sxs-lookup"><span data-stu-id="830ae-244">This usually moves the object.</span></span>

- <span data-ttu-id="830ae-245">將兩根手指放在物件上，然後拉近兩根手指或分開兩根手指，以叫用擴充操作。</span><span class="sxs-lookup"><span data-stu-id="830ae-245">Put two fingers on an object and move the fingers closer together or farther apart from one another to invoke an expansion manipulation.</span></span> <span data-ttu-id="830ae-246">這通常會調整物件大小。</span><span class="sxs-lookup"><span data-stu-id="830ae-246">This usually resizes the object.</span></span>

- <span data-ttu-id="830ae-247">將兩根手指放在物件上，然後旋轉這兩根手指，以叫用旋轉操作。</span><span class="sxs-lookup"><span data-stu-id="830ae-247">Put two fingers on an object and rotate the fingers around each other to invoke a rotation manipulation.</span></span> <span data-ttu-id="830ae-248">這通常會旋轉物件。</span><span class="sxs-lookup"><span data-stu-id="830ae-248">This usually rotates the object.</span></span>

 <span data-ttu-id="830ae-249">可以同時進行多種類型的操作。</span><span class="sxs-lookup"><span data-stu-id="830ae-249">More than one type of manipulation can occur simultaneously.</span></span>

 <span data-ttu-id="830ae-250">當您讓物件回應操作時，可以讓物件看起來像有慣性。</span><span class="sxs-lookup"><span data-stu-id="830ae-250">When you cause objects to respond to manipulations, you can have the object appear to have inertia.</span></span> <span data-ttu-id="830ae-251">這可讓您的物件模擬真實世界。</span><span class="sxs-lookup"><span data-stu-id="830ae-251">This can make your objects simulate the physical world.</span></span> <span data-ttu-id="830ae-252">例如，當您在桌上推動書本時，如果推得夠用力，則在放開書本之後，書本還會繼續移動。</span><span class="sxs-lookup"><span data-stu-id="830ae-252">For example, when you push a book across a table, if you push hard enough the book will continue to move after you release it.</span></span> [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="830ae-253">可讓您透過在使用者的手指放開物件之後引發操作事件，來模擬此行為。</span><span class="sxs-lookup"><span data-stu-id="830ae-253">enables you to simulate this behavior by raising manipulation events after the user's fingers releases the object.</span></span>

 <span data-ttu-id="830ae-254">如需有關如何建立應用程式，可讓使用者移動、 調整大小，以及旋轉物件的資訊，請參閱[逐步解說：建立您的第一個觸控應用程式](walkthrough-creating-your-first-touch-application.md)。</span><span class="sxs-lookup"><span data-stu-id="830ae-254">For information about how to create an application that enables the user to move, resize, and rotate an object, see [Walkthrough: Creating Your First Touch Application](walkthrough-creating-your-first-touch-application.md).</span></span>

 <span data-ttu-id="830ae-255"><xref:System.Windows.UIElement>定義下列操作事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-255">The <xref:System.Windows.UIElement> defines the following manipulation events.</span></span>

- <xref:System.Windows.UIElement.ManipulationStarting>

- <xref:System.Windows.UIElement.ManipulationStarted>

- <xref:System.Windows.UIElement.ManipulationDelta>

- <xref:System.Windows.UIElement.ManipulationInertiaStarting>

- <xref:System.Windows.UIElement.ManipulationCompleted>

- <xref:System.Windows.UIElement.ManipulationBoundaryFeedback>

 <span data-ttu-id="830ae-256">根據預設，<xref:System.Windows.UIElement>不會收到這些操作事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-256">By default, a <xref:System.Windows.UIElement> does not receive these manipulation events.</span></span> <span data-ttu-id="830ae-257">操作事件，即可<xref:System.Windows.UIElement>，將<xref:System.Windows.UIElement.IsManipulationEnabled%2A?displayProperty=nameWithType>至`true`。</span><span class="sxs-lookup"><span data-stu-id="830ae-257">To receive manipulation events on a <xref:System.Windows.UIElement>, set <xref:System.Windows.UIElement.IsManipulationEnabled%2A?displayProperty=nameWithType> to `true`.</span></span>

#### <a name="the-execution-path-of-manipulation-events"></a><span data-ttu-id="830ae-258">操作事件的執行路徑</span><span class="sxs-lookup"><span data-stu-id="830ae-258">The Execution Path of Manipulation Events</span></span>
 <span data-ttu-id="830ae-259">請考慮使用者「擲回」物件的情況。</span><span class="sxs-lookup"><span data-stu-id="830ae-259">Consider a scenario where a user "throws" an object.</span></span> <span data-ttu-id="830ae-260">使用者將手指放在物件上，並將手指移過觸控式螢幕的一小段距離，然後在移動時移開手指。</span><span class="sxs-lookup"><span data-stu-id="830ae-260">The user puts a finger on the object, moves the finger across the touchscreen for a short distance, and then lifts the finger while it is moving.</span></span> <span data-ttu-id="830ae-261">這樣的結果是會移動使用者手指下方的物件，並在使用者移開手指之後繼續移動。</span><span class="sxs-lookup"><span data-stu-id="830ae-261">The result of this is that the object will move under the user's finger and continue to move after the user lifts the finger.</span></span>

 <span data-ttu-id="830ae-262">下圖顯示操作事件的執行路徑以及每個事件的重要資訊。</span><span class="sxs-lookup"><span data-stu-id="830ae-262">The following illustration shows the execution path of manipulation events and important information about each event.</span></span>

 <span data-ttu-id="830ae-263">![操作事件的順序。](./media/ndp-manipulationevents.png "NDP_ManipulationEvents")操作事件</span><span class="sxs-lookup"><span data-stu-id="830ae-263">![The sequence of manipulation events.](./media/ndp-manipulationevents.png "NDP_ManipulationEvents") Manipulation events</span></span>

 <span data-ttu-id="830ae-264">下列清單描述上圖中的事件順序。</span><span class="sxs-lookup"><span data-stu-id="830ae-264">The following list describes the sequence of the events in the preceding illustration.</span></span>

1. <span data-ttu-id="830ae-265"><xref:System.Windows.UIElement.ManipulationStarting>事件發生於使用者將手指放在物件上。</span><span class="sxs-lookup"><span data-stu-id="830ae-265">The <xref:System.Windows.UIElement.ManipulationStarting> event occurs when the user places a finger on the object.</span></span> <span data-ttu-id="830ae-266">除此之外，此事件可讓您設定<xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>屬性。</span><span class="sxs-lookup"><span data-stu-id="830ae-266">Among other things, this event allows you to set the <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A> property.</span></span> <span data-ttu-id="830ae-267">在後續事件中，操作位置會相對於<xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>。</span><span class="sxs-lookup"><span data-stu-id="830ae-267">In the subsequent events, the position of the manipulation will be relative to the <xref:System.Windows.Input.ManipulationStartingEventArgs.ManipulationContainer%2A>.</span></span> <span data-ttu-id="830ae-268">在事件以外<xref:System.Windows.UIElement.ManipulationStarting>，這個屬性是唯讀的因此<xref:System.Windows.UIElement.ManipulationStarting>事件是唯一的時候，您可以設定此屬性。</span><span class="sxs-lookup"><span data-stu-id="830ae-268">In events other than <xref:System.Windows.UIElement.ManipulationStarting>, this property is read-only, so the <xref:System.Windows.UIElement.ManipulationStarting> event is the only time that you can set this property.</span></span>

2. <span data-ttu-id="830ae-269"><xref:System.Windows.UIElement.ManipulationStarted>接下來發生的事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-269">The <xref:System.Windows.UIElement.ManipulationStarted> event occurs next.</span></span> <span data-ttu-id="830ae-270">此事件會報告操作的原點。</span><span class="sxs-lookup"><span data-stu-id="830ae-270">This event reports the origin of the manipulation.</span></span>

3. <span data-ttu-id="830ae-271"><xref:System.Windows.UIElement.ManipulationDelta>事件會發生多次使用者手指移過觸控式螢幕上。</span><span class="sxs-lookup"><span data-stu-id="830ae-271">The <xref:System.Windows.UIElement.ManipulationDelta> event occurs multiple times as a user's fingers move on a touchscreen.</span></span> <span data-ttu-id="830ae-272"><xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A>屬性<xref:System.Windows.Input.ManipulationDeltaEventArgs>類別會報告操作是否會解譯為移動、 擴充還是平移。</span><span class="sxs-lookup"><span data-stu-id="830ae-272">The <xref:System.Windows.Input.ManipulationDeltaEventArgs.DeltaManipulation%2A> property of the <xref:System.Windows.Input.ManipulationDeltaEventArgs> class reports whether the manipulation is interpreted as movement, expansion, or translation.</span></span> <span data-ttu-id="830ae-273">這是您執行大部分物件操作工作的位置。</span><span class="sxs-lookup"><span data-stu-id="830ae-273">This is where you perform most of the work of manipulating an object.</span></span>

4. <span data-ttu-id="830ae-274"><xref:System.Windows.UIElement.ManipulationInertiaStarting>使用者手指遺失接觸物件時，就會發生事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-274">The <xref:System.Windows.UIElement.ManipulationInertiaStarting> event occurs when the user's fingers lose contact with the object.</span></span> <span data-ttu-id="830ae-275">此事件可讓您指定慣性期間的操作減速。</span><span class="sxs-lookup"><span data-stu-id="830ae-275">This event enables you to specify the deceleration of the manipulations during inertia.</span></span> <span data-ttu-id="830ae-276">因此，如果選擇的話，您的物件可以模擬不同的實體空間或屬性。</span><span class="sxs-lookup"><span data-stu-id="830ae-276">This is so your object can emulate different physical spaces or attributes if you choose.</span></span> <span data-ttu-id="830ae-277">例如，假設應用程式有兩個物件代表真實世界中的項目，而且其中一個比另一個重。</span><span class="sxs-lookup"><span data-stu-id="830ae-277">For example, suppose your application has two objects that represent items in the physical world, and one is heavier than the other.</span></span> <span data-ttu-id="830ae-278">您可以將較重的物件減速，使其比較輕的物件更快。</span><span class="sxs-lookup"><span data-stu-id="830ae-278">You can make the heavier object decelerate faster than the lighter object.</span></span>

5. <span data-ttu-id="830ae-279"><xref:System.Windows.UIElement.ManipulationDelta>事件在慣性發生時，就會發生多次。</span><span class="sxs-lookup"><span data-stu-id="830ae-279">The <xref:System.Windows.UIElement.ManipulationDelta> event occurs multiple times as inertia occurs.</span></span> <span data-ttu-id="830ae-280">請注意，使用者手指移過觸控式螢幕時，以及 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 模擬慣性時，都會發生此事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-280">Note that this event occurs when the user's fingers move across the touchscreen and when [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] simulates inertia.</span></span> <span data-ttu-id="830ae-281">亦即<xref:System.Windows.UIElement.ManipulationDelta>之前和之後，就會發生<xref:System.Windows.UIElement.ManipulationInertiaStarting>事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-281">In other words, <xref:System.Windows.UIElement.ManipulationDelta> occurs before and after the <xref:System.Windows.UIElement.ManipulationInertiaStarting> event.</span></span> <span data-ttu-id="830ae-282"><xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A?displayProperty=nameWithType>屬性的報表是否<xref:System.Windows.UIElement.ManipulationDelta>事件發生期間慣性，因此您可以檢查該屬性，以及執行不同的動作，其值而定。</span><span class="sxs-lookup"><span data-stu-id="830ae-282">The <xref:System.Windows.Input.ManipulationDeltaEventArgs.IsInertial%2A?displayProperty=nameWithType> property reports whether the <xref:System.Windows.UIElement.ManipulationDelta> event occurs during inertia, so you can check that property and perform different actions, depending on its value.</span></span>

6. <span data-ttu-id="830ae-283"><xref:System.Windows.UIElement.ManipulationCompleted>就會發生事件的操作和任何慣性結束時。</span><span class="sxs-lookup"><span data-stu-id="830ae-283">The <xref:System.Windows.UIElement.ManipulationCompleted> event occurs when the manipulation and any inertia ends.</span></span> <span data-ttu-id="830ae-284">也就是說，畢竟<xref:System.Windows.UIElement.ManipulationDelta>事件發生，<xref:System.Windows.UIElement.ManipulationCompleted>來表示已完成的操作就會發生事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-284">That is, after all the <xref:System.Windows.UIElement.ManipulationDelta> events occur, the <xref:System.Windows.UIElement.ManipulationCompleted> event occurs to signal that the manipulation is complete.</span></span>

 <span data-ttu-id="830ae-285"><xref:System.Windows.UIElement>也會定義<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-285">The <xref:System.Windows.UIElement> also defines the <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> event.</span></span> <span data-ttu-id="830ae-286">這個事件發生時<xref:System.Windows.Input.ManipulationDeltaEventArgs.ReportBoundaryFeedback%2A>方法呼叫<xref:System.Windows.UIElement.ManipulationDelta>事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-286">This event occurs when the <xref:System.Windows.Input.ManipulationDeltaEventArgs.ReportBoundaryFeedback%2A> method is called in the <xref:System.Windows.UIElement.ManipulationDelta> event.</span></span> <span data-ttu-id="830ae-287"><xref:System.Windows.UIElement.ManipulationBoundaryFeedback>事件可讓應用程式或元件在物件到達界限時提供視覺化回饋。</span><span class="sxs-lookup"><span data-stu-id="830ae-287">The <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> event enables applications or components to provide visual feedback when an object hits a boundary.</span></span> <span data-ttu-id="830ae-288">例如，<xref:System.Windows.Window>類別控制代碼<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>事件，讓視窗在遇到其邊緣時稍微移動。</span><span class="sxs-lookup"><span data-stu-id="830ae-288">For example, the <xref:System.Windows.Window> class handles the <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> event to cause the window to slightly move when its edge is encountered.</span></span>

 <span data-ttu-id="830ae-289">您可以藉由呼叫取消操作<xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A>以外的任何操作事件中的事件引數的方法<xref:System.Windows.UIElement.ManipulationBoundaryFeedback>事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-289">You can cancel the manipulation by calling the <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A> method on the event arguments in any manipulation event except <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> event.</span></span> <span data-ttu-id="830ae-290">當您呼叫<xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A>不會再引發操作事件，會發生觸控的滑鼠事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-290">When you call <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A>, the manipulation events are no longer raised and mouse events occur for touch.</span></span> <span data-ttu-id="830ae-291">下表描述操作取消時間與所發生的滑鼠事件之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="830ae-291">The following table describes the relationship between the time the manipulation is canceled and the mouse events that occur.</span></span>

|<span data-ttu-id="830ae-292">其中呼叫 Cancel 的事件</span><span class="sxs-lookup"><span data-stu-id="830ae-292">The event that Cancel is called in</span></span>|<span data-ttu-id="830ae-293">針對已發生之輸入所發生的滑鼠事件</span><span class="sxs-lookup"><span data-stu-id="830ae-293">The mouse events that occur for input that already occurred</span></span>|
|----------------------------------------|-----------------------------------------------------------------|
|<span data-ttu-id="830ae-294"><xref:System.Windows.UIElement.ManipulationStarting> 和 <xref:System.Windows.UIElement.ManipulationStarted></span><span class="sxs-lookup"><span data-stu-id="830ae-294"><xref:System.Windows.UIElement.ManipulationStarting> and <xref:System.Windows.UIElement.ManipulationStarted></span></span>|<span data-ttu-id="830ae-295">滑鼠向下事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-295">Mouse down events.</span></span>|
|<xref:System.Windows.UIElement.ManipulationDelta>|<span data-ttu-id="830ae-296">滑鼠向下和滑鼠移動事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-296">Mouse down and mouse move events.</span></span>|
|<span data-ttu-id="830ae-297"><xref:System.Windows.UIElement.ManipulationInertiaStarting> 和 <xref:System.Windows.UIElement.ManipulationCompleted></span><span class="sxs-lookup"><span data-stu-id="830ae-297"><xref:System.Windows.UIElement.ManipulationInertiaStarting> and <xref:System.Windows.UIElement.ManipulationCompleted></span></span>|<span data-ttu-id="830ae-298">滑鼠向下、滑鼠移動和滑鼠向上事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-298">Mouse down, mouse move, and mouse up events.</span></span>|

 <span data-ttu-id="830ae-299">請注意，如果您呼叫<xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A>時的操作處於慣性時，此方法會傳回`false`和輸入不會引發滑鼠事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-299">Note that if you call <xref:System.Windows.Input.ManipulationStartingEventArgs.Cancel%2A> when the manipulation is in inertia, the method returns `false` and the input does not raise mouse events.</span></span>

### <a name="the-relationship-between-touch-and-manipulation-events"></a><span data-ttu-id="830ae-300">觸控與操作事件之間的關聯性</span><span class="sxs-lookup"><span data-stu-id="830ae-300">The Relationship Between Touch and Manipulation Events</span></span>
 <span data-ttu-id="830ae-301">A<xref:System.Windows.UIElement>一律可以收到觸控事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-301">A <xref:System.Windows.UIElement> can always receive touch events.</span></span> <span data-ttu-id="830ae-302">當<xref:System.Windows.UIElement.IsManipulationEnabled%2A>屬性設定為`true`、<xref:System.Windows.UIElement>可以接收觸控和操作事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-302">When the <xref:System.Windows.UIElement.IsManipulationEnabled%2A> property is set to `true`, a <xref:System.Windows.UIElement> can receive both touch and manipulation events.</span></span>  <span data-ttu-id="830ae-303">如果<xref:System.Windows.UIElement.TouchDown>未處理事件 (亦即<xref:System.Windows.RoutedEventArgs.Handled%2A>屬性是`false`)，操作邏輯會擷取項目的觸控，並產生操作事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-303">If the <xref:System.Windows.UIElement.TouchDown> event is not handled (that is, the <xref:System.Windows.RoutedEventArgs.Handled%2A> property is `false`), the manipulation logic captures the touch to the element and generates the manipulation events.</span></span> <span data-ttu-id="830ae-304">如果<xref:System.Windows.RoutedEventArgs.Handled%2A>屬性設定為`true`在<xref:System.Windows.UIElement.TouchDown>事件，操作邏輯不會產生操作事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-304">If the <xref:System.Windows.RoutedEventArgs.Handled%2A> property is set to `true` in the <xref:System.Windows.UIElement.TouchDown> event, the manipulation logic does not generate manipulation events.</span></span> <span data-ttu-id="830ae-305">下圖示範觸控事件與操作事件之間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="830ae-305">The following illustration shows the relationship between touch events and manipulation events.</span></span>

 <span data-ttu-id="830ae-306">![觸控與操作事件之間的關聯性](./media/ndp-touchmanipulateevents.png "NDP_TouchManipulateEvents")觸控與操作事件</span><span class="sxs-lookup"><span data-stu-id="830ae-306">![Relationship between touch and manipulation events](./media/ndp-touchmanipulateevents.png "NDP_TouchManipulateEvents") Touch and manipulation events</span></span>

 <span data-ttu-id="830ae-307">下列清單描述上圖中所顯示之觸控事件與操作事件間的關聯性。</span><span class="sxs-lookup"><span data-stu-id="830ae-307">The following list describes the relationship between the touch and manipulation events that is shown in the preceding illustration.</span></span>

- <span data-ttu-id="830ae-308">當第一個觸控裝置會產生<xref:System.Windows.UIElement.TouchDown>上的事件<xref:System.Windows.UIElement>，操作邏輯呼叫<xref:System.Windows.UIElement.CaptureTouch%2A>方法，以產生<xref:System.Windows.UIElement.GotTouchCapture>事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-308">When the first touch device generates a <xref:System.Windows.UIElement.TouchDown> event on a <xref:System.Windows.UIElement>, the manipulation logic calls the <xref:System.Windows.UIElement.CaptureTouch%2A> method, which generates the <xref:System.Windows.UIElement.GotTouchCapture> event.</span></span>

- <span data-ttu-id="830ae-309">當<xref:System.Windows.UIElement.GotTouchCapture>發生時，操作邏輯呼叫<xref:System.Windows.Input.Manipulation.AddManipulator%2A?displayProperty=nameWithType>方法，以產生<xref:System.Windows.UIElement.ManipulationStarting>事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-309">When the <xref:System.Windows.UIElement.GotTouchCapture> occurs, the manipulation logic calls the <xref:System.Windows.Input.Manipulation.AddManipulator%2A?displayProperty=nameWithType> method, which generates the <xref:System.Windows.UIElement.ManipulationStarting> event.</span></span>

- <span data-ttu-id="830ae-310">當<xref:System.Windows.UIElement.TouchMove>事件發生時，操作邏輯會產生<xref:System.Windows.UIElement.ManipulationDelta>之前發生的事件<xref:System.Windows.UIElement.ManipulationInertiaStarting>事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-310">When the <xref:System.Windows.UIElement.TouchMove> events occur, the manipulation logic generates the <xref:System.Windows.UIElement.ManipulationDelta> events that occur before the <xref:System.Windows.UIElement.ManipulationInertiaStarting> event.</span></span>

- <span data-ttu-id="830ae-311">當最後一個觸控裝置的項目就會引發<xref:System.Windows.UIElement.TouchUp>事件，操作邏輯會產生<xref:System.Windows.UIElement.ManipulationInertiaStarting>事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-311">When the last touch device on the element raises the <xref:System.Windows.UIElement.TouchUp> event, the manipulation logic generates the <xref:System.Windows.UIElement.ManipulationInertiaStarting> event.</span></span>

<a name="focus"></a>
## <a name="focus"></a><span data-ttu-id="830ae-312">焦點</span><span class="sxs-lookup"><span data-stu-id="830ae-312">Focus</span></span>
 <span data-ttu-id="830ae-313">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中有兩個關於焦點的主要概念︰鍵盤焦點和邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="830ae-313">There are two main concepts that pertain to focus in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]: keyboard focus and logical focus.</span></span>

### <a name="keyboard-focus"></a><span data-ttu-id="830ae-314">鍵盤焦點</span><span class="sxs-lookup"><span data-stu-id="830ae-314">Keyboard Focus</span></span>
 <span data-ttu-id="830ae-315">鍵盤焦點是指接收鍵盤輸入的項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-315">Keyboard focus refers to the element that is receiving keyboard input.</span></span>  <span data-ttu-id="830ae-316">整個桌面只能有一個項目有鍵盤焦點。</span><span class="sxs-lookup"><span data-stu-id="830ae-316">There can be only one element on the whole desktop that has keyboard focus.</span></span>  <span data-ttu-id="830ae-317">在  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]，具有鍵盤焦點的項目會有<xref:System.Windows.IInputElement.IsKeyboardFocused%2A>設定為`true`。</span><span class="sxs-lookup"><span data-stu-id="830ae-317">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], the element that has keyboard focus will have <xref:System.Windows.IInputElement.IsKeyboardFocused%2A> set to `true`.</span></span>  <span data-ttu-id="830ae-318">靜態<xref:System.Windows.Input.Keyboard>方法<xref:System.Windows.Input.Keyboard.FocusedElement%2A>傳回目前具有鍵盤焦點的項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-318">The static <xref:System.Windows.Input.Keyboard> method <xref:System.Windows.Input.Keyboard.FocusedElement%2A> returns the element that currently has keyboard focus.</span></span>

 <span data-ttu-id="830ae-319">可以取得鍵盤焦點，按下 tab 鍵的項目，或按一下將滑鼠停在特定項目，例如<xref:System.Windows.Controls.TextBox>。</span><span class="sxs-lookup"><span data-stu-id="830ae-319">Keyboard focus can be obtained by tabbing to an element or by clicking the mouse on certain elements, such as a <xref:System.Windows.Controls.TextBox>.</span></span>  <span data-ttu-id="830ae-320">鍵盤焦點，還可以取得以程式設計方式使用<xref:System.Windows.Input.Keyboard.Focus%2A>方法<xref:System.Windows.Input.Keyboard>類別。</span><span class="sxs-lookup"><span data-stu-id="830ae-320">Keyboard focus can also be obtained programmatically by using the <xref:System.Windows.Input.Keyboard.Focus%2A> method on the <xref:System.Windows.Input.Keyboard> class.</span></span>  <span data-ttu-id="830ae-321"><xref:System.Windows.Input.Keyboard.Focus%2A> 嘗試將指定的項目鍵盤焦點。</span><span class="sxs-lookup"><span data-stu-id="830ae-321"><xref:System.Windows.Input.Keyboard.Focus%2A> attempts to give the specified element keyboard focus.</span></span>  <span data-ttu-id="830ae-322">所傳回的項目<xref:System.Windows.Input.Keyboard.Focus%2A>是目前具有鍵盤焦點的項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-322">The element returned by <xref:System.Windows.Input.Keyboard.Focus%2A> is the element that currently has keyboard focus.</span></span>

 <span data-ttu-id="830ae-323">為了讓項目取得鍵盤焦點<xref:System.Windows.UIElement.Focusable%2A>屬性和<xref:System.Windows.UIElement.IsVisible%2A>屬性必須設為 **，則為 true**。</span><span class="sxs-lookup"><span data-stu-id="830ae-323">In order for an element to obtain keyboard focus the <xref:System.Windows.UIElement.Focusable%2A> property and the <xref:System.Windows.UIElement.IsVisible%2A> properties must be set to **true**.</span></span>  <span data-ttu-id="830ae-324">部分類別，例如<xref:System.Windows.Controls.Panel>，具有<xref:System.Windows.UIElement.Focusable%2A>設為`false`的預設值; 因此，您可能要將此屬性設定為`true`如果您想要能夠取得焦點的項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-324">Some classes, such as <xref:System.Windows.Controls.Panel>, have <xref:System.Windows.UIElement.Focusable%2A> set to `false` by default; therefore, you may have to set this property to `true` if you want that element to be able to obtain focus.</span></span>

 <span data-ttu-id="830ae-325">下列範例會使用<xref:System.Windows.Input.Keyboard.Focus%2A>上設定鍵盤焦點<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="830ae-325">The following example uses <xref:System.Windows.Input.Keyboard.Focus%2A> to set keyboard focus on a <xref:System.Windows.Controls.Button>.</span></span>  <span data-ttu-id="830ae-326">應用程式中設定初始焦點的建議的位置是在<xref:System.Windows.FrameworkElement.Loaded>事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="830ae-326">The recommended place to set initial focus in an application is in the <xref:System.Windows.FrameworkElement.Loaded> event handler.</span></span>

 [!code-csharp[focussample#FocusSampleSetFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplesetfocus)]
 [!code-vb[focussample#FocusSampleSetFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplesetfocus)]

 <span data-ttu-id="830ae-327">如需鍵盤焦點的詳細資訊，請參閱[焦點概觀](focus-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="830ae-327">For more information about keyboard focus, see [Focus Overview](focus-overview.md).</span></span>

### <a name="logical-focus"></a><span data-ttu-id="830ae-328">邏輯焦點</span><span class="sxs-lookup"><span data-stu-id="830ae-328">Logical Focus</span></span>
 <span data-ttu-id="830ae-329">邏輯焦點是指<xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType>焦點範圍中。</span><span class="sxs-lookup"><span data-stu-id="830ae-329">Logical focus refers to the <xref:System.Windows.Input.FocusManager.FocusedElement%2A?displayProperty=nameWithType> in a focus scope.</span></span>  <span data-ttu-id="830ae-330">應用程式中可以有多個具有邏輯焦點的項目，但特定的焦點範圍中只能有一個有邏輯焦點的項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-330">There can be multiple elements that have logical focus in an application, but there may only be one element that has logical focus in a particular focus scope.</span></span>

 <span data-ttu-id="830ae-331">焦點範圍是在容器項目追蹤<xref:System.Windows.Input.FocusManager.FocusedElement%2A>其範圍內。</span><span class="sxs-lookup"><span data-stu-id="830ae-331">A focus scope is a container element that keeps track of the <xref:System.Windows.Input.FocusManager.FocusedElement%2A> within its scope.</span></span>  <span data-ttu-id="830ae-332">當焦點離開焦點範圍時，焦點項目就會失去鍵盤焦點，但卻仍然保有邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="830ae-332">When focus leaves a focus scope, the focused element will lose keyboard focus but will retain logical focus.</span></span>  <span data-ttu-id="830ae-333">當焦點回到焦點範圍時，焦點項目就會取得鍵盤焦點。</span><span class="sxs-lookup"><span data-stu-id="830ae-333">When focus returns to the focus scope, the focused element will obtain keyboard focus.</span></span>  <span data-ttu-id="830ae-334">這讓鍵盤焦點能在多個焦點範圍間變更，但確保焦點範圍內的焦點項目仍是焦點返回時的焦點項目。</span><span class="sxs-lookup"><span data-stu-id="830ae-334">This allows for keyboard focus to be changed between multiple focus scopes but insures that the focused element within the focus scope remains the focused element when focus returns.</span></span>

 <span data-ttu-id="830ae-335">項目可以轉換成焦點範圍[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)]藉由設定<xref:System.Windows.Input.FocusManager>附加屬性<xref:System.Windows.Input.FocusManager.IsFocusScope%2A>要`true`，或藉由設定附加的屬性使用的程式碼中<xref:System.Windows.Input.FocusManager.SetIsFocusScope%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="830ae-335">An element can be turned into a focus scope in [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] by setting the <xref:System.Windows.Input.FocusManager> attached property <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> to `true`, or in code by setting the attached property by using the <xref:System.Windows.Input.FocusManager.SetIsFocusScope%2A> method.</span></span>

 <span data-ttu-id="830ae-336">下列範例會使<xref:System.Windows.Controls.StackPanel>成焦點範圍，藉由設定<xref:System.Windows.Input.FocusManager.IsFocusScope%2A>附加屬性。</span><span class="sxs-lookup"><span data-stu-id="830ae-336">The following example makes a <xref:System.Windows.Controls.StackPanel> into a focus scope by setting the <xref:System.Windows.Input.FocusManager.IsFocusScope%2A> attached property.</span></span>

 [!code-xaml[MarkupSnippets#MarkupIsFocusScopeXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/MarkupSnippets/CSharp/Window1.xaml#markupisfocusscopexaml)]

 [!code-csharp[FocusSnippets#FocusSetIsFocusScope](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSnippets/CSharp/Window1.xaml.cs#focussetisfocusscope)]
 [!code-vb[FocusSnippets#FocusSetIsFocusScope](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSnippets/visualbasic/window1.xaml.vb#focussetisfocusscope)]

 <span data-ttu-id="830ae-337">中的類別[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]是焦點範圍，預設為<xref:System.Windows.Window>， <xref:System.Windows.Controls.Menu>， <xref:System.Windows.Controls.ToolBar>，和<xref:System.Windows.Controls.ContextMenu>。</span><span class="sxs-lookup"><span data-stu-id="830ae-337">Classes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] which are focus scopes by default are <xref:System.Windows.Window>, <xref:System.Windows.Controls.Menu>, <xref:System.Windows.Controls.ToolBar>, and <xref:System.Windows.Controls.ContextMenu>.</span></span>

 <span data-ttu-id="830ae-338">具有鍵盤焦點的項目也會有邏輯焦點; 它所屬焦點範圍因此，在具有的項目上設定焦點<xref:System.Windows.Input.Keyboard.Focus%2A>方法<xref:System.Windows.Input.Keyboard>類別或基底類別會嘗試提供的項目鍵盤焦點和邏輯焦點。</span><span class="sxs-lookup"><span data-stu-id="830ae-338">An element that has keyboard focus will also have logical focus for the focus scope it belongs to; therefore, setting focus on an element with the <xref:System.Windows.Input.Keyboard.Focus%2A> method on the <xref:System.Windows.Input.Keyboard> class or the base element classes will attempt to give the element keyboard focus and logical focus.</span></span>

 <span data-ttu-id="830ae-339">若要判斷焦點範圍中的焦點項目，請使用<xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>。</span><span class="sxs-lookup"><span data-stu-id="830ae-339">To determine the focused element in a focus scope, use <xref:System.Windows.Input.FocusManager.GetFocusedElement%2A>.</span></span> <span data-ttu-id="830ae-340">若要變更焦點範圍的焦點項目，請使用<xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>。</span><span class="sxs-lookup"><span data-stu-id="830ae-340">To change the focused element for a focus scope, use <xref:System.Windows.Input.FocusManager.SetFocusedElement%2A>.</span></span>

 <span data-ttu-id="830ae-341">如需邏輯焦點的詳細資訊，請參閱[焦點概觀](focus-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="830ae-341">For more information about logical focus, see [Focus Overview](focus-overview.md).</span></span>

<a name="mouse_position"></a>
## <a name="mouse-position"></a><span data-ttu-id="830ae-342">滑鼠位置</span><span class="sxs-lookup"><span data-stu-id="830ae-342">Mouse Position</span></span>
 <span data-ttu-id="830ae-343">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 輸入 [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] 提供有關座標空間的有用資訊。</span><span class="sxs-lookup"><span data-stu-id="830ae-343">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] provides helpful information with regard to coordinate spaces.</span></span>  <span data-ttu-id="830ae-344">例如，座標 `(0,0)` 是左上角的座標，但樹狀結構中的項目左上方為何？</span><span class="sxs-lookup"><span data-stu-id="830ae-344">For example, coordinate `(0,0)` is the upper-left coordinate, but the upper-left of which element in the tree?</span></span> <span data-ttu-id="830ae-345">為輸入目標的項目？</span><span class="sxs-lookup"><span data-stu-id="830ae-345">The element that is the input target?</span></span> <span data-ttu-id="830ae-346">附加事件處理常式的項目？</span><span class="sxs-lookup"><span data-stu-id="830ae-346">The element you attached your event handler to?</span></span> <span data-ttu-id="830ae-347">或其他事項？</span><span class="sxs-lookup"><span data-stu-id="830ae-347">Or something else?</span></span> <span data-ttu-id="830ae-348">為了避免混淆，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 輸入 [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] 會需要您在處理透過滑鼠取得的座標時指定參考框架。</span><span class="sxs-lookup"><span data-stu-id="830ae-348">To avoid confusion, the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] input [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] requires that you specify your frame of reference when you work with coordinates obtained through the mouse.</span></span> <span data-ttu-id="830ae-349"><xref:System.Windows.Input.Mouse.GetPosition%2A>方法會傳回滑鼠指標相對於指定項目的座標。</span><span class="sxs-lookup"><span data-stu-id="830ae-349">The <xref:System.Windows.Input.Mouse.GetPosition%2A> method returns the coordinate of the mouse pointer relative to the specified element.</span></span>

<a name="mouse_capture"></a>
## <a name="mouse-capture"></a><span data-ttu-id="830ae-350">滑鼠捕捉</span><span class="sxs-lookup"><span data-stu-id="830ae-350">Mouse Capture</span></span>
 <span data-ttu-id="830ae-351">滑鼠裝置專門保留稱為滑鼠捕捉的強制回應特性。</span><span class="sxs-lookup"><span data-stu-id="830ae-351">Mouse devices specifically hold a modal characteristic known as mouse capture.</span></span> <span data-ttu-id="830ae-352">滑鼠捕捉是用來維護啟動拖放作業後的轉換輸入狀態；因此，不一定會發生涉及滑鼠指標之額定螢幕位置的其他作業。</span><span class="sxs-lookup"><span data-stu-id="830ae-352">Mouse capture is used to maintain a transitional input state when a drag-and-drop operation is started, so that other operations involving the nominal on-screen position of the mouse pointer do not necessarily occur.</span></span> <span data-ttu-id="830ae-353">拖曳期間，使用者按一下就會中止拖放，這樣會在拖曳原點持有滑鼠捕捉時，讓大部分的 mouseover 提示為不適當。</span><span class="sxs-lookup"><span data-stu-id="830ae-353">During the drag, the user cannot click without aborting the drag-and-drop, which makes most mouseover cues inappropriate while the mouse capture is held by the drag origin.</span></span> <span data-ttu-id="830ae-354">輸入系統會公開可判斷滑鼠捕捉狀態的 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]，以及可強制滑鼠捕捉到特定項目或清除滑鼠捕捉狀態的 [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="830ae-354">The input system exposes [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] that can determine mouse capture state, as well as [!INCLUDE[TLA2#tla_api#plural](../../../../includes/tla2sharptla-apisharpplural-md.md)] that can force mouse capture to a specific element, or clear mouse capture state.</span></span> <span data-ttu-id="830ae-355">如需拖放作業的詳細資訊，請參閱[拖放概觀](drag-and-drop-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="830ae-355">For more information on drag-and-drop operations, see [Drag and Drop Overview](drag-and-drop-overview.md).</span></span>

<a name="commands"></a>
## <a name="commands"></a><span data-ttu-id="830ae-356">命令</span><span class="sxs-lookup"><span data-stu-id="830ae-356">Commands</span></span>
 <span data-ttu-id="830ae-357">命令比裝置輸入更接近語意層級的輸入處理。</span><span class="sxs-lookup"><span data-stu-id="830ae-357">Commands enable input handling at a more semantic level than device input.</span></span>  <span data-ttu-id="830ae-358">命令是簡單指示詞，例如 `Cut`、`Copy`、`Paste` 或 `Open`。</span><span class="sxs-lookup"><span data-stu-id="830ae-358">Commands are simple directives, such as `Cut`, `Copy`, `Paste`, or `Open`.</span></span>  <span data-ttu-id="830ae-359">命令適用於將命令邏輯集中。</span><span class="sxs-lookup"><span data-stu-id="830ae-359">Commands are useful for centralizing your command logic.</span></span>  <span data-ttu-id="830ae-360">可能會存取相同的命令，從<xref:System.Windows.Controls.Menu>上<xref:System.Windows.Controls.ToolBar>，或透過鍵盤快速鍵。</span><span class="sxs-lookup"><span data-stu-id="830ae-360">The same command might be accessed from a <xref:System.Windows.Controls.Menu>, on a <xref:System.Windows.Controls.ToolBar>, or through a keyboard shortcut.</span></span> <span data-ttu-id="830ae-361">命令也提供一種機制，可在命令變成無法使用時停用控制項。</span><span class="sxs-lookup"><span data-stu-id="830ae-361">Commands also provide a mechanism for disabling controls when the command becomes unavailable.</span></span>

 <span data-ttu-id="830ae-362"><xref:System.Windows.Input.RoutedCommand> 已[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]實作<xref:System.Windows.Input.ICommand>。</span><span class="sxs-lookup"><span data-stu-id="830ae-362"><xref:System.Windows.Input.RoutedCommand> is the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] implementation of <xref:System.Windows.Input.ICommand>.</span></span>  <span data-ttu-id="830ae-363">當<xref:System.Windows.Input.RoutedCommand>執行時，<xref:System.Windows.Input.CommandManager.PreviewExecuted>和<xref:System.Windows.Input.CommandManager.Executed>的通道和反昇到項目樹狀結構，例如其他輸入的命令目標上引發事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-363">When a <xref:System.Windows.Input.RoutedCommand> is executed, a <xref:System.Windows.Input.CommandManager.PreviewExecuted> and an <xref:System.Windows.Input.CommandManager.Executed> event are raised on the command target, which tunnel and bubble through the element tree like other input.</span></span>  <span data-ttu-id="830ae-364">如果未設定命令目標，則具有鍵盤焦點的項目就是命令目標。</span><span class="sxs-lookup"><span data-stu-id="830ae-364">If a command target is not set, the element with keyboard focus will be the command target.</span></span>  <span data-ttu-id="830ae-365">執行該命令的邏輯會附加至<xref:System.Windows.Input.CommandBinding>。</span><span class="sxs-lookup"><span data-stu-id="830ae-365">The logic that performs the command is attached to a <xref:System.Windows.Input.CommandBinding>.</span></span>  <span data-ttu-id="830ae-366">當<xref:System.Windows.Input.CommandManager.Executed>事件到達<xref:System.Windows.Input.CommandBinding>會針對該特定的命令<xref:System.Windows.Input.ExecutedRoutedEventHandler>上<xref:System.Windows.Input.CommandBinding>呼叫。</span><span class="sxs-lookup"><span data-stu-id="830ae-366">When an <xref:System.Windows.Input.CommandManager.Executed> event reaches a <xref:System.Windows.Input.CommandBinding> for that specific command, the <xref:System.Windows.Input.ExecutedRoutedEventHandler> on the <xref:System.Windows.Input.CommandBinding> is called.</span></span>  <span data-ttu-id="830ae-367">此處理常式會執行命令的動作。</span><span class="sxs-lookup"><span data-stu-id="830ae-367">This handler performs the action of the command.</span></span>

 <span data-ttu-id="830ae-368">如需命令的詳細資訊，請參閱[命令概觀](commanding-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="830ae-368">For more information on commanding, see [Commanding Overview](commanding-overview.md).</span></span>

 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="830ae-369">提供常用的命令，其中包含程式庫<xref:System.Windows.Input.ApplicationCommands>， <xref:System.Windows.Input.MediaCommands>， <xref:System.Windows.Input.ComponentCommands>， <xref:System.Windows.Input.NavigationCommands>，和<xref:System.Windows.Documents.EditingCommands>，或者您也可以定義自己。</span><span class="sxs-lookup"><span data-stu-id="830ae-369">provides a library of common commands which consists of <xref:System.Windows.Input.ApplicationCommands>, <xref:System.Windows.Input.MediaCommands>, <xref:System.Windows.Input.ComponentCommands>, <xref:System.Windows.Input.NavigationCommands>, and <xref:System.Windows.Documents.EditingCommands>, or you can define your own.</span></span>

 <span data-ttu-id="830ae-370">下列範例示範如何設定<xref:System.Windows.Controls.MenuItem>以便在按一下時它會叫用<xref:System.Windows.Input.ApplicationCommands.Paste%2A>命令<xref:System.Windows.Controls.TextBox>，假設<xref:System.Windows.Controls.TextBox>具有鍵盤焦點。</span><span class="sxs-lookup"><span data-stu-id="830ae-370">The following example shows how to set up a <xref:System.Windows.Controls.MenuItem> so that when it is clicked it will invoke the <xref:System.Windows.Input.ApplicationCommands.Paste%2A> command on the <xref:System.Windows.Controls.TextBox>, assuming the <xref:System.Windows.Controls.TextBox> has keyboard focus.</span></span>

 [!code-xaml[CommandingOverviewSnippets#CommandingOverviewSimpleCommand](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml#commandingoverviewsimplecommand)]

 [!code-csharp[CommandingOverviewSnippets#CommandingOverviewCommandTargetCodeBehind](~/samples/snippets/csharp/VS_Snippets_Wpf/CommandingOverviewSnippets/CSharp/Window1.xaml.cs#commandingoverviewcommandtargetcodebehind)]
 [!code-vb[CommandingOverviewSnippets#CommandingOverviewCommandTargetCodeBehind](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CommandingOverviewSnippets/visualbasic/window1.xaml.vb#commandingoverviewcommandtargetcodebehind)]

 <span data-ttu-id="830ae-371">如需 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中命令的詳細資訊，請參閱[命令概觀](commanding-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="830ae-371">For more information about commands in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], see [Commanding Overview](commanding-overview.md).</span></span>

<a name="the_input_system_and_base_elements"></a>
## <a name="the-input-system-and-base-elements"></a><span data-ttu-id="830ae-372">輸入系統和基底項目</span><span class="sxs-lookup"><span data-stu-id="830ae-372">The Input System and Base Elements</span></span>
 <span data-ttu-id="830ae-373">輸入事件，例如所定義的附加事件<xref:System.Windows.Input.Mouse>， <xref:System.Windows.Input.Keyboard>，和<xref:System.Windows.Input.Stylus>類別已輸入的系統產生的並插入至點擊測試視覺化樹狀結構在執行階段為基礎的物件模型中的特定位置。</span><span class="sxs-lookup"><span data-stu-id="830ae-373">Input events such as the attached events defined by the <xref:System.Windows.Input.Mouse>, <xref:System.Windows.Input.Keyboard>, and <xref:System.Windows.Input.Stylus> classes are raised by the input system and injected into a particular position in the object model based on hit testing the visual tree at run time.</span></span>

 <span data-ttu-id="830ae-374">每個事件， <xref:System.Windows.Input.Mouse>， <xref:System.Windows.Input.Keyboard>，並<xref:System.Windows.Input.Stylus>定義為附加的事件也會重新公開在基底類別所<xref:System.Windows.UIElement>和<xref:System.Windows.ContentElement>做為新的路由事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-374">Each of the events that <xref:System.Windows.Input.Mouse>, <xref:System.Windows.Input.Keyboard>, and <xref:System.Windows.Input.Stylus> define as an attached event is also re-exposed by the base element classes <xref:System.Windows.UIElement> and <xref:System.Windows.ContentElement> as a new routed event.</span></span> <span data-ttu-id="830ae-375">可處理原始附加事件並重複使用事件資料的類別會產生基底項目路由事件。</span><span class="sxs-lookup"><span data-stu-id="830ae-375">The base element routed events are generated by classes handling the original attached event and reusing the event data.</span></span>

 <span data-ttu-id="830ae-376">輸入事件透過其基底項目輸入事件實作與特定來源項目建立關聯時，可以透過事件路由的其餘部分進行路由傳送，而其乃根據邏輯和視覺化樹狀結構物件的組合，並透過應用程式碼進行處理。</span><span class="sxs-lookup"><span data-stu-id="830ae-376">When the input event becomes associated with a particular source element through its base element input event implementation, it can be routed through the remainder of an event route that is based on a combination of logical and visual tree objects, and be handled by application code.</span></span>  <span data-ttu-id="830ae-377">一般而言，是更方便地處理這些裝置相關輸入的事件上使用路由的事件<xref:System.Windows.UIElement>並<xref:System.Windows.ContentElement>，因為您可以使用更直覺式事件處理常式語法[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]和程式碼中。</span><span class="sxs-lookup"><span data-stu-id="830ae-377">Generally, it is more convenient to handle these device-related input events using the routed events on <xref:System.Windows.UIElement> and <xref:System.Windows.ContentElement>, because you can use more intuitive event handler syntax both in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and in code.</span></span> <span data-ttu-id="830ae-378">您可以選擇改為處理已初始程序的附加事件，但會遇到幾個問題︰基底項目類別處理可能會將附加事件標記為已處理，而且您需要使用存取子方法，而不是真正事件語法，才能附加所附加事件的處理常式。</span><span class="sxs-lookup"><span data-stu-id="830ae-378">You could choose to handle the attached event that initiated the process instead, but you would face several issues: the attached event may be marked handled by the base element class handling, and you need to use accessor methods rather than true event syntax in order to attach handlers for attached events.</span></span>

<a name="whats_next"></a>
## <a name="whats-next"></a><span data-ttu-id="830ae-379">後續步驟</span><span class="sxs-lookup"><span data-stu-id="830ae-379">What's Next</span></span>
 <span data-ttu-id="830ae-380">您現在有數種方式可處理 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的輸入。</span><span class="sxs-lookup"><span data-stu-id="830ae-380">You now have several techniques to handle input in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>  <span data-ttu-id="830ae-381">您也應該進一步了解各種類型的輸入事件以及 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 所使用的路由事件機制。</span><span class="sxs-lookup"><span data-stu-id="830ae-381">You should also have an improved understanding of the various types of input events and the routed event mechanisms used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span>

 <span data-ttu-id="830ae-382">具有其他資源可詳細說明 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 架構項目和事件路由。</span><span class="sxs-lookup"><span data-stu-id="830ae-382">Additional resources are available that explain [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] framework elements and event routing in more detail.</span></span> <span data-ttu-id="830ae-383">如需詳細資訊，請參閱下列概觀：[命令概觀](commanding-overview.md)、[焦點概觀](focus-overview.md)、[基底項目概觀](base-elements-overview.md)、[WPF 中的樹狀結構](trees-in-wpf.md)和[路由事件概觀](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="830ae-383">See the following overviews for more information, [Commanding Overview](commanding-overview.md), [Focus Overview](focus-overview.md), [Base Elements Overview](base-elements-overview.md), [Trees in WPF](trees-in-wpf.md), and [Routed Events Overview](routed-events-overview.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="830ae-384">另請參閱</span><span class="sxs-lookup"><span data-stu-id="830ae-384">See also</span></span>

- [<span data-ttu-id="830ae-385">焦點概觀</span><span class="sxs-lookup"><span data-stu-id="830ae-385">Focus Overview</span></span>](focus-overview.md)
- [<span data-ttu-id="830ae-386">命令概觀</span><span class="sxs-lookup"><span data-stu-id="830ae-386">Commanding Overview</span></span>](commanding-overview.md)
- [<span data-ttu-id="830ae-387">路由事件概觀</span><span class="sxs-lookup"><span data-stu-id="830ae-387">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="830ae-388">基底項目概觀</span><span class="sxs-lookup"><span data-stu-id="830ae-388">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="830ae-389">屬性</span><span class="sxs-lookup"><span data-stu-id="830ae-389">Properties</span></span>](properties-wpf.md)
