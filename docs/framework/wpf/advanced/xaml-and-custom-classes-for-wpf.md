---
title: WPF 的 XAML 和自訂類別
ms.date: 03/30/2017
helpviewer_keywords:
- custom classes in XAML [WPF]
- XAML [WPF], custom classes
- classes [WPF], custom classes in XAML
ms.assetid: e7313137-581e-4a64-8453-d44e15a6164a
ms.openlocfilehash: b573137b8d96565776d4b31f7ae8e5cc0b203a21
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/03/2019
ms.locfileid: "73459466"
---
# <a name="xaml-and-custom-classes-for-wpf"></a><span data-ttu-id="acce7-102">WPF 的 XAML 和自訂類別</span><span class="sxs-lookup"><span data-stu-id="acce7-102">XAML and Custom Classes for WPF</span></span>
<span data-ttu-id="acce7-103">通用語言執行平臺（CLR）架構中所實做的 XAML 支援以任何 common language runtime （CLR）語言定義自訂類別或結構，然後使用 XAML 標記存取該類別的功能。</span><span class="sxs-lookup"><span data-stu-id="acce7-103">XAML as implemented in common language runtime (CLR) frameworks supports the ability to define a custom class or structure in any common language runtime (CLR) language, and then access that class using XAML markup.</span></span> <span data-ttu-id="acce7-104">您可以在相同的標記檔案內混用 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 定義的類型與您的自訂類型，方法一般是透過將自訂類型對應至 XAML 命名空間前置詞。</span><span class="sxs-lookup"><span data-stu-id="acce7-104">You can use a mixture of [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]-defined types and your custom types within the same markup file, typically by mapping the custom types to a XAML namespace prefix.</span></span> <span data-ttu-id="acce7-105">本主題討論自訂類別必須滿足才能用作 XAML 項目的需求。</span><span class="sxs-lookup"><span data-stu-id="acce7-105">This topic discusses the requirements that a custom class must satisfy to be usable as a XAML element.</span></span>  

<a name="Custom_Classes_in_Applications_vs__in_Assemblies"></a>   
## <a name="custom-classes-in-applications-or-assemblies"></a><span data-ttu-id="acce7-106">應用程式或組件中的自訂類別</span><span class="sxs-lookup"><span data-stu-id="acce7-106">Custom Classes in Applications or Assemblies</span></span>  
 <span data-ttu-id="acce7-107">可以使用兩種不同的方式來定義 XAML 中所使用的自訂類別︰在程式碼後置或產生主要 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 應用程式的其他程式碼內，或作為不同組件中的類別，例如用作類別庫的可執行檔或 DLL。</span><span class="sxs-lookup"><span data-stu-id="acce7-107">Custom classes that are used in XAML can be defined in two distinct ways: within the code-behind or other code that produces the primary [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application, or as a class in a separate assembly, such as an executable or DLL used as a class library.</span></span> <span data-ttu-id="acce7-108">所有這些方法都會有特定優缺點。</span><span class="sxs-lookup"><span data-stu-id="acce7-108">Each of these approaches has particular advantages and disadvantages.</span></span>  
  
- <span data-ttu-id="acce7-109">建立類別庫的優點是可以跨許多不同的可能應用程式來共用任何這類自訂類別。</span><span class="sxs-lookup"><span data-stu-id="acce7-109">The advantage of creating a class library is that any such custom classes can be shared across many different possible applications.</span></span> <span data-ttu-id="acce7-110">不同的程式庫也方便控制應用程式的版本控制問題，並簡化如何建立所要類別用法作為 XAML 頁面上根項目的類別。</span><span class="sxs-lookup"><span data-stu-id="acce7-110">A separate library also makes versioning issues of applications easier to control, and simplifies creating a class where the intended class usage is as a root element on a XAML page.</span></span>  
  
- <span data-ttu-id="acce7-111">在應用程式中定義自訂類別的優點在於這項技巧相當簡單，並將在引進主要應用程式可執行檔以外的個別組件時所遇到的部署和測試問題降到最少。</span><span class="sxs-lookup"><span data-stu-id="acce7-111">The advantage of defining the custom classes in the application is that this technique is relatively lightweight and minimizes the deployment and testing issues encountered when you introduce separate assemblies beyond the main application executable.</span></span>  
  
- <span data-ttu-id="acce7-112">不論定義於相同或不同組件中，都需要在 CLR 命名空間與 XML 命名空間之間對應自訂類別，才能當成項目用於 XAML 中。</span><span class="sxs-lookup"><span data-stu-id="acce7-112">Whether defined in the same or different assembly, custom classes need to be mapped between CLR  namespace and XML  namespace in order to be used in XAML as elements.</span></span> <span data-ttu-id="acce7-113">請參閱 [WPF XAML 的 XAML 命名空間和命名空間對應](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="acce7-113">See [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="Requirements_for_a_Custom_Class_as_a_XAML_Element"></a>   
## <a name="requirements-for-a-custom-class-as-a-xaml-element"></a><span data-ttu-id="acce7-114">作為 XAML 項目之自訂類別的需求</span><span class="sxs-lookup"><span data-stu-id="acce7-114">Requirements for a Custom Class as a XAML Element</span></span>  
 <span data-ttu-id="acce7-115">若要可具現化為物件項目，您的類別必須符合下列需求︰</span><span class="sxs-lookup"><span data-stu-id="acce7-115">In order to be able to be instantiated as an object element, your class must meet the following requirements:</span></span>  
  
- <span data-ttu-id="acce7-116">自訂類別必須是公用，並支援預設 (無參數) 公用建構函式</span><span class="sxs-lookup"><span data-stu-id="acce7-116">Your custom class must be public and support a default (parameterless) public constructor.</span></span> <span data-ttu-id="acce7-117">(如需結構相關附註，請參閱下節)。</span><span class="sxs-lookup"><span data-stu-id="acce7-117">(See following section for notes regarding structures.)</span></span>  
  
- <span data-ttu-id="acce7-118">自訂類別不能是巢狀類別。</span><span class="sxs-lookup"><span data-stu-id="acce7-118">Your custom class must not be a nested class.</span></span> <span data-ttu-id="acce7-119">巢狀類別以及其在具有其他 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 和 (或) XAML 功能之一般 CLR 使用語法介面中的「點」，例如附加屬性。</span><span class="sxs-lookup"><span data-stu-id="acce7-119">Nested classes and the "dot" in their general CLR usage syntax interfere with other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] and/or XAML features such as attached properties.</span></span>  
  
 <span data-ttu-id="acce7-120">除了啟用物件項目語法之外，您的物件定義也會啟用採用該物件作為值類型之任何其他公用屬性的屬性項目語法。</span><span class="sxs-lookup"><span data-stu-id="acce7-120">In addition to enabling object element syntax, your object definition also enables property element syntax for any other public properties that take that object as the value type.</span></span> <span data-ttu-id="acce7-121">這是因為物件現在可以具現化為物件項目，並且可以填入這類屬性的屬性項目值。</span><span class="sxs-lookup"><span data-stu-id="acce7-121">This is because the object can now be instantiated as an object element and can fill the property element value of such a property.</span></span>  
  
### <a name="structures"></a><span data-ttu-id="acce7-122">結構</span><span class="sxs-lookup"><span data-stu-id="acce7-122">Structures</span></span>  
 <span data-ttu-id="acce7-123">您定義為自訂類型的結構，一律可以在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 的 XAML 中進行構造。這是因為 CLR 編譯器會隱含地為結構建立無參數的函式，以將所有屬性值初始化為其預設值。</span><span class="sxs-lookup"><span data-stu-id="acce7-123">Structures that you define as custom types are always able to be constructed in XAML  in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] .This is because the CLR compilers implicitly create a parameterless constructor for a structure that initializes all property values to their defaults.</span></span> <span data-ttu-id="acce7-124">在某些情況下，您可能不想要結構的預設建構行為和 (或) 物件項目用法。</span><span class="sxs-lookup"><span data-stu-id="acce7-124">In some cases, the default construction behavior and/or object element usage for a structure is not desirable.</span></span> <span data-ttu-id="acce7-125">這可能是因為結構是要填入值並在概念上當成聯集運作；其中，所包含的值可能會有互斥解譯，因此無法設定其屬性。</span><span class="sxs-lookup"><span data-stu-id="acce7-125">This might be because the structure is intended to fill values and function conceptually as a union, where the values contained might have mutually exclusive interpretations and thus none of its properties are settable.</span></span> <span data-ttu-id="acce7-126"><xref:System.Windows.GridLength>[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 這類結構的範例。</span><span class="sxs-lookup"><span data-stu-id="acce7-126">A [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] example of such a structure is <xref:System.Windows.GridLength>.</span></span> <span data-ttu-id="acce7-127">一般而言，這類結構應該實作類型轉換子；如此，使用可建立結構值的不同解譯或模式的字串慣例，即可透過屬性形式表示這些值。</span><span class="sxs-lookup"><span data-stu-id="acce7-127">Generally, such structures should implement a type converter such that the values can be expressed in attribute form, using string conventions that create the different interpretations or modes of the structure's values.</span></span> <span data-ttu-id="acce7-128">結構也應該透過非無參數的函式來公開程式碼結構的類似行為。</span><span class="sxs-lookup"><span data-stu-id="acce7-128">The structure should also expose similar behavior for code construction through a non-parameterless constructor.</span></span>  
  
<a name="Requirements_for_Properties_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-properties-of-a-custom-class-as-xaml-attributes"></a><span data-ttu-id="acce7-129">作為 XAML 屬性之自訂類別的屬性需求</span><span class="sxs-lookup"><span data-stu-id="acce7-129">Requirements for Properties of a Custom Class as XAML Attributes</span></span>  
 <span data-ttu-id="acce7-130">屬性必須參考傳值型別（例如基本類型），或針對具有無參數的函式或可存取 XAML 處理器之專用類型轉換器的類型使用類別。</span><span class="sxs-lookup"><span data-stu-id="acce7-130">Properties must reference a by-value type (such as a primitive), or use a class for type that has either a parameterless constructor or a dedicated type converter that a XAML processor can access.</span></span> <span data-ttu-id="acce7-131">在 CLR XAML 的執行中，XAML 處理器會透過對語言基本類型的原生支援來尋找這類轉換器，或透過將 <xref:System.ComponentModel.TypeConverterAttribute> 的應用程式，提供給支援型別定義中的型別或成員。</span><span class="sxs-lookup"><span data-stu-id="acce7-131">In the CLR XAML implementation, XAML processors either find such converters through native support for language primitives, or through application of <xref:System.ComponentModel.TypeConverterAttribute> to a type or member in backing type definitions</span></span>  
  
 <span data-ttu-id="acce7-132">或者，屬性可以參考抽象類別類型或介面。</span><span class="sxs-lookup"><span data-stu-id="acce7-132">Alternatively, the property may reference an abstract class type, or an interface.</span></span> <span data-ttu-id="acce7-133">針對抽象類別或介面，XAML 剖析預期屬性值必須填入可實作介面的實體類別執行個體，或衍生自抽象類別之類型的執行個體。</span><span class="sxs-lookup"><span data-stu-id="acce7-133">For abstract classes or interfaces, the expectation for XAML parsing is that the property value must be filled with practical class instances that implement the interface, or instances of types that derive from the abstract class.</span></span>  
  
 <span data-ttu-id="acce7-134">屬性可以宣告於抽象類別上，但只可以設定於衍生自抽象類別的實值類別上。</span><span class="sxs-lookup"><span data-stu-id="acce7-134">Properties can be declared on an abstract class, but can only be set on practical classes that derive from the abstract class.</span></span> <span data-ttu-id="acce7-135">這是因為建立類別的物件專案時，必須在類別上有公用無參數的函式。</span><span class="sxs-lookup"><span data-stu-id="acce7-135">This is because creating the object element for the class at all requires a public parameterless constructor on the class.</span></span>  
  
### <a name="typeconverter-enabled-attribute-syntax"></a><span data-ttu-id="acce7-136">TypeConverter 啟用屬性語法</span><span class="sxs-lookup"><span data-stu-id="acce7-136">TypeConverter Enabled Attribute Syntax</span></span>  
 <span data-ttu-id="acce7-137">如果您在類別層級提供專用屬性化類型轉換子，則套用的類型轉換可啟用任何需要具現化該類型之屬性 (property) 的屬性 (attribute) 語法。</span><span class="sxs-lookup"><span data-stu-id="acce7-137">If you provide a dedicated, attributed type converter at the class level, the applied type conversion enables attribute syntax for any property that needs to instantiate that type.</span></span> <span data-ttu-id="acce7-138">類型轉換器不會啟用類型的物件元素使用方式;只有該類型的無參數函式存在，才會啟用物件元素的使用方式。</span><span class="sxs-lookup"><span data-stu-id="acce7-138">A type converter does not enable object element usage of the type; only the presence of a parameterless constructor for that type enables object element usage.</span></span> <span data-ttu-id="acce7-139">因此，除非類型本身也支援物件項目語法，否則已啟用類型轉換子的屬性一般無法用於屬性語法。</span><span class="sxs-lookup"><span data-stu-id="acce7-139">Therefore, properties that are type-converter enabled are generally speaking not usable in property syntax, unless the type itself also supports object element syntax.</span></span> <span data-ttu-id="acce7-140">這個的例外狀況是您可以指定屬性項目語法，但讓屬性項目包含字串。</span><span class="sxs-lookup"><span data-stu-id="acce7-140">The exception to this is that you can specify a property element syntax, but have the property element contain a string.</span></span> <span data-ttu-id="acce7-141">這種用法基本上等同于屬性語法使用方式，而這種用法並不常見，除非需要更健全的屬性值的空白字元處理。</span><span class="sxs-lookup"><span data-stu-id="acce7-141">That usage is really essentially equivalent to an attribute syntax usage, and such a usage is not common unless there is a need for more robust white-space handling of the attribute value.</span></span> <span data-ttu-id="acce7-142">例如，以下是取用字串的屬性 (property) 項目用法以及對等的屬性 (attribute) 用法︰</span><span class="sxs-lookup"><span data-stu-id="acce7-142">For example, the following is a property element usage that takes a string, and the attribute usage equivalent:</span></span>  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe)]  
  
 [!code-xaml[XamlOvwSupport#GoofyTCPE2](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofytcpe2)]  
  
 <span data-ttu-id="acce7-143">允許屬性語法的屬性範例，但不允許透過 XAML 使用包含物件元素的屬性專案語法，而是採用 <xref:System.Windows.Input.Cursor> 類型的各種屬性。</span><span class="sxs-lookup"><span data-stu-id="acce7-143">Examples of properties where attribute syntax is allowed but property element syntax that contains an object element is disallowed through XAML are various properties that take the <xref:System.Windows.Input.Cursor> type.</span></span> <span data-ttu-id="acce7-144"><xref:System.Windows.Input.Cursor> 類別具有專用類型轉換器 <xref:System.Windows.Input.CursorConverter>，但不會公開無參數的函式，因此，即使實際的 <xref:System.Windows.Input.Cursor> 類型是參考型別，也只能透過屬性語法來設定 <xref:System.Windows.FrameworkElement.Cursor%2A> 屬性。</span><span class="sxs-lookup"><span data-stu-id="acce7-144">The <xref:System.Windows.Input.Cursor> class has a dedicated type converter <xref:System.Windows.Input.CursorConverter>, but does not expose a parameterless constructor, so the <xref:System.Windows.FrameworkElement.Cursor%2A> property can only be set through attribute syntax even though the actual <xref:System.Windows.Input.Cursor> type is a reference type.</span></span>  
  
### <a name="per-property-type-converters"></a><span data-ttu-id="acce7-145">每個屬性的類型轉換子</span><span class="sxs-lookup"><span data-stu-id="acce7-145">Per-Property Type Converters</span></span>  
 <span data-ttu-id="acce7-146">或者，屬性本身可以宣告屬性層級的類型轉換子。</span><span class="sxs-lookup"><span data-stu-id="acce7-146">Alternatively, the property itself may declare a type converter at the property level.</span></span> <span data-ttu-id="acce7-147">這會啟用「迷你語言」，藉由處理屬性的傳入字串值做為根據適當類型之 <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> 作業的輸入，來具現化屬性（inline）之類型的物件。</span><span class="sxs-lookup"><span data-stu-id="acce7-147">This enables a "mini language" that instantiates objects of the type of the property inline, by processing incoming string values of the attribute as input for a <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> operation based on the appropriate type.</span></span> <span data-ttu-id="acce7-148">這項作業一般是要提供方便使用的存取子，而不是在 XAML 中設定屬性的唯一方法。</span><span class="sxs-lookup"><span data-stu-id="acce7-148">Typically this is done to provide a convenience accessor, and not as the sole means to enable setting a property in XAML.</span></span> <span data-ttu-id="acce7-149">不過，如果您想要使用未提供無參數的函式或屬性化型別轉換器的現有 CLR 型別，則也可以針對屬性使用類型轉換器。</span><span class="sxs-lookup"><span data-stu-id="acce7-149">However, it is also possible to use type converters for attributes where you want to use existing CLR types that do not supply either a parameterless constructor or an attributed type converter.</span></span> <span data-ttu-id="acce7-150">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API 的範例是採用 <xref:System.Globalization.CultureInfo> 類型的某些屬性。</span><span class="sxs-lookup"><span data-stu-id="acce7-150">Examples from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] API are certain properties that take the <xref:System.Globalization.CultureInfo> type.</span></span> <span data-ttu-id="acce7-151">在此情況下，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 使用現有的 Microsoft .NET Framework <xref:System.Globalization.CultureInfo> 類型，以更有效地解決舊版架構中使用的相容性和遷移案例，但 <xref:System.Globalization.CultureInfo> 類型不支援必要的程式，或型別層級型別轉換，可直接當做 XAML 屬性值使用。</span><span class="sxs-lookup"><span data-stu-id="acce7-151">In this case, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] used the existing Microsoft .NET Framework <xref:System.Globalization.CultureInfo> type to better address compatibility and migration scenarios that were used in earlier versions of frameworks, but the <xref:System.Globalization.CultureInfo> type did not support the necessary constructors or type-level type conversion to be usable as a XAML property value directly.</span></span>  
  
 <span data-ttu-id="acce7-152">只要公開具有 XAML 用法的屬性，特別的是，如果您是控制項作者，則應該強烈考慮支援該屬性與相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="acce7-152">Whenever you expose a property that has a XAML usage, particularly if you are a control author, you should strongly consider backing that property with a dependency property.</span></span> <span data-ttu-id="acce7-153">如果您使用現有的 XAML 處理器 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 執行，這特別適用，因為您可以使用 <xref:System.Windows.DependencyProperty> 支援來改善效能。</span><span class="sxs-lookup"><span data-stu-id="acce7-153">This is particularly true if you use the existing [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] implementation of the XAML processor, because you can improve performance by using <xref:System.Windows.DependencyProperty> backing.</span></span> <span data-ttu-id="acce7-154">相依性屬性會公開使用者預期 XAML 可存取屬性之屬性的屬性系統功能。</span><span class="sxs-lookup"><span data-stu-id="acce7-154">A dependency property will expose property system features for your property that users will come to expect for a XAML accessible property.</span></span> <span data-ttu-id="acce7-155">這包括動畫、資料繫結和樣式支援這類功能。</span><span class="sxs-lookup"><span data-stu-id="acce7-155">This includes features such as animation, data binding, and style support.</span></span> <span data-ttu-id="acce7-156">如需詳細資訊，請參閱[自訂相依性屬性](custom-dependency-properties.md)和 [XAML 載入和相依性屬性](xaml-loading-and-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="acce7-156">For more information, see [Custom Dependency Properties](custom-dependency-properties.md) and [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>  
  
### <a name="writing-and-attributing-a-type-converter"></a><span data-ttu-id="acce7-157">撰寫並屬性化類型轉換子</span><span class="sxs-lookup"><span data-stu-id="acce7-157">Writing and Attributing a Type Converter</span></span>  
 <span data-ttu-id="acce7-158">您偶爾會需要撰寫自訂的 <xref:System.ComponentModel.TypeConverter> 衍生類別，以提供屬性類型的類型轉換。</span><span class="sxs-lookup"><span data-stu-id="acce7-158">You occasionally will need to write a custom <xref:System.ComponentModel.TypeConverter> derived class to provide type conversion for your property type.</span></span> <span data-ttu-id="acce7-159">如需如何衍生自並建立可支援 XAML 用法的類型轉換器，以及如何套用 <xref:System.ComponentModel.TypeConverterAttribute>的指示，請參閱[TypeConverters 和 XAML](typeconverters-and-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="acce7-159">For instructions on how to derive from and create a type converter that can support XAML usages, and how to apply the <xref:System.ComponentModel.TypeConverterAttribute>, see [TypeConverters and XAML](typeconverters-and-xaml.md).</span></span>  
  
<a name="Requirements_for_Events_of_a_Custom_Class_as_XAML"></a>   
## <a name="requirements-for-xaml-event-handler-attribute-syntax-on-events-of-a-custom-class"></a><span data-ttu-id="acce7-160">自訂類別事件上 XAML 事件處理常式屬性語法的需求</span><span class="sxs-lookup"><span data-stu-id="acce7-160">Requirements for XAML Event Handler Attribute Syntax on Events of a Custom Class</span></span>  
 <span data-ttu-id="acce7-161">若要以 CLR 事件的形式使用，必須在支援無參數的函式的類別上，或在可于衍生類別上存取事件的抽象類別上，將事件公開為公用事件。</span><span class="sxs-lookup"><span data-stu-id="acce7-161">To be usable as a CLR event, the event must be exposed as a public event on a class that supports a parameterless constructor, or on an abstract class where the event can be accessed on derived classes.</span></span> <span data-ttu-id="acce7-162">為了方便地當做路由事件使用，您的 CLR 事件應該會執行明確的 `add` 和 `remove` 方法，這會新增和移除 CLR 事件簽章的處理常式，然後將這些處理常式轉送至 <xref:System.Windows.UIElement.AddHandler%2A> 和 <xref:System.Windows.UIElement.RemoveHandler%2A> 方法。</span><span class="sxs-lookup"><span data-stu-id="acce7-162">In order to be used conveniently as a routed event, your CLR event should implement explicit `add` and `remove` methods, which add and remove handlers for the CLR event signature and forward those handlers to the <xref:System.Windows.UIElement.AddHandler%2A> and <xref:System.Windows.UIElement.RemoveHandler%2A> methods.</span></span> <span data-ttu-id="acce7-163">這些方法會在附加事件的執行個體上新增或移除路由事件處理常式存放區的處理常式。</span><span class="sxs-lookup"><span data-stu-id="acce7-163">These methods add or remove the handlers to the routed event handler store on the instance that the event is attached to.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="acce7-164">您可以使用 <xref:System.Windows.UIElement.AddHandler%2A>，直接為路由事件註冊處理常式，並故意不定義會公開路由事件的 CLR 事件。</span><span class="sxs-lookup"><span data-stu-id="acce7-164">It is possible to register handlers directly for routed events using <xref:System.Windows.UIElement.AddHandler%2A>, and to deliberately not define a CLR event that exposes the routed event.</span></span> <span data-ttu-id="acce7-165">通常不會建議您使用此方式，因為事件不會啟用用於附加處理常式的 XAML 屬性語法，而且產生的類別將針對該類型的功能提供較不容易明瞭的 XAML 檢視。</span><span class="sxs-lookup"><span data-stu-id="acce7-165">This is not generally recommended because the event will not enable XAML attribute syntax for attaching handlers, and your resulting class will offer a less transparent XAML view of that type's capabilities.</span></span>  
  
<a name="Collection_Properties"></a>   
## <a name="writing-collection-properties"></a><span data-ttu-id="acce7-166">撰寫集合屬性</span><span class="sxs-lookup"><span data-stu-id="acce7-166">Writing Collection Properties</span></span>  
 <span data-ttu-id="acce7-167">採用集合類型的屬性具有 XAML 語法，可讓您指定新增至集合的物件。</span><span class="sxs-lookup"><span data-stu-id="acce7-167">Properties that take a collection type have a XAML syntax that enables you to specify objects that are added to the collection.</span></span> <span data-ttu-id="acce7-168">此語法有兩個值得注意的功能。</span><span class="sxs-lookup"><span data-stu-id="acce7-168">This syntax has two notable features.</span></span>  
  
- <span data-ttu-id="acce7-169">本身為集合物件的物件不需要指定於物件項目語法中。</span><span class="sxs-lookup"><span data-stu-id="acce7-169">The object that is the collection object does not need to be specified in object element syntax.</span></span> <span data-ttu-id="acce7-170">只要在 XAML 中指定採用集合類型的屬性，該集合類型的存在就是隱含的。</span><span class="sxs-lookup"><span data-stu-id="acce7-170">The presence of that collection type is implicit whenever you specify a property in XAML that takes a collection type.</span></span>  
  
- <span data-ttu-id="acce7-171">標記中集合屬性的子項目會處理成集合的成員。</span><span class="sxs-lookup"><span data-stu-id="acce7-171">Child elements of the collection property in markup are processed to become members of the collection.</span></span> <span data-ttu-id="acce7-172">一般而言，是透過 `Add` 這類清單/字典方法，或透過索引子，執行對集合成員的程式碼存取。</span><span class="sxs-lookup"><span data-stu-id="acce7-172">Ordinarily, the code access to the members of a collection is performed through list/dictionary methods such as `Add`, or through an indexer.</span></span> <span data-ttu-id="acce7-173">但是 XAML 語法不支援方法或索引子 (例外狀況︰XAML 2009 可以支援方法，但使用 XAML 2009 限制可能的 WPF 用法；請參閱 [XAML 2009 語言功能](../../xaml-services/xaml-2009-language-features.md))。</span><span class="sxs-lookup"><span data-stu-id="acce7-173">But XAML syntax does not support methods or indexers (exception: XAML 2009 can support methods, but using XAML 2009 restricts the possible WPF usages; see [XAML 2009 Language Features](../../xaml-services/xaml-2009-language-features.md)).</span></span> <span data-ttu-id="acce7-174">集合很明顯是建置項目樹狀結構的很常見需求，而且您需要某個方法在宣告式 XAML 中填入這些集合。</span><span class="sxs-lookup"><span data-stu-id="acce7-174">Collections are obviously a very common requirement for building a tree of elements, and you need some way to populate these collections in declarative XAML.</span></span> <span data-ttu-id="acce7-175">因此，會處理集合屬性的子項目，方法是將它們新增至為集合屬性類型值的集合。</span><span class="sxs-lookup"><span data-stu-id="acce7-175">Therefore, child elements of a collection property are processed by adding them to the collection that is the collection property type value.</span></span>  
  
 <span data-ttu-id="acce7-176">.NET Framework XAML 服務實作，因此 WPF XAML 處理器會使用下列構成集合屬性的定義。</span><span class="sxs-lookup"><span data-stu-id="acce7-176">The .NET Framework XAML Services implementation and thus the WPF XAML processor uses the following definition for what constitutes a collection property.</span></span> <span data-ttu-id="acce7-177">屬性的屬性類型必須實作下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="acce7-177">The property type of the property must implement one of the following:</span></span>  
  
- <span data-ttu-id="acce7-178">執行 <xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="acce7-178">Implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="acce7-179">執行 <xref:System.Collections.IDictionary> 或泛型對等（<xref:System.Collections.Generic.IDictionary%602>）。</span><span class="sxs-lookup"><span data-stu-id="acce7-179">Implements <xref:System.Collections.IDictionary> or the generic equivalent (<xref:System.Collections.Generic.IDictionary%602>).</span></span>  
  
- <span data-ttu-id="acce7-180">衍生自 <xref:System.Array> （如需 XAML 中陣列的詳細資訊，請參閱[X:Array 標記延伸](../../xaml-services/x-array-markup-extension.md)）。</span><span class="sxs-lookup"><span data-stu-id="acce7-180">Derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).)</span></span>  
  
- <span data-ttu-id="acce7-181">執行 <xref:System.Windows.Markup.IAddChild> （由 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]所定義的介面）。</span><span class="sxs-lookup"><span data-stu-id="acce7-181">Implements <xref:System.Windows.Markup.IAddChild> (an interface defined by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]).</span></span>  
  
 <span data-ttu-id="acce7-182">CLR 中的所有這些類型都會有 `Add` 方法，而 XAML 處理器使用此方法，在建立物件圖形時，將項目新增至基礎集合。</span><span class="sxs-lookup"><span data-stu-id="acce7-182">Each of these types in CLR has an `Add` method, which is used by the XAML processor to add items to the underlying collection when creating the object graph.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="acce7-183">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML 處理器不支援泛型 `List` 和 `Dictionary` 介面（<xref:System.Collections.Generic.IList%601> 和 <xref:System.Collections.Generic.IDictionary%602>）進行集合偵測。</span><span class="sxs-lookup"><span data-stu-id="acce7-183">The generic `List` and `Dictionary` interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processor.</span></span> <span data-ttu-id="acce7-184">不過，您可以使用 <xref:System.Collections.Generic.List%601> 類別做為基類，因為它會直接執行 <xref:System.Collections.IList>，或當做基類來 <xref:System.Collections.Generic.Dictionary%602>，因為它會直接執行 <xref:System.Collections.IDictionary>。</span><span class="sxs-lookup"><span data-stu-id="acce7-184">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="acce7-185">當您宣告採用集合的屬性時，請注意如何在類型的新執行個體中初始化該屬性值。</span><span class="sxs-lookup"><span data-stu-id="acce7-185">When you declare a property that takes a collection, be cautious about how that property value is initialized in new instances of the type.</span></span> <span data-ttu-id="acce7-186">如果您未將屬性實作為相依性屬性，則讓屬性使用可呼叫集合類型建構函式的支援欄位就已足夠。</span><span class="sxs-lookup"><span data-stu-id="acce7-186">If you are not implementing the property as a dependency property, then having the property use a backing field that calls the collection type constructor is adequate.</span></span> <span data-ttu-id="acce7-187">如果您的屬性是相依性屬性，則可能需要將集合屬性初始化為預設類型建構函式的一部分。</span><span class="sxs-lookup"><span data-stu-id="acce7-187">If your property is a dependency property, then you may need to initialize the collection property as part of the default type constructor.</span></span> <span data-ttu-id="acce7-188">這是因為相依性屬性會從中繼資料取得其預設值，而且您通常不想要集合屬性的初始值成為靜態共用集合。</span><span class="sxs-lookup"><span data-stu-id="acce7-188">This is because a dependency property takes its default value from metadata, and you typically do not want the initial value of a collection property to be a static, shared collection.</span></span> <span data-ttu-id="acce7-189">一個包含類型執行個體應該要有一個集合執行個體。</span><span class="sxs-lookup"><span data-stu-id="acce7-189">There should be a collection instance per each containing type instance.</span></span> <span data-ttu-id="acce7-190">如需詳細資訊，請參閱[自訂相依性屬性](custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="acce7-190">For more information, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="acce7-191">您可以實作集合屬性的自訂集合類型。</span><span class="sxs-lookup"><span data-stu-id="acce7-191">You can implement a custom collection type for your collection property.</span></span> <span data-ttu-id="acce7-192">因為有隱含的集合屬性處理，所以自訂集合類型不需要提供無參數的函式，就能以隱含方式在 XAML 中使用。</span><span class="sxs-lookup"><span data-stu-id="acce7-192">Because of implicit collection property treatment, the custom collection type does not need to provide a parameterless constructor in order to be used in XAML implicitly.</span></span> <span data-ttu-id="acce7-193">不過，您可以選擇性地為集合類型提供無參數的函式。</span><span class="sxs-lookup"><span data-stu-id="acce7-193">However, you can optionally provide a parameterless constructor for the collection type.</span></span> <span data-ttu-id="acce7-194">這是相當實用的做法。</span><span class="sxs-lookup"><span data-stu-id="acce7-194">This can be a worthwhile practice.</span></span> <span data-ttu-id="acce7-195">除非您提供無參數的函式，否則無法將集合明確宣告為 object 元素。</span><span class="sxs-lookup"><span data-stu-id="acce7-195">Unless you do provide a parameterless constructor, you cannot explicitly declare the collection as an object element.</span></span> <span data-ttu-id="acce7-196">部分標記作者可能會想要將明確集合視為標記樣式。</span><span class="sxs-lookup"><span data-stu-id="acce7-196">Some markup authors might prefer to see the explicit collection as a matter of markup style.</span></span> <span data-ttu-id="acce7-197">此外，當您建立使用集合類型做為屬性值的新物件時，無參數的函式也可以簡化初始化需求。</span><span class="sxs-lookup"><span data-stu-id="acce7-197">Also, a parameterless constructor can simplify the initialization requirements when you create new objects that use your collection type as a property value.</span></span>  
  
<a name="XAMLCONtent"></a>   
## <a name="declaring-xaml-content-properties"></a><span data-ttu-id="acce7-198">宣告 XAML 內容屬性</span><span class="sxs-lookup"><span data-stu-id="acce7-198">Declaring XAML Content Properties</span></span>  
 <span data-ttu-id="acce7-199">XAML 語言定義 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 內容屬性的概念。</span><span class="sxs-lookup"><span data-stu-id="acce7-199">The XAML language defines the concept of a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] content property.</span></span> <span data-ttu-id="acce7-200">每個可用於物件語法中的類別都只能有一個 XAML 內容屬性。</span><span class="sxs-lookup"><span data-stu-id="acce7-200">Each class that is usable in object syntax can have exactly one XAML content property.</span></span> <span data-ttu-id="acce7-201">若要將屬性宣告為類別的 XAML 內容屬性，請套用 <xref:System.Windows.Markup.ContentPropertyAttribute> 做為類別定義的一部分。</span><span class="sxs-lookup"><span data-stu-id="acce7-201">To declare a property to be the XAML content property for your class, apply the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of the class definition.</span></span> <span data-ttu-id="acce7-202">將 [預期的 XAML 內容] 屬性的名稱指定為屬性中的 <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A>。</span><span class="sxs-lookup"><span data-stu-id="acce7-202">Specify the name of the intended XAML content property as the <xref:System.Windows.Markup.ContentPropertyAttribute.Name%2A> in the attribute.</span></span> <span data-ttu-id="acce7-203">屬性會依名稱指定為字串，而不是當做反映結構（例如 <xref:System.Reflection.PropertyInfo>）。</span><span class="sxs-lookup"><span data-stu-id="acce7-203">The property is specified as a string by name, not as a reflection construct such as <xref:System.Reflection.PropertyInfo>.</span></span>  
  
 <span data-ttu-id="acce7-204">您可以將集合屬性指定為 XAML 內容屬性。</span><span class="sxs-lookup"><span data-stu-id="acce7-204">You can specify a collection property to be the XAML content property.</span></span> <span data-ttu-id="acce7-205">這會導致使用該屬性，藉此，物件項目可以有一或多個子項目，而不需要任何中介集合物件項目或屬性項目標記。</span><span class="sxs-lookup"><span data-stu-id="acce7-205">This results in a usage for that property whereby the object element can have one or more child elements, without any intervening collection object elements or property element tags.</span></span> <span data-ttu-id="acce7-206">這些項目則是視為 XAML 內容屬性的值，並新增至支援集合執行個體。</span><span class="sxs-lookup"><span data-stu-id="acce7-206">These elements are then treated as the value for the XAML content property and added to the backing collection instance.</span></span>  
  
 <span data-ttu-id="acce7-207">一些現有的 XAML 內容屬性使用 `Object` 屬性類型。</span><span class="sxs-lookup"><span data-stu-id="acce7-207">Some existing XAML content properties use the property type of `Object`.</span></span> <span data-ttu-id="acce7-208">這會啟用可接受基本值（例如 <xref:System.String>）以及取得單一參考物件值的 XAML 內容屬性。</span><span class="sxs-lookup"><span data-stu-id="acce7-208">This enables a XAML content property that can take primitive values such as a <xref:System.String> as well as taking a single reference object value.</span></span> <span data-ttu-id="acce7-209">如果您遵循此模型，則您的類型會負責類型判斷，以及可能類型的處理。</span><span class="sxs-lookup"><span data-stu-id="acce7-209">If you follow this model, your type is responsible for type determination as well as the handling of possible types.</span></span> <span data-ttu-id="acce7-210"><xref:System.Object> 內容類型的一般原因是要支援簡單的方法，將物件內容新增為字串（接收預設的呈現法），或加入物件內容的先進方法來指定非預設的呈現方式，或其他資料。</span><span class="sxs-lookup"><span data-stu-id="acce7-210">The typical reason for an <xref:System.Object> content type is to support both a simple means of adding object content as a string (which receives a default presentation treatment), or an advanced means of adding object content that specifies a non-default presentation or additional data.</span></span>  
  
<a name="Serializing"></a>   
## <a name="serializing-xaml"></a><span data-ttu-id="acce7-211">序列化 XAML</span><span class="sxs-lookup"><span data-stu-id="acce7-211">Serializing XAML</span></span>  
 <span data-ttu-id="acce7-212">在特定情況下，例如，如果您是控制項作者，則可能也要確保可在 XAML 中具現化的任何物件表示也都可以序列化回對等的 XAML 標記。</span><span class="sxs-lookup"><span data-stu-id="acce7-212">For certain scenarios, such as if you are a control author, you may also want to assure that any object representation that can be instantiated in XAML can also be serialized back to equivalent XAML markup.</span></span> <span data-ttu-id="acce7-213">本主題未描述序列化需求。</span><span class="sxs-lookup"><span data-stu-id="acce7-213">Serialization requirements are not described in this topic.</span></span> <span data-ttu-id="acce7-214">請參閱[控制項撰寫概觀](../controls/control-authoring-overview.md)和[項目樹狀結構和序列化](element-tree-and-serialization.md)。</span><span class="sxs-lookup"><span data-stu-id="acce7-214">See [Control Authoring Overview](../controls/control-authoring-overview.md) and [Element Tree and Serialization](element-tree-and-serialization.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="acce7-215">請參閱</span><span class="sxs-lookup"><span data-stu-id="acce7-215">See also</span></span>

- [<span data-ttu-id="acce7-216">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="acce7-216">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="acce7-217">自訂相依性屬性</span><span class="sxs-lookup"><span data-stu-id="acce7-217">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="acce7-218">控制項撰寫概觀</span><span class="sxs-lookup"><span data-stu-id="acce7-218">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="acce7-219">基底項目概觀</span><span class="sxs-lookup"><span data-stu-id="acce7-219">Base Elements Overview</span></span>](base-elements-overview.md)
- [<span data-ttu-id="acce7-220">XAML 載入和相依性屬性</span><span class="sxs-lookup"><span data-stu-id="acce7-220">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
