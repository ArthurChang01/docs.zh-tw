---
title: "應用程式啟動時間"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- splash screen [WPF], startup time
- WPF [WPF], startup time
- startup time [WPF]
- application startup [WPF]
- performance [WPF], startup time
ms.assetid: f0ec58d8-626f-4d8a-9873-c20f95e08b96
caps.latest.revision: "11"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: e1e39bf6db28290b7cba600ea1d2012c58633587
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/21/2017
---
# <a name="application-startup-time"></a><span data-ttu-id="dcac7-102">應用程式啟動時間</span><span class="sxs-lookup"><span data-stu-id="dcac7-102">Application Startup Time</span></span>
<span data-ttu-id="dcac7-103">WPF 應用程式啟動所需的時間可能有很大的差異。</span><span class="sxs-lookup"><span data-stu-id="dcac7-103">The amount of time that is required for a WPF application to start can vary greatly.</span></span> <span data-ttu-id="dcac7-104">本主題說明各種技術來縮短 Windows Presentation Foundation (WPF) 應用程式的認知和實際啟動時間。</span><span class="sxs-lookup"><span data-stu-id="dcac7-104">This topic describes various techniques for reducing the perceived and actual startup time for a Windows Presentation Foundation (WPF) application.</span></span>  
  
## <a name="understanding-cold-startup-and-warm-startup"></a><span data-ttu-id="dcac7-105">了解冷啟動和暖啟動</span><span class="sxs-lookup"><span data-stu-id="dcac7-105">Understanding Cold Startup and Warm Startup</span></span>  
 <span data-ttu-id="dcac7-106">冷啟動發生於系統重新開機後第一次啟動應用程式，或您啟動應用程式，關閉它，然後經過很長一段時間後重新啟動。</span><span class="sxs-lookup"><span data-stu-id="dcac7-106">Cold startup occurs when your application starts for the first time after a system reboot, or when you start your application, close it, and then start it again after a long period of time.</span></span> <span data-ttu-id="dcac7-107">應用程式啟動時，如果 Windows 記憶體管理員的待命清單中沒有必要的分頁 (程式碼、靜態資料、登錄等)，就會發生分頁錯誤。</span><span class="sxs-lookup"><span data-stu-id="dcac7-107">When an application starts, if the required pages (code, static data, registry, etc) are not present in the Windows memory manager's standby list, page faults occur.</span></span> <span data-ttu-id="dcac7-108">將頁面放入記憶體需要存取磁碟。</span><span class="sxs-lookup"><span data-stu-id="dcac7-108">Disk access is required to bring the pages into memory.</span></span>  
  
 <span data-ttu-id="dcac7-109">暖啟動發生於主要通用語言執行平台 (CLR) 元件的大部分頁面已經載入記憶體中，可節省寶貴的磁碟存取時間。</span><span class="sxs-lookup"><span data-stu-id="dcac7-109">Warm startup occurs when most of the pages for the main common language runtime (CLR) components are already loaded in memory, which saves expensive disk access time.</span></span> <span data-ttu-id="dcac7-110">這就是為什麼 Managed 應用程式第二次執行時較快啟動。</span><span class="sxs-lookup"><span data-stu-id="dcac7-110">That is why a managed application starts faster when it runs a second time.</span></span>  
  
## <a name="implement-a-splash-screen"></a><span data-ttu-id="dcac7-111">實作啟動顯示畫面</span><span class="sxs-lookup"><span data-stu-id="dcac7-111">Implement a Splash Screen</span></span>  
 <span data-ttu-id="dcac7-112">如果從啟動應用程式到顯示第一個 UI 之間，有很明顯、無可避免的延遲時間，請使用「啟動顯示畫面」最佳化感知的啟動時間。</span><span class="sxs-lookup"><span data-stu-id="dcac7-112">In cases where there is a significant, unavoidable delay between starting an application and displaying the first UI, optimize the perceived startup time by using a *splash screen*.</span></span> <span data-ttu-id="dcac7-113">這種方法會在使用者啟動應用程式時，幾乎立即顯示影像。</span><span class="sxs-lookup"><span data-stu-id="dcac7-113">This approach displays an image almost immediately after the user starts the application.</span></span> <span data-ttu-id="dcac7-114">當應用程式準備好顯示第一個 UI 時，啟動顯示畫面會消失。</span><span class="sxs-lookup"><span data-stu-id="dcac7-114">When the application is ready to display its first UI, the splash screen fades.</span></span> <span data-ttu-id="dcac7-115">從開始[!INCLUDE[net_v35SP1_short](../../../../includes/net-v35sp1-short-md.md)]，您可以使用<xref:System.Windows.SplashScreen>類別來實作啟動顯示畫面。</span><span class="sxs-lookup"><span data-stu-id="dcac7-115">Starting in the [!INCLUDE[net_v35SP1_short](../../../../includes/net-v35sp1-short-md.md)], you can use the <xref:System.Windows.SplashScreen> class to implement a splash screen.</span></span> <span data-ttu-id="dcac7-116">如需詳細資訊，請參閱[將啟動顯示畫面新增至 WPF 應用程式](../../../../docs/framework/wpf/app-development/how-to-add-a-splash-screen-to-a-wpf-application.md)。</span><span class="sxs-lookup"><span data-stu-id="dcac7-116">For more information, see [Add a Splash Screen to a WPF Application](../../../../docs/framework/wpf/app-development/how-to-add-a-splash-screen-to-a-wpf-application.md).</span></span>  
  
 <span data-ttu-id="dcac7-117">您也可以使用原生 Win32 圖形，以實作您自己的啟動顯示畫面。</span><span class="sxs-lookup"><span data-stu-id="dcac7-117">You can also implement your own splash screen by using native Win32 graphics.</span></span> <span data-ttu-id="dcac7-118">顯示您之前的實作<xref:System.Windows.Application.Run%2A>方法呼叫。</span><span class="sxs-lookup"><span data-stu-id="dcac7-118">Display your implementation before the <xref:System.Windows.Application.Run%2A> method is called.</span></span>  
  
## <a name="analyze-the-startup-code"></a><span data-ttu-id="dcac7-119">分析啟始程式碼</span><span class="sxs-lookup"><span data-stu-id="dcac7-119">Analyze the Startup Code</span></span>  
 <span data-ttu-id="dcac7-120">判斷冷啟動緩慢的原因。</span><span class="sxs-lookup"><span data-stu-id="dcac7-120">Determine the reason for a slow cold startup.</span></span> <span data-ttu-id="dcac7-121">磁碟 I/O 可能是原因，但不一定如此。</span><span class="sxs-lookup"><span data-stu-id="dcac7-121">Disk I/O may be responsible, but this is not always the case.</span></span> <span data-ttu-id="dcac7-122">一般情況下，您應該盡可能不要使用外部資源，例如網路、Web 服務或磁碟。</span><span class="sxs-lookup"><span data-stu-id="dcac7-122">In general, you should minimize the use of external resources, such as network, Web services, or disk.</span></span>  
  
 <span data-ttu-id="dcac7-123">在測試之前，請確認沒有其他正在執行的應用程式或服務使用 Managed 程式碼或 WPF 程式碼。</span><span class="sxs-lookup"><span data-stu-id="dcac7-123">Before you test, verify that no other running applications or services use managed code or WPF code.</span></span>  
  
 <span data-ttu-id="dcac7-124">重新開機之後立即啟動 WPF 應用程式，判斷它花多少時間才出現。</span><span class="sxs-lookup"><span data-stu-id="dcac7-124">Start your WPF application immediately after a reboot, and determine how long it takes to display.</span></span> <span data-ttu-id="dcac7-125">如果後續啟動您的應用程式 (暖啟動) 都非常快速，則冷啟動問題極可能是 I/O 引起。</span><span class="sxs-lookup"><span data-stu-id="dcac7-125">If all subsequent launches of your application (warm startup) are much faster, your cold startup issue is most likely caused by I/O.</span></span>  
  
 <span data-ttu-id="dcac7-126">如果應用程式的冷啟動問題與 I/O 無關，很可能是您的應用程式執行一些冗長的初始化或計算、等待某個事件完成，或在啟動時需要大量 JIT 編譯。</span><span class="sxs-lookup"><span data-stu-id="dcac7-126">If your application's cold startup issue is not related to I/O, it is likely that your application performs some lengthy initialization or computation, waits for some event to complete, or requires a lot of JIT compilation at startup.</span></span> <span data-ttu-id="dcac7-127">下列章節詳述其中一些狀況。</span><span class="sxs-lookup"><span data-stu-id="dcac7-127">The following sections describe some of these situations in more detail.</span></span>  
  
## <a name="optimize-module-loading"></a><span data-ttu-id="dcac7-128">最佳化模組載入</span><span class="sxs-lookup"><span data-stu-id="dcac7-128">Optimize Module Loading</span></span>  
 <span data-ttu-id="dcac7-129">使用處理序總管 (Procexp.exe) 和 Tlist.exe 之類的工具，判斷您的應用程式載入哪些模組。</span><span class="sxs-lookup"><span data-stu-id="dcac7-129">Use tools such as Process Explorer (Procexp.exe) and Tlist.exe to determine which modules your application loads.</span></span> <span data-ttu-id="dcac7-130">`Tlist <pid>` 命令會顯示處理序載入的所有模組。</span><span class="sxs-lookup"><span data-stu-id="dcac7-130">The command `Tlist <pid>` shows all the modules that are loaded by a process.</span></span>  
  
 <span data-ttu-id="dcac7-131">例如，如果您未連線至網路，但看到載入 System.Web.dll，表示您的應用程式中有模組參考這個組件。</span><span class="sxs-lookup"><span data-stu-id="dcac7-131">For example, if you are not connecting to the Web and you see that System.Web.dll is loaded, then there is a module in your application that references this assembly.</span></span> <span data-ttu-id="dcac7-132">請確定該參考是必要。</span><span class="sxs-lookup"><span data-stu-id="dcac7-132">Check to make sure that the reference is necessary.</span></span>  
  
 <span data-ttu-id="dcac7-133">如果應用程式有多個模組，請將它們合併成單一模組。</span><span class="sxs-lookup"><span data-stu-id="dcac7-133">If your application has multiple modules, merge them into a single module.</span></span> <span data-ttu-id="dcac7-134">這個方法需要的 CLR 組件載入負荷較少。</span><span class="sxs-lookup"><span data-stu-id="dcac7-134">This approach requires less CLR assembly-loading overhead.</span></span> <span data-ttu-id="dcac7-135">較少的組件也表示 CLR 維護較少的狀態。</span><span class="sxs-lookup"><span data-stu-id="dcac7-135">Fewer assemblies also mean that the CLR maintains less state.</span></span>  
  
## <a name="defer-initialization-operations"></a><span data-ttu-id="dcac7-136">延後初始化作業</span><span class="sxs-lookup"><span data-stu-id="dcac7-136">Defer Initialization Operations</span></span>  
 <span data-ttu-id="dcac7-137">請考慮將初始化程式碼延後到主要應用程式視窗出現之後。</span><span class="sxs-lookup"><span data-stu-id="dcac7-137">Consider postponing initialization code until after the main application window is rendered.</span></span>  
  
 <span data-ttu-id="dcac7-138">請注意，初始化可能在類別建構函式內執行，如果初始化程式碼參考其他類別，可能會造成連鎖效應而執行許多類別建構函式。</span><span class="sxs-lookup"><span data-stu-id="dcac7-138">Be aware that initialization may be performed inside a class constructor, and if the initialization code references other classes, it can cause a cascading effect in which many class constructors are executed.</span></span>  
  
## <a name="avoid-application-configuration"></a><span data-ttu-id="dcac7-139">避免應用程式組態</span><span class="sxs-lookup"><span data-stu-id="dcac7-139">Avoid Application Configuration</span></span>  
 <span data-ttu-id="dcac7-140">請考慮避免應用程式組態。</span><span class="sxs-lookup"><span data-stu-id="dcac7-140">Consider avoiding application configuration.</span></span> <span data-ttu-id="dcac7-141">例如，如果應用程式有簡單的組態需求及嚴格的啟動時間目標，則登錄項目或簡單的 INI 檔案可能是較快的啟動替代方法。</span><span class="sxs-lookup"><span data-stu-id="dcac7-141">For example, if an application has simple configuration requirements and has strict startup time goals, registry entries or a simple INI file may be a faster startup alternative.</span></span>  
  
## <a name="utilize-the-gac"></a><span data-ttu-id="dcac7-142">利用 GAC</span><span class="sxs-lookup"><span data-stu-id="dcac7-142">Utilize the GAC</span></span>  
 <span data-ttu-id="dcac7-143">如果組件未安裝在全域組件快取 (GAC) 中，則強式命名組件的雜湊驗證和 Ngen 映像驗證 (如果電腦上有該組件的原生映像) 會造成延遲。</span><span class="sxs-lookup"><span data-stu-id="dcac7-143">If an assembly is not installed in the Global Assembly Cache (GAC), there are delays caused by hash verification of strong-named assemblies and by Ngen image validation if a native image for that assembly is available on the computer.</span></span> <span data-ttu-id="dcac7-144">安裝在 GAC 中的所有組件會跳過強式名稱驗證。</span><span class="sxs-lookup"><span data-stu-id="dcac7-144">Strong-name verification is skipped for all assemblies installed in the GAC.</span></span> <span data-ttu-id="dcac7-145">如需詳細資訊，請參閱 [Gacutil.exe (全域組件快取工具)](../../../../docs/framework/tools/gacutil-exe-gac-tool.md)。</span><span class="sxs-lookup"><span data-stu-id="dcac7-145">For more information, see [Gacutil.exe (Global Assembly Cache Tool)](../../../../docs/framework/tools/gacutil-exe-gac-tool.md).</span></span>  
  
## <a name="use-ngenexe"></a><span data-ttu-id="dcac7-146">使用 Ngen.exe</span><span class="sxs-lookup"><span data-stu-id="dcac7-146">Use Ngen.exe</span></span>  
 <span data-ttu-id="dcac7-147">請考慮在您的應用程式上使用原生映像產生器 (Ngen.exe)。</span><span class="sxs-lookup"><span data-stu-id="dcac7-147">Consider using the Native Image Generator (Ngen.exe) on your application.</span></span> <span data-ttu-id="dcac7-148">使用 Ngen.exe 表示以 CPU 消耗換取更多磁碟存取，因為由 Ngen.exe 產生的原生映像可能大於 MSIL 映像。</span><span class="sxs-lookup"><span data-stu-id="dcac7-148">Using Ngen.exe means trading CPU consumption for more disk access because the native image generated by Ngen.exe is likely to be larger than the MSIL image.</span></span>  
  
 <span data-ttu-id="dcac7-149">若要改善暖啟動時間，您在應用程式上應該一律使用 Ngen.exe，因為這可避免應用程式程式碼 JIT 編譯的 CPU 成本。</span><span class="sxs-lookup"><span data-stu-id="dcac7-149">To improve the warm startup time, you should always use Ngen.exe on your application, because this avoids the CPU cost of JIT compilation of the application code.</span></span>  
  
 <span data-ttu-id="dcac7-150">在某些冷啟動情節中，使用 Ngen.exe 也很有用。</span><span class="sxs-lookup"><span data-stu-id="dcac7-150">In some cold startup scenarios, using Ngen.exe can also be helpful.</span></span> <span data-ttu-id="dcac7-151">這是因為不需要載入 JIT 編譯器 (mscorjit.dll)。</span><span class="sxs-lookup"><span data-stu-id="dcac7-151">This is because the JIT compiler (mscorjit.dll) does not have to be loaded.</span></span>  
  
 <span data-ttu-id="dcac7-152">同時有 Ngen 和 JIT 模組可能得到最差效果。</span><span class="sxs-lookup"><span data-stu-id="dcac7-152">Having both Ngen and JIT modules can have the worst effect.</span></span> <span data-ttu-id="dcac7-153">這是因為必須載入 mscorjit.dll，而且當 JIT 編譯器處理您的程式碼時，JIT 編譯器在讀取組件的中繼資料時必須存取 Ngen 映像中的許多分頁。</span><span class="sxs-lookup"><span data-stu-id="dcac7-153">This is because mscorjit.dll must be loaded, and when the JIT compiler works on your code, many pages in the Ngen images must be accessed when the JIT compiler reads the assemblies' metadata.</span></span>  
  
### <a name="ngen-and-clickonce"></a><span data-ttu-id="dcac7-154">Ngen 和 ClickOnce</span><span class="sxs-lookup"><span data-stu-id="dcac7-154">Ngen and ClickOnce</span></span>  
 <span data-ttu-id="dcac7-155">您打算部署應用程式的方式也會造成載入時間不同。</span><span class="sxs-lookup"><span data-stu-id="dcac7-155">The way you plan to deploy your application can also make a difference in load time.</span></span> [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)]<span data-ttu-id="dcac7-156"> 應用程式部署不支援 Ngen。</span><span class="sxs-lookup"><span data-stu-id="dcac7-156"> application deployment does not support Ngen.</span></span> <span data-ttu-id="dcac7-157">如果您決定對應用程式使用 Ngen.exe，您必須使用其他部署機制，例如 Windows Installer。</span><span class="sxs-lookup"><span data-stu-id="dcac7-157">If you decide to use Ngen.exe for your application, you will have to use another deployment mechanism, such as Windows Installer.</span></span>  
  
 <span data-ttu-id="dcac7-158">如需詳細資訊，請參閱 [Ngen.exe (原生映像產生器)](../../../../docs/framework/tools/ngen-exe-native-image-generator.md)。</span><span class="sxs-lookup"><span data-stu-id="dcac7-158">For more information, see [Ngen.exe (Native Image Generator)](../../../../docs/framework/tools/ngen-exe-native-image-generator.md).</span></span>  
  
### <a name="rebasing-and-dll-address-collisions"></a><span data-ttu-id="dcac7-159">重設基底和 DLL 位址衝突</span><span class="sxs-lookup"><span data-stu-id="dcac7-159">Rebasing and DLL Address Collisions</span></span>  
 <span data-ttu-id="dcac7-160">如果您使用 Ngen.exe，請注意，當原生映像載入記憶體中時，可能會發生重定基底。</span><span class="sxs-lookup"><span data-stu-id="dcac7-160">If you use Ngen.exe, be aware that rebasing can occur when the native images are loaded in memory.</span></span> <span data-ttu-id="dcac7-161">如果因為位址範圍已配置而未於慣用基底位址載入 DLL，Windows 載入器會將其載入其他位址，作業會很耗時。</span><span class="sxs-lookup"><span data-stu-id="dcac7-161">If a DLL is not loaded at its preferred base address because that address range is already allocated, the Windows loader will load it at another address, which can be a time-consuming operation.</span></span>  
  
 <span data-ttu-id="dcac7-162">您可以使用虛擬位址傾印 (Vadump.exe) 工具，檢查是否有所有頁面都是私用的模組。</span><span class="sxs-lookup"><span data-stu-id="dcac7-162">You can use the Virtual Address Dump (Vadump.exe) tool to check if there are modules in which all the pages are private.</span></span> <span data-ttu-id="dcac7-163">如果是這樣，模組可能已重定基底到不同的位址。</span><span class="sxs-lookup"><span data-stu-id="dcac7-163">If this is the case, the module may have been rebased to a different address.</span></span> <span data-ttu-id="dcac7-164">因此，無法共用其頁面。</span><span class="sxs-lookup"><span data-stu-id="dcac7-164">Therefore, its pages cannot be shared.</span></span>  
  
 <span data-ttu-id="dcac7-165">如需有關如何設定基底位址的詳細資訊，請參閱 [Ngen.exe (原生映像產生器)](../../../../docs/framework/tools/ngen-exe-native-image-generator.md)。</span><span class="sxs-lookup"><span data-stu-id="dcac7-165">For more information about how to set the base address, see [Ngen.exe (Native Image Generator)](../../../../docs/framework/tools/ngen-exe-native-image-generator.md).</span></span>  
  
## <a name="optimize-authenticode"></a><span data-ttu-id="dcac7-166">最佳化 Authenticode</span><span class="sxs-lookup"><span data-stu-id="dcac7-166">Optimize Authenticode</span></span>  
 <span data-ttu-id="dcac7-167">Authenticode 驗證會增加啟動時間。</span><span class="sxs-lookup"><span data-stu-id="dcac7-167">Authenticode verification adds to the startup time.</span></span> <span data-ttu-id="dcac7-168">Authenticode 簽署的組件必須經過憑證授權單位 (CA) 驗證。</span><span class="sxs-lookup"><span data-stu-id="dcac7-168">Authenticode-signed assemblies have to be verified with the certification authority (CA).</span></span> <span data-ttu-id="dcac7-169">這項驗證可能耗費時間，因為需要連線至網路許多次來下載目前的憑證撤銷清單。</span><span class="sxs-lookup"><span data-stu-id="dcac7-169">This verification can be time consuming, because it can require connecting to the network several times to download current certificate revocation lists.</span></span> <span data-ttu-id="dcac7-170">這也可確保受信任根的路徑上存在完整的有效憑證鏈結。</span><span class="sxs-lookup"><span data-stu-id="dcac7-170">It also makes sure that there is a full chain of valid certificates on the path to a trusted root.</span></span> <span data-ttu-id="dcac7-171">這意味著載入組件時會延遲幾秒鐘。</span><span class="sxs-lookup"><span data-stu-id="dcac7-171">This can translate to several seconds of delay while the assembly is being loaded.</span></span>  
  
 <span data-ttu-id="dcac7-172">請考慮在用戶端電腦上安裝 CA 憑證，或盡可能避免使用 Authenticode。</span><span class="sxs-lookup"><span data-stu-id="dcac7-172">Consider installing the CA certificate on the client computer, or avoid using Authenticode when it is possible.</span></span> <span data-ttu-id="dcac7-173">如果您知道您的應用程式不需要發行者辨識項，則不需要付出簽章驗證的成本。</span><span class="sxs-lookup"><span data-stu-id="dcac7-173">If you know that your application does not need the publisher evidence, you do not have to pay the cost of signature verification.</span></span>  
  
 <span data-ttu-id="dcac7-174">從 [!INCLUDE[net_v35_short](../../../../includes/net-v35-short-md.md)] 開始，有一個組態選項可略過 Authenticode 驗證。</span><span class="sxs-lookup"><span data-stu-id="dcac7-174">Starting in [!INCLUDE[net_v35_short](../../../../includes/net-v35-short-md.md)], there is a configuration option that allows the Authenticode verification to be bypassed.</span></span> <span data-ttu-id="dcac7-175">若要這樣做，請在 app.exe.config 檔案中新增下列設定︰</span><span class="sxs-lookup"><span data-stu-id="dcac7-175">To do this, add the following setting to the app.exe.config file:</span></span>  
  
```xml  
<configuration>  
    <runtime>  
        <generatePublisherEvidence enabled="false"/>   
    </runtime>  
</configuration>  
```  
  
 <span data-ttu-id="dcac7-176">如需詳細資訊，請參閱 [\<generatePublisherEvidence> 元素](../../../../docs/framework/configure-apps/file-schema/runtime/generatepublisherevidence-element.md)。</span><span class="sxs-lookup"><span data-stu-id="dcac7-176">For more information, see [\<generatePublisherEvidence> Element](../../../../docs/framework/configure-apps/file-schema/runtime/generatepublisherevidence-element.md).</span></span>  
  
## <a name="compare-performance-on-windows-vista"></a><span data-ttu-id="dcac7-177">在 Windows Vista 上比較效能</span><span class="sxs-lookup"><span data-stu-id="dcac7-177">Compare Performance on Windows Vista</span></span>  
 <span data-ttu-id="dcac7-178">Windows Vista 的記憶體管理員有一項稱為 SuperFetch 的技術。</span><span class="sxs-lookup"><span data-stu-id="dcac7-178">The memory manager in Windows Vista has a technology called SuperFetch.</span></span> <span data-ttu-id="dcac7-179">SuperFetch 會分析一段時間的使用模式，以判斷特定使用者的最佳記憶體內容。</span><span class="sxs-lookup"><span data-stu-id="dcac7-179">SuperFetch analyzes memory usage patterns over time to determine the optimal memory content for a specific user.</span></span> <span data-ttu-id="dcac7-180">它會持續運作來隨時維護該內容。</span><span class="sxs-lookup"><span data-stu-id="dcac7-180">It works continuously to maintain that content at all times.</span></span>  
  
 <span data-ttu-id="dcac7-181">這種方式不同於 Windows XP 中所使用的預先提取技術，此技術會預先將資料載入記憶體中，但不分析使用模式。</span><span class="sxs-lookup"><span data-stu-id="dcac7-181">This approach differs from the pre-fetch technique used in Windows XP, which preloads data into memory without analyzing usage patterns.</span></span> <span data-ttu-id="dcac7-182">經過一段時間，如果使用者經常在 Windows Vista 上使用您的 WPF 應用程式，應用程式的冷啟動時間會改善。</span><span class="sxs-lookup"><span data-stu-id="dcac7-182">Over time, if the user uses your WPF application frequently on Windows Vista, the cold startup time of your application may improve.</span></span>  
  
## <a name="use-appdomains-efficiently"></a><span data-ttu-id="dcac7-183">有效率地使用 AppDomain</span><span class="sxs-lookup"><span data-stu-id="dcac7-183">Use AppDomains Efficiently</span></span>  
 <span data-ttu-id="dcac7-184">可能的話，請將組件載入定義域中性程式碼區域中，以確保應用程式的所有 AppDomains 中使用原生映像 (如果有的話)。</span><span class="sxs-lookup"><span data-stu-id="dcac7-184">If possible, load assemblies into a domain-neutral code area to make sure that the native image, if one exists, is used in all AppDomains created in the application.</span></span>  
  
 <span data-ttu-id="dcac7-185">為了達到最佳效能，請減少跨網域呼叫，以強制達成有效率的跨網域通訊。</span><span class="sxs-lookup"><span data-stu-id="dcac7-185">For the best performance, enforce efficient cross-domain communication by reducing cross-domain calls.</span></span> <span data-ttu-id="dcac7-186">可能的話，請使用不含引數或有基本型別引數的呼叫。</span><span class="sxs-lookup"><span data-stu-id="dcac7-186">When possible, use calls without arguments or with primitive type arguments.</span></span>  
  
## <a name="use-the-neutralresourceslanguage-attribute"></a><span data-ttu-id="dcac7-187">使用 NeutralResourcesLanguage 屬性</span><span class="sxs-lookup"><span data-stu-id="dcac7-187">Use the NeutralResourcesLanguage Attribute</span></span>  
 <span data-ttu-id="dcac7-188">使用<xref:System.Resources.NeutralResourcesLanguageAttribute>指定中性文化特性的<xref:System.Resources.ResourceManager>。</span><span class="sxs-lookup"><span data-stu-id="dcac7-188">Use the <xref:System.Resources.NeutralResourcesLanguageAttribute> to specify the neutral culture for the <xref:System.Resources.ResourceManager>.</span></span> <span data-ttu-id="dcac7-189">這個方法可避免組件查閱失敗。</span><span class="sxs-lookup"><span data-stu-id="dcac7-189">This approach avoids unsuccessful assembly lookups.</span></span>  
  
## <a name="use-the-binaryformatter-class-for-serialization"></a><span data-ttu-id="dcac7-190">使用 BinaryFormatter 類別進行序列化</span><span class="sxs-lookup"><span data-stu-id="dcac7-190">Use the BinaryFormatter Class for Serialization</span></span>  
 <span data-ttu-id="dcac7-191">如果您必須使用序列化，使用<xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>類別而不是<xref:System.Xml.Serialization.XmlSerializer>類別。</span><span class="sxs-lookup"><span data-stu-id="dcac7-191">If you must use serialization, use the <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> class instead of the <xref:System.Xml.Serialization.XmlSerializer> class.</span></span> <span data-ttu-id="dcac7-192"><xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter>類別實作在基底類別程式庫 (BCL) mscorlib.dll 組件中。</span><span class="sxs-lookup"><span data-stu-id="dcac7-192">The <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> class is implemented in the Base Class Library (BCL) in the mscorlib.dll assembly.</span></span> <span data-ttu-id="dcac7-193"><xref:System.Xml.Serialization.XmlSerializer>實作 System.Xml.dll 組件，這可能是其他 DLL，用於載入。</span><span class="sxs-lookup"><span data-stu-id="dcac7-193">The <xref:System.Xml.Serialization.XmlSerializer> is implemented in the System.Xml.dll assembly, which might be an additional DLL to load.</span></span>  
  
 <span data-ttu-id="dcac7-194">如果您必須使用<xref:System.Xml.Serialization.XmlSerializer>類別，您可以達到較佳的效能，如果您預先產生序列化組件。</span><span class="sxs-lookup"><span data-stu-id="dcac7-194">If you must use the <xref:System.Xml.Serialization.XmlSerializer> class, you can achieve better performance if you pre-generate the serialization assembly.</span></span>  
  
## <a name="configure-clickonce-to-check-for-updates-after-startup"></a><span data-ttu-id="dcac7-195">將 ClickOnce 設定為啟動之後檢查更新</span><span class="sxs-lookup"><span data-stu-id="dcac7-195">Configure ClickOnce to Check for Updates After Startup</span></span>  
 <span data-ttu-id="dcac7-196">如果您的應用程式使用 [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)]，請將 [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] 設定成在應用程式啟動之後檢查部署網站是否有更新，以避免在啟動時存取網路。</span><span class="sxs-lookup"><span data-stu-id="dcac7-196">If your application uses [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)], avoid network access on startup by configuring [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] to check the deployment site for updates after the application starts.</span></span>  
  
 <span data-ttu-id="dcac7-197">如果您使用 XAML 瀏覽器應用程式 (XBAP) 模型，請記住，即使 XBAP 已在 [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] 快取中，[!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] 仍會檢查部署網站是否有更新。</span><span class="sxs-lookup"><span data-stu-id="dcac7-197">If you use the XAML browser application (XBAP) model, keep in mind that [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] checks the deployment site for updates even if the XBAP is already in the [!INCLUDE[ndptecclick](../../../../includes/ndptecclick-md.md)] cache.</span></span> <span data-ttu-id="dcac7-198">如需詳細資訊，請參閱 [ClickOnce Security and Deployment](/visualstudio/deployment/clickonce-security-and-deployment)。</span><span class="sxs-lookup"><span data-stu-id="dcac7-198">For more information, see [ClickOnce Security and Deployment](/visualstudio/deployment/clickonce-security-and-deployment).</span></span>  
  
## <a name="configure-the-presentationfontcache-service-to-start-automatically"></a><span data-ttu-id="dcac7-199">將 PresentationFontCache 服務設定為自動啟動</span><span class="sxs-lookup"><span data-stu-id="dcac7-199">Configure the PresentationFontCache Service to Start Automatically</span></span>  
 <span data-ttu-id="dcac7-200">重新開機後第一個執行的 WPF 應用程式是 PresentationFontCache 服務。</span><span class="sxs-lookup"><span data-stu-id="dcac7-200">The first WPF application to run after a reboot is the PresentationFontCache service.</span></span> <span data-ttu-id="dcac7-201">此服務會快取系統字型、改善字型存取，並改善整體效能。</span><span class="sxs-lookup"><span data-stu-id="dcac7-201">The service caches the system fonts, improves font access, and improves overall performance.</span></span> <span data-ttu-id="dcac7-202">啟動服務時會產生額外負荷，在一些受控制的環境中，請考慮將服務設定成在系統重新開機時自動啟動。</span><span class="sxs-lookup"><span data-stu-id="dcac7-202">There is an overhead in starting the service, and in some controlled environments, consider configuring the service to start automatically when the system reboots.</span></span>  
  
## <a name="set-data-binding-programmatically"></a><span data-ttu-id="dcac7-203">以程式設計的方式設定資料繫結</span><span class="sxs-lookup"><span data-stu-id="dcac7-203">Set Data Binding Programmatically</span></span>  
 <span data-ttu-id="dcac7-204">而不是使用 XAML 設定<xref:System.Windows.FrameworkElement.DataContext%2A>以宣告方式主要視窗中，請考慮將其設定以程式設計方式在<xref:System.Windows.Application.OnActivated%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="dcac7-204">Instead of using XAML to set the <xref:System.Windows.FrameworkElement.DataContext%2A> declaratively for the main window, consider setting it programmatically in the <xref:System.Windows.Application.OnActivated%2A> method.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="dcac7-205">另請參閱</span><span class="sxs-lookup"><span data-stu-id="dcac7-205">See Also</span></span>  
 <xref:System.Windows.SplashScreen>  
 <xref:System.AppDomain>  
 <xref:System.Resources.NeutralResourcesLanguageAttribute>  
 <xref:System.Resources.ResourceManager>  
 [<span data-ttu-id="dcac7-206">在 WPF 應用程式中加入啟動顯示畫面</span><span class="sxs-lookup"><span data-stu-id="dcac7-206">Add a Splash Screen to a WPF Application</span></span>](../../../../docs/framework/wpf/app-development/how-to-add-a-splash-screen-to-a-wpf-application.md)  
 [<span data-ttu-id="dcac7-207">Ngen.exe (原生映像產生器)</span><span class="sxs-lookup"><span data-stu-id="dcac7-207">Ngen.exe (Native Image Generator)</span></span>](../../../../docs/framework/tools/ngen-exe-native-image-generator.md)  
 [<span data-ttu-id="dcac7-208">\<generatePublisherEvidence> 元素</span><span class="sxs-lookup"><span data-stu-id="dcac7-208">\<generatePublisherEvidence> Element</span></span>](../../../../docs/framework/configure-apps/file-schema/runtime/generatepublisherevidence-element.md)
