---
title: WPF 中的程式碼後置和 XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], code-behind
- code-behind files [WPF], XAML
ms.assetid: 9df6d3c9-aed3-471c-af36-6859b19d999f
ms.openlocfilehash: 4a77060661cb0d71b0209cbcdeba23ffc2c6e5c7
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/08/2019
ms.locfileid: "59088559"
---
# <a name="code-behind-and-xaml-in-wpf"></a><span data-ttu-id="290b0-102">WPF 中的程式碼後置和 XAML</span><span class="sxs-lookup"><span data-stu-id="290b0-102">Code-Behind and XAML in WPF</span></span>
<a name="introduction"></a> <span data-ttu-id="290b0-103">程式碼後置指的是用來描述與標記定義的物件，聯結的程式碼時[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]頁面是進行標記編譯。</span><span class="sxs-lookup"><span data-stu-id="290b0-103">Code-behind is a term used to describe the code that is joined with markup-defined objects, when a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] page is markup-compiled.</span></span> <span data-ttu-id="290b0-104">本主題描述程式碼後置的需求，以及在程式碼的替代的內嵌程式碼機制[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="290b0-104">This topic describes requirements for code-behind as well as an alternative inline code mechanism for code in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 <span data-ttu-id="290b0-105">此主題包括下列章節：</span><span class="sxs-lookup"><span data-stu-id="290b0-105">This topic contains the following sections:</span></span>  
  
-   [<span data-ttu-id="290b0-106">必要條件</span><span class="sxs-lookup"><span data-stu-id="290b0-106">Prerequisites</span></span>](#Prerequisites)  
  
-   [<span data-ttu-id="290b0-107">程式碼後置和 XAML 語言</span><span class="sxs-lookup"><span data-stu-id="290b0-107">Code-Behind and the XAML Language</span></span>](#codebehind_and_the_xaml_language)  
  
-   [<span data-ttu-id="290b0-108">程式碼後置、 事件處理常式，並在 WPF 中的部分類別需求</span><span class="sxs-lookup"><span data-stu-id="290b0-108">Code-behind, Event Handler, and Partial Class Requirements in WPF</span></span>](#Code_behind__Event_Handler__and_Partial_Class)  
  
-   [<span data-ttu-id="290b0-109">x:Code</span><span class="sxs-lookup"><span data-stu-id="290b0-109">x:Code</span></span>](#x_Code)  
  
-   [<span data-ttu-id="290b0-110">內嵌程式碼的限制</span><span class="sxs-lookup"><span data-stu-id="290b0-110">Inline Code Limitations</span></span>](#Inline_Code_Limitations)  
  
<a name="Prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="290b0-111">必要條件</span><span class="sxs-lookup"><span data-stu-id="290b0-111">Prerequisites</span></span>  
 <span data-ttu-id="290b0-112">本主題假設您已閱讀[XAML 概觀 (WPF)](xaml-overview-wpf.md)具備的一些基本知識和[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]和物件導向程式設計。</span><span class="sxs-lookup"><span data-stu-id="290b0-112">This topic assumes that you have read the [XAML Overview (WPF)](xaml-overview-wpf.md) and have some basic knowledge of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] and object-oriented programming.</span></span>  
  
<a name="codebehind_and_the_xaml_language"></a>   
## <a name="code-behind-and-the-xaml-language"></a><span data-ttu-id="290b0-113">程式碼後置和 XAML 語言</span><span class="sxs-lookup"><span data-stu-id="290b0-113">Code-Behind and the XAML Language</span></span>  
 <span data-ttu-id="290b0-114">XAML 語言包含語言層級功能，使您能夠標記檔案，從標記檔端相關聯的程式碼檔案。</span><span class="sxs-lookup"><span data-stu-id="290b0-114">The XAML language includes language-level features that make it possible to associate code files with markup files, from the markup file side.</span></span> <span data-ttu-id="290b0-115">具體而言，XAML 語言定義的語言功能[X:class 指示詞](../../xaml-services/x-class-directive.md)， [X:subclass 指示詞](../../xaml-services/x-subclass-directive.md)，並[X:classmodifier 指示詞](../../xaml-services/x-classmodifier-directive.md)。</span><span class="sxs-lookup"><span data-stu-id="290b0-115">Specifically, the XAML language defines the language features [x:Class Directive](../../xaml-services/x-class-directive.md), [x:Subclass Directive](../../xaml-services/x-subclass-directive.md), and [x:ClassModifier Directive](../../xaml-services/x-classmodifier-directive.md).</span></span> <span data-ttu-id="290b0-116">完全的程式碼應該如何產生，以及如何將整合標記和程式碼，不是 XAML 語言所指定的一部分。</span><span class="sxs-lookup"><span data-stu-id="290b0-116">Exactly how the code should be produced, and how to integrate markup and code, is not part of what the XAML language specifies.</span></span> <span data-ttu-id="290b0-117">保留最多架構，例如 WPF 來判斷如何將整合程式碼、 如何使用 XAML 應用程式和程式設計模型，以及組建中的動作或其他支援，這一切需要。</span><span class="sxs-lookup"><span data-stu-id="290b0-117">It is left up to frameworks such as WPF to determine how to integrate the code, how to use XAML in the application and programming models, and the build actions or other support that all this requires.</span></span>  
  
<a name="Code_behind__Event_Handler__and_Partial_Class"></a>   
## <a name="code-behind-event-handler-and-partial-class-requirements-in-wpf"></a><span data-ttu-id="290b0-118">程式碼後置、 事件處理常式，並在 WPF 中的部分類別需求</span><span class="sxs-lookup"><span data-stu-id="290b0-118">Code-behind, Event Handler, and Partial Class Requirements in WPF</span></span>  
  
-   <span data-ttu-id="290b0-119">部分類別必須衍生自支援的根項目類型。</span><span class="sxs-lookup"><span data-stu-id="290b0-119">The partial class must derive from the type that backs the root element.</span></span>  
  
-   <span data-ttu-id="290b0-120">請注意，在標記編譯建置動作的預設行為，可以讓衍生空白部分類別定義中的程式碼後置的一端。</span><span class="sxs-lookup"><span data-stu-id="290b0-120">Note that under the default behavior of the markup compile build actions, you can leave the derivation blank in the partial class definition on the code-behind side.</span></span> <span data-ttu-id="290b0-121">編譯的結果會假設為部分類別中，基礎頁面根的支援類型，即使未指定。</span><span class="sxs-lookup"><span data-stu-id="290b0-121">The compiled result will assume the page root's backing type to be the basis for the partial class, even if it not specified.</span></span> <span data-ttu-id="290b0-122">不過，依賴此行為不是最佳的作法。</span><span class="sxs-lookup"><span data-stu-id="290b0-122">However, relying on this behavior is not a best practice.</span></span>  
  
-   <span data-ttu-id="290b0-123">您在程式碼後置中撰寫的事件處理常式必須是執行個體方法，而且不可為靜態方法。</span><span class="sxs-lookup"><span data-stu-id="290b0-123">The event handlers you write in the code-behind must be instance methods and cannot be static methods.</span></span> <span data-ttu-id="290b0-124">這些方法必須由所識別之 CLR 命名空間內的部分類別定義`x:Class`。</span><span class="sxs-lookup"><span data-stu-id="290b0-124">These methods must be defined by the partial class within the CLR namespace identified by `x:Class`.</span></span> <span data-ttu-id="290b0-125">您無法限定名稱的事件處理常式，以指示[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]處理器尋找事件連接不同的類別範圍中的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="290b0-125">You cannot qualify the name of an event handler to instruct a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor to look for an event handler for event wiring in a different class scope.</span></span>  
  
-   <span data-ttu-id="290b0-126">處理常式必須符合適當的事件的委派，在支援型別系統中。</span><span class="sxs-lookup"><span data-stu-id="290b0-126">The handler must match the delegate for the appropriate event in the backing type system.</span></span>  
  
-   <span data-ttu-id="290b0-127">Microsoft Visual Basic 語言的具體來說，您可以使用語言特有`Handles`關鍵字來關聯執行個體和事件處理常式宣告，而不是附加處理常式中的屬性中的處理常式[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="290b0-127">For the Microsoft Visual Basic language specifically, you can use the language-specific `Handles` keyword to associate handlers with instances and events in the handler declaration, instead of attaching handlers with attributes in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="290b0-128">不過，這項技術的確有些限制因為`Handles`關鍵字無法支援所有的特定功能[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]事件系統，例如特定路由事件的案例，或附加事件。</span><span class="sxs-lookup"><span data-stu-id="290b0-128">However, this technique does have some limitations because the `Handles` keyword cannot support all of the specific features of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system, such as certain routed event scenarios or attached events.</span></span> <span data-ttu-id="290b0-129">如需詳細資訊，請參閱 < [Visual Basic 和 WPF 事件處理](visual-basic-and-wpf-event-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="290b0-129">For details, see [Visual Basic and WPF Event Handling](visual-basic-and-wpf-event-handling.md).</span></span>  
  
<a name="x_Code"></a>   
## <a name="xcode"></a><span data-ttu-id="290b0-130">x:Code</span><span class="sxs-lookup"><span data-stu-id="290b0-130">x:Code</span></span>  
 <span data-ttu-id="290b0-131">[X:code](../../xaml-services/x-code-intrinsic-xaml-type.md)指示詞的項目定義於[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="290b0-131">[x:Code](../../xaml-services/x-code-intrinsic-xaml-type.md) is a directive element defined in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span></span> <span data-ttu-id="290b0-132">`x:Code`指示詞項目可以包含內嵌程式碼。</span><span class="sxs-lookup"><span data-stu-id="290b0-132">An `x:Code` directive element can contain inline programming code.</span></span> <span data-ttu-id="290b0-133">是內嵌定義的程式碼可以互動[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]相同頁面上。</span><span class="sxs-lookup"><span data-stu-id="290b0-133">The code that is defined inline can interact with the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] on the same page.</span></span> <span data-ttu-id="290b0-134">下列範例說明內嵌 C# 程式碼。</span><span class="sxs-lookup"><span data-stu-id="290b0-134">The following example illustrates inline C# code.</span></span> <span data-ttu-id="290b0-135">請注意，程式碼位於`x:Code`項目，並將程式碼，必須以括住`<CDATA[`...`]]>`逸出的內容[!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)]，以便[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]處理器 (解譯其中一個[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]結構描述或[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]結構描述) 不會嘗試解譯內容實際上為[!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="290b0-135">Notice that the code is inside the `x:Code` element and that the code must be surrounded by `<CDATA[`...`]]>` to escape the contents for [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)], so that a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor (interpreting either the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] schema or the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] schema) will not try to interpret the contents literally as [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)].</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ButtonWithInlineCode](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page4.xaml#buttonwithinlinecode)]  
  
<a name="Inline_Code_Limitations"></a>   
## <a name="inline-code-limitations"></a><span data-ttu-id="290b0-136">內嵌程式碼的限制</span><span class="sxs-lookup"><span data-stu-id="290b0-136">Inline Code Limitations</span></span>  
 <span data-ttu-id="290b0-137">您應該考慮避免或限制的內嵌程式碼使用。</span><span class="sxs-lookup"><span data-stu-id="290b0-137">You should consider avoiding or limiting the use of inline code.</span></span> <span data-ttu-id="290b0-138">架構和程式碼的原理，維護在標記和程式碼後置之間有分隔會保留的設計工具] 和 [開發人員角色更多不同。</span><span class="sxs-lookup"><span data-stu-id="290b0-138">In terms of architecture and coding philosophy, maintaining a separation between markup and code-behind keeps the designer and developer roles much more distinct.</span></span> <span data-ttu-id="290b0-139">更技術性的層級中，您為內嵌程式碼撰寫的程式碼可能會很冗長，因此若要撰寫，因為您一律將寫入到[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]產生部分類別中，且只能使用預設 XML 命名空間對應。</span><span class="sxs-lookup"><span data-stu-id="290b0-139">On a more technical level, the code that you write for inline code can be awkward to write, because you are always writing into the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] generated partial class, and can only use the default XML namespace mappings.</span></span> <span data-ttu-id="290b0-140">因為您無法新增`using`陳述式，您必須完整限定的許多[!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)]您進行的呼叫。</span><span class="sxs-lookup"><span data-stu-id="290b0-140">Because you cannot add `using` statements, you must fully qualify many of the [!INCLUDE[TLA2#tla_api](../../../../includes/tla2sharptla-api-md.md)] calls that you make.</span></span> <span data-ttu-id="290b0-141">預設值[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]對應包含大部分但非全部[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]在於的命名空間[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]組件，您必須完整限定類型和成員包含在其他的 CLR 命名空間內的呼叫。</span><span class="sxs-lookup"><span data-stu-id="290b0-141">The default [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] mappings include most but not all [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] namespaces that are present in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] assemblies; you will have to fully qualify calls to types and members contained within the other CLR namespaces.</span></span> <span data-ttu-id="290b0-142">您也無法定義部分類別以外的項目中的內嵌程式碼中，且您參考的所有使用者程式碼實體都必須是成員或產生的部分類別中的變數。</span><span class="sxs-lookup"><span data-stu-id="290b0-142">You also cannot define anything beyond the partial class in the inline code, and all user code entities you reference must exist as a member or variable within the generated partial class.</span></span> <span data-ttu-id="290b0-143">其他語言特定程式設計功能，例如巨集或`#ifdef`針對全域變數或組建變數，也會不提供。</span><span class="sxs-lookup"><span data-stu-id="290b0-143">Other language specific programming features, such as macros or `#ifdef` against global variables or build variables, are also not available.</span></span> <span data-ttu-id="290b0-144">如需詳細資訊，請參閱 < [X:code 內建 XAML 類型](../../xaml-services/x-code-intrinsic-xaml-type.md)。</span><span class="sxs-lookup"><span data-stu-id="290b0-144">For more information, see [x:Code Intrinsic XAML Type](../../xaml-services/x-code-intrinsic-xaml-type.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="290b0-145">另請參閱</span><span class="sxs-lookup"><span data-stu-id="290b0-145">See also</span></span>

- [<span data-ttu-id="290b0-146">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="290b0-146">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="290b0-147">x:Code 內建 XAML 類型</span><span class="sxs-lookup"><span data-stu-id="290b0-147">x:Code Intrinsic XAML Type</span></span>](../../xaml-services/x-code-intrinsic-xaml-type.md)
- [<span data-ttu-id="290b0-148">建置 WPF 應用程式</span><span class="sxs-lookup"><span data-stu-id="290b0-148">Building a WPF Application</span></span>](../app-development/building-a-wpf-application-wpf.md)
- [<span data-ttu-id="290b0-149">XAML 語法詳細資料</span><span class="sxs-lookup"><span data-stu-id="290b0-149">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
