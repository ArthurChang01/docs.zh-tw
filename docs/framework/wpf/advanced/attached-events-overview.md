---
title: 附加事件概觀
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- handling attached events [WPF]
- defining attached events as routed events [WPF]
- attached events [WPF], scenarios for
- attached events vs. routed events [WPF]
- backing attached events with routed events [WPF]
- attached events [WPF], definition
ms.assetid: 2c40eae3-80e4-4a45-ae09-df6c9ab4d91e
ms.openlocfilehash: 76ff60cfe26f9105d4504164802987115fc2a7e2
ms.sourcegitcommit: 944ddc52b7f2632f30c668815f92b378efd38eea
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/03/2019
ms.locfileid: "73455470"
---
# <a name="attached-events-overview"></a><span data-ttu-id="811a3-102">附加事件概觀</span><span class="sxs-lookup"><span data-stu-id="811a3-102">Attached Events Overview</span></span>

<span data-ttu-id="811a3-103">Extensible Application Markup Language （XAML）會定義語言元件和事件種類，稱為*附加事件*。</span><span class="sxs-lookup"><span data-stu-id="811a3-103">Extensible Application Markup Language (XAML) defines a language component and type of event called an *attached event*.</span></span> <span data-ttu-id="811a3-104">附加事件的概念，讓您能新增特定事件的處理常式到任意項目，而不是實際定義或繼承事件的項目。</span><span class="sxs-lookup"><span data-stu-id="811a3-104">The concept of an attached event enables you to add a handler for a particular event to an arbitrary element rather than to an element that actually defines or inherits the event.</span></span> <span data-ttu-id="811a3-105">在此情況下，可能引發事件的物件和目的地處理執行個體都不會定義或以其他方式「擁有」事件。</span><span class="sxs-lookup"><span data-stu-id="811a3-105">In this case, neither the object potentially raising the event nor the destination handling instance defines or otherwise "owns" the event.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="811a3-106">Prerequisites</span><span class="sxs-lookup"><span data-stu-id="811a3-106">Prerequisites</span></span>  
 <span data-ttu-id="811a3-107">本主題假設您已閱讀[路由事件概觀](routed-events-overview.md)和 [XAML 概觀 (WPF)](../../../desktop-wpf/fundamentals/xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="811a3-107">This topic assumes that you have read [Routed Events Overview](routed-events-overview.md) and [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>  
  
<a name="Syntax"></a>   
## <a name="attached-event-syntax"></a><span data-ttu-id="811a3-108">附加事件語法</span><span class="sxs-lookup"><span data-stu-id="811a3-108">Attached Event Syntax</span></span>  
 <span data-ttu-id="811a3-109">附加的事件具有 XAML 語法和程式碼撰寫模式，必須由支援程式碼使用，才能支援附加的事件使用方式。</span><span class="sxs-lookup"><span data-stu-id="811a3-109">Attached events have a XAML syntax and a coding pattern that must be used by the backing code in order to support the attached event usage.</span></span>  
  
 <span data-ttu-id="811a3-110">在 XAML 語法中，附加事件不只是由其事件名稱所指定，而是由其擁有類型加上事件名稱（以點（.）分隔）。</span><span class="sxs-lookup"><span data-stu-id="811a3-110">In XAML syntax, the attached event is specified not just by its event name, but by its owning type plus the event name, separated by a dot (.).</span></span> <span data-ttu-id="811a3-111">因為事件名稱以其擁有類型的名稱來限定，附加事件語法可讓任何附加事件附加至可以具現化的任何項目。</span><span class="sxs-lookup"><span data-stu-id="811a3-111">Because the event name is qualified with the name of its owning type, the attached event syntax allows any attached event to be attached to any element that can be instantiated.</span></span>  
  
 <span data-ttu-id="811a3-112">例如，下列是用於附加自訂 `NeedsCleaning` 附加事件之處理常式的 XAML 語法：</span><span class="sxs-lookup"><span data-stu-id="811a3-112">For example, the following is the XAML syntax for attaching a handler for a custom `NeedsCleaning` attached event:</span></span>  
  
 [!code-xaml[WPFAquariumSln#AE](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquarium/Window1.xaml#ae)]  
  
 <span data-ttu-id="811a3-113">請注意 `aqua:` 前置詞，前置詞在此情況中是必要的，因為附加事件是來自自訂對應 xmlns 的自訂事件。</span><span class="sxs-lookup"><span data-stu-id="811a3-113">Note the `aqua:` prefix; the prefix is necessary in this case because the attached event is a custom event that comes from a custom mapped xmlns.</span></span>  
  
<a name="WPFImplements"></a>   
## <a name="how-wpf-implements-attached-events"></a><span data-ttu-id="811a3-114">WPF 如何實作附加事件</span><span class="sxs-lookup"><span data-stu-id="811a3-114">How WPF Implements Attached Events</span></span>

<span data-ttu-id="811a3-115">在 WPF 中，附加事件是由 <xref:System.Windows.RoutedEvent> 欄位所支援，而且會在引發之後透過樹狀結構進行路由。</span><span class="sxs-lookup"><span data-stu-id="811a3-115">In WPF, attached events are backed by a <xref:System.Windows.RoutedEvent> field and are routed through the tree after they are raised.</span></span> <span data-ttu-id="811a3-116">一般而言，附加事件的來源 (引發事件的物件) 是系統或服務來源，因此執行引發事件之程式碼的物件不直接是項目樹狀結構的一部分。</span><span class="sxs-lookup"><span data-stu-id="811a3-116">Typically, the source of the attached event (the object that raises the event) is a system or service source, and the object that runs the code that raises the event is therefore not a direct part of the element tree.</span></span>  
  
<a name="Scenarios"></a>   
## <a name="scenarios-for-attached-events"></a><span data-ttu-id="811a3-117">附加事件的情節</span><span class="sxs-lookup"><span data-stu-id="811a3-117">Scenarios for Attached Events</span></span>  
 <span data-ttu-id="811a3-118">在 WPF 中，附加事件會出現在有服務層級抽象的特定功能區域中，例如，針對靜態 <xref:System.Windows.Input.Mouse> 類別或 <xref:System.Windows.Controls.Validation> 類別所啟用的事件。</span><span class="sxs-lookup"><span data-stu-id="811a3-118">In WPF, attached events are present in certain feature areas where there is service-level abstraction, such as for the events enabled by the static <xref:System.Windows.Input.Mouse> class or the <xref:System.Windows.Controls.Validation> class.</span></span> <span data-ttu-id="811a3-119">與服務互動或是使用服務的類別可以以附加事件語法使用事件，或者它們可以選擇將附加事件公開為路由事件，路由事件是類別整合服務功能的方式之一。</span><span class="sxs-lookup"><span data-stu-id="811a3-119">Classes that interact with or use the service can either use the event in the attached event syntax, or they can choose to surface the attached event as a routed event that is part of how the class integrates the capabilities of the service.</span></span>  
  
 <span data-ttu-id="811a3-120">雖然 WPF 會定義數個附加事件，但您會直接使用或處理附加事件的情況非常有限。</span><span class="sxs-lookup"><span data-stu-id="811a3-120">Although WPF defines a number of attached events, the scenarios where you will either use or handle the attached event directly are very limited.</span></span> <span data-ttu-id="811a3-121">一般而言，附加事件會提供架構用途，但接著會轉送到非附加的（使用 CLR 事件「包裝函式」）路由事件。</span><span class="sxs-lookup"><span data-stu-id="811a3-121">Generally, the attached event serves an architecture purpose, but is then forwarded to a non-attached (backed with a CLR event "wrapper") routed event.</span></span>  
  
 <span data-ttu-id="811a3-122">例如，基礎附加事件 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 可以使用該 <xref:System.Windows.UIElement> 上的 <xref:System.Windows.UIElement.MouseDown>，更輕鬆地在任何指定的 <xref:System.Windows.UIElement> 上處理，而不是在 XAML 或程式碼中處理附加的事件語法。</span><span class="sxs-lookup"><span data-stu-id="811a3-122">For instance, the underlying attached event <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> can more easily be handled on any given <xref:System.Windows.UIElement> by using <xref:System.Windows.UIElement.MouseDown> on that <xref:System.Windows.UIElement> rather than dealing with attached event syntax either in XAML or code.</span></span> <span data-ttu-id="811a3-123">附加事件在架構中有其用途，因為它可讓您在未來擴充輸入裝置。</span><span class="sxs-lookup"><span data-stu-id="811a3-123">The attached event serves a purpose in the architecture because it allows for future expansion of input devices.</span></span> <span data-ttu-id="811a3-124">假設裝置只需要引發 <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> 才能模擬滑鼠輸入，而且不需要衍生自 <xref:System.Windows.Input.Mouse> 來執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="811a3-124">The hypothetical device would only need to raise <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> in order to simulate mouse input, and would not need to derive from <xref:System.Windows.Input.Mouse> to do so.</span></span> <span data-ttu-id="811a3-125">不過，此案例牽涉到事件的程式碼處理，而附加事件的 XAML 處理與此案例無關。</span><span class="sxs-lookup"><span data-stu-id="811a3-125">However, this scenario involves code handling of the events, and XAML handling of the attached event is not relevant to this scenario.</span></span>  
  
<a name="Handling"></a>   
## <a name="handling-an-attached-event-in-wpf"></a><span data-ttu-id="811a3-126">在 WPF 中處理附加事件</span><span class="sxs-lookup"><span data-stu-id="811a3-126">Handling an Attached Event in WPF</span></span>  
 <span data-ttu-id="811a3-127">處理附加事件的程序，以及您將撰寫的處理常式程式碼，基本上與路由事件一樣。</span><span class="sxs-lookup"><span data-stu-id="811a3-127">The process for handling an attached event, and the handler code that you will write, is basically the same as for a routed event.</span></span>  
  
 <span data-ttu-id="811a3-128">一般而言，WPF 附加事件與 WPF 路由事件的差異並不大。</span><span class="sxs-lookup"><span data-stu-id="811a3-128">In general, a WPF attached event is not very different from a WPF routed event.</span></span> <span data-ttu-id="811a3-129">其差異在於事件的來源，以及類別如何公開為成員（這也會影響 XAML 處理常式語法）。</span><span class="sxs-lookup"><span data-stu-id="811a3-129">The differences are how the event is sourced and how it is exposed by a class as a member (which also affects the XAML handler syntax).</span></span>  
  
 <span data-ttu-id="811a3-130">不過，如先前所述，現有的 WPF 附加事件並不特別適用于 WPF 中的處理。</span><span class="sxs-lookup"><span data-stu-id="811a3-130">However, as noted earlier, the existing WPF attached events are not particularly intended for handling in WPF.</span></span> <span data-ttu-id="811a3-131">更常見的是，事件的目的是要在複合 (compositing) 中啟用報告狀態給父項目的複合項目，在此情況下，事件通常會在程式碼中引發，並依賴相關父類別中的類別處理。</span><span class="sxs-lookup"><span data-stu-id="811a3-131">More often, the purpose of the event is to enable a composited element to report a state to a parent element in compositing, in which case the event is usually raised in code and also relies on class handling in the relevant parent class.</span></span> <span data-ttu-id="811a3-132">比方說，<xref:System.Windows.Controls.Primitives.Selector> 內的專案應該會引發附加的 <xref:System.Windows.Controls.Primitives.Selector.Selected> 事件，然後由 <xref:System.Windows.Controls.Primitives.Selector> 類別處理此類別，然後由 <xref:System.Windows.Controls.Primitives.Selector> 類別來轉換成不同的路由事件，<xref:System.Windows.Controls.Primitives.Selector.SelectionChanged>。</span><span class="sxs-lookup"><span data-stu-id="811a3-132">For instance, items within a <xref:System.Windows.Controls.Primitives.Selector> are expected to raise the attached <xref:System.Windows.Controls.Primitives.Selector.Selected> event, which is then class handled by the <xref:System.Windows.Controls.Primitives.Selector> class and then potentially converted by the <xref:System.Windows.Controls.Primitives.Selector> class into a different routed event, <xref:System.Windows.Controls.Primitives.Selector.SelectionChanged>.</span></span> <span data-ttu-id="811a3-133">如需路由事件與類別處理的詳細資訊，請參閱[將路由事件標記為已處理以及類別處理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="811a3-133">For more information on routed events and class handling, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
<a name="Custom"></a>   
## <a name="defining-your-own-attached-events-as-routed-events"></a><span data-ttu-id="811a3-134">將您自己的附加事件定義為路由事件</span><span class="sxs-lookup"><span data-stu-id="811a3-134">Defining Your Own Attached Events as Routed Events</span></span>  
 <span data-ttu-id="811a3-135">如果您是從通用 WPF 基類衍生，您可以在類別中包含特定模式方法，並使用已存在於基類上的公用程式方法，來實作為附加事件。</span><span class="sxs-lookup"><span data-stu-id="811a3-135">If you are deriving from common WPF base classes, you can implement your own attached events by including certain pattern methods in your class and by using utility methods that are already present on the base classes.</span></span>  
  
 <span data-ttu-id="811a3-136">模式如下所示︰</span><span class="sxs-lookup"><span data-stu-id="811a3-136">The pattern is as follows:</span></span>  
  
- <span data-ttu-id="811a3-137">方法會新增具有兩個參數的 __*事件名稱*處理常式__。</span><span class="sxs-lookup"><span data-stu-id="811a3-137">A method __Add*EventName*Handler__ with two parameters.</span></span> <span data-ttu-id="811a3-138">第一個參數是要加入事件處理常式的實例。</span><span class="sxs-lookup"><span data-stu-id="811a3-138">The first parameter is the instance to which the event handler is added.</span></span> <span data-ttu-id="811a3-139">第二個參數是要加入的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="811a3-139">The second parameter is the event handler to add.</span></span> <span data-ttu-id="811a3-140">方法必須是 `public` 且 `static`，而且沒有傳回值。</span><span class="sxs-lookup"><span data-stu-id="811a3-140">The method must be `public` and `static`, with no return value.</span></span>  
  
- <span data-ttu-id="811a3-141">方法會移除具有兩個參數的 __*事件名稱*處理常式__。</span><span class="sxs-lookup"><span data-stu-id="811a3-141">A method __Remove*EventName*Handler__ with two parameters.</span></span> <span data-ttu-id="811a3-142">第一個參數是要從中移除事件處理常式的實例。</span><span class="sxs-lookup"><span data-stu-id="811a3-142">The first parameter is the instance from which the event handler is removed.</span></span> <span data-ttu-id="811a3-143">第二個參數是要移除的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="811a3-143">The second parameter is the event handler to remove.</span></span> <span data-ttu-id="811a3-144">方法必須是 `public` 且 `static`，而且沒有傳回值。</span><span class="sxs-lookup"><span data-stu-id="811a3-144">The method must be `public` and `static`, with no return value.</span></span>  
  
 <span data-ttu-id="811a3-145">在元素上宣告附加事件處理常式屬性時，「__新增事件*名稱*處理常式__」存取子方法可加速 XAML 處理。</span><span class="sxs-lookup"><span data-stu-id="811a3-145">The __Add*EventName*Handler__ accessor method facilitates XAML processing when attached event handler attributes are declared on an element.</span></span> <span data-ttu-id="811a3-146">「__加入事件*名稱*處理常式__」和「__移除事件*名稱*」處理常式__方法也可讓您存取附加事件的事件處理常式存放區。</span><span class="sxs-lookup"><span data-stu-id="811a3-146">The __Add*EventName*Handler__ and __Remove*EventName*Handler__ methods also enable code access to the event handler store for the attached event.</span></span>  
  
 <span data-ttu-id="811a3-147">這種一般模式還不夠精確，無法用於架構中的實際執行，因為任何指定的 XAML 讀取器執行可能會有不同的配置來識別支援語言和架構中的基礎事件。</span><span class="sxs-lookup"><span data-stu-id="811a3-147">This general pattern is not yet precise enough for practical implementation in a framework, because any given XAML reader implementation might have different schemes for identifying underlying events in the supporting language and architecture.</span></span> <span data-ttu-id="811a3-148">這是 WPF 將附加事件實作為路由事件的原因之一;用於事件（<xref:System.Windows.RoutedEvent>）的識別碼已由 WPF 事件系統定義。</span><span class="sxs-lookup"><span data-stu-id="811a3-148">This is one of the reasons that WPF implements attached events as routed events; the identifier to use for an event (<xref:System.Windows.RoutedEvent>) is already defined by the WPF event system.</span></span> <span data-ttu-id="811a3-149">此外，路由事件是附加事件之 XAML 語言層級概念的自然執行延伸模組。</span><span class="sxs-lookup"><span data-stu-id="811a3-149">Also, routing an event is a natural implementation extension on the XAML language-level concept of an attached event.</span></span>  
  
 <span data-ttu-id="811a3-150">WPF 附加事件的「__加入*事件名稱*」處理常式__，包含以路由事件和處理常式做為引數呼叫 <xref:System.Windows.UIElement.AddHandler%2A>。</span><span class="sxs-lookup"><span data-stu-id="811a3-150">The __Add*EventName*Handler__ implementation for a WPF attached event consists of calling the <xref:System.Windows.UIElement.AddHandler%2A> with the routed event and handler as arguments.</span></span>  
  
 <span data-ttu-id="811a3-151">這項實策略和路由事件系統通常會將附加事件的處理限制為 <xref:System.Windows.UIElement> 衍生類別或 <xref:System.Windows.ContentElement> 衍生類別，因為只有那些類別有 <xref:System.Windows.UIElement.AddHandler%2A> 的實作為方法。</span><span class="sxs-lookup"><span data-stu-id="811a3-151">This implementation strategy and the routed event system in general restrict handling for attached events to either <xref:System.Windows.UIElement> derived classes or <xref:System.Windows.ContentElement> derived classes, because only those classes have <xref:System.Windows.UIElement.AddHandler%2A> implementations.</span></span>  
  
 <span data-ttu-id="811a3-152">例如，下列程式碼會使用將附加事件宣告為路由事件的 WPF 附加事件策略，在 owner 類別 `Aquarium`上定義 `NeedsCleaning` 附加事件。</span><span class="sxs-lookup"><span data-stu-id="811a3-152">For example, the following code defines the `NeedsCleaning` attached event on the owner class `Aquarium`, using the WPF attached event strategy of declaring the attached event as a routed event.</span></span>  
  
 [!code-csharp[WPFAquariumSln#AECode](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#aecode)]
 [!code-vb[WPFAquariumSln#AECode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#aecode)]  
  
 <span data-ttu-id="811a3-153">請注意，用來建立附加事件識別碼欄位 <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>的方法，實際上與用來註冊非附加路由事件的方法相同。</span><span class="sxs-lookup"><span data-stu-id="811a3-153">Note that the method used to establish the attached event identifier field, <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>, is actually the same method that is used to register a non-attached routed event.</span></span> <span data-ttu-id="811a3-154">附加事件和路由事件全都註冊到集中式內部存放區。</span><span class="sxs-lookup"><span data-stu-id="811a3-154">Attached events and routed events all are registered to a centralized internal store.</span></span> <span data-ttu-id="811a3-155">此事件存放區實作促成了[路由事件概觀](routed-events-overview.md)中所討論的「事件即介面」概念考量。</span><span class="sxs-lookup"><span data-stu-id="811a3-155">This event store implementation enables the "events as an interface" conceptual consideration that is discussed in [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="Raising"></a>   
## <a name="raising-a-wpf-attached-event"></a><span data-ttu-id="811a3-156">引發 WPF 附加事件</span><span class="sxs-lookup"><span data-stu-id="811a3-156">Raising a WPF Attached Event</span></span>  
 <span data-ttu-id="811a3-157">您通常不需要從程式碼引發現有的 WPF 定義附加事件。</span><span class="sxs-lookup"><span data-stu-id="811a3-157">You do not typically need to raise existing WPF-defined attached events from your code.</span></span> <span data-ttu-id="811a3-158">這些事件會遵循一般的「服務」概念模型，而 <xref:System.Windows.Input.InputManager> 的服務類別會負責引發事件。</span><span class="sxs-lookup"><span data-stu-id="811a3-158">These events follow the general "service" conceptual model, and service classes such as <xref:System.Windows.Input.InputManager> are responsible for raising the events.</span></span>  
  
 <span data-ttu-id="811a3-159">不過，如果您要根據 <xref:System.Windows.RoutedEvent>上基附加事件的 WPF 模型來定義自訂附加事件，您可以使用 <xref:System.Windows.UIElement.RaiseEvent%2A> 從任何 <xref:System.Windows.UIElement> 或 <xref:System.Windows.ContentElement>引發附加事件。</span><span class="sxs-lookup"><span data-stu-id="811a3-159">However, if you are defining a custom attached event based on the WPF model of basing attached events on <xref:System.Windows.RoutedEvent>, you can use <xref:System.Windows.UIElement.RaiseEvent%2A> to raise an attached event from any <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="811a3-160">引發路由事件（已附加）需要您在專案樹狀結構中宣告特定元素做為事件來源;該來源會回報為 <xref:System.Windows.UIElement.RaiseEvent%2A> 呼叫端。</span><span class="sxs-lookup"><span data-stu-id="811a3-160">Raising a routed event (attached or not) requires that you declare a particular element in the element tree as the event source; that source is reported as the <xref:System.Windows.UIElement.RaiseEvent%2A> caller.</span></span> <span data-ttu-id="811a3-161">判斷樹狀結構中的哪個項目報告為來源是服務的責任</span><span class="sxs-lookup"><span data-stu-id="811a3-161">Determining which element is reported as the source in the tree is your service's responsibility</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="811a3-162">請參閱</span><span class="sxs-lookup"><span data-stu-id="811a3-162">See also</span></span>

- [<span data-ttu-id="811a3-163">路由事件概觀</span><span class="sxs-lookup"><span data-stu-id="811a3-163">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="811a3-164">XAML 語法詳細資料</span><span class="sxs-lookup"><span data-stu-id="811a3-164">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
- [<span data-ttu-id="811a3-165">WPF 的 XAML 和自訂類別</span><span class="sxs-lookup"><span data-stu-id="811a3-165">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
