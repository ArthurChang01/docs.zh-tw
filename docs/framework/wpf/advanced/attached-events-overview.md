---
title: 附加事件概觀
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- handling attached events [WPF]
- defining attached events as routed events [WPF]
- attached events [WPF], scenarios for
- attached events vs. routed events [WPF]
- backing attached events with routed events [WPF]
- attached events [WPF], definition
ms.assetid: 2c40eae3-80e4-4a45-ae09-df6c9ab4d91e
ms.openlocfilehash: 8f0b5109dd569791ca8f45dbe969b1c9e2f6407b
ms.sourcegitcommit: 5b6d778ebb269ee6684fb57ad69a8c28b06235b9
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/08/2019
ms.locfileid: "59140851"
---
# <a name="attached-events-overview"></a><span data-ttu-id="ce07e-102">附加事件概觀</span><span class="sxs-lookup"><span data-stu-id="ce07e-102">Attached Events Overview</span></span>
[!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] <span data-ttu-id="ce07e-103">語言元件和呼叫的事件類型會定義*附加事件*。</span><span class="sxs-lookup"><span data-stu-id="ce07e-103">defines a language component and type of event called an *attached event*.</span></span> <span data-ttu-id="ce07e-104">附加事件的概念，讓您能新增特定事件的處理常式到任意項目，而不是實際定義或繼承事件的項目。</span><span class="sxs-lookup"><span data-stu-id="ce07e-104">The concept of an attached event enables you to add a handler for a particular event to an arbitrary element rather than to an element that actually defines or inherits the event.</span></span> <span data-ttu-id="ce07e-105">在此情況下，可能引發事件的物件和目的地處理執行個體都不會定義或以其他方式「擁有」事件。</span><span class="sxs-lookup"><span data-stu-id="ce07e-105">In this case, neither the object potentially raising the event nor the destination handling instance defines or otherwise "owns" the event.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="ce07e-106">必要條件</span><span class="sxs-lookup"><span data-stu-id="ce07e-106">Prerequisites</span></span>  
 <span data-ttu-id="ce07e-107">本主題假設您已閱讀[路由事件概觀](routed-events-overview.md)和 [XAML 概觀 (WPF)](xaml-overview-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="ce07e-107">This topic assumes that you have read [Routed Events Overview](routed-events-overview.md) and [XAML Overview (WPF)](xaml-overview-wpf.md).</span></span>  
  
<a name="Syntax"></a>   
## <a name="attached-event-syntax"></a><span data-ttu-id="ce07e-108">附加事件語法</span><span class="sxs-lookup"><span data-stu-id="ce07e-108">Attached Event Syntax</span></span>  
 <span data-ttu-id="ce07e-109">附加事件具有 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 語法和程式碼撰寫模式，支援程式碼必須使用才能支援附加事件的使用。</span><span class="sxs-lookup"><span data-stu-id="ce07e-109">Attached events have a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax and a coding pattern that must be used by the backing code in order to support the attached event usage.</span></span>  
  
 <span data-ttu-id="ce07e-110">在 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 語法中，附加事件的指定不只是依事件名稱，也依其擁有類型加上事件名稱，以點 (.) 分隔。</span><span class="sxs-lookup"><span data-stu-id="ce07e-110">In [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax, the attached event is specified not just by its event name, but by its owning type plus the event name, separated by a dot (.).</span></span> <span data-ttu-id="ce07e-111">因為事件名稱以其擁有類型的名稱來限定，附加事件語法可讓任何附加事件附加至可以具現化的任何項目。</span><span class="sxs-lookup"><span data-stu-id="ce07e-111">Because the event name is qualified with the name of its owning type, the attached event syntax allows any attached event to be attached to any element that can be instantiated.</span></span>  
  
 <span data-ttu-id="ce07e-112">例如，下列是附加自訂 `NeedsCleaning` 附加事件之處理常式的 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 語法︰</span><span class="sxs-lookup"><span data-stu-id="ce07e-112">For example, the following is the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] syntax for attaching a handler for a custom `NeedsCleaning` attached event:</span></span>  
  
 [!code-xaml[WPFAquariumSln#AE](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquarium/Window1.xaml#ae)]  
  
 <span data-ttu-id="ce07e-113">請注意 `aqua:` 前置詞，前置詞在此情況中是必要的，因為附加事件是來自自訂對應 xmlns 的自訂事件。</span><span class="sxs-lookup"><span data-stu-id="ce07e-113">Note the `aqua:` prefix; the prefix is necessary in this case because the attached event is a custom event that comes from a custom mapped xmlns.</span></span>  
  
<a name="WPFImplements"></a>   
## <a name="how-wpf-implements-attached-events"></a><span data-ttu-id="ce07e-114">WPF 如何實作附加事件</span><span class="sxs-lookup"><span data-stu-id="ce07e-114">How WPF Implements Attached Events</span></span>  
 <span data-ttu-id="ce07e-115">在  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]，附加事件都會受到<xref:System.Windows.RoutedEvent>欄位，並在引發之後路由傳送到樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="ce07e-115">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], attached events are backed by a <xref:System.Windows.RoutedEvent> field and are routed through the tree after they are raised.</span></span> <span data-ttu-id="ce07e-116">一般而言，附加事件的來源 (引發事件的物件) 是系統或服務來源，因此執行引發事件之程式碼的物件不直接是項目樹狀結構的一部分。</span><span class="sxs-lookup"><span data-stu-id="ce07e-116">Typically, the source of the attached event (the object that raises the event) is a system or service source, and the object that runs the code that raises the event is therefore not a direct part of the element tree.</span></span>  
  
<a name="Scenarios"></a>   
## <a name="scenarios-for-attached-events"></a><span data-ttu-id="ce07e-117">附加事件的情節</span><span class="sxs-lookup"><span data-stu-id="ce07e-117">Scenarios for Attached Events</span></span>  
 <span data-ttu-id="ce07e-118">在  [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]，附加事件會出現在特定功能區域沒有服務層級的抽象概念，例如靜態所啟用的事件<xref:System.Windows.Input.Mouse>類別或<xref:System.Windows.Controls.Validation>類別。</span><span class="sxs-lookup"><span data-stu-id="ce07e-118">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], attached events are present in certain feature areas where there is service-level abstraction, such as for the events enabled by the static <xref:System.Windows.Input.Mouse> class or the <xref:System.Windows.Controls.Validation> class.</span></span> <span data-ttu-id="ce07e-119">與服務互動或是使用服務的類別可以以附加事件語法使用事件，或者它們可以選擇將附加事件公開為路由事件，路由事件是類別整合服務功能的方式之一。</span><span class="sxs-lookup"><span data-stu-id="ce07e-119">Classes that interact with or use the service can either use the event in the attached event syntax, or they can choose to surface the attached event as a routed event that is part of how the class integrates the capabilities of the service.</span></span>  
  
 <span data-ttu-id="ce07e-120">雖然 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 定義許多附加事件，您會直接使用或處理附加事件的情節非常有限。</span><span class="sxs-lookup"><span data-stu-id="ce07e-120">Although [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] defines a number of attached events, the scenarios where you will either use or handle the attached event directly are very limited.</span></span> <span data-ttu-id="ce07e-121">一般而言，附加事件用於架構用途，但接著會轉送到非附加的 (由 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 事件「包裝函式」支援) 路由事件。</span><span class="sxs-lookup"><span data-stu-id="ce07e-121">Generally, the attached event serves an architecture purpose, but is then forwarded to a non-attached (backed with a [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] event "wrapper") routed event.</span></span>  
  
 <span data-ttu-id="ce07e-122">比方說，基礎附加事件<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>可以更輕鬆地處理任何給定<xref:System.Windows.UIElement>利用<xref:System.Windows.UIElement.MouseDown>上的<xref:System.Windows.UIElement>而不處理附加的事件語法中[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]或程式碼。</span><span class="sxs-lookup"><span data-stu-id="ce07e-122">For instance, the underlying attached event <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> can more easily be handled on any given <xref:System.Windows.UIElement> by using <xref:System.Windows.UIElement.MouseDown> on that <xref:System.Windows.UIElement> rather than dealing with attached event syntax either in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or code.</span></span> <span data-ttu-id="ce07e-123">附加事件在架構中有其用途，因為它可讓您在未來擴充輸入裝置。</span><span class="sxs-lookup"><span data-stu-id="ce07e-123">The attached event serves a purpose in the architecture because it allows for future expansion of input devices.</span></span> <span data-ttu-id="ce07e-124">假想的裝置只需要引發<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>模擬滑鼠輸入，並不需要衍生自<xref:System.Windows.Input.Mouse>若要這樣做。</span><span class="sxs-lookup"><span data-stu-id="ce07e-124">The hypothetical device would only need to raise <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> in order to simulate mouse input, and would not need to derive from <xref:System.Windows.Input.Mouse> to do so.</span></span> <span data-ttu-id="ce07e-125">不過，此情節牽涉到事件的程式碼處理，附加事件的 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 處理與此情節無關。</span><span class="sxs-lookup"><span data-stu-id="ce07e-125">However, this scenario involves code handling of the events, and [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] handling of the attached event is not relevant to this scenario.</span></span>  
  
<a name="Handling"></a>   
## <a name="handling-an-attached-event-in-wpf"></a><span data-ttu-id="ce07e-126">在 WPF 中處理附加事件</span><span class="sxs-lookup"><span data-stu-id="ce07e-126">Handling an Attached Event in WPF</span></span>  
 <span data-ttu-id="ce07e-127">處理附加事件的程序，以及您將撰寫的處理常式程式碼，基本上與路由事件一樣。</span><span class="sxs-lookup"><span data-stu-id="ce07e-127">The process for handling an attached event, and the handler code that you will write, is basically the same as for a routed event.</span></span>  
  
 <span data-ttu-id="ce07e-128">一般而言，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 附加事件與 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 路由事件差異不大。</span><span class="sxs-lookup"><span data-stu-id="ce07e-128">In general, a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] attached event is not very different from a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed event.</span></span> <span data-ttu-id="ce07e-129">差異之處在於事件來源的方式，以及它由類別公開為成員的方式 (這也會影響 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 處理常式語法)。</span><span class="sxs-lookup"><span data-stu-id="ce07e-129">The differences are how the event is sourced and how it is exposed by a class as a member (which also affects the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] handler syntax).</span></span>  
  
 <span data-ttu-id="ce07e-130">不過，如先前所述，現有的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 附加事件並不特別適合在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中處理。</span><span class="sxs-lookup"><span data-stu-id="ce07e-130">However, as noted earlier, the existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] attached events are not particularly intended for handling in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="ce07e-131">更常見的是，事件的目的是要在複合 (compositing) 中啟用報告狀態給父項目的複合項目，在此情況下，事件通常會在程式碼中引發，並依賴相關父類別中的類別處理。</span><span class="sxs-lookup"><span data-stu-id="ce07e-131">More often, the purpose of the event is to enable a composited element to report a state to a parent element in compositing, in which case the event is usually raised in code and also relies on class handling in the relevant parent class.</span></span> <span data-ttu-id="ce07e-132">比方說，項目內<xref:System.Windows.Controls.Primitives.Selector>預期會引發附加<xref:System.Windows.Controls.Primitives.Selector.Selected>處理事件，然後是類別<xref:System.Windows.Controls.Primitives.Selector>類別，並接著可能會藉由轉換<xref:System.Windows.Controls.Primitives.Selector>到不同的路由事件的類別<xref:System.Windows.Controls.Primitives.Selector.SelectionChanged>.</span><span class="sxs-lookup"><span data-stu-id="ce07e-132">For instance, items within a <xref:System.Windows.Controls.Primitives.Selector> are expected to raise the attached <xref:System.Windows.Controls.Primitives.Selector.Selected> event, which is then class handled by the <xref:System.Windows.Controls.Primitives.Selector> class and then potentially converted by the <xref:System.Windows.Controls.Primitives.Selector> class into a different routed event, <xref:System.Windows.Controls.Primitives.Selector.SelectionChanged>.</span></span> <span data-ttu-id="ce07e-133">如需路由事件與類別處理的詳細資訊，請參閱[將路由事件標記為已處理以及類別處理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="ce07e-133">For more information on routed events and class handling, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
<a name="Custom"></a>   
## <a name="defining-your-own-attached-events-as-routed-events"></a><span data-ttu-id="ce07e-134">將您自己的附加事件定義為路由事件</span><span class="sxs-lookup"><span data-stu-id="ce07e-134">Defining Your Own Attached Events as Routed Events</span></span>  
 <span data-ttu-id="ce07e-135">如果您衍生自一般 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 基底類別，您可以在類別中加入特定模式方法，並使用已在基底類別的公用程式方法，來實作自己的附加事件。</span><span class="sxs-lookup"><span data-stu-id="ce07e-135">If you are deriving from common [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] base classes, you can implement your own attached events by including certain pattern methods in your class and by using utility methods that are already present on the base classes.</span></span>  
  
 <span data-ttu-id="ce07e-136">模式如下所示︰</span><span class="sxs-lookup"><span data-stu-id="ce07e-136">The pattern is as follows:</span></span>  
  
-   <span data-ttu-id="ce07e-137">一種方法**新增*EventName*處理常式**具有兩個參數。</span><span class="sxs-lookup"><span data-stu-id="ce07e-137">A method **Add*EventName*Handler** with two parameters.</span></span> <span data-ttu-id="ce07e-138">第一個參數必須識別事件，並識別出的事件必須符合的名稱***EventName***在方法名稱。</span><span class="sxs-lookup"><span data-stu-id="ce07e-138">The first parameter must identify the event, and the identified event must match names with the ***EventName*** in the method name.</span></span> <span data-ttu-id="ce07e-139">第二個參數是要新增的處理常式。</span><span class="sxs-lookup"><span data-stu-id="ce07e-139">The second parameter is the handler to add.</span></span> <span data-ttu-id="ce07e-140">這個方法必須是`public`和`static`，且沒有傳回值。</span><span class="sxs-lookup"><span data-stu-id="ce07e-140">The method must be `public` and `static`, with no return value.</span></span>  
  
-   <span data-ttu-id="ce07e-141">一種方法**移除*EventName*處理常式**具有兩個參數。</span><span class="sxs-lookup"><span data-stu-id="ce07e-141">A method **Remove*EventName*Handler** with two parameters.</span></span> <span data-ttu-id="ce07e-142">第一個參數必須識別事件，並識別出的事件必須符合的名稱***EventName***在方法名稱。</span><span class="sxs-lookup"><span data-stu-id="ce07e-142">The first parameter must identify the event, and the identified event must match names with the ***EventName*** in the method name.</span></span> <span data-ttu-id="ce07e-143">第二個參數是要移除的處理常式。</span><span class="sxs-lookup"><span data-stu-id="ce07e-143">The second parameter is the handler to remove.</span></span> <span data-ttu-id="ce07e-144">這個方法必須是`public`和`static`，且沒有傳回值。</span><span class="sxs-lookup"><span data-stu-id="ce07e-144">The method must be `public` and `static`, with no return value.</span></span>  
  
 <span data-ttu-id="ce07e-145">**新增*EventName*處理常式**存取子方法可協助[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]時處理附加事件處理常式屬性宣告的項目。</span><span class="sxs-lookup"><span data-stu-id="ce07e-145">The **Add*EventName*Handler** accessor method facilitates the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processing when attached event handler attributes are declared on an element.</span></span> <span data-ttu-id="ce07e-146">**新增*EventName*處理常式**並**移除*EventName*處理常式**方法也可讓程式碼存取的事件處理常式存放區附加事件。</span><span class="sxs-lookup"><span data-stu-id="ce07e-146">The **Add*EventName*Handler** and **Remove*EventName*Handler** methods also enable code access to the event handler store for the attached event.</span></span>  
  
 <span data-ttu-id="ce07e-147">這種一般模式還不夠精確，無法實際實作在架構中，因為任何指定的 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 讀取器實作都可能會有不同的方式來識別支援語言與架構中的基礎事件。</span><span class="sxs-lookup"><span data-stu-id="ce07e-147">This general pattern is not yet precise enough for practical implementation in a framework, because any given [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] reader implementation might have different schemes for identifying underlying events in the supporting language and architecture.</span></span> <span data-ttu-id="ce07e-148">這是其中一個原因所[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]作為路由事件的實作附加事件、 要使用事件的識別項 (<xref:System.Windows.RoutedEvent>) 已經定義[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]事件系統。</span><span class="sxs-lookup"><span data-stu-id="ce07e-148">This is one of the reasons that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] implements attached events as routed events; the identifier to use for an event (<xref:System.Windows.RoutedEvent>) is already defined by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] event system.</span></span> <span data-ttu-id="ce07e-149">此外，路由事件是 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 語言層級的附加事件概念的自然實作延伸模組。</span><span class="sxs-lookup"><span data-stu-id="ce07e-149">Also, routing an event is a natural implementation extension on the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] language-level concept of an attached event.</span></span>  
  
 <span data-ttu-id="ce07e-150">**新增*EventName*處理常式**實作[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]附加的事件組成包括呼叫<xref:System.Windows.UIElement.AddHandler%2A>與路由的事件和處理常式做為引數。</span><span class="sxs-lookup"><span data-stu-id="ce07e-150">The **Add*EventName*Handler** implementation for a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] attached event consists of calling the <xref:System.Windows.UIElement.AddHandler%2A> with the routed event and handler as arguments.</span></span>  
  
 <span data-ttu-id="ce07e-151">此實作策略和路由的事件系統一般會處理附加事件的限制設為<xref:System.Windows.UIElement>衍生的類別或<xref:System.Windows.ContentElement>衍生類別，因為只有這些類別有<xref:System.Windows.UIElement.AddHandler%2A>實作。</span><span class="sxs-lookup"><span data-stu-id="ce07e-151">This implementation strategy and the routed event system in general restrict handling for attached events to either <xref:System.Windows.UIElement> derived classes or <xref:System.Windows.ContentElement> derived classes, because only those classes have <xref:System.Windows.UIElement.AddHandler%2A> implementations.</span></span>  
  
 <span data-ttu-id="ce07e-152">例如，下列程式碼定義擁有者類別 `Aquarium` 上的 `NeedsCleaning` 附加事件，並使用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 附加事件策略，將附加事件宣告為路由事件。</span><span class="sxs-lookup"><span data-stu-id="ce07e-152">For example, the following code defines the `NeedsCleaning` attached event on the owner class `Aquarium`, using the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] attached event strategy of declaring the attached event as a routed event.</span></span>  
  
 [!code-csharp[WPFAquariumSln#AECode](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#aecode)]
 [!code-vb[WPFAquariumSln#AECode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#aecode)]  
  
 <span data-ttu-id="ce07e-153">請注意此方法用來建立附加的事件的識別項欄位， <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>，實際的方法一樣，用來登錄非附加路由的事件。</span><span class="sxs-lookup"><span data-stu-id="ce07e-153">Note that the method used to establish the attached event identifier field, <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>, is actually the same method that is used to register a non-attached routed event.</span></span> <span data-ttu-id="ce07e-154">附加事件和路由事件全都註冊到集中式內部存放區。</span><span class="sxs-lookup"><span data-stu-id="ce07e-154">Attached events and routed events all are registered to a centralized internal store.</span></span> <span data-ttu-id="ce07e-155">此事件存放區實作促成了[路由事件概觀](routed-events-overview.md)中所討論的「事件即介面」概念考量。</span><span class="sxs-lookup"><span data-stu-id="ce07e-155">This event store implementation enables the "events as an interface" conceptual consideration that is discussed in [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="Raising"></a>   
## <a name="raising-a-wpf-attached-event"></a><span data-ttu-id="ce07e-156">引發 WPF 附加事件</span><span class="sxs-lookup"><span data-stu-id="ce07e-156">Raising a WPF Attached Event</span></span>  
 <span data-ttu-id="ce07e-157">您通常不需要從程式碼引發現有的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 已定義附加事件。</span><span class="sxs-lookup"><span data-stu-id="ce07e-157">You do not typically need to raise existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] defined attached events from your code.</span></span> <span data-ttu-id="ce07e-158">這些事件遵循一般 「 服務 」 概念模型，而且這類服務類別<xref:System.Windows.Input.InputManager>負責引發事件。</span><span class="sxs-lookup"><span data-stu-id="ce07e-158">These events follow the general "service" conceptual model, and service classes such as <xref:System.Windows.Input.InputManager> are responsible for raising the events.</span></span>  
  
 <span data-ttu-id="ce07e-159">不過，如果您要定義自訂的附加的事件，依據[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]為基礎的模型上附加事件<xref:System.Windows.RoutedEvent>，您可以使用<xref:System.Windows.UIElement.RaiseEvent%2A>引發任何附加的事件<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>。</span><span class="sxs-lookup"><span data-stu-id="ce07e-159">However, if you are defining a custom attached event based on the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] model of basing attached events on <xref:System.Windows.RoutedEvent>, you can use <xref:System.Windows.UIElement.RaiseEvent%2A> to raise an attached event from any <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="ce07e-160">引發路由的事件 （不論附加） 需要您宣告為事件來源; 項目樹狀結構中的特定項目該來源會報告為<xref:System.Windows.UIElement.RaiseEvent%2A>呼叫端。</span><span class="sxs-lookup"><span data-stu-id="ce07e-160">Raising a routed event (attached or not) requires that you declare a particular element in the element tree as the event source; that source is reported as the <xref:System.Windows.UIElement.RaiseEvent%2A> caller.</span></span> <span data-ttu-id="ce07e-161">判斷樹狀結構中的哪個項目報告為來源是服務的責任</span><span class="sxs-lookup"><span data-stu-id="ce07e-161">Determining which element is reported as the source in the tree is your service's responsibility</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="ce07e-162">另請參閱</span><span class="sxs-lookup"><span data-stu-id="ce07e-162">See also</span></span>

- [<span data-ttu-id="ce07e-163">路由事件概觀</span><span class="sxs-lookup"><span data-stu-id="ce07e-163">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="ce07e-164">XAML 語法詳細資料</span><span class="sxs-lookup"><span data-stu-id="ce07e-164">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
- [<span data-ttu-id="ce07e-165">WPF 的 XAML 和自訂類別</span><span class="sxs-lookup"><span data-stu-id="ce07e-165">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
