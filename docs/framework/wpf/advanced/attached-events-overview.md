---
title: 附加事件概觀
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- handling attached events [WPF]
- defining attached events as routed events [WPF]
- attached events [WPF], scenarios for
- attached events vs. routed events [WPF]
- backing attached events with routed events [WPF]
- attached events [WPF], definition
ms.assetid: 2c40eae3-80e4-4a45-ae09-df6c9ab4d91e
ms.openlocfilehash: e125c9a57090049f4319da96c7004f06606d0147
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141558"
---
# <a name="attached-events-overview"></a><span data-ttu-id="c1196-102">附加事件概觀</span><span class="sxs-lookup"><span data-stu-id="c1196-102">Attached Events Overview</span></span>

<span data-ttu-id="c1196-103">可延伸應用程式標記語言 （XAML） 定義稱為*附加事件*的語言元件和事件種類。</span><span class="sxs-lookup"><span data-stu-id="c1196-103">Extensible Application Markup Language (XAML) defines a language component and type of event called an *attached event*.</span></span> <span data-ttu-id="c1196-104">附加事件的概念，讓您能新增特定事件的處理常式到任意項目，而不是實際定義或繼承事件的項目。</span><span class="sxs-lookup"><span data-stu-id="c1196-104">The concept of an attached event enables you to add a handler for a particular event to an arbitrary element rather than to an element that actually defines or inherits the event.</span></span> <span data-ttu-id="c1196-105">在此情況下，可能引發事件的物件和目的地處理執行個體都不會定義或以其他方式「擁有」事件。</span><span class="sxs-lookup"><span data-stu-id="c1196-105">In this case, neither the object potentially raising the event nor the destination handling instance defines or otherwise "owns" the event.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="c1196-106">必要條件</span><span class="sxs-lookup"><span data-stu-id="c1196-106">Prerequisites</span></span>  
 <span data-ttu-id="c1196-107">本主題假設您已閱讀[路由事件概觀](routed-events-overview.md)和 [XAML 概觀 (WPF)](../../../desktop-wpf/fundamentals/xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="c1196-107">This topic assumes that you have read [Routed Events Overview](routed-events-overview.md) and [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>  
  
<a name="Syntax"></a>
## <a name="attached-event-syntax"></a><span data-ttu-id="c1196-108">附加事件語法</span><span class="sxs-lookup"><span data-stu-id="c1196-108">Attached Event Syntax</span></span>  
 <span data-ttu-id="c1196-109">附加的事件具有 XAML 語法和編碼模式，備份代碼必須使用該模式才能支援附加的事件使用。</span><span class="sxs-lookup"><span data-stu-id="c1196-109">Attached events have a XAML syntax and a coding pattern that must be used by the backing code in order to support the attached event usage.</span></span>  
  
 <span data-ttu-id="c1196-110">在 XAML 語法中，附加的事件不僅由其事件名稱指定，還由其所屬類型加上事件名稱指定，由點 （.） 分隔。</span><span class="sxs-lookup"><span data-stu-id="c1196-110">In XAML syntax, the attached event is specified not just by its event name, but by its owning type plus the event name, separated by a dot (.).</span></span> <span data-ttu-id="c1196-111">因為事件名稱以其擁有類型的名稱來限定，附加事件語法可讓任何附加事件附加至可以具現化的任何項目。</span><span class="sxs-lookup"><span data-stu-id="c1196-111">Because the event name is qualified with the name of its owning type, the attached event syntax allows any attached event to be attached to any element that can be instantiated.</span></span>  
  
 <span data-ttu-id="c1196-112">例如，以下是用於附加自訂`NeedsCleaning`附加事件的處理常式的 XAML 語法：</span><span class="sxs-lookup"><span data-stu-id="c1196-112">For example, the following is the XAML syntax for attaching a handler for a custom `NeedsCleaning` attached event:</span></span>  
  
 [!code-xaml[WPFAquariumSln#AE](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquarium/Window1.xaml#ae)]  
  
 <span data-ttu-id="c1196-113">請注意 `aqua:` 前置詞，前置詞在此情況中是必要的，因為附加事件是來自自訂對應 xmlns 的自訂事件。</span><span class="sxs-lookup"><span data-stu-id="c1196-113">Note the `aqua:` prefix; the prefix is necessary in this case because the attached event is a custom event that comes from a custom mapped xmlns.</span></span>  
  
<a name="WPFImplements"></a>
## <a name="how-wpf-implements-attached-events"></a><span data-ttu-id="c1196-114">WPF 如何實作附加事件</span><span class="sxs-lookup"><span data-stu-id="c1196-114">How WPF Implements Attached Events</span></span>

<span data-ttu-id="c1196-115">在 WPF 中，附加的事件由<xref:System.Windows.RoutedEvent>欄位備份，並在引發後通過樹路由它們。</span><span class="sxs-lookup"><span data-stu-id="c1196-115">In WPF, attached events are backed by a <xref:System.Windows.RoutedEvent> field and are routed through the tree after they are raised.</span></span> <span data-ttu-id="c1196-116">一般而言，附加事件的來源 (引發事件的物件) 是系統或服務來源，因此執行引發事件之程式碼的物件不直接是項目樹狀結構的一部分。</span><span class="sxs-lookup"><span data-stu-id="c1196-116">Typically, the source of the attached event (the object that raises the event) is a system or service source, and the object that runs the code that raises the event is therefore not a direct part of the element tree.</span></span>  
  
<a name="Scenarios"></a>
## <a name="scenarios-for-attached-events"></a><span data-ttu-id="c1196-117">附加事件的情節</span><span class="sxs-lookup"><span data-stu-id="c1196-117">Scenarios for Attached Events</span></span>  
 <span data-ttu-id="c1196-118">在 WPF 中，附加事件存在於存在服務等級抽象的某些功能區域，例如對於靜態<xref:System.Windows.Input.Mouse>類或<xref:System.Windows.Controls.Validation>類啟用的事件。</span><span class="sxs-lookup"><span data-stu-id="c1196-118">In WPF, attached events are present in certain feature areas where there is service-level abstraction, such as for the events enabled by the static <xref:System.Windows.Input.Mouse> class or the <xref:System.Windows.Controls.Validation> class.</span></span> <span data-ttu-id="c1196-119">與服務互動或是使用服務的類別可以以附加事件語法使用事件，或者它們可以選擇將附加事件公開為路由事件，路由事件是類別整合服務功能的方式之一。</span><span class="sxs-lookup"><span data-stu-id="c1196-119">Classes that interact with or use the service can either use the event in the attached event syntax, or they can choose to surface the attached event as a routed event that is part of how the class integrates the capabilities of the service.</span></span>  
  
 <span data-ttu-id="c1196-120">儘管 WPF 定義了許多附加事件，但直接使用或處理附加事件的情況非常有限。</span><span class="sxs-lookup"><span data-stu-id="c1196-120">Although WPF defines a number of attached events, the scenarios where you will either use or handle the attached event directly are very limited.</span></span> <span data-ttu-id="c1196-121">通常，附加事件具有體系結構目的，但隨後將轉發到未附加（帶有 CLR 事件"包裝器"的路由事件）。</span><span class="sxs-lookup"><span data-stu-id="c1196-121">Generally, the attached event serves an architecture purpose, but is then forwarded to a non-attached (backed with a CLR event "wrapper") routed event.</span></span>  
  
 <span data-ttu-id="c1196-122"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>例如，通過在給定的<xref:System.Windows.UIElement>上面使用<xref:System.Windows.UIElement.MouseDown>，而不是在 XAML 或代碼中處理附加<xref:System.Windows.UIElement>的事件語法，可以更輕鬆地處理基礎附加事件。</span><span class="sxs-lookup"><span data-stu-id="c1196-122">For instance, the underlying attached event <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> can more easily be handled on any given <xref:System.Windows.UIElement> by using <xref:System.Windows.UIElement.MouseDown> on that <xref:System.Windows.UIElement> rather than dealing with attached event syntax either in XAML or code.</span></span> <span data-ttu-id="c1196-123">附加事件在架構中有其用途，因為它可讓您在未來擴充輸入裝置。</span><span class="sxs-lookup"><span data-stu-id="c1196-123">The attached event serves a purpose in the architecture because it allows for future expansion of input devices.</span></span> <span data-ttu-id="c1196-124">假設設備只需要提高<xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>，以類比滑鼠輸入，並且不需要派生<xref:System.Windows.Input.Mouse>來執行此操作。</span><span class="sxs-lookup"><span data-stu-id="c1196-124">The hypothetical device would only need to raise <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> in order to simulate mouse input, and would not need to derive from <xref:System.Windows.Input.Mouse> to do so.</span></span> <span data-ttu-id="c1196-125">但是，此方案涉及事件的代碼處理，並且附加事件的 XAML 處理與此方案無關。</span><span class="sxs-lookup"><span data-stu-id="c1196-125">However, this scenario involves code handling of the events, and XAML handling of the attached event is not relevant to this scenario.</span></span>  
  
<a name="Handling"></a>
## <a name="handling-an-attached-event-in-wpf"></a><span data-ttu-id="c1196-126">在 WPF 中處理附加事件</span><span class="sxs-lookup"><span data-stu-id="c1196-126">Handling an Attached Event in WPF</span></span>  
 <span data-ttu-id="c1196-127">處理附加事件的程序，以及您將撰寫的處理常式程式碼，基本上與路由事件一樣。</span><span class="sxs-lookup"><span data-stu-id="c1196-127">The process for handling an attached event, and the handler code that you will write, is basically the same as for a routed event.</span></span>  
  
 <span data-ttu-id="c1196-128">通常，WPF 附加事件與 WPF 路由事件沒有很大區別。</span><span class="sxs-lookup"><span data-stu-id="c1196-128">In general, a WPF attached event is not very different from a WPF routed event.</span></span> <span data-ttu-id="c1196-129">差異是事件的來源方式以及類作為成員如何公開事件（這也會影響 XAML 處理常式語法）。</span><span class="sxs-lookup"><span data-stu-id="c1196-129">The differences are how the event is sourced and how it is exposed by a class as a member (which also affects the XAML handler syntax).</span></span>  
  
 <span data-ttu-id="c1196-130">但是，如前所述，現有的 WPF 附加事件並非特別適用于在 WPF 中處理。</span><span class="sxs-lookup"><span data-stu-id="c1196-130">However, as noted earlier, the existing WPF attached events are not particularly intended for handling in WPF.</span></span> <span data-ttu-id="c1196-131">更常見的是，事件的目的是要在複合 (compositing) 中啟用報告狀態給父項目的複合項目，在此情況下，事件通常會在程式碼中引發，並依賴相關父類別中的類別處理。</span><span class="sxs-lookup"><span data-stu-id="c1196-131">More often, the purpose of the event is to enable a composited element to report a state to a parent element in compositing, in which case the event is usually raised in code and also relies on class handling in the relevant parent class.</span></span> <span data-ttu-id="c1196-132">例如，應引發<xref:System.Windows.Controls.Primitives.Selector>附加<xref:System.Windows.Controls.Primitives.Selector.Selected>事件，然後<xref:System.Windows.Controls.Primitives.Selector>由類處理該事件，然後由<xref:System.Windows.Controls.Primitives.Selector>類可能將其轉換為其他路由事件 。 <xref:System.Windows.Controls.Primitives.Selector.SelectionChanged></span><span class="sxs-lookup"><span data-stu-id="c1196-132">For instance, items within a <xref:System.Windows.Controls.Primitives.Selector> are expected to raise the attached <xref:System.Windows.Controls.Primitives.Selector.Selected> event, which is then class handled by the <xref:System.Windows.Controls.Primitives.Selector> class and then potentially converted by the <xref:System.Windows.Controls.Primitives.Selector> class into a different routed event, <xref:System.Windows.Controls.Primitives.Selector.SelectionChanged>.</span></span> <span data-ttu-id="c1196-133">如需路由事件與類別處理的詳細資訊，請參閱[將路由事件標記為已處理以及類別處理](marking-routed-events-as-handled-and-class-handling.md)。</span><span class="sxs-lookup"><span data-stu-id="c1196-133">For more information on routed events and class handling, see [Marking Routed Events as Handled, and Class Handling](marking-routed-events-as-handled-and-class-handling.md).</span></span>  
  
<a name="Custom"></a>
## <a name="defining-your-own-attached-events-as-routed-events"></a><span data-ttu-id="c1196-134">將您自己的附加事件定義為路由事件</span><span class="sxs-lookup"><span data-stu-id="c1196-134">Defining Your Own Attached Events as Routed Events</span></span>  
 <span data-ttu-id="c1196-135">如果要從常見的 WPF 基類派生，則可以通過在類中包括某些模式方法並使用基類上已經存在的實用程式方法來實現您自己的附加事件。</span><span class="sxs-lookup"><span data-stu-id="c1196-135">If you are deriving from common WPF base classes, you can implement your own attached events by including certain pattern methods in your class and by using utility methods that are already present on the base classes.</span></span>  
  
 <span data-ttu-id="c1196-136">模式如下所示︰</span><span class="sxs-lookup"><span data-stu-id="c1196-136">The pattern is as follows:</span></span>  
  
- <span data-ttu-id="c1196-137">方法添加具有兩個參數__*的事件名稱*處理常式__。</span><span class="sxs-lookup"><span data-stu-id="c1196-137">A method __Add*EventName*Handler__ with two parameters.</span></span> <span data-ttu-id="c1196-138">第一個參數是向其添加事件處理常式的實例。</span><span class="sxs-lookup"><span data-stu-id="c1196-138">The first parameter is the instance to which the event handler is added.</span></span> <span data-ttu-id="c1196-139">第二個參數是要添加的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c1196-139">The second parameter is the event handler to add.</span></span> <span data-ttu-id="c1196-140">方法必須為`public`和`static`，沒有傳回值。</span><span class="sxs-lookup"><span data-stu-id="c1196-140">The method must be `public` and `static`, with no return value.</span></span>  
  
- <span data-ttu-id="c1196-141">方法刪除具有兩個參數__*的事件名稱*處理常式__。</span><span class="sxs-lookup"><span data-stu-id="c1196-141">A method __Remove*EventName*Handler__ with two parameters.</span></span> <span data-ttu-id="c1196-142">第一個參數是從中刪除事件處理常式的實例。</span><span class="sxs-lookup"><span data-stu-id="c1196-142">The first parameter is the instance from which the event handler is removed.</span></span> <span data-ttu-id="c1196-143">第二個參數是要刪除的事件處理常式。</span><span class="sxs-lookup"><span data-stu-id="c1196-143">The second parameter is the event handler to remove.</span></span> <span data-ttu-id="c1196-144">方法必須為`public`和`static`，沒有傳回值。</span><span class="sxs-lookup"><span data-stu-id="c1196-144">The method must be `public` and `static`, with no return value.</span></span>  
  
 <span data-ttu-id="c1196-145">在元素上聲明附加的事件處理常式屬性時，__添加*事件名稱*處理常式__訪問器方法有助於 XAML 處理。</span><span class="sxs-lookup"><span data-stu-id="c1196-145">The __Add*EventName*Handler__ accessor method facilitates XAML processing when attached event handler attributes are declared on an element.</span></span> <span data-ttu-id="c1196-146">__添加*事件名稱*處理常式__和__刪除*事件名稱*處理常式__方法還允許對附加事件的事件處理常式存儲進行代碼訪問。</span><span class="sxs-lookup"><span data-stu-id="c1196-146">The __Add*EventName*Handler__ and __Remove*EventName*Handler__ methods also enable code access to the event handler store for the attached event.</span></span>  
  
 <span data-ttu-id="c1196-147">此常規模式還不足以在框架中實際實現，因為任何給定的 XAML 讀取器實現可能具有不同的方案來標識支援語言和體系結構中的基礎事件。</span><span class="sxs-lookup"><span data-stu-id="c1196-147">This general pattern is not yet precise enough for practical implementation in a framework, because any given XAML reader implementation might have different schemes for identifying underlying events in the supporting language and architecture.</span></span> <span data-ttu-id="c1196-148">這是 WPF 將附加事件作為路由事件實現的原因之一;用於事件 （<xref:System.Windows.RoutedEvent>） 的識別碼已由 WPF 事件系統定義。</span><span class="sxs-lookup"><span data-stu-id="c1196-148">This is one of the reasons that WPF implements attached events as routed events; the identifier to use for an event (<xref:System.Windows.RoutedEvent>) is already defined by the WPF event system.</span></span> <span data-ttu-id="c1196-149">此外，路由事件是附加事件的 XAML 語言級別概念的自然實現擴展。</span><span class="sxs-lookup"><span data-stu-id="c1196-149">Also, routing an event is a natural implementation extension on the XAML language-level concept of an attached event.</span></span>  
  
 <span data-ttu-id="c1196-150">WPF 附加事件的__添加*事件名稱*處理常式__實現包括將<xref:System.Windows.UIElement.AddHandler%2A>路由事件和處理常式調用作為參數。</span><span class="sxs-lookup"><span data-stu-id="c1196-150">The __Add*EventName*Handler__ implementation for a WPF attached event consists of calling the <xref:System.Windows.UIElement.AddHandler%2A> with the routed event and handler as arguments.</span></span>  
  
 <span data-ttu-id="c1196-151">此實現策略和路由事件系統通常將附加事件的處理限制為<xref:System.Windows.UIElement>派生類或<xref:System.Windows.ContentElement>派生類，因為只有這些類具有<xref:System.Windows.UIElement.AddHandler%2A>實現。</span><span class="sxs-lookup"><span data-stu-id="c1196-151">This implementation strategy and the routed event system in general restrict handling for attached events to either <xref:System.Windows.UIElement> derived classes or <xref:System.Windows.ContentElement> derived classes, because only those classes have <xref:System.Windows.UIElement.AddHandler%2A> implementations.</span></span>  
  
 <span data-ttu-id="c1196-152">例如，以下代碼定義擁有者類`NeedsCleaning``Aquarium`上的附加事件，使用 WPF 附加的事件策略將附加事件聲明為路由事件。</span><span class="sxs-lookup"><span data-stu-id="c1196-152">For example, the following code defines the `NeedsCleaning` attached event on the owner class `Aquarium`, using the WPF attached event strategy of declaring the attached event as a routed event.</span></span>  
  
 [!code-csharp[WPFAquariumSln#AECode](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#aecode)]
 [!code-vb[WPFAquariumSln#AECode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#aecode)]  
  
 <span data-ttu-id="c1196-153">請注意，用於建立附加事件識別碼欄位<xref:System.Windows.EventManager.RegisterRoutedEvent%2A>的方法 實際上是用於註冊非附加路由事件的方法。</span><span class="sxs-lookup"><span data-stu-id="c1196-153">Note that the method used to establish the attached event identifier field, <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>, is actually the same method that is used to register a non-attached routed event.</span></span> <span data-ttu-id="c1196-154">附加事件和路由事件全都註冊到集中式內部存放區。</span><span class="sxs-lookup"><span data-stu-id="c1196-154">Attached events and routed events all are registered to a centralized internal store.</span></span> <span data-ttu-id="c1196-155">此事件存放區實作促成了[路由事件概觀](routed-events-overview.md)中所討論的「事件即介面」概念考量。</span><span class="sxs-lookup"><span data-stu-id="c1196-155">This event store implementation enables the "events as an interface" conceptual consideration that is discussed in [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="Raising"></a>
## <a name="raising-a-wpf-attached-event"></a><span data-ttu-id="c1196-156">引發 WPF 附加事件</span><span class="sxs-lookup"><span data-stu-id="c1196-156">Raising a WPF Attached Event</span></span>  
 <span data-ttu-id="c1196-157">您通常不需要從代碼中引發現有的 WPF 定義的附加事件。</span><span class="sxs-lookup"><span data-stu-id="c1196-157">You do not typically need to raise existing WPF-defined attached events from your code.</span></span> <span data-ttu-id="c1196-158">這些事件遵循一般"服務"概念模型，服務類（如<xref:System.Windows.Input.InputManager>負責引發事件）。</span><span class="sxs-lookup"><span data-stu-id="c1196-158">These events follow the general "service" conceptual model, and service classes such as <xref:System.Windows.Input.InputManager> are responsible for raising the events.</span></span>  
  
 <span data-ttu-id="c1196-159">但是，如果您正在基於基於 附加事件的 WPF 模型定義<xref:System.Windows.RoutedEvent>自訂附加事件，則可以使用<xref:System.Windows.UIElement.RaiseEvent%2A>從 任何<xref:System.Windows.UIElement>或<xref:System.Windows.ContentElement>引發附加事件。</span><span class="sxs-lookup"><span data-stu-id="c1196-159">However, if you are defining a custom attached event based on the WPF model of basing attached events on <xref:System.Windows.RoutedEvent>, you can use <xref:System.Windows.UIElement.RaiseEvent%2A> to raise an attached event from any <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="c1196-160">引發路由事件（附加或不附加）要求您將元素樹中的特定元素聲明為事件源;否則，將元素聲明為事件源。該源報告為<xref:System.Windows.UIElement.RaiseEvent%2A>調用方。</span><span class="sxs-lookup"><span data-stu-id="c1196-160">Raising a routed event (attached or not) requires that you declare a particular element in the element tree as the event source; that source is reported as the <xref:System.Windows.UIElement.RaiseEvent%2A> caller.</span></span> <span data-ttu-id="c1196-161">判斷樹狀結構中的哪個項目報告為來源是服務的責任</span><span class="sxs-lookup"><span data-stu-id="c1196-161">Determining which element is reported as the source in the tree is your service's responsibility</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c1196-162">另請參閱</span><span class="sxs-lookup"><span data-stu-id="c1196-162">See also</span></span>

- [<span data-ttu-id="c1196-163">路由事件概觀</span><span class="sxs-lookup"><span data-stu-id="c1196-163">Routed Events Overview</span></span>](routed-events-overview.md)
- [<span data-ttu-id="c1196-164">XAML 語法詳細資料</span><span class="sxs-lookup"><span data-stu-id="c1196-164">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
- [<span data-ttu-id="c1196-165">WPF 的 XAML 和自訂類別</span><span class="sxs-lookup"><span data-stu-id="c1196-165">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
