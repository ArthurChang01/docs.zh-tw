---
title: 相依性屬性中繼資料
ms.date: 03/30/2017
helpviewer_keywords:
- APIs [WPF], metadata
- dependency properties [WPF], metadata
- metadata [WPF], for dependency properties
- overriding metadata [WPF]
ms.assetid: d01ed009-b722-41bf-b82f-fe1a8cdc50dd
ms.openlocfilehash: 154a2543c62de545e8b2df711d6ad51989d0689d
ms.sourcegitcommit: 68653db98c5ea7744fd438710248935f70020dfb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/22/2019
ms.locfileid: "69964842"
---
# <a name="dependency-property-metadata"></a><span data-ttu-id="40c44-102">相依性屬性中繼資料</span><span class="sxs-lookup"><span data-stu-id="40c44-102">Dependency Property Metadata</span></span>
<span data-ttu-id="40c44-103">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]屬性系統包含的元資料包告系統, 超出了透過反映或通用 common language runtime (CLR) 特性來報告屬性的內容。</span><span class="sxs-lookup"><span data-stu-id="40c44-103">The [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system includes a metadata reporting system that goes beyond what can be reported about a property through reflection or general common language runtime (CLR) characteristics.</span></span> <span data-ttu-id="40c44-104">相依性屬性的中繼資料也可由定義相依性屬性的類別唯一指派、在相依性屬性新增至不同類別時變更，以及由從定義的基底類別繼承相依性屬性的所有衍生類別明確覆寫。</span><span class="sxs-lookup"><span data-stu-id="40c44-104">Metadata for a dependency property can also be assigned uniquely by the class that defines a dependency property, can be changed when the dependency property is added to a different class, and can be specifically overridden by all derived classes that inherit the dependency property from the defining base class.</span></span>  

<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="40c44-105">必要條件</span><span class="sxs-lookup"><span data-stu-id="40c44-105">Prerequisites</span></span>  
 <span data-ttu-id="40c44-106">本主題假設您已從 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 類別的現有相依性屬性消費者角度了解相依性屬性，並已閱讀[相依性屬性概觀](dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="40c44-106">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="40c44-107">為了解本主題中的範例，您也應該了解 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 並知道如何撰寫 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 應用程式。</span><span class="sxs-lookup"><span data-stu-id="40c44-107">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>  
  
<a name="dp_metadata_contents"></a>   
## <a name="how-dependency-property-metadata-is-used"></a><span data-ttu-id="40c44-108">相依性屬性中繼資料的使用方式</span><span class="sxs-lookup"><span data-stu-id="40c44-108">How Dependency Property Metadata is Used</span></span>  
 <span data-ttu-id="40c44-109">相依性屬性中繼資料以物件的形式存在，可接受查詢來查看相依性屬性的特性。</span><span class="sxs-lookup"><span data-stu-id="40c44-109">Dependency property metadata exists as an object that can be queried to examine the characteristics of a dependency property.</span></span> <span data-ttu-id="40c44-110">屬性系統也經常存取此中繼資料，因為它會處理任何指定的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="40c44-110">This metadata is also accessed frequently by the property system as it processes any given dependency property.</span></span> <span data-ttu-id="40c44-111">相依性屬性的中繼資料物件可包含下列類型的資訊：</span><span class="sxs-lookup"><span data-stu-id="40c44-111">The metadata object for a dependency property can contain the following types of information:</span></span>  
  
- <span data-ttu-id="40c44-112">相依性屬性的預設值 (如果無法由區域數值、樣式、繼承等判斷出相依性屬性的其他值)。如需預設值在屬性系統指派相依性屬性的值時所佔優先順序的完整說明，請參閱[相依性屬性值優先順序](dependency-property-value-precedence.md)。</span><span class="sxs-lookup"><span data-stu-id="40c44-112">Default value for the dependency property, if no other value can be determined for the dependency property by local value, style, inheritance, etc. For a thorough discussion of how default values participate in the precedence used by the property system when assigning values for dependency properties, see [Dependency Property Value Precedence](dependency-property-value-precedence.md).</span></span>  
  
- <span data-ttu-id="40c44-113">影響各擁有者類型之強制型轉或變更通知行為的回呼實作參考。</span><span class="sxs-lookup"><span data-stu-id="40c44-113">References to callback implementations that affect coercion or change-notification behaviors on a per-owner-type basis.</span></span> <span data-ttu-id="40c44-114">請注意，這些回呼通常是在非公用存取層級定義，因此一般無法從中繼資料取得實際參考，除非參考位於允許的存取範圍內。</span><span class="sxs-lookup"><span data-stu-id="40c44-114">Note that these callbacks are often defined with a nonpublic access level, so obtaining the actual references from metadata is generally not possible unless the references are within your permitted access scope.</span></span> <span data-ttu-id="40c44-115">如需相依性屬性回呼的詳細資訊，請參閱[相依性屬性回呼和驗證](dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="40c44-115">For more information on dependency property callbacks, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>  
  
- <span data-ttu-id="40c44-116">如果將考慮中的相依性屬性視為 WPF 架構層級屬性，中繼資料可能會包含 WPF 架構層級相依性屬性特性，以報告服務的資訊和狀態 (例如 WPF 架構層級配置引擎和屬性繼承邏輯)。</span><span class="sxs-lookup"><span data-stu-id="40c44-116">If the dependency property in question is considered to be a WPF framework-level property, the metadata might contain WPF framework-level dependency property characteristics, which report information and state for services such as the WPF framework-level layout engine and property inheritance logic.</span></span> <span data-ttu-id="40c44-117">如需相依性屬性中繼資料在這方面的詳細資訊，請參閱[架構屬性中繼資料](framework-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="40c44-117">For more information on this aspect of dependency property metadata, see [Framework Property Metadata](framework-property-metadata.md).</span></span>  
  
<a name="APIs"></a>   
## <a name="metadata-apis"></a><span data-ttu-id="40c44-118">中繼資料 API</span><span class="sxs-lookup"><span data-stu-id="40c44-118">Metadata APIs</span></span>  
 <span data-ttu-id="40c44-119">報告屬性系統所使用之大部分中繼資料資訊的型別是<xref:System.Windows.PropertyMetadata>類別。</span><span class="sxs-lookup"><span data-stu-id="40c44-119">The type that reports most of the metadata information used by the property system is the <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="40c44-120">當相依性屬性向屬性系統註冊時，會選擇性指定中繼資料執行個體，而且若有其他類型將自身作為擁有者新增或覆寫從基底類別相依性屬性定義繼承的中繼資料，則可再次指定中繼資料執行個體</span><span class="sxs-lookup"><span data-stu-id="40c44-120">Metadata instances are optionally specified when dependency properties are registered with the property system, and can be specified again for additional types that either add themselves as owners or override metadata they inherit from the base class dependency property definition.</span></span> <span data-ttu-id="40c44-121">(在屬性註冊未指定中繼資料的情況下, 會使用<xref:System.Windows.PropertyMetadata>該類別的預設值建立預設值)。<xref:System.Windows.PropertyMetadata>當您呼叫從<xref:System.Windows.DependencyObject>實例上的相依性屬性取得中繼資料的各種多<xref:System.Windows.DependencyProperty.GetMetadata%2A>載時, 會傳回已註冊的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="40c44-121">(For cases where a property registration does not specify metadata, a default <xref:System.Windows.PropertyMetadata> is created with default values for that class.)The registered metadata is returned as <xref:System.Windows.PropertyMetadata> when you call the various <xref:System.Windows.DependencyProperty.GetMetadata%2A> overloads that get metadata from a dependency property on a <xref:System.Windows.DependencyObject> instance.</span></span>  
  
 <span data-ttu-id="40c44-122">然後<xref:System.Windows.PropertyMetadata> , 類別會衍生自, 以針對架構分割 (例如 WPF 架構層級類別) 提供更具體的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="40c44-122">The <xref:System.Windows.PropertyMetadata> class is then derived from to provide more specific metadata for architectural divisions such as the WPF framework-level classes.</span></span> <span data-ttu-id="40c44-123"><xref:System.Windows.UIPropertyMetadata>加入動畫報表, 並<xref:System.Windows.FrameworkPropertyMetadata>提供上一節中所述的 WPF 架構層級屬性。</span><span class="sxs-lookup"><span data-stu-id="40c44-123"><xref:System.Windows.UIPropertyMetadata> adds animation reporting, and <xref:System.Windows.FrameworkPropertyMetadata> provides the WPF framework-level properties mentioned in the previous section.</span></span> <span data-ttu-id="40c44-124">註冊相依性屬性時, 可以向這些<xref:System.Windows.PropertyMetadata>衍生類別註冊。</span><span class="sxs-lookup"><span data-stu-id="40c44-124">When dependency properties are registered, they can be registered with these <xref:System.Windows.PropertyMetadata> derived classes.</span></span> <span data-ttu-id="40c44-125">當檢查中繼資料時, 基底<xref:System.Windows.PropertyMetadata>類型可能會轉換成衍生類別, 讓您可以檢查更具體的屬性。</span><span class="sxs-lookup"><span data-stu-id="40c44-125">When the metadata is examined, the base <xref:System.Windows.PropertyMetadata> type can potentially be cast to the derived classes so that you can examine the more specific properties.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="40c44-126">在此檔中, 可以指定<xref:System.Windows.FrameworkPropertyMetadata>的屬性特性有時稱為「旗標」。</span><span class="sxs-lookup"><span data-stu-id="40c44-126">The property characteristics that can be specified in <xref:System.Windows.FrameworkPropertyMetadata> are sometimes referred to in this documentation as "flags".</span></span> <span data-ttu-id="40c44-127">當您建立新的中繼資料實例以用於相依性屬性註冊或中繼資料覆寫時, 您可以使用<xref:System.Windows.FrameworkPropertyMetadataOptions>旗標型列舉來指定這些值, 然後將列舉的可能串連值提供給<xref:System.Windows.FrameworkPropertyMetadata>函數。</span><span class="sxs-lookup"><span data-stu-id="40c44-127">When you create new metadata instances for use in dependency property registrations or metadata overrides, you specify these values using the flagwise enumeration <xref:System.Windows.FrameworkPropertyMetadataOptions> and then you supply possibly concatenated values of the enumeration to the <xref:System.Windows.FrameworkPropertyMetadata> constructor.</span></span> <span data-ttu-id="40c44-128">不過, 在結構化之後, 這些選項特性會<xref:System.Windows.FrameworkPropertyMetadata>以一系列的布林值屬性 (而不是「結構化列舉值」) 的形式公開在中。</span><span class="sxs-lookup"><span data-stu-id="40c44-128">However, once constructed, these option characteristics are exposed within a <xref:System.Windows.FrameworkPropertyMetadata> as a series of Boolean properties rather than the constructing enumeration value.</span></span> <span data-ttu-id="40c44-129">布林值屬性可讓您查看每個條件，而不需要將遮罩套用到旗標型列舉值以取得所需的資訊。</span><span class="sxs-lookup"><span data-stu-id="40c44-129">The Boolean properties enable you to check each conditional, rather than requiring you to apply a mask to a flagwise enumeration value to get the information you are interested in.</span></span> <span data-ttu-id="40c44-130">此函式會使用<xref:System.Windows.FrameworkPropertyMetadataOptions>串連的, 以保持可合理的函式簽章長度, 而實際的結構化中繼資料會公開離散屬性, 讓查詢中繼資料更加直覺。</span><span class="sxs-lookup"><span data-stu-id="40c44-130">The constructor uses the concatenated <xref:System.Windows.FrameworkPropertyMetadataOptions> in order to keep the length of the constructor signature reasonable, whereas the actual constructed metadata exposes the discrete properties to make querying the metadata more intuitive.</span></span>  
  
<a name="override_or_subclass"></a>   
## <a name="when-to-override-metadata-when-to-derive-a-class"></a><span data-ttu-id="40c44-131">何時覆寫中繼資料及衍生類別</span><span class="sxs-lookup"><span data-stu-id="40c44-131">When to Override Metadata, When to Derive a Class</span></span>  
 <span data-ttu-id="40c44-132">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 屬性系統能夠變更相依性屬性的部分特性，而不需要重新實作整個屬性。</span><span class="sxs-lookup"><span data-stu-id="40c44-132">The [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system has established capabilities for changing some characteristics of dependency properties without requiring them to be entirely re-implemented.</span></span> <span data-ttu-id="40c44-133">這是由於相依性屬性位於特定類型上，因此可藉由為相依性屬性建構不同的屬性中繼資料執行個體來達成。</span><span class="sxs-lookup"><span data-stu-id="40c44-133">This is accomplished by constructing a different instance of property metadata for the dependency property as it exists on a particular type.</span></span> <span data-ttu-id="40c44-134">請注意，大多數現有相依性屬性不是虛擬屬性，因此嚴格來說，要在繼承的類別上「重新實作」這些屬性，只能藉由鏡像處理現有成員來達成。</span><span class="sxs-lookup"><span data-stu-id="40c44-134">Note that most existing dependency properties are not virtual properties, so strictly speaking "re-implementing" them on inherited classes could only be accomplished by shadowing the existing member.</span></span>  
  
 <span data-ttu-id="40c44-135">如果您要嘗試為某個類型上的相依性屬性啟用的情節，無法藉由修改現有相依性屬性的特性來達成，則可能需要建立衍生類別，然後在該衍生類別上宣告自訂相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="40c44-135">If the scenario you are trying to enable for a dependency property on a type cannot be accomplished by modifying characteristics of existing dependency properties, it might then be necessary to create a derived class, and then to declare a custom dependency property on your derived class.</span></span> <span data-ttu-id="40c44-136">自訂相依性屬性的行為與 api 所[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]定義的相依性屬性完全相同。</span><span class="sxs-lookup"><span data-stu-id="40c44-136">A custom dependency property behaves identically to dependency properties defined by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs.</span></span> <span data-ttu-id="40c44-137">如需自訂相依性屬性的詳細資訊，請參閱[自訂相依性屬性](custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="40c44-137">For more details about custom dependency properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
 <span data-ttu-id="40c44-138">您無法覆寫的相依性屬性有一個值得注意的特性，那就是它的實值型別。</span><span class="sxs-lookup"><span data-stu-id="40c44-138">One notable characteristic of a dependency property that you cannot override is its value type.</span></span> <span data-ttu-id="40c44-139">如果您繼承的相依性屬性所具有的行為大致符合需求，但此相依性屬性需要不同的類型，就必須實作自訂相依性屬性，而且可能需要透過類型轉換或自訂類別上的其他實作連結屬性。</span><span class="sxs-lookup"><span data-stu-id="40c44-139">If you are inheriting a dependency property that has the approximate behavior you require, but you require a different type for it, you will have to implement a custom dependency property and perhaps link the properties through type conversion or other implementation on your custom class.</span></span> <span data-ttu-id="40c44-140">此外, 您也無法取代現有<xref:System.Windows.ValidateValueCallback>的, 因為此回呼存在於註冊欄位本身, 而不在其中繼資料內。</span><span class="sxs-lookup"><span data-stu-id="40c44-140">Also, you cannot replace an existing <xref:System.Windows.ValidateValueCallback>, because this callback exists in the registration field itself and not within its metadata.</span></span>  
  
<a name="scenarios"></a>   
## <a name="scenarios-for-changing-existing-metadata"></a><span data-ttu-id="40c44-141">變更現有中繼資料的情節</span><span class="sxs-lookup"><span data-stu-id="40c44-141">Scenarios for Changing Existing Metadata</span></span>  
 <span data-ttu-id="40c44-142">如果您使用現有相依性屬性的中繼資料，變更相依性屬性中繼資料的一個常見情節是變更預設值。</span><span class="sxs-lookup"><span data-stu-id="40c44-142">If you are working with metadata of an existing dependency property, one common scenario for changing dependency property metadata is to change the default value.</span></span> <span data-ttu-id="40c44-143">變更或新增屬性系統回呼是更進階的情節。</span><span class="sxs-lookup"><span data-stu-id="40c44-143">Changing or adding property system callbacks is a more advanced scenario.</span></span> <span data-ttu-id="40c44-144">如果您的衍生類別實作在相依性屬性之間有不同的相互關係，就可能會想要這麼做。</span><span class="sxs-lookup"><span data-stu-id="40c44-144">You might want to do this if your implementation of a derived class has different interrelationships between dependency properties.</span></span> <span data-ttu-id="40c44-145">具有同時支援程式碼和宣告式使用方式之程式設計模型的條件之一，就是屬性必須能夠以任何順序設定。</span><span class="sxs-lookup"><span data-stu-id="40c44-145">One of the conditionals of having a programming model that supports both code and declarative usage is that properties must enable being set in any order.</span></span> <span data-ttu-id="40c44-146">因此，任何相依性屬性都必須在沒有內容的情況下進行 Just-In-Time 設定，不能依賴建構函式中可能找到的設定順序來進行設定。</span><span class="sxs-lookup"><span data-stu-id="40c44-146">Thus any dependent properties need to be set just-in-time without context and cannot rely on knowing a setting order such as might be found in a constructor.</span></span> <span data-ttu-id="40c44-147">如需屬性系統在這方面的詳細資訊，請參閱[相依性屬性回呼和驗證](dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="40c44-147">For more information on this aspect of the property system, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span> <span data-ttu-id="40c44-148">請注意，驗證回呼不是中繼資料的一部分，而是相依性屬性識別項的一部分。</span><span class="sxs-lookup"><span data-stu-id="40c44-148">Note that validation callbacks are not part of the metadata; they are part of the dependency property identifier.</span></span> <span data-ttu-id="40c44-149">因此，您無法藉由覆寫中繼資料來變更驗證回呼。</span><span class="sxs-lookup"><span data-stu-id="40c44-149">Therefore, validation callbacks cannot be changed by overriding the metadata.</span></span>  
  
 <span data-ttu-id="40c44-150">在某些情況下，您可能也想變更現有相依性屬性上的 WPF 架構層級屬性中繼資料選項。</span><span class="sxs-lookup"><span data-stu-id="40c44-150">In some cases you might also want to alter the WPF framework-level property metadata options on existing dependency properties.</span></span> <span data-ttu-id="40c44-151">這些選項會將 WPF 架構層級屬性的某些已知條件傳達給其他 WPF 架構層級處理序 (例如配置系統)。</span><span class="sxs-lookup"><span data-stu-id="40c44-151">These options communicate certain known conditionals about WPF framework-level properties to other WPF framework-level processes such as the layout system.</span></span>  <span data-ttu-id="40c44-152">設定選項通常只有在註冊新的相依性屬性時才會完成, 但是也可以在<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>或<xref:System.Windows.DependencyProperty.AddOwner%2A>呼叫中變更 WPF 架構層級的屬性中繼資料。</span><span class="sxs-lookup"><span data-stu-id="40c44-152">Setting the options is generally done only when registering a new dependency property, but it is also possible to change the WPF framework-level property metadata as part of a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> or <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span> <span data-ttu-id="40c44-153">如需要使用的特定值和詳細資訊，請參閱[架構屬性中繼資料](framework-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="40c44-153">For the specific values to use and more information, see [Framework Property Metadata](framework-property-metadata.md).</span></span> <span data-ttu-id="40c44-154">如需如何針對新註冊的相依性屬性設定這些選項的詳細資訊，請參閱[自訂相依性屬性](custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="40c44-154">For more information that is pertinent to how these options should be set for a newly registered dependency property, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>  
  
<a name="dp_override_metadata"></a>   
### <a name="overriding-metadata"></a><span data-ttu-id="40c44-155">覆寫中繼資料</span><span class="sxs-lookup"><span data-stu-id="40c44-155">Overriding Metadata</span></span>  
 <span data-ttu-id="40c44-156">覆寫中繼資料的目的，主要是讓您有機會變更各種中繼資料衍生的行為，這些行為會套用到類型上的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="40c44-156">The purpose of overriding metadata is primarily so that you have the opportunity to change the various metadata-derived behaviors that are applied to the dependency property as it exists on your type.</span></span> <span data-ttu-id="40c44-157">[中繼資料](#dp_metadata_contents)一節會詳細說明原因。</span><span class="sxs-lookup"><span data-stu-id="40c44-157">The reasons for this are explained in more detail in the [Metadata](#dp_metadata_contents) section.</span></span> <span data-ttu-id="40c44-158">如需詳細資訊，包括一些程式碼範例，請參閱[覆寫相依性屬性的中繼資料](how-to-override-metadata-for-a-dependency-property.md)。</span><span class="sxs-lookup"><span data-stu-id="40c44-158">For more information including some code examples, see [Override Metadata for a Dependency Property](how-to-override-metadata-for-a-dependency-property.md).</span></span>  
  
 <span data-ttu-id="40c44-159">在註冊呼叫 (<xref:System.Windows.DependencyProperty.Register%2A>) 期間, 可以提供相依性屬性的屬性中繼資料。</span><span class="sxs-lookup"><span data-stu-id="40c44-159">Property metadata can be supplied for a dependency property during the registration call (<xref:System.Windows.DependencyProperty.Register%2A>).</span></span> <span data-ttu-id="40c44-160">不過，在許多情況下，當您的類別繼承該相依性屬性時，您可能會想要為類別提供特定類型的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="40c44-160">However, in many cases, you might want to provide type-specific metadata for your class when it inherits that dependency property.</span></span> <span data-ttu-id="40c44-161">您可以藉由呼叫<xref:System.Windows.DependencyProperty.OverrideMetadata%2A>方法來執行這項操作。</span><span class="sxs-lookup"><span data-stu-id="40c44-161">You can do this by calling the <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> method.</span></span>  <span data-ttu-id="40c44-162">如需[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] api 的範例<xref:System.Windows.FrameworkElement> , 類別是第一次註冊<xref:System.Windows.UIElement.Focusable%2A>相依性屬性的型別。</span><span class="sxs-lookup"><span data-stu-id="40c44-162">For an example from the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs, the <xref:System.Windows.FrameworkElement> class is the type that first registers the <xref:System.Windows.UIElement.Focusable%2A> dependency property.</span></span> <span data-ttu-id="40c44-163">但是, `false` `true` <xref:System.Windows.UIElement.Focusable%2A>類別會覆寫相依性屬性的中繼資料, 以提供它自己的初始預設值, 將它從變更為, 否則會重新使用原始的執行。 <xref:System.Windows.Controls.Control></span><span class="sxs-lookup"><span data-stu-id="40c44-163">But the <xref:System.Windows.Controls.Control> class overrides metadata for the dependency property to provide its own initial default value, changing it from `false` to `true`, and otherwise re-uses the original <xref:System.Windows.UIElement.Focusable%2A> implementation.</span></span>  
  
 <span data-ttu-id="40c44-164">當您覆寫中繼資料時，不同的中繼資料特性會被合併或取代。</span><span class="sxs-lookup"><span data-stu-id="40c44-164">When you override metadata, the different metadata characteristics are either merged or replaced.</span></span>  
  
- <span data-ttu-id="40c44-165"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>已合併。</span><span class="sxs-lookup"><span data-stu-id="40c44-165"><xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is merged.</span></span> <span data-ttu-id="40c44-166">如果您加入新<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>的, 該回呼就會儲存在中繼資料中。</span><span class="sxs-lookup"><span data-stu-id="40c44-166">If you add a new <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="40c44-167">如果您未<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>在覆寫中指定, 則的<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>值會升級為最接近的上階 (在中繼資料中指定) 的參考。</span><span class="sxs-lookup"><span data-stu-id="40c44-167">If you do not specify a <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="40c44-168">的實際屬性系統行為<xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A>是將階層中所有中繼資料擁有者的執行保留並加入資料表中, 而屬性系統會先叫用最常衍生的類別回呼。</span><span class="sxs-lookup"><span data-stu-id="40c44-168">The actual property system behavior for <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> is that implementations for all metadata owners in the hierarchy are retained and added to a table, with order of execution by the property system being that the most derived class's callbacks are invoked first.</span></span>  
  
- <span data-ttu-id="40c44-169"><xref:System.Windows.PropertyMetadata.DefaultValue%2A>已取代。</span><span class="sxs-lookup"><span data-stu-id="40c44-169"><xref:System.Windows.PropertyMetadata.DefaultValue%2A> is replaced.</span></span> <span data-ttu-id="40c44-170">如果您未<xref:System.Windows.PropertyMetadata.DefaultValue%2A>在覆寫中指定, 的<xref:System.Windows.PropertyMetadata.DefaultValue%2A>值會來自在中繼資料中指定它的最接近上階。</span><span class="sxs-lookup"><span data-stu-id="40c44-170">If you do not specify a <xref:System.Windows.PropertyMetadata.DefaultValue%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.DefaultValue%2A> comes from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="40c44-171"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>系統會取代實作為。</span><span class="sxs-lookup"><span data-stu-id="40c44-171"><xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations are replaced.</span></span> <span data-ttu-id="40c44-172">如果您加入新<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>的, 該回呼就會儲存在中繼資料中。</span><span class="sxs-lookup"><span data-stu-id="40c44-172">If you add a new <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>, that callback is stored in the metadata.</span></span> <span data-ttu-id="40c44-173">如果您未<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>在覆寫中指定, 則的<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>值會升級為最接近的上階 (在中繼資料中指定) 的參考。</span><span class="sxs-lookup"><span data-stu-id="40c44-173">If you do not specify a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the override, the value of <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> is promoted as a reference from the nearest ancestor that specified it in metadata.</span></span>  
  
- <span data-ttu-id="40c44-174">屬性系統行為是只會叫用<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>立即中繼資料中的。</span><span class="sxs-lookup"><span data-stu-id="40c44-174">The property system behavior is that only the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> in the immediate metadata is invoked.</span></span> <span data-ttu-id="40c44-175">不會保留階層<xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>中其他實體系的參考。</span><span class="sxs-lookup"><span data-stu-id="40c44-175">No references to other <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> implementations in the hierarchy are retained.</span></span>  
  
 <span data-ttu-id="40c44-176">這個行為是由<xref:System.Windows.PropertyMetadata.Merge%2A>所執行, 而且可以在衍生的中繼資料類別上覆寫。</span><span class="sxs-lookup"><span data-stu-id="40c44-176">This behavior is implemented by <xref:System.Windows.PropertyMetadata.Merge%2A>, and can be overridden on derived metadata classes.</span></span>  
  
#### <a name="overriding-attached-property-metadata"></a><span data-ttu-id="40c44-177">覆寫附加屬性中繼資料</span><span class="sxs-lookup"><span data-stu-id="40c44-177">Overriding Attached Property Metadata</span></span>  
 <span data-ttu-id="40c44-178">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中，附加屬性會以相依性屬性的方式實作。</span><span class="sxs-lookup"><span data-stu-id="40c44-178">In [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)], attached properties are implemented as dependency properties.</span></span> <span data-ttu-id="40c44-179">這表示它們也有屬性中繼資料，可供個別類別覆寫。</span><span class="sxs-lookup"><span data-stu-id="40c44-179">This means that they also have property metadata, which individual classes can override.</span></span> <span data-ttu-id="40c44-180">在中[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] , 附加屬性的範圍考慮通常是任何<xref:System.Windows.DependencyObject>可以設定的附加屬性。</span><span class="sxs-lookup"><span data-stu-id="40c44-180">The scoping considerations for an attached property in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] are generally that any <xref:System.Windows.DependencyObject> can have an attached property set on them.</span></span> <span data-ttu-id="40c44-181">因此, 任何<xref:System.Windows.DependencyObject>衍生的類別都可以覆寫任何附加屬性的中繼資料, 因為它可能會在類別的實例上設定。</span><span class="sxs-lookup"><span data-stu-id="40c44-181">Therefore, any <xref:System.Windows.DependencyObject> derived class can override the metadata for any attached property, as it might be set on an instance of the class.</span></span> <span data-ttu-id="40c44-182">您可以覆寫預設值、回呼或 WPF 架構層級特性報告屬性。</span><span class="sxs-lookup"><span data-stu-id="40c44-182">You can override default values, callbacks, or WPF framework-level characteristic-reporting properties.</span></span> <span data-ttu-id="40c44-183">如果在類別執行個體上設定附加屬性，則會套用這些覆寫屬性中繼資料特性。</span><span class="sxs-lookup"><span data-stu-id="40c44-183">If the attached property is set on an instance of your class, those override property metadata characteristics apply.</span></span> <span data-ttu-id="40c44-184">例如，您可以覆寫預設值，只要沒有另外設定屬性，就會將覆寫值回報為類別執行個體上附加屬性的值。</span><span class="sxs-lookup"><span data-stu-id="40c44-184">For instance, you can override the default value, such that your override value is reported as the value of the attached property on instances of your class, whenever the property is not otherwise set.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="40c44-185"><xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>屬性與附加屬性不相關。</span><span class="sxs-lookup"><span data-stu-id="40c44-185">The <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> property is not relevant for attached properties.</span></span>  
  
<a name="dp_add_owner"></a>   
### <a name="adding-a-class-as-an-owner-of-an-existing-dependency-property"></a><span data-ttu-id="40c44-186">新增類別作為現有相依性屬性的擁有者</span><span class="sxs-lookup"><span data-stu-id="40c44-186">Adding a Class as an Owner of an Existing Dependency Property</span></span>  
 <span data-ttu-id="40c44-187">類別可以使用<xref:System.Windows.DependencyProperty.AddOwner%2A>方法, 將本身新增為已註冊之相依性屬性的擁有者。</span><span class="sxs-lookup"><span data-stu-id="40c44-187">A class can add itself as an owner of a dependency property that has already been registered, by using the <xref:System.Windows.DependencyProperty.AddOwner%2A> method.</span></span> <span data-ttu-id="40c44-188">這可讓類別使用原本註冊給其他類型的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="40c44-188">This enables the class to use a dependency property that was originally registered for a different type.</span></span> <span data-ttu-id="40c44-189">新增的類別通常不是原先註冊該相依性屬性作為擁有者之類型的衍生類別。</span><span class="sxs-lookup"><span data-stu-id="40c44-189">The adding class is typically not a derived class of the type that first registered that dependency property as owner.</span></span> <span data-ttu-id="40c44-190">實際上，這可讓類別及其衍生類別「繼承」相依性屬性實作，而原始擁有者類別和新增的類別不需要在同一個真實類別階層中。</span><span class="sxs-lookup"><span data-stu-id="40c44-190">Effectively, this allows your class and its derived classes to "inherit" a dependency property implementation without the original owner class and the adding class being in the same true class hierarchy.</span></span> <span data-ttu-id="40c44-191">此外，新增的類別 (及所有衍生類別) 接著可為原始相依性屬性提供特定類型的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="40c44-191">In addition, the adding class (and all derived classes as well) can then provide type-specific metadata for the original dependency property.</span></span>  
  
 <span data-ttu-id="40c44-192">除了透過屬性系統公用程式方法自行新增作為擁有者，新增的類別也應在本身上宣告其他公用成員，讓相依性屬性完全融合在屬性系統中，並能公開給程式碼和標記。</span><span class="sxs-lookup"><span data-stu-id="40c44-192">As well as adding itself as owner through the property system utility methods, the adding class should declare additional public members on itself in order to make the dependency property] a full participant in the property system with exposure to both code and markup.</span></span> <span data-ttu-id="40c44-193">新增現有相依性屬性的類別與定義新自訂相依性屬性的類別一樣，也必須公開該相依性屬性的物件模型。</span><span class="sxs-lookup"><span data-stu-id="40c44-193">A class that adds an existing dependency property has the same responsibilities as far as exposing the object model for that dependency property as does a class that defines a new custom dependency property.</span></span> <span data-ttu-id="40c44-194">第一個要公開的成員是相依性屬性識別項欄位。</span><span class="sxs-lookup"><span data-stu-id="40c44-194">The first such member to expose is a dependency property identifier field.</span></span> <span data-ttu-id="40c44-195">此欄位應該`public static readonly`是類型<xref:System.Windows.DependencyProperty>的欄位, 它會指派給<xref:System.Windows.DependencyProperty.AddOwner%2A>呼叫的傳回值。</span><span class="sxs-lookup"><span data-stu-id="40c44-195">This field should be a `public static readonly` field of type <xref:System.Windows.DependencyProperty>, which is assigned to the return value of the <xref:System.Windows.DependencyProperty.AddOwner%2A> call.</span></span> <span data-ttu-id="40c44-196">要定義的第二個成員是 common language runtime (CLR) 「包裝函式」屬性。</span><span class="sxs-lookup"><span data-stu-id="40c44-196">The second member to define is the common language runtime (CLR) "wrapper" property.</span></span> <span data-ttu-id="40c44-197">包裝函式可讓您更方便地在程式碼中操作相依性屬性 (您<xref:System.Windows.DependencyObject.SetValue%2A>可以避免每次呼叫, 而且只能在包裝函式本身中呼叫一次)。</span><span class="sxs-lookup"><span data-stu-id="40c44-197">The wrapper makes it much more convenient to manipulate your dependency property in code (you avoid calls to <xref:System.Windows.DependencyObject.SetValue%2A> each time, and can make that call only once in the wrapper itself).</span></span> <span data-ttu-id="40c44-198">包裝函式的實作方式與註冊自訂相依性屬性時實作包裝函式的方式完全相同。</span><span class="sxs-lookup"><span data-stu-id="40c44-198">The wrapper is implemented identically to how it would be implemented if you were registering a custom dependency property.</span></span> <span data-ttu-id="40c44-199">如需實作相依性屬性的詳細資訊，請參閱[自訂相依性屬性](custom-dependency-properties.md)和[新增相依性屬性的擁有者類型](how-to-add-an-owner-type-for-a-dependency-property.md)。</span><span class="sxs-lookup"><span data-stu-id="40c44-199">For more information about implementing a dependency property, see [Custom Dependency Properties](custom-dependency-properties.md) and [Add an Owner Type for a Dependency Property](how-to-add-an-owner-type-for-a-dependency-property.md).</span></span>  
  
#### <a name="addowner-and-attached-properties"></a><span data-ttu-id="40c44-200">AddOwner 和附加屬性</span><span class="sxs-lookup"><span data-stu-id="40c44-200">AddOwner and Attached Properties</span></span>  
 <span data-ttu-id="40c44-201">您可以針對<xref:System.Windows.DependencyProperty.AddOwner%2A>由 owner 類別定義為附加屬性的相依性屬性呼叫。</span><span class="sxs-lookup"><span data-stu-id="40c44-201">You can call <xref:System.Windows.DependencyProperty.AddOwner%2A> for a dependency property that is defined as an attached property by the owner class.</span></span> <span data-ttu-id="40c44-202">一般這麼做的原因是要將先前的附加屬性公開為非附加相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="40c44-202">Generally the reason for doing this is to expose the previously attached property as a non-attached dependency property.</span></span> <span data-ttu-id="40c44-203">接著, 您會將<xref:System.Windows.DependencyProperty.AddOwner%2A>傳回值`public static readonly`公開為當做相依性屬性識別碼使用的欄位, 並定義適當的「包裝函式」屬性, 讓屬性出現在 members 資料表中, 並支援非附加屬性類別中的使用方式。</span><span class="sxs-lookup"><span data-stu-id="40c44-203">You then will expose the <xref:System.Windows.DependencyProperty.AddOwner%2A> return value as a `public static readonly` field for use as the dependency property identifier, and will define appropriate "wrapper" properties so that the property appears in the members table and supports a non-attached property usage in your class.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="40c44-204">另請參閱</span><span class="sxs-lookup"><span data-stu-id="40c44-204">See also</span></span>

- <xref:System.Windows.PropertyMetadata>
- <xref:System.Windows.DependencyObject>
- <xref:System.Windows.DependencyProperty>
- <xref:System.Windows.DependencyProperty.GetMetadata%2A>
- [<span data-ttu-id="40c44-205">相依性屬性概觀</span><span class="sxs-lookup"><span data-stu-id="40c44-205">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="40c44-206">架構屬性中繼資料</span><span class="sxs-lookup"><span data-stu-id="40c44-206">Framework Property Metadata</span></span>](framework-property-metadata.md)
