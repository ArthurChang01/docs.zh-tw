---
title: XAML 語法詳細資料
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: dbff4bed59c8d1e861555676578b52528e2aebbe
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/12/2020
ms.locfileid: "79186191"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="3edf6-102">XAML 語法詳細資料</span><span class="sxs-lookup"><span data-stu-id="3edf6-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="3edf6-103">本主題定義用於描述 XAML 語法元素的術語。</span><span class="sxs-lookup"><span data-stu-id="3edf6-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="3edf6-104">這些術語在本文檔的其餘部分中經常使用，具體用於 WPF 文檔，以及使用 XAML 或其他框架的其他框架，這些框架或在 System.Xaml 級別啟用的 XAML 語言支援。</span><span class="sxs-lookup"><span data-stu-id="3edf6-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="3edf6-105">本主題將展開主題[XAML 概述 （WPF）](../../../desktop-wpf/fundamentals/xaml.md)仲介紹的基本術語。</span><span class="sxs-lookup"><span data-stu-id="3edf6-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>  

<a name="the_xaml_language_specification"></a>
## <a name="the-xaml-language-specification"></a><span data-ttu-id="3edf6-106">XAML 語言規範</span><span class="sxs-lookup"><span data-stu-id="3edf6-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="3edf6-107">此處定義的 XAML 語法術語也在 XAML 語言規範中定義或引用。</span><span class="sxs-lookup"><span data-stu-id="3edf6-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="3edf6-108">XAML 是基於 XML 的語言，它遵循或擴展了 XML 結構規則。</span><span class="sxs-lookup"><span data-stu-id="3edf6-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="3edf6-109">某些術語來自或基於描述 XML 語言或 XML 文件物件模型時常用的術語。</span><span class="sxs-lookup"><span data-stu-id="3edf6-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="3edf6-110">有關 XAML 語言規範的詳細資訊，請從 Microsoft 下載中心下載[\[MS-XAML。\] ](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf)</span><span class="sxs-lookup"><span data-stu-id="3edf6-110">For more information about the XAML language specification, download [\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>
## <a name="xaml-and-clr"></a><span data-ttu-id="3edf6-111">XAML 和 CLR</span><span class="sxs-lookup"><span data-stu-id="3edf6-111">XAML and CLR</span></span>  
 <span data-ttu-id="3edf6-112">XAML 是一種標記語言。</span><span class="sxs-lookup"><span data-stu-id="3edf6-112">XAML is a markup language.</span></span> <span data-ttu-id="3edf6-113">通用語言運行時 （CLR） （CLR） 的名稱所暗示，支援運行時執行。</span><span class="sxs-lookup"><span data-stu-id="3edf6-113">The common language runtime (CLR), as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="3edf6-114">XAML 本身並不是 CLR 運行時直接使用的常見語言之一。</span><span class="sxs-lookup"><span data-stu-id="3edf6-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="3edf6-115">相反，您可以將 XAML 視為支援其自己的類型系統。</span><span class="sxs-lookup"><span data-stu-id="3edf6-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="3edf6-116">WPF 使用的特定 XAML 解析系統構建在 CLR 和 CLR 類型系統上。</span><span class="sxs-lookup"><span data-stu-id="3edf6-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="3edf6-117">XAML 類型映射到 CLR 類型，以在分析 WPF 的 XAML 時具現化運行時表示。</span><span class="sxs-lookup"><span data-stu-id="3edf6-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="3edf6-118">因此，本文檔中關於語法的討論的其餘部分將包括對 CLR 類型系統的引用，即使 XAML 語言規範中的等效語法討論沒有。</span><span class="sxs-lookup"><span data-stu-id="3edf6-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="3edf6-119">（根據 XAML 語言規範級別，XAML 類型可以映射到任何其他類型系統，其中不必是 CLR，但需要創建和使用不同的 XAML 解析器。</span><span class="sxs-lookup"><span data-stu-id="3edf6-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="3edf6-120">類型和類繼承的成員</span><span class="sxs-lookup"><span data-stu-id="3edf6-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="3edf6-121">屬性和事件作為[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]類型的 XAML 成員顯示時通常從基類型繼承。</span><span class="sxs-lookup"><span data-stu-id="3edf6-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="3edf6-122">例如，請考慮此示例： `<Button Background="Blue" .../>`。</span><span class="sxs-lookup"><span data-stu-id="3edf6-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="3edf6-123">如果要<xref:System.Windows.Controls.Control.Background%2A>查看類定義、反射結果或文檔，<xref:System.Windows.Controls.Button>則該屬性不是類上的立即聲明屬性。</span><span class="sxs-lookup"><span data-stu-id="3edf6-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="3edf6-124"><xref:System.Windows.Controls.Control.Background%2A>而是從基<xref:System.Windows.Controls.Control>類繼承的。</span><span class="sxs-lookup"><span data-stu-id="3edf6-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="3edf6-125">XAML 元素[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]的類繼承行為與 XML 標記的架構強制解釋有重大背離。</span><span class="sxs-lookup"><span data-stu-id="3edf6-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="3edf6-126">類繼承可能會變得複雜，尤其是在中間基類是抽象的，或者涉及介面時。</span><span class="sxs-lookup"><span data-stu-id="3edf6-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="3edf6-127">這是 XAML 元素集及其允許屬性難以準確、完整地使用通常用於 XML 程式設計的架構類型（如 DTD 或 XSD 格式）的一個原因。</span><span class="sxs-lookup"><span data-stu-id="3edf6-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for XML programming, such as DTD or XSD format.</span></span> <span data-ttu-id="3edf6-128">另一個原因是 XAML 語言本身的可擴充性和類型映射功能排除了允許類型和成員的任何固定表示形式的完整性。</span><span class="sxs-lookup"><span data-stu-id="3edf6-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>
## <a name="object-element-syntax"></a><span data-ttu-id="3edf6-129">物件元素語法</span><span class="sxs-lookup"><span data-stu-id="3edf6-129">Object Element Syntax</span></span>  
 <span data-ttu-id="3edf6-130">*物件元素語法*是 XAML 標記語法，它通過聲明 XML 元素具現化 CLR 類或結構。</span><span class="sxs-lookup"><span data-stu-id="3edf6-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="3edf6-131">此語法類似于其他標記語言（如 HTML）的元素語法。</span><span class="sxs-lookup"><span data-stu-id="3edf6-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="3edf6-132">物件元素語法以左角度括弧 （），\<緊接著是具現化的類或結構的類型名稱。</span><span class="sxs-lookup"><span data-stu-id="3edf6-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="3edf6-133">零個或多個空格可以遵循類型名稱，也可以在物件元素上聲明零個或多個屬性，其中一個或多個空格分隔每個屬性名稱 ="值"對。</span><span class="sxs-lookup"><span data-stu-id="3edf6-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="3edf6-134">最後，以下必須為 true：</span><span class="sxs-lookup"><span data-stu-id="3edf6-134">Finally, one of the following must be true:</span></span>  
  
- <span data-ttu-id="3edf6-135">元素和標記必須用前斜杠 （/） 緊接，然後緊跟直角支架 （>）。</span><span class="sxs-lookup"><span data-stu-id="3edf6-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
- <span data-ttu-id="3edf6-136">開口標記必須由直角支架（>）完成。</span><span class="sxs-lookup"><span data-stu-id="3edf6-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="3edf6-137">其他物件元素、屬性元素或內部文本可以遵循打開標記。</span><span class="sxs-lookup"><span data-stu-id="3edf6-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="3edf6-138">此處可能包含的內容通常受元素的物件模型的約束。</span><span class="sxs-lookup"><span data-stu-id="3edf6-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="3edf6-139">物件元素的等效關閉標記也必須存在，以適當的嵌套並與其他打開和關閉標記對平衡。</span><span class="sxs-lookup"><span data-stu-id="3edf6-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="3edf6-140">.NET 實現的 XAML 具有一組規則，這些規則將物件元素映射到類型、屬性或事件的屬性以及 XAML 命名空間到 CLR 命名空間加上程式集。</span><span class="sxs-lookup"><span data-stu-id="3edf6-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="3edf6-141">對於 WPF 和 .NET，XAML 物件元素映射到引用程式集中定義的 .NET 類型，屬性對應到這些類型的成員。</span><span class="sxs-lookup"><span data-stu-id="3edf6-141">For WPF and .NET, XAML object elements map to .NET types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="3edf6-142">在 XAML 中引用 CLR 類型時，您也有權訪問該類型的繼承成員。</span><span class="sxs-lookup"><span data-stu-id="3edf6-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="3edf6-143">例如，以下示例是物件元素語法，它具現化<xref:System.Windows.Controls.Button>類的新實例，並指定該<xref:System.Windows.FrameworkElement.Name%2A>屬性的屬性和值：</span><span class="sxs-lookup"><span data-stu-id="3edf6-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="3edf6-144">下面的示例是物件元素語法，該語法還包括 XAML 內容屬性語法。</span><span class="sxs-lookup"><span data-stu-id="3edf6-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="3edf6-145">中包含的內部文本將用於設置<xref:System.Windows.Controls.TextBox>XAML 內容屬性 。 <xref:System.Windows.Controls.TextBox.Text%2A></span><span class="sxs-lookup"><span data-stu-id="3edf6-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="3edf6-146">內容模型</span><span class="sxs-lookup"><span data-stu-id="3edf6-146">Content Models</span></span>  
 <span data-ttu-id="3edf6-147">類在語法方面可能支援作為 XAML 物件元素的用法，但該元素只有在放置在總體內容模型或元素樹的預期位置時，才會在應用程式或頁面中正常運行。</span><span class="sxs-lookup"><span data-stu-id="3edf6-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="3edf6-148">例如，通常<xref:System.Windows.Controls.MenuItem>應僅作為<xref:System.Windows.Controls.Primitives.MenuBase>派生類（如<xref:System.Windows.Controls.Menu>） 的子級放置。</span><span class="sxs-lookup"><span data-stu-id="3edf6-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="3edf6-149">特定元素的內容模型作為控制項和其他[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]類可用作 XAML 元素的類頁上的備註的一部分進行記錄。</span><span class="sxs-lookup"><span data-stu-id="3edf6-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>
## <a name="properties-of-object-elements"></a><span data-ttu-id="3edf6-150">物件元素的屬性</span><span class="sxs-lookup"><span data-stu-id="3edf6-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="3edf6-151">XAML 中的屬性由各種可能的語法設置。</span><span class="sxs-lookup"><span data-stu-id="3edf6-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="3edf6-152">哪些語法可用於特定屬性將因所設置的屬性的基礎類型系統特徵而異。</span><span class="sxs-lookup"><span data-stu-id="3edf6-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="3edf6-153">通過設置屬性的值，可以像運行時物件圖中存在的物件一樣，向物件添加要素或特徵。</span><span class="sxs-lookup"><span data-stu-id="3edf6-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="3edf6-154">從物件元素創建的物件的初始狀態基於無參數建構函式行為。</span><span class="sxs-lookup"><span data-stu-id="3edf6-154">The initial state of the created object from a object element is based on the parameterless constructor behavior.</span></span> <span data-ttu-id="3edf6-155">通常，應用程式將使用任何給定物件的完全預設實例以外的內容。</span><span class="sxs-lookup"><span data-stu-id="3edf6-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>
## <a name="attribute-syntax-properties"></a><span data-ttu-id="3edf6-156">屬性 (Attribute) 語法 (屬性(Property))</span><span class="sxs-lookup"><span data-stu-id="3edf6-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="3edf6-157">屬性語法是 XAML 標記語法，通過在現有物件元素上聲明屬性來設置屬性的值。</span><span class="sxs-lookup"><span data-stu-id="3edf6-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="3edf6-158">屬性名稱必須與支援相關物件元素的類屬性的 CLR 成員名稱匹配。</span><span class="sxs-lookup"><span data-stu-id="3edf6-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="3edf6-159">屬性名稱後跟指派運算子 （\*）。</span><span class="sxs-lookup"><span data-stu-id="3edf6-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="3edf6-160">屬性值必須是包含在引號中的字串。</span><span class="sxs-lookup"><span data-stu-id="3edf6-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3edf6-161">可以使用交替引號在屬性中放置文本引號。</span><span class="sxs-lookup"><span data-stu-id="3edf6-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="3edf6-162">例如，可以使用單引號作為聲明包含其中雙引號字元的字串的方法。</span><span class="sxs-lookup"><span data-stu-id="3edf6-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="3edf6-163">無論使用單引號還是雙引號，都應使用匹配對來打開和關閉屬性值字串。</span><span class="sxs-lookup"><span data-stu-id="3edf6-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="3edf6-164">還有一些逸出序列或其他技術可用於解決任何特定 XAML 語法施加的字元限制。</span><span class="sxs-lookup"><span data-stu-id="3edf6-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="3edf6-165">請參閱[XML 字元實體和 XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md)。</span><span class="sxs-lookup"><span data-stu-id="3edf6-165">See [XML Character Entities and XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span></span>  
  
 <span data-ttu-id="3edf6-166">要通過屬性語法進行設置，屬性必須是公共的，並且必須是可寫入的。</span><span class="sxs-lookup"><span data-stu-id="3edf6-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="3edf6-167">支援類型系統中的屬性值必須是數值型別，或者必須是訪問相關備份類型時 XAML 處理器可以具現化或引用的參考型別。</span><span class="sxs-lookup"><span data-stu-id="3edf6-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="3edf6-168">對於 WPF XAML 事件，引用為屬性名稱的事件必須是公共的，並且具有公共委託。</span><span class="sxs-lookup"><span data-stu-id="3edf6-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="3edf6-169">屬性或事件必須是由包含物件元素具現化的類或結構的成員。</span><span class="sxs-lookup"><span data-stu-id="3edf6-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="3edf6-170">屬性值的處理</span><span class="sxs-lookup"><span data-stu-id="3edf6-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="3edf6-171">首開和收盤引號中包含的字串值由 XAML 處理器處理。</span><span class="sxs-lookup"><span data-stu-id="3edf6-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="3edf6-172">對於屬性，預設處理行為由基礎 CLR 屬性的類型確定。</span><span class="sxs-lookup"><span data-stu-id="3edf6-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="3edf6-173">屬性值由以下之一填充，使用此處理順序：</span><span class="sxs-lookup"><span data-stu-id="3edf6-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1. <span data-ttu-id="3edf6-174">如果 XAML 處理器遇到大括弧或派生自<xref:System.Windows.Markup.MarkupExtension>的物件元素，則首先計算引用的標記擴展，而不是將該值作為字串處理，標記擴展返回的物件用作值。</span><span class="sxs-lookup"><span data-stu-id="3edf6-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="3edf6-175">在許多情況下，標記擴展返回的物件將是對現有物件的引用，或將計算推遲到運行時的運算式，而不是新具現化的物件。</span><span class="sxs-lookup"><span data-stu-id="3edf6-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2. <span data-ttu-id="3edf6-176">如果屬性用屬性聲明<xref:System.ComponentModel.TypeConverter>，或者該屬性的數值型別用屬性<xref:System.ComponentModel.TypeConverter>聲明，則屬性的字串值將作為轉換輸入提交到類型轉換器，轉換器將返回一個新的物件實例。</span><span class="sxs-lookup"><span data-stu-id="3edf6-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3. <span data-ttu-id="3edf6-177">如果沒有<xref:System.ComponentModel.TypeConverter>，則嘗試直接轉換為屬性類型。</span><span class="sxs-lookup"><span data-stu-id="3edf6-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="3edf6-178">此最終級別是 XAML 語言基元類型之間的解析器本機值的直接轉換，或對枚舉中命名常量的名稱的檢查（解析器隨後訪問匹配值）。</span><span class="sxs-lookup"><span data-stu-id="3edf6-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="3edf6-179">枚舉屬性值</span><span class="sxs-lookup"><span data-stu-id="3edf6-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="3edf6-180">XAML 中的枚舉由 XAML 解析器進行內在處理，枚舉成員應通過指定枚舉命名常量之一的字串名稱來指定枚舉。</span><span class="sxs-lookup"><span data-stu-id="3edf6-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="3edf6-181">對於非標記枚舉值，本機行為是處理屬性值的字串並將其解析為枚舉值之一。</span><span class="sxs-lookup"><span data-stu-id="3edf6-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="3edf6-182">您不會在格式枚*舉*中指定枚舉。*值*，就像您在代碼中所做的一樣。</span><span class="sxs-lookup"><span data-stu-id="3edf6-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="3edf6-183">相反，您只指定*值*，而*枚舉*則由要設置的屬性的類型推斷。</span><span class="sxs-lookup"><span data-stu-id="3edf6-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="3edf6-184">如果在*枚舉*中指定屬性。*值*形式，它將不會正確解析。</span><span class="sxs-lookup"><span data-stu-id="3edf6-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="3edf6-185">對於正面枚舉，行為基於 方法<xref:System.Enum.Parse%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="3edf6-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3edf6-186">可以通過用逗號分隔每個值來為旗面枚舉指定多個值。</span><span class="sxs-lookup"><span data-stu-id="3edf6-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="3edf6-187">但是，不能合併不按標誌標記的枚舉值。</span><span class="sxs-lookup"><span data-stu-id="3edf6-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="3edf6-188">例如，不能使用逗號語法嘗試創建<xref:System.Windows.Trigger>對非標誌枚舉的多個條件具有作用的 語法：</span><span class="sxs-lookup"><span data-stu-id="3edf6-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```xaml  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="3edf6-189">在 WPF 中，支援在 XAML 中可設置的屬性的標記枚舉很少見。</span><span class="sxs-lookup"><span data-stu-id="3edf6-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="3edf6-190">但是，此類枚舉之一是<xref:System.Windows.Media.StyleSimulations>。</span><span class="sxs-lookup"><span data-stu-id="3edf6-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="3edf6-191">例如，您可以使用逗號分隔的標記屬性語法來修改<xref:System.Windows.Documents.Glyphs>類的備註中提供的示例;`StyleSimulations = "BoldSimulation"`可能變成`StyleSimulations = "BoldSimulation,ItalicSimulation"`。</span><span class="sxs-lookup"><span data-stu-id="3edf6-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="3edf6-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>是另一個可以指定多個枚舉值的屬性。</span><span class="sxs-lookup"><span data-stu-id="3edf6-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="3edf6-193">但是，此屬性恰好是一個特殊情況，因為<xref:System.Windows.Input.ModifierKeys>枚舉支援其自己的類型轉換器。</span><span class="sxs-lookup"><span data-stu-id="3edf6-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="3edf6-194">修改器的類型轉換器使用加號 （+） 作為分隔符號而不是逗號 （，）。</span><span class="sxs-lookup"><span data-stu-id="3edf6-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="3edf6-195">此轉換支援更傳統的語法，以表示 Microsoft Windows 程式設計中的關鍵組合，例如"Ctrl_Alt"。</span><span class="sxs-lookup"><span data-stu-id="3edf6-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="3edf6-196">屬性和事件成員名稱引用</span><span class="sxs-lookup"><span data-stu-id="3edf6-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="3edf6-197">指定屬性時，可以引用作為為包含物件元素具現化的 CLR 類型的成員存在的任何屬性或事件。</span><span class="sxs-lookup"><span data-stu-id="3edf6-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="3edf6-198">或者，您可以引用附加的屬性或附加事件，而獨立于包含的物件元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="3edf6-199">（附加屬性將在接下來的部分中討論。</span><span class="sxs-lookup"><span data-stu-id="3edf6-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="3edf6-200">還可以使用*typeName*從可通過預設命名空間訪問的任何物件命名任何事件。*事件*部分限定名稱;此語法支援為路由事件附加處理常式，其中處理常式旨在處理來自子項目的事件路由，但父元素的成員表中也沒有該事件。</span><span class="sxs-lookup"><span data-stu-id="3edf6-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="3edf6-201">此語法類似于附加的事件語法，但此處的事件不是真正的附加事件。</span><span class="sxs-lookup"><span data-stu-id="3edf6-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="3edf6-202">相反，您引用的事件具有限定名稱。</span><span class="sxs-lookup"><span data-stu-id="3edf6-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="3edf6-203">有關詳細資訊，請參閱[路由事件概述](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="3edf6-203">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="3edf6-204">對於某些方案，屬性名稱有時作為屬性的值提供，而不是屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="3edf6-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="3edf6-205">該屬性名稱還可以包括限定詞，例如表單*擁有者類型*中指定的屬性。*屬項屬性名稱*。</span><span class="sxs-lookup"><span data-stu-id="3edf6-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="3edf6-206">在 XAML 中編寫樣式或範本時，此方案很常見。</span><span class="sxs-lookup"><span data-stu-id="3edf6-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="3edf6-207">作為屬性值提供的屬性名稱的處理規則不同，並且受要設置的屬性類型或特定 WPF 子系統的行為控制。</span><span class="sxs-lookup"><span data-stu-id="3edf6-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="3edf6-208">有關詳細資訊，請參閱[樣式和範本](../controls/styling-and-templating.md)化。</span><span class="sxs-lookup"><span data-stu-id="3edf6-208">For details, see [Styling and Templating](../controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="3edf6-209">屬性名稱的另一個用法是屬性值描述屬性-屬性關係時。</span><span class="sxs-lookup"><span data-stu-id="3edf6-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="3edf6-210">此功能用於資料繫結和分鏡腳本目標，並且由<xref:System.Windows.PropertyPath>類及其類型轉換器啟用。</span><span class="sxs-lookup"><span data-stu-id="3edf6-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="3edf6-211">有關查找語義的更完整說明，請參閱[屬性路徑 XAML 語法](propertypath-xaml-syntax.md)。</span><span class="sxs-lookup"><span data-stu-id="3edf6-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>
## <a name="property-element-syntax"></a><span data-ttu-id="3edf6-212">屬性元素語法</span><span class="sxs-lookup"><span data-stu-id="3edf6-212">Property Element Syntax</span></span>  
 <span data-ttu-id="3edf6-213">*屬性元素語法*是一種語法，它在某種程度上與元素的基本 XML 語法規則不同。</span><span class="sxs-lookup"><span data-stu-id="3edf6-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="3edf6-214">在 XML 中，屬性的值是事實字串，唯一可能的變化是使用哪個字串編碼格式。</span><span class="sxs-lookup"><span data-stu-id="3edf6-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="3edf6-215">在 XAML 中，可以將其他物件元素指定為屬性的值。</span><span class="sxs-lookup"><span data-stu-id="3edf6-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="3edf6-216">此屬性元素語法啟用此功能。</span><span class="sxs-lookup"><span data-stu-id="3edf6-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="3edf6-217">該屬性使用*元素TypeName*中的打開元素標記指定該屬性，而不是將屬性指定為元素標記中的屬性。*屬性名稱*表單中，在 其中指定屬性的值，然後關閉屬性元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="3edf6-218">具體而言，語法以左角度括弧 （）\<開頭，緊接著是屬性元素語法中包含的類或結構的類型名稱。</span><span class="sxs-lookup"><span data-stu-id="3edf6-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="3edf6-219">緊接著是一個點 （.），然後是屬性的名稱，然後是直角括弧 （>）。</span><span class="sxs-lookup"><span data-stu-id="3edf6-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="3edf6-220">與屬性語法一樣，該屬性必須存在於指定類型的已聲明的公共成員中。</span><span class="sxs-lookup"><span data-stu-id="3edf6-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="3edf6-221">要分配給該屬性的值包含在屬性元素中。</span><span class="sxs-lookup"><span data-stu-id="3edf6-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="3edf6-222">通常，該值作為一個或多個物件元素給出，因為將物件指定為值是屬性元素語法旨在解決的方案。</span><span class="sxs-lookup"><span data-stu-id="3edf6-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="3edf6-223">最後，指定相同*元素TypeName*的等效結束標記。*屬性名稱*組合必須提供，以適當的嵌套和平衡與其他元素標記。</span><span class="sxs-lookup"><span data-stu-id="3edf6-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="3edf6-224">例如，以下是 屬性的屬性的屬性元素語法<xref:System.Windows.FrameworkElement.ContextMenu%2A><xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="3edf6-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="3edf6-225">屬性元素中的值也可以作為內部文本給出，在指定的屬性類型為基元數值型別的情況下，例如<xref:System.String>， 或指定名稱的枚舉。</span><span class="sxs-lookup"><span data-stu-id="3edf6-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="3edf6-226">這兩個用法有些不常見，因為每個情況都可以使用更簡單的屬性語法。</span><span class="sxs-lookup"><span data-stu-id="3edf6-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="3edf6-227">使用字串填充屬性元素的一個方案是，對於不是 XAML 內容屬性但仍用於表示 UI 文本的屬性，並且特定的空白元素（如行饋送）必須出現在該 UI 文本中。</span><span class="sxs-lookup"><span data-stu-id="3edf6-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="3edf6-228">屬性語法無法保留行饋，但屬性元素語法可以，只要顯著的空白保留處於活動狀態（有關詳細資訊，請參閱[XAML 中的空白處理](../../../desktop-wpf/xaml-services/white-space-processing.md)）。</span><span class="sxs-lookup"><span data-stu-id="3edf6-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span></span> <span data-ttu-id="3edf6-229">另一種情況是[，x：Uid 指令](../../../desktop-wpf/xaml-services/xuid-directive.md)可以應用於屬性元素，從而將 中的值標記為應在 WPF 輸出 BAML 或其他技術中當地語系化的值。</span><span class="sxs-lookup"><span data-stu-id="3edf6-229">Another scenario is so that [x:Uid Directive](../../../desktop-wpf/xaml-services/xuid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="3edf6-230">屬性元素未在 WPF 邏輯樹中表示。</span><span class="sxs-lookup"><span data-stu-id="3edf6-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="3edf6-231">屬性元素只是設置屬性的特定語法，而不是具有實例或物件支援它的元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="3edf6-232">（有關邏輯樹概念的詳細資訊，請參閱[WPF 中的樹](trees-in-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="3edf6-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="3edf6-233">對於同時支援屬性和屬性元素語法的屬性，這兩種語法通常具有相同的結果，儘管空格處理等細微之處在語法之間可能略有不同。</span><span class="sxs-lookup"><span data-stu-id="3edf6-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>
## <a name="collection-syntax"></a><span data-ttu-id="3edf6-234">集合語法</span><span class="sxs-lookup"><span data-stu-id="3edf6-234">Collection Syntax</span></span>  
 <span data-ttu-id="3edf6-235">XAML 規範要求 XAML 處理器實現標識數值型別為集合的屬性。</span><span class="sxs-lookup"><span data-stu-id="3edf6-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="3edf6-236">.NET 中的常規 XAML 處理器實現基於託管代碼和 CLR，它通過以下之一標識集合類型：</span><span class="sxs-lookup"><span data-stu-id="3edf6-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
- <span data-ttu-id="3edf6-237">類型實現<xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="3edf6-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="3edf6-238">類型實現<xref:System.Collections.IDictionary>。</span><span class="sxs-lookup"><span data-stu-id="3edf6-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
- <span data-ttu-id="3edf6-239">類型派生自<xref:System.Array>（有關 XAML 中的陣列的詳細資訊，請參閱[x：陣列標記擴展](../../../desktop-wpf/xaml-services/xarray-markup-extension.md)。</span><span class="sxs-lookup"><span data-stu-id="3edf6-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="3edf6-240">如果屬性的類型是集合，則推斷的集合類型不需要在標記中指定為物件元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="3edf6-241">相反，打算成為集合中的項的元素被指定為屬性元素的一個或多個子項目。</span><span class="sxs-lookup"><span data-stu-id="3edf6-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="3edf6-242">每個此類項在載入期間計算到物件，並通過調用隱含集合`Add`的方法添加到集合中。</span><span class="sxs-lookup"><span data-stu-id="3edf6-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="3edf6-243">例如， 的<xref:System.Windows.Style.Triggers%2A><xref:System.Windows.Style>屬性採用專用集合類型<xref:System.Windows.TriggerCollection>， 實現<xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="3edf6-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="3edf6-244">不必具現化標記中<xref:System.Windows.TriggerCollection>的物件元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="3edf6-245"><xref:System.Windows.Trigger>相反，您將一個或多個項指定為`Style.Triggers`屬性元素中的元素，其中<xref:System.Windows.Trigger>（或派生類）是強烈鍵入和隱式<xref:System.Windows.TriggerCollection>中的項類型所需的類型。</span><span class="sxs-lookup"><span data-stu-id="3edf6-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="3edf6-246">屬性可以是集合類型，也可以是該類型和派生類型的 XAML 內容屬性，本主題的下一部分將對此進行討論。</span><span class="sxs-lookup"><span data-stu-id="3edf6-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="3edf6-247">隱式集合元素在邏輯樹表示形式中創建成員，即使它不作為元素出現在標記中。</span><span class="sxs-lookup"><span data-stu-id="3edf6-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="3edf6-248">通常，父類型的建構函式對其屬性之一的集合執行具現化，並且最初空集合將成為物件樹的一部分。</span><span class="sxs-lookup"><span data-stu-id="3edf6-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="3edf6-249">泛型清單和字典介面<xref:System.Collections.Generic.IList%601>（<xref:System.Collections.Generic.IDictionary%602>和 ） 不支援用於集合檢測。</span><span class="sxs-lookup"><span data-stu-id="3edf6-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="3edf6-250">但是，您可以將<xref:System.Collections.Generic.List%601>類用作基類，因為它直接實現<xref:System.Collections.IList>，或者<xref:System.Collections.Generic.Dictionary%602>作為基類實現，因為它直接實現。 <xref:System.Collections.IDictionary></span><span class="sxs-lookup"><span data-stu-id="3edf6-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="3edf6-251">在集合類型的 .NET 參考頁中，在 XAML 語法部分中偶爾會將此語法與集合物件元素的故意省略記錄稱為隱式集合語法。</span><span class="sxs-lookup"><span data-stu-id="3edf6-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="3edf6-252">除根項目外，作為另一個元素的子項目嵌套的 XAML 檔中的每個物件元素實際上是一個元素，它是以下一種情況之一或兩種情況：其父元素的隱式集合屬性的成員或指定父元素的 XAML 內容屬性的值的元素（XAML 內容屬性將在下一節中討論）。</span><span class="sxs-lookup"><span data-stu-id="3edf6-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="3edf6-253">換句話說，標記頁中的父元素和子項目的關係實際上是根上的單個物件，根下方的每個物件元素要麼是提供父元素屬性值的單個實例，要麼是也是父級的集合類型屬性值的集合。</span><span class="sxs-lookup"><span data-stu-id="3edf6-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="3edf6-254">這種單根概念在 XML 中很常見，並且在載入 XAML（如<xref:System.Windows.Markup.XamlReader.Load%2A>） 的 API 行為中經常被強化。</span><span class="sxs-lookup"><span data-stu-id="3edf6-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="3edf6-255">下面的示例是顯式指定的集合的物件元素 （<xref:System.Windows.Media.GradientStopCollection>的語法。</span><span class="sxs-lookup"><span data-stu-id="3edf6-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="3edf6-256">請注意，並不總是可以顯式聲明集合。</span><span class="sxs-lookup"><span data-stu-id="3edf6-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="3edf6-257">例如，嘗試在前面顯示<xref:System.Windows.TriggerCollection><xref:System.Windows.Style.Triggers%2A>的示例中顯式聲明將失敗。</span><span class="sxs-lookup"><span data-stu-id="3edf6-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="3edf6-258">顯式聲明集合要求集合類必須支援無參數建構函式，並且<xref:System.Windows.TriggerCollection>沒有無參數建構函式。</span><span class="sxs-lookup"><span data-stu-id="3edf6-258">Explicitly declaring the collection requires that the collection class must support a parameterless constructor, and <xref:System.Windows.TriggerCollection> does not have a parameterless constructor.</span></span>  
  
<a name="xaml_content_properties"></a>
## <a name="xaml-content-properties"></a><span data-ttu-id="3edf6-259">XAML 內容屬性</span><span class="sxs-lookup"><span data-stu-id="3edf6-259">XAML Content Properties</span></span>  
 <span data-ttu-id="3edf6-260">XAML 內容語法是僅在指定<xref:System.Windows.Markup.ContentPropertyAttribute>作為類聲明的一部分的類上啟用的語法。</span><span class="sxs-lookup"><span data-stu-id="3edf6-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="3edf6-261">引用<xref:System.Windows.Markup.ContentPropertyAttribute>作為該類型元素（包括派生類）的內容屬性的屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="3edf6-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="3edf6-262">當 XAML 處理器處理時，物件元素的打開和關閉標記之間找到的任何子項目或內部文本都將分配為該物件的 XAML 內容屬性的值。</span><span class="sxs-lookup"><span data-stu-id="3edf6-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="3edf6-263">允許為內容屬性指定顯式屬性元素，但此用法通常不顯示在 .NET 引用中的 XAML 語法部分中。</span><span class="sxs-lookup"><span data-stu-id="3edf6-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="3edf6-264">顯式/詳細技術偶爾對標記清晰度或標記樣式具有價值，但內容屬性通常旨在簡化標記，以便可以直接嵌套與父子關係且直觀相關的元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="3edf6-265">根據嚴格的 XAML 語言定義，元素上其他屬性的屬性元素標記不會指定為"內容";因此，根據嚴格的 XAML 語言定義，元素的屬性元素標記不會指定為"內容";它們以前在 XAML 解析器的處理順序中處理，不被視為"內容"。</span><span class="sxs-lookup"><span data-stu-id="3edf6-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="3edf6-266">XAML 內容屬性值必須是連續的</span><span class="sxs-lookup"><span data-stu-id="3edf6-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="3edf6-267">XAML 內容屬性的值必須完全放在該物件元素上的任何其他屬性元素之前或完全之後。</span><span class="sxs-lookup"><span data-stu-id="3edf6-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="3edf6-268">無論 XAML 內容屬性的值指定為字串，還是指定為一個或多個物件，都是如此。</span><span class="sxs-lookup"><span data-stu-id="3edf6-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="3edf6-269">例如，以下標記不解析：</span><span class="sxs-lookup"><span data-stu-id="3edf6-269">For example, the following markup does not parse:</span></span>  
  
```xaml  
<Button>I am a
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="3edf6-270">這是非法的，主要是因為如果使用屬性元素語法對內容屬性顯式進行此語法，則內容屬性將設置兩次：</span><span class="sxs-lookup"><span data-stu-id="3edf6-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xaml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="3edf6-271">同樣非法的示例是，如果內容屬性是集合，並且子項目與屬性元素交織在一起：</span><span class="sxs-lookup"><span data-stu-id="3edf6-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xaml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="3edf6-272">內容屬性和集合語法合併</span><span class="sxs-lookup"><span data-stu-id="3edf6-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="3edf6-273">為了接受多個物件元素作為內容，內容屬性的類型必須特別為集合類型。</span><span class="sxs-lookup"><span data-stu-id="3edf6-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="3edf6-274">與集合類型的屬性元素語法類似，XAML 處理器必須標識集合類型的類型。</span><span class="sxs-lookup"><span data-stu-id="3edf6-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="3edf6-275">如果元素具有 XAML 內容屬性，並且 XAML 內容屬性的類型是集合，則隱含的集合類型不需要在標記中指定為物件元素，並且不需要將 XAML 內容屬性指定為屬性元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="3edf6-276">因此，標記中的明顯內容模型現在可以將多個子項目指定為內容。</span><span class="sxs-lookup"><span data-stu-id="3edf6-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="3edf6-277">以下是<xref:System.Windows.Controls.Panel>派生類的內容語法。</span><span class="sxs-lookup"><span data-stu-id="3edf6-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="3edf6-278">所有<xref:System.Windows.Controls.Panel>派生類都建立 XAML 內容屬性<xref:System.Windows.Controls.Panel.Children%2A>，這需要 類型的<xref:System.Windows.Controls.UIElementCollection>值 。</span><span class="sxs-lookup"><span data-stu-id="3edf6-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="3edf6-279">請注意，標記中既不需要<xref:System.Windows.Controls.Panel.Children%2A>屬性元素，也<xref:System.Windows.Controls.UIElementCollection>不需要 元素的元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="3edf6-280">這是 XAML 的設計功能，因此，在不影響屬性元素標記或集合物件的情況下，[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]可以更直觀地將定義 定義的 元素表示為具有直接父子項目關係的嵌套元素樹。</span><span class="sxs-lookup"><span data-stu-id="3edf6-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="3edf6-281">事實上，<xref:System.Windows.Controls.UIElementCollection>無法在標記中顯式指定為物件元素。設計。</span><span class="sxs-lookup"><span data-stu-id="3edf6-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="3edf6-282">因為它的唯一用途是作為隱式集合，<xref:System.Windows.Controls.UIElementCollection>因此不會公開公共無參數建構函式，因此不能具現化為物件元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public parameterless constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="3edf6-283">將物件中的屬性元素和物件元素與內容屬性混合</span><span class="sxs-lookup"><span data-stu-id="3edf6-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="3edf6-284">XAML 規範聲明 XAML 處理器可以強制用於填充物件元素中的 XAML 內容屬性的物件元素必須是連續的，並且不能混合。</span><span class="sxs-lookup"><span data-stu-id="3edf6-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="3edf6-285">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML 處理器強制執行了對混合屬性元素和內容的限制。</span><span class="sxs-lookup"><span data-stu-id="3edf6-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="3edf6-286">可以將子物件元素作為物件元素中的第一個直接標記。</span><span class="sxs-lookup"><span data-stu-id="3edf6-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="3edf6-287">然後，您可以引入屬性元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-287">Then you can introduce property elements.</span></span> <span data-ttu-id="3edf6-288">或者，您可以指定一個或多個屬性元素，然後指定內容，然後指定更多屬性元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="3edf6-289">但是，一旦屬性元素遵循內容，您就不能引入任何進一步的內容，您只能添加屬性元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="3edf6-290">此內容/屬性元素順序要求不適用於用作內容的內部文本。</span><span class="sxs-lookup"><span data-stu-id="3edf6-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="3edf6-291">但是，保持內部文本連續仍然是一種良好的標記樣式，因為如果屬性元素與內部文本交織在一起，則很難在標記中直觀地檢測到顯著的空白。</span><span class="sxs-lookup"><span data-stu-id="3edf6-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>
## <a name="xaml-namespaces"></a><span data-ttu-id="3edf6-292">XAML 命名空間</span><span class="sxs-lookup"><span data-stu-id="3edf6-292">XAML Namespaces</span></span>  
 <span data-ttu-id="3edf6-293">前面的語法示例均未指定 XAML 命名空間，而不是預設的 XAML 命名空間。</span><span class="sxs-lookup"><span data-stu-id="3edf6-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="3edf6-294">在典型的[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]應用程式中，預設 XAML 命名空間指定為[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]命名空間。</span><span class="sxs-lookup"><span data-stu-id="3edf6-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="3edf6-295">您可以指定預設 XAML 命名空間以外的 XAML 命名空間，並且仍然使用類似的語法。</span><span class="sxs-lookup"><span data-stu-id="3edf6-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="3edf6-296">但是，在命名在預設 XAML 命名空間中無法訪問的類的任何地方，該類名稱必須前面加上映射到相應 CLR 命名空間的 XAML 命名空間的首碼。</span><span class="sxs-lookup"><span data-stu-id="3edf6-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="3edf6-297">例如，`<custom:Example/>`物件元素語法用於具現化`Example`類的實例，其中包含該類的 CLR 命名空間（可能還有包含支援類型的外部程式集資訊）以前映射到`custom`首碼。</span><span class="sxs-lookup"><span data-stu-id="3edf6-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="3edf6-298">有關 XAML 命名空間的詳細資訊，請參閱[WPF XAML 的 XAML 命名空間和命名空間映射](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="3edf6-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>
## <a name="markup-extensions"></a><span data-ttu-id="3edf6-299">標記延伸</span><span class="sxs-lookup"><span data-stu-id="3edf6-299">Markup Extensions</span></span>  
 <span data-ttu-id="3edf6-300">XAML 定義了標記擴展程式設計實體，該實體允許從字串屬性值或物件元素的正常 XAML 處理器處理中轉義，並將處理延遲到備份類。</span><span class="sxs-lookup"><span data-stu-id="3edf6-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="3edf6-301">使用屬性語法時標識 XAML 處理器的標記擴展的字元是首角大括弧 （*），後跟關閉大括弧 （*） 以外的任何字元。</span><span class="sxs-lookup"><span data-stu-id="3edf6-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="3edf6-302">開頭大括弧後的第一個字串必須引用提供特定擴展行為的類，如果該子字串是真實類名稱的一部分，則引用可能會省略子字串"擴展"。</span><span class="sxs-lookup"><span data-stu-id="3edf6-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="3edf6-303">此後，可能會出現單個空格，然後每個後續字元都用作擴展實現的輸入，直到遇到關閉的大括弧。</span><span class="sxs-lookup"><span data-stu-id="3edf6-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="3edf6-304">.NET XAML 實現使用<xref:System.Windows.Markup.MarkupExtension>抽象類別作為其他[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]框架或技術支援的所有標記擴展的基礎。</span><span class="sxs-lookup"><span data-stu-id="3edf6-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="3edf6-305">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]專門實現的標記擴展通常旨在提供引用其他現有物件的方法，或對將在運行時計算的物件進行延遲引用。</span><span class="sxs-lookup"><span data-stu-id="3edf6-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="3edf6-306">例如，通過指定`{Binding}`標記擴展代替特定屬性通常採用的值來完成簡單的 WPF 資料繫結。</span><span class="sxs-lookup"><span data-stu-id="3edf6-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="3edf6-307">許多 WPF 標記擴展為無法進行屬性語法的屬性啟用屬性語法。</span><span class="sxs-lookup"><span data-stu-id="3edf6-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="3edf6-308">例如，<xref:System.Windows.Style>物件是一種相對複雜的類型，包含嵌套的物件和屬性系列。</span><span class="sxs-lookup"><span data-stu-id="3edf6-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="3edf6-309">WPF 中的樣式通常定義為<xref:System.Windows.ResourceDictionary>中的資源，然後通過請求資源的兩個 WPF 標記擴展之一引用。</span><span class="sxs-lookup"><span data-stu-id="3edf6-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="3edf6-310">標記擴展將屬性值的計算延遲到資源查找，並啟用在屬性語法中提供<xref:System.Windows.FrameworkElement.Style%2A>屬性的值，採用類型<xref:System.Windows.Style>，如以下示例所示：</span><span class="sxs-lookup"><span data-stu-id="3edf6-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="3edf6-311">此處，`StaticResource`標識提供標記<xref:System.Windows.StaticResourceExtension>擴展實現的類。</span><span class="sxs-lookup"><span data-stu-id="3edf6-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="3edf6-312">下一個`MyStyle`字串用作非預設<xref:System.Windows.StaticResourceExtension>建構函式的輸入，其中從擴充字元串獲取的參數聲明請求<xref:System.Windows.ResourceKey>的 。</span><span class="sxs-lookup"><span data-stu-id="3edf6-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="3edf6-313">`MyStyle`應為<xref:System.Windows.Style>定義為資源的[x：鍵](../../../desktop-wpf/xaml-services/xkey-directive.md)值。</span><span class="sxs-lookup"><span data-stu-id="3edf6-313">`MyStyle` is expected to be the [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="3edf6-314">[靜態資源標記擴展](staticresource-markup-extension.md)使用請求使用資源在載入時通過靜態資源查找邏輯<xref:System.Windows.Style>提供屬性值。</span><span class="sxs-lookup"><span data-stu-id="3edf6-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="3edf6-315">如需標記延伸的詳細資訊，請參閱[標記延伸和 WPF XAML](markup-extensions-and-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="3edf6-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="3edf6-316">有關在常規 .NET XAML 實現中啟用的標記擴展和其他 XAML 程式設計功能的引用，請參閱[XAML 命名空間 （x：）語言功能](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="3edf6-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span></span> <span data-ttu-id="3edf6-317">有關特定于 WPF 的標記擴展，請參閱[WPF XAML 擴展](wpf-xaml-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="3edf6-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>
## <a name="attached-properties"></a><span data-ttu-id="3edf6-318">附加屬性</span><span class="sxs-lookup"><span data-stu-id="3edf6-318">Attached Properties</span></span>  
 <span data-ttu-id="3edf6-319">附加屬性是在 XAML 中引入的程式設計概念，根據該概念，屬性可以由特定類型擁有和定義，但設置為任何元素的屬性或屬性元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="3edf6-320">附加屬性的主要方案是使標記結構中的子項目能夠將資訊報告給父元素，而無需跨所有元素進行廣泛共用的物件模型。</span><span class="sxs-lookup"><span data-stu-id="3edf6-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="3edf6-321">相反，父元素可以使用附加屬性向子項目報告資訊。</span><span class="sxs-lookup"><span data-stu-id="3edf6-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="3edf6-322">有關附加屬性的用途以及如何創建自己的附加屬性的詳細資訊，請參閱[附加屬性概述](attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="3edf6-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="3edf6-323">附加屬性使用表面上類似于屬性元素語法的語法，因為您還指定了*typeName*。*屬性名稱*組合。</span><span class="sxs-lookup"><span data-stu-id="3edf6-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="3edf6-324">有兩個重大差異：</span><span class="sxs-lookup"><span data-stu-id="3edf6-324">There are two important differences:</span></span>  
  
- <span data-ttu-id="3edf6-325">您可以使用*類型名稱*。*屬性名稱*組合，即使通過屬性語法設置附加屬性也是如此。</span><span class="sxs-lookup"><span data-stu-id="3edf6-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="3edf6-326">附加屬性是唯一限定屬性名稱是屬性語法中的要求。</span><span class="sxs-lookup"><span data-stu-id="3edf6-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
- <span data-ttu-id="3edf6-327">還可以對附加屬性使用屬性元素語法。</span><span class="sxs-lookup"><span data-stu-id="3edf6-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="3edf6-328">但是，對於典型的屬性元素語法，指定的*類型Name*是包含屬性元素的物件元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="3edf6-329">如果引用附加屬性，則*typeName*是定義附加屬性的類，而不是包含的物件元素。</span><span class="sxs-lookup"><span data-stu-id="3edf6-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>
## <a name="attached-events"></a><span data-ttu-id="3edf6-330">附加事件</span><span class="sxs-lookup"><span data-stu-id="3edf6-330">Attached Events</span></span>  
 <span data-ttu-id="3edf6-331">附加事件是在 XAML 中引入的另一個程式設計概念，其中事件可以由特定類型定義，但處理常式可以附加到任何物件元素上。</span><span class="sxs-lookup"><span data-stu-id="3edf6-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="3edf6-332">在 WOF 實現中，定義附加事件的類型通常是定義服務的靜態類型，有時這些附加事件由公開服務類型的路由事件別名公開。</span><span class="sxs-lookup"><span data-stu-id="3edf6-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="3edf6-333">附加事件的處理常式通過屬性語法指定。</span><span class="sxs-lookup"><span data-stu-id="3edf6-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="3edf6-334">與附加事件一樣，附加事件的屬性語法將展開，以允許*typeName*。*事件名稱*用法，其中*類型名稱*是為附加的事件`Add`基礎結構`Remove`提供和事件處理常式訪問器的類，*事件名稱*是事件名稱。</span><span class="sxs-lookup"><span data-stu-id="3edf6-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="3edf6-335">XAML 根項目的剖析</span><span class="sxs-lookup"><span data-stu-id="3edf6-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="3edf6-336">下表顯示了分解的典型 XAML 根項目，顯示了根項目的特定屬性：</span><span class="sxs-lookup"><span data-stu-id="3edf6-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="3edf6-337">打開根項目的物件元素</span><span class="sxs-lookup"><span data-stu-id="3edf6-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="3edf6-338">預設 （[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]） XAML 命名空間</span><span class="sxs-lookup"><span data-stu-id="3edf6-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="3edf6-339">XAML 語言 XAML 命名空間</span><span class="sxs-lookup"><span data-stu-id="3edf6-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="3edf6-340">將標記連接到為部分類定義的任何代碼後面的任何部分類聲明</span><span class="sxs-lookup"><span data-stu-id="3edf6-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="3edf6-341">根物件元素的結束。</span><span class="sxs-lookup"><span data-stu-id="3edf6-341">End of object element for the root.</span></span> <span data-ttu-id="3edf6-342">物件尚未關閉，因為元素包含子項目</span><span class="sxs-lookup"><span data-stu-id="3edf6-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="3edf6-343">可選和非推薦的 XAML 用法</span><span class="sxs-lookup"><span data-stu-id="3edf6-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="3edf6-344">以下各節介紹 XAML 處理器在技術上支援的 XAML 用法，但會產生詳細性或其他美學問題，干擾在開發包含 XAML 源的應用程式時保持人類可讀的 XAML 檔。</span><span class="sxs-lookup"><span data-stu-id="3edf6-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="3edf6-345">可選屬性元素用法</span><span class="sxs-lookup"><span data-stu-id="3edf6-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="3edf6-346">可選屬性元素用法包括顯式寫入 XAML 處理器認為隱式的元素內容屬性。</span><span class="sxs-lookup"><span data-stu-id="3edf6-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="3edf6-347">例如，當您聲明 的內容時<xref:System.Windows.Controls.Menu>，可以選擇顯式聲明 集合<xref:System.Windows.Controls.ItemsControl.Items%2A><xref:System.Windows.Controls.Menu>為`<Menu.Items>`屬性元素標記，並將每個<xref:System.Windows.Controls.MenuItem>集合放在`<Menu.Items>`中，而不是使用隱式 XAML 處理器行為，所有<xref:System.Windows.Controls.Menu>子項目的所有子項目都必須是<xref:System.Windows.Controls.MenuItem>和 放置在<xref:System.Windows.Controls.ItemsControl.Items%2A>集合中。</span><span class="sxs-lookup"><span data-stu-id="3edf6-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="3edf6-348">有時，可選用法有助於直觀地闡明標記中表示的物件結構。</span><span class="sxs-lookup"><span data-stu-id="3edf6-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="3edf6-349">或者有時顯式屬性元素使用可以避免在技術上起作用但視覺上令人困惑的標記，例如屬性值中的嵌套標記擴展。</span><span class="sxs-lookup"><span data-stu-id="3edf6-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="3edf6-350">全類型名稱.成員名稱限定屬性</span><span class="sxs-lookup"><span data-stu-id="3edf6-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="3edf6-351">*類型名稱*。屬性*的 iName*表單實際上比路由事件案例更通用。</span><span class="sxs-lookup"><span data-stu-id="3edf6-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="3edf6-352">但在其他情況下，形式是多餘的，你應該避免它，如果僅僅是標記風格和可讀性的原因。</span><span class="sxs-lookup"><span data-stu-id="3edf6-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="3edf6-353">在下面的示例中，對<xref:System.Windows.Controls.Control.Background%2A>該屬性的三個引用中的每一個都完全等效：</span><span class="sxs-lookup"><span data-stu-id="3edf6-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="3edf6-354">`Button.Background`工作，因為 該<xref:System.Windows.Controls.Button>屬性的限定查找成功（<xref:System.Windows.Controls.Control.Background%2A>從 Control 繼承），並且<xref:System.Windows.Controls.Button>是物件元素或基類的類。</span><span class="sxs-lookup"><span data-stu-id="3edf6-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="3edf6-355">`Control.Background`工作，<xref:System.Windows.Controls.Control>因為類實際上定義<xref:System.Windows.Controls.Control.Background%2A>，是<xref:System.Windows.Controls.Control>一個<xref:System.Windows.Controls.Button>基類。</span><span class="sxs-lookup"><span data-stu-id="3edf6-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="3edf6-356">但是，以下*類型名稱*。*成員名稱*表單示例不起作用，因此顯示注釋：</span><span class="sxs-lookup"><span data-stu-id="3edf6-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="3edf6-357"><xref:System.Windows.Controls.Label>是另一派生類，<xref:System.Windows.Controls.Control>如果您在`Label.Background`<xref:System.Windows.Controls.Label>物件元素中指定，則此用法將起作用。</span><span class="sxs-lookup"><span data-stu-id="3edf6-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="3edf6-358">但是，由於<xref:System.Windows.Controls.Label>不是 的類或基類<xref:System.Windows.Controls.Button>，因此指定的 XAML 處理器行為是作為附加`Label.Background`屬性進行處理。</span><span class="sxs-lookup"><span data-stu-id="3edf6-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="3edf6-359">`Label.Background`不是可用的附加屬性，並且此用法將失敗。</span><span class="sxs-lookup"><span data-stu-id="3edf6-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="3edf6-360">基類型名稱.成員名稱屬性元素</span><span class="sxs-lookup"><span data-stu-id="3edf6-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="3edf6-361">以類似的方式與*類型名稱*。*成員名稱*表單適用于屬性語法，*基類型名稱*。*成員名稱*語法適用于屬性元素語法。</span><span class="sxs-lookup"><span data-stu-id="3edf6-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="3edf6-362">例如，以下語法有效：</span><span class="sxs-lookup"><span data-stu-id="3edf6-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="3edf6-363">此處，即使屬性元素包含在 中`Control.Background``Button`，屬性元素也給出為</span><span class="sxs-lookup"><span data-stu-id="3edf6-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="3edf6-364">但就像*類型名稱*。*屬性的成員名稱*表單，*基本類型名稱*。*成員名稱*在標記中是不好的樣式，您應該避免它。</span><span class="sxs-lookup"><span data-stu-id="3edf6-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="3edf6-365">另請參閱</span><span class="sxs-lookup"><span data-stu-id="3edf6-365">See also</span></span>

- [<span data-ttu-id="3edf6-366">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="3edf6-366">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="3edf6-367">XAML 命名空間 (x:) 語言功能</span><span class="sxs-lookup"><span data-stu-id="3edf6-367">XAML Namespace (x:) Language Features</span></span>](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [<span data-ttu-id="3edf6-368">WPF XAML 擴充功能</span><span class="sxs-lookup"><span data-stu-id="3edf6-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="3edf6-369">相依性屬性概觀</span><span class="sxs-lookup"><span data-stu-id="3edf6-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="3edf6-370">TypeConverter 和 XAML</span><span class="sxs-lookup"><span data-stu-id="3edf6-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="3edf6-371">WPF 的 XAML 和自訂類別</span><span class="sxs-lookup"><span data-stu-id="3edf6-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
