---
title: "XAML 語法詳細資料"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
caps.latest.revision: "26"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.openlocfilehash: 0aa85c9ec6e6b911444b07a4169dc769ac4df816
ms.sourcegitcommit: 4f3fef493080a43e70e951223894768d36ce430a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/21/2017
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="26d77-102">XAML 語法詳細資料</span><span class="sxs-lookup"><span data-stu-id="26d77-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="26d77-103">本主題中定義的詞彙用於描述 XAML 語法的項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="26d77-104">這些條款常用的這份文件，WPF 文件的其餘具體而言，適用於其他使用 XAML 或啟用 System.Xaml 層級的 XAML 語言支援的基本 XAML 概念的架構。</span><span class="sxs-lookup"><span data-stu-id="26d77-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="26d77-105">本主題詳述主題所介紹的基本術語[XAML 概觀 (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="26d77-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md).</span></span>  
  

  
<a name="the_xaml_language_specification"></a>   
## <a name="the-xaml-language-specification"></a><span data-ttu-id="26d77-106">XAML 語言規格</span><span class="sxs-lookup"><span data-stu-id="26d77-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="26d77-107">此處定義的 XAML 語法術語也定義，或者參考 XAML 語言規格中。</span><span class="sxs-lookup"><span data-stu-id="26d77-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="26d77-108">XAML 是 XML 為基礎的語言會遵循及基礎 XML 結構的規則。</span><span class="sxs-lookup"><span data-stu-id="26d77-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="26d77-109">一些用語所共用，或描述 XML 語言或 XML 文件物件模型時常用的詞彙為基礎。</span><span class="sxs-lookup"><span data-stu-id="26d77-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="26d77-110">如需 XAML 語言規格的詳細資訊，請下載[ \[MS-XAML\] ](http://go.microsoft.com/fwlink/?LinkId=114525)從 Microsoft 下載中心取得。</span><span class="sxs-lookup"><span data-stu-id="26d77-110">For more information about the XAML language specification, download [\[MS-XAML\]](http://go.microsoft.com/fwlink/?LinkId=114525) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>   
## <a name="xaml-and-clr"></a><span data-ttu-id="26d77-111">XAML 和 CLR</span><span class="sxs-lookup"><span data-stu-id="26d77-111">XAML and CLR</span></span>  
 <span data-ttu-id="26d77-112">XAML 是一種標記語言。</span><span class="sxs-lookup"><span data-stu-id="26d77-112">XAML is a markup language.</span></span> <span data-ttu-id="26d77-113">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]、 為隱含的名稱可讓執行階段執行。</span><span class="sxs-lookup"><span data-stu-id="26d77-113">The [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="26d77-114">XAML 不是單獨使用其中一個直接由 CLR 執行階段的常見語言。</span><span class="sxs-lookup"><span data-stu-id="26d77-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="26d77-115">相反地，您可以將 XAML 視為支援它自己的型別系統。</span><span class="sxs-lookup"><span data-stu-id="26d77-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="26d77-116">特定的 XAML 剖析系統，以供 WPF 是建置在 CLR 與 CLR 型別系統。</span><span class="sxs-lookup"><span data-stu-id="26d77-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="26d77-117">XAML 類型會對應至 CLR 型別，wpf XAML 剖析時，具現化的執行的階段表示法。</span><span class="sxs-lookup"><span data-stu-id="26d77-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="26d77-118">基於這個理由，即使對等的語法中的討論區 XAML 語言規格不相符的語法，在這份文件中討論的其餘部分時，將包含 CLR 型別系統中，參考。</span><span class="sxs-lookup"><span data-stu-id="26d77-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="26d77-119">（每 XAML 語言規格層級中，XAML 類型無法對應到任何其他型別系統，沒有是 CLR 中，但是，就必須建立和使用不同的 XAML 剖析器。）</span><span class="sxs-lookup"><span data-stu-id="26d77-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="26d77-120">型別和類別繼承的成員</span><span class="sxs-lookup"><span data-stu-id="26d77-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="26d77-121">屬性和事件，您會看到顯示的 XAML 成員為[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]類型通常都繼承自基底型別。</span><span class="sxs-lookup"><span data-stu-id="26d77-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="26d77-122">例如，請考量以下範例： `<Button Background="Blue" .../>`。</span><span class="sxs-lookup"><span data-stu-id="26d77-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="26d77-123"><xref:System.Windows.Controls.Control.Background%2A>屬性不是立即宣告的屬性上<xref:System.Windows.Controls.Button>類別，如果您要查看的類別定義，反映結果或文件。</span><span class="sxs-lookup"><span data-stu-id="26d77-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="26d77-124">相反地，<xref:System.Windows.Controls.Control.Background%2A>繼承自基底<xref:System.Windows.Controls.Control>類別。</span><span class="sxs-lookup"><span data-stu-id="26d77-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="26d77-125">類別的繼承行為[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]XAML 項目是重要出發，從結構描述強制執行的解譯 XML 標記。</span><span class="sxs-lookup"><span data-stu-id="26d77-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="26d77-126">類別繼承會變得複雜，特別是當中繼的基底類別是抽象類別，或當牽涉到介面時。</span><span class="sxs-lookup"><span data-stu-id="26d77-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="26d77-127">這是一個原因的 XAML 項目和其所允許的屬性集是難以表示精確且完全使用結構描述型別，通常用於[!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)]程式設計，例如 DTD 或 XSD 格式。</span><span class="sxs-lookup"><span data-stu-id="26d77-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] programming, such as DTD or XSD format.</span></span> <span data-ttu-id="26d77-128">另一個原因是該擴充性和 XAML 語言本身的類型對應功能不允許的類型和成員的任何固定表示法的完整性。</span><span class="sxs-lookup"><span data-stu-id="26d77-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>   
## <a name="object-element-syntax"></a><span data-ttu-id="26d77-129">物件元素語法</span><span class="sxs-lookup"><span data-stu-id="26d77-129">Object Element Syntax</span></span>  
 <span data-ttu-id="26d77-130">*物件項目語法*是藉由宣告的 XML 項目執行個體化 CLR 類別或結構的 XAML 標記語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="26d77-131">這個語法類似於其他標記語言，例如 HTML 項目語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="26d77-132">物件項目語法的開頭是左角括號 (\<)，後面接著立即在類別或結構所產生的型別名稱。</span><span class="sxs-lookup"><span data-stu-id="26d77-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="26d77-133">零個或多個空格，可以遵循的型別名稱，以及零個或多個屬性也可以宣告物件項目上有一或多個空格分隔每個屬性名稱 = 「 值 」 配對。</span><span class="sxs-lookup"><span data-stu-id="26d77-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="26d77-134">最後，下列其中一項必須為真：</span><span class="sxs-lookup"><span data-stu-id="26d77-134">Finally, one of the following must be true:</span></span>  
  
-   <span data-ttu-id="26d77-135">此項目和標記必須先關閉以正斜線 （/） 後面緊接跟著右角括弧 (>)。</span><span class="sxs-lookup"><span data-stu-id="26d77-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
-   <span data-ttu-id="26d77-136">開頭標記必須完成的右角括號 (>)。</span><span class="sxs-lookup"><span data-stu-id="26d77-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="26d77-137">其他物件項目、 屬性項目或內部文字，可以遵循的開頭標記。</span><span class="sxs-lookup"><span data-stu-id="26d77-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="26d77-138">完全內容可能包含以下通常受到物件模型的項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="26d77-139">對等項目結尾標記的物件項目也必須位於正確的巢狀，並使用其他的開頭和結尾標記配對之間取得平衡。</span><span class="sxs-lookup"><span data-stu-id="26d77-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="26d77-140">由.NET 實作 XAML 有一組對應物件項目型別，屬性至屬性或事件和 XAML 命名空間到 CLR 命名空間加上組件的規則。</span><span class="sxs-lookup"><span data-stu-id="26d77-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="26d77-141">如需 WPF 和.NET Framework，XAML 物件項目對應至[!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)]參考的組件中所定義的型別和屬性會對應至這些型別的成員。</span><span class="sxs-lookup"><span data-stu-id="26d77-141">For WPF and the .NET Framework, XAML object elements map to [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="26d77-142">當您參考的 CLR 型別，在 XAML 中時，您可以存取該型別繼承的成員。</span><span class="sxs-lookup"><span data-stu-id="26d77-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="26d77-143">例如，下列範例是會具現化的新執行個體的物件項目語法<xref:System.Windows.Controls.Button>類別，以及也會指定<xref:System.Windows.FrameworkElement.Name%2A>屬性和該屬性的值：</span><span class="sxs-lookup"><span data-stu-id="26d77-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="26d77-144">下列範例是物件也包含 XAML 內容屬性語法的項目語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="26d77-145">中包含的內部文字會用來設定<xref:System.Windows.Controls.TextBox>XAML 內容屬性， <xref:System.Windows.Controls.TextBox.Text%2A>。</span><span class="sxs-lookup"><span data-stu-id="26d77-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="26d77-146">內容模型</span><span class="sxs-lookup"><span data-stu-id="26d77-146">Content Models</span></span>  
 <span data-ttu-id="26d77-147">類別可能會以 XAML 物件項目語法，以支援使用，但是該項目只正常運作的應用程式或頁面放在整體內容模型或項目樹狀結構之預期的位置時。</span><span class="sxs-lookup"><span data-stu-id="26d77-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="26d77-148">例如，<xref:System.Windows.Controls.MenuItem>通常只可出現的子系<xref:System.Windows.Controls.Primitives.MenuBase>衍生類別，例如<xref:System.Windows.Controls.Menu>。</span><span class="sxs-lookup"><span data-stu-id="26d77-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="26d77-149">內容模型的特定項目會記載為控制項和其他類別頁面上的 「 註解的一部分[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]類別，可以用做為 XAML 項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>   
## <a name="properties-of-object-elements"></a><span data-ttu-id="26d77-150">物件元素的屬性</span><span class="sxs-lookup"><span data-stu-id="26d77-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="26d77-151">在 XAML 中的屬性會設定各種可能的語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="26d77-152">何種語法可用於特定的屬性而異，根據您要設定之屬性的基礎類型系統特性。</span><span class="sxs-lookup"><span data-stu-id="26d77-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="26d77-153">藉由設定屬性的值，您加入功能或特性物件存在於執行的階段物件圖形中。</span><span class="sxs-lookup"><span data-stu-id="26d77-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="26d77-154">從物件項目所建立物件的初始狀態為基礎的預設建構函式的行為。</span><span class="sxs-lookup"><span data-stu-id="26d77-154">The initial state of the created object from a object element is based on the default constructor behavior.</span></span> <span data-ttu-id="26d77-155">一般而言，應用程式將使用完全預設執行任何的個體指定的物件以外的項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>   
## <a name="attribute-syntax-properties"></a><span data-ttu-id="26d77-156">屬性 (Attribute) 語法 (屬性(Property))</span><span class="sxs-lookup"><span data-stu-id="26d77-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="26d77-157">屬性語法是藉由宣告屬性的現有物件項目上設定屬性值的 XAML 標記語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="26d77-158">屬性名稱必須符合 CLR 成員名稱的類別之備份的相關物件元素的屬性。</span><span class="sxs-lookup"><span data-stu-id="26d77-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="26d77-159">指派運算子 （=） 後面的屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="26d77-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="26d77-160">屬性值必須括在引號內的字串。</span><span class="sxs-lookup"><span data-stu-id="26d77-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26d77-161">您可以使用替代的引號，放置在屬性中的常值引號。</span><span class="sxs-lookup"><span data-stu-id="26d77-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="26d77-162">例如您可以使用單引號來宣告包含在其中的雙引號字元的字串。</span><span class="sxs-lookup"><span data-stu-id="26d77-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="26d77-163">不論您使用單引號或雙引號時，您應該使用相符的配對，來開啟和關閉屬性值字串。</span><span class="sxs-lookup"><span data-stu-id="26d77-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="26d77-164">也有逸出序列或其他技術可用來解決任何特定的 XAML 語法所加諸的字元限制。</span><span class="sxs-lookup"><span data-stu-id="26d77-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="26d77-165">請參閱[XML 字元實體和 XAML](../../../../docs/framework/xaml-services/xml-character-entities-and-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="26d77-165">See [XML Character Entities and XAML](../../../../docs/framework/xaml-services/xml-character-entities-and-xaml.md).</span></span>  
  
 <span data-ttu-id="26d77-166">若要設定透過屬性的語法，屬性必須是公用的而且必須可寫入。</span><span class="sxs-lookup"><span data-stu-id="26d77-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="26d77-167">在支援類型系統中屬性的值必須是實值類型，或必須可具現化或存取相關時，XAML 處理器所參考的參考型別備份類型。</span><span class="sxs-lookup"><span data-stu-id="26d77-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="26d77-168">WPF XAML 事件之事件的參考做為屬性名稱必須具有公用和具有公用委派。</span><span class="sxs-lookup"><span data-stu-id="26d77-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="26d77-169">屬性或事件必須是類別或結構所包含的物件項目執行個體化的成員。</span><span class="sxs-lookup"><span data-stu-id="26d77-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="26d77-170">屬性值的處理</span><span class="sxs-lookup"><span data-stu-id="26d77-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="26d77-171">XAML 處理器會處理包含在開頭和結尾引號的字串值。</span><span class="sxs-lookup"><span data-stu-id="26d77-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="26d77-172">屬性，預設的處理行為是取決於基礎的 CLR 屬性的類型。</span><span class="sxs-lookup"><span data-stu-id="26d77-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="26d77-173">下列程式碼，其中會填入屬性值使用此處理順序：</span><span class="sxs-lookup"><span data-stu-id="26d77-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1.  <span data-ttu-id="26d77-174">如果 XAML 處理器發現了大括號或物件項目衍生自<xref:System.Windows.Markup.MarkupExtension>、 然後參考的標記延伸會先評估而不是處理字串形式的值，標記延伸模組所傳回的物件做為值。</span><span class="sxs-lookup"><span data-stu-id="26d77-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="26d77-175">在許多情況下的標記延伸模組所傳回的物件會參考現有的物件或評估延後到執行階段，並不是新具現化的物件的運算式。</span><span class="sxs-lookup"><span data-stu-id="26d77-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2.  <span data-ttu-id="26d77-176">如果屬性宣告的屬性化<xref:System.ComponentModel.TypeConverter>，或在宣告該屬性的值類型與屬性化<xref:System.ComponentModel.TypeConverter>、 屬性的字串值送出至做為轉換輸入中，類型轉換器和轉換器會傳回新的物件執行個體。</span><span class="sxs-lookup"><span data-stu-id="26d77-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3.  <span data-ttu-id="26d77-177">如果沒有任何<xref:System.ComponentModel.TypeConverter>，嘗試直接轉換成屬性型別。</span><span class="sxs-lookup"><span data-stu-id="26d77-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="26d77-178">這個最後一個層級是直接在 XAML 語言基本類型或列舉型別 （剖析器再存取相符的值） 的具名常數的名稱檢查之間的剖析器原生值轉換。</span><span class="sxs-lookup"><span data-stu-id="26d77-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="26d77-179">列舉型別屬性值</span><span class="sxs-lookup"><span data-stu-id="26d77-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="26d77-180">列舉型別在 XAML 中的處理的內容本質上並 XAML 剖析器，以及藉由指定列舉的具名常數的其中一個的字串名稱應指定列舉的成員。</span><span class="sxs-lookup"><span data-stu-id="26d77-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="26d77-181">原生的行為是屬性值的字串處理，並將它解析為其中一個列舉值 （attribute） 的列舉值。</span><span class="sxs-lookup"><span data-stu-id="26d77-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="26d77-182">您不指定格式列舉*列舉*。*值*、 與您在程式碼。</span><span class="sxs-lookup"><span data-stu-id="26d77-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="26d77-183">相反地，只指定*值*，和*列舉*由您要設定屬性的型別推斷。</span><span class="sxs-lookup"><span data-stu-id="26d77-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="26d77-184">如果您指定屬性在*列舉*。*值*表單中，它將不會解析正確。</span><span class="sxs-lookup"><span data-stu-id="26d77-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="26d77-185">若是旗列舉型別，行為根據<xref:System.Enum.Parse%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="26d77-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="26d77-186">您可以使用逗號區隔每個值指定多個旗列舉值。</span><span class="sxs-lookup"><span data-stu-id="26d77-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="26d77-187">不過，您無法結合不旗標式的列舉值。</span><span class="sxs-lookup"><span data-stu-id="26d77-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="26d77-188">比方說，您無法使用逗號語法來嘗試建立<xref:System.Windows.Trigger>，充當 （attribute） 的列舉型別的多個條件：</span><span class="sxs-lookup"><span data-stu-id="26d77-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="26d77-189">在 WPF 中於旗列舉型別支援可在 XAML 中設定的屬性。</span><span class="sxs-lookup"><span data-stu-id="26d77-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="26d77-190">不過，這類列舉是<xref:System.Windows.Media.StyleSimulations>。</span><span class="sxs-lookup"><span data-stu-id="26d77-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="26d77-191">您執行個體，可以使用逗點分隔旗屬性語法來修改的 「 備註 」 中所提供的範例<xref:System.Windows.Documents.Glyphs>類別;`StyleSimulations = "BoldSimulation"`可能會變得`StyleSimulations = "BoldSimulation,ItalicSimulation"`。</span><span class="sxs-lookup"><span data-stu-id="26d77-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="26d77-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>是另一個屬性可在其中指定一個以上的列舉值。</span><span class="sxs-lookup"><span data-stu-id="26d77-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="26d77-193">不過，這個屬性剛好是特殊案例中，因為<xref:System.Windows.Input.ModifierKeys>列舉型別支援它自己的型別轉換子。</span><span class="sxs-lookup"><span data-stu-id="26d77-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="26d77-194">修飾詞的類型轉換器會使用加號 （+），做為分隔符號，而不是逗號 （，）。</span><span class="sxs-lookup"><span data-stu-id="26d77-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="26d77-195">此轉換支援更傳統的語法，以代表索引鍵的組合，在 Microsoft Windows 程式設計中，例如 「 Ctrl + Alt。</span><span class="sxs-lookup"><span data-stu-id="26d77-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="26d77-196">屬性和事件成員名稱參考</span><span class="sxs-lookup"><span data-stu-id="26d77-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="26d77-197">在指定屬性時，您可以參考任何屬性或您所包含的物件項目針對具現化的 CLR 型別成員的事件。</span><span class="sxs-lookup"><span data-stu-id="26d77-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="26d77-198">或者，您可以參考附加的屬性或附加的包含物件項目獨立事件。</span><span class="sxs-lookup"><span data-stu-id="26d77-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="26d77-199">（附加的屬性會在後續的章節中討論）。</span><span class="sxs-lookup"><span data-stu-id="26d77-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="26d77-200">您也可以名稱是透過預設命名空間存取使用的所有物件的任何事件*typeName*。*事件*部分限定的名稱; 此附加的路由事件的處理常式的支援此處理常式要處理事件的路由從子項目，但父項目也沒有該事件在其成員資料表中的語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="26d77-201">這個語法類似於附加的事件的語法，但這裡的事件不是，則為 true 的附加的事件。</span><span class="sxs-lookup"><span data-stu-id="26d77-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="26d77-202">相反地，您會參考具有限定名稱的事件。</span><span class="sxs-lookup"><span data-stu-id="26d77-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="26d77-203">如需詳細資訊，請參閱[路由傳送事件概觀](../../../../docs/framework/wpf/advanced/routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="26d77-203">For more information, see [Routed Events Overview](../../../../docs/framework/wpf/advanced/routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="26d77-204">某些情況下，有時會提供屬性名稱做為屬性，而不是屬性名稱的值。</span><span class="sxs-lookup"><span data-stu-id="26d77-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="26d77-205">該屬性的名稱也可以包含辨識符號，例如表單中指定的屬性*ownerType*。*dependencyPropertyName*。</span><span class="sxs-lookup"><span data-stu-id="26d77-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="26d77-206">在 XAML 中撰寫樣式或範本時，常會使用此案例。</span><span class="sxs-lookup"><span data-stu-id="26d77-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="26d77-207">提供做為屬性值的屬性名稱的處理規則不同，而且依所設定的屬性類型或特定 WPF 子系統的行為會控管。</span><span class="sxs-lookup"><span data-stu-id="26d77-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="26d77-208">如需詳細資訊，請參閱[設定樣式和範本](../../../../docs/framework/wpf/controls/styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="26d77-208">For details, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="26d77-209">屬性值描述屬性屬性關聯性時的屬性名稱的另一個使用方式。</span><span class="sxs-lookup"><span data-stu-id="26d77-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="26d77-210">這項功能會使用資料繫結和分鏡腳本的目標，且已啟用<xref:System.Windows.PropertyPath>類別和其型別轉換子。</span><span class="sxs-lookup"><span data-stu-id="26d77-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="26d77-211">查閱語意的更完整描述，請參閱[PropertyPath XAML 語法](../../../../docs/framework/wpf/advanced/propertypath-xaml-syntax.md)。</span><span class="sxs-lookup"><span data-stu-id="26d77-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](../../../../docs/framework/wpf/advanced/propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>   
## <a name="property-element-syntax"></a><span data-ttu-id="26d77-212">屬性元素語法</span><span class="sxs-lookup"><span data-stu-id="26d77-212">Property Element Syntax</span></span>  
 <span data-ttu-id="26d77-213">*屬性項目語法*是一個值稍有基本的 XML 語法規則的項目與值的語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="26d77-214">在 XML 中，屬性值的既定的字串，唯一可能的變化是正在使用哪一種字串編碼格式。</span><span class="sxs-lookup"><span data-stu-id="26d77-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="26d77-215">在 XAML 中，您可以指定其他物件項目是屬性的值。</span><span class="sxs-lookup"><span data-stu-id="26d77-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="26d77-216">屬性項目語法會啟用這項功能。</span><span class="sxs-lookup"><span data-stu-id="26d77-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="26d77-217">而不是做為屬性項目標記中所指定的屬性，指定的屬性是使用開啟元素標記*elementTypeName*。*propertyName*表單內，所指定屬性的值和屬性項目已關閉。</span><span class="sxs-lookup"><span data-stu-id="26d77-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="26d77-218">具體來說，語法開頭是左角括號 (\<)，後面接著立即類別或結構屬性項目語法內所包含的型別名稱。</span><span class="sxs-lookup"><span data-stu-id="26d77-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="26d77-219">這後面緊接跟著單一點 （.），然後由屬性的名稱，然後的右角括號 (>)。</span><span class="sxs-lookup"><span data-stu-id="26d77-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="26d77-220">如同屬性語法，該屬性必須存在於指定的類型宣告的公用成員。</span><span class="sxs-lookup"><span data-stu-id="26d77-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="26d77-221">要指派給屬性的值會包含在屬性項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="26d77-222">一般而言，指定以一個或多個物件元素的值，指定做為值的物件是案例，因為該屬性的項目語法為了位址。</span><span class="sxs-lookup"><span data-stu-id="26d77-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="26d77-223">最後，指定相同的對等的結尾標記*elementTypeName*。*propertyName*組合必須，以提供適當的巢狀結構和平衡與其他項目標籤。</span><span class="sxs-lookup"><span data-stu-id="26d77-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="26d77-224">例如，下列是屬性的項目語法<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="26d77-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="26d77-225">屬性項目內的值也指定為內部文字，在案例中所指定的屬性類型的基本值類型，例如<xref:System.String>，或列舉型別指定名稱的位置。</span><span class="sxs-lookup"><span data-stu-id="26d77-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="26d77-226">這些兩種用法是稍微不常見，因為每個案例也可以使用簡單的屬性語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="26d77-227">屬性項目填入字串的其中一個案例是針對不是 XAML 內容屬性，但仍會用於 UI 文字表示法的內容，並出現在該 UI 文字中所需的特定的空白項目，例如換行字元。</span><span class="sxs-lookup"><span data-stu-id="26d77-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular whitespace elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="26d77-228">屬性語法無法保留換行字元，但可以屬性項目語法，只要保留重要的空白字元為作用中 (如需詳細資訊，請參閱[XAML 中的空白字元處理](../../../../docs/framework/xaml-services/whitespace-processing-in-xaml.md))。</span><span class="sxs-lookup"><span data-stu-id="26d77-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant whitespace preservation is active (for details, see [Whitespace Processing in XAML](../../../../docs/framework/xaml-services/whitespace-processing-in-xaml.md)).</span></span> <span data-ttu-id="26d77-229">另一個案例是讓[X:uid 指示詞](../../../../docs/framework/xaml-services/x-uid-directive.md)可以套用至屬性項目和值應該當地語系化 WPF 中，輸出 BAML 或其他技術，因此標記內的值。</span><span class="sxs-lookup"><span data-stu-id="26d77-229">Another scenario is so that [x:Uid Directive](../../../../docs/framework/xaml-services/x-uid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="26d77-230">屬性項目不會呈現 WPF 邏輯樹狀結構中。</span><span class="sxs-lookup"><span data-stu-id="26d77-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="26d77-231">屬性項目是只設定屬性，特定語法，而且不具有執行個體或物件支援的項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="26d77-232">(如邏輯樹狀結構的詳細資訊，請參閱[中 WPF 樹狀架構](../../../../docs/framework/wpf/advanced/trees-in-wpf.md)。)</span><span class="sxs-lookup"><span data-stu-id="26d77-232">(For details on the logical tree concept, see [Trees in WPF](../../../../docs/framework/wpf/advanced/trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="26d77-233">對於屬性和屬性的項目語法其中受支援的屬性，兩個語法通常具有相同的結果，雖然微妙例如空白字元處理方式稍之間的語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as whitespace handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>   
## <a name="collection-syntax"></a><span data-ttu-id="26d77-234">集合語法</span><span class="sxs-lookup"><span data-stu-id="26d77-234">Collection Syntax</span></span>  
 <span data-ttu-id="26d77-235">XAML 規格要求 XAML 處理器實作識別其中實值型別是集合的屬性。</span><span class="sxs-lookup"><span data-stu-id="26d77-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="26d77-236">在.NET 中的一般 XAML 處理器實作根據 managed 程式碼與 CLR，用來識別集合型別，透過下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="26d77-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
-   <span data-ttu-id="26d77-237">型別會實作<xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="26d77-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
-   <span data-ttu-id="26d77-238">型別會實作<xref:System.Collections.IDictionary>。</span><span class="sxs-lookup"><span data-stu-id="26d77-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
-   <span data-ttu-id="26d77-239">型別衍生自<xref:System.Array>(如需 XAML 中的陣列的詳細資訊，請參閱[X:array 標記延伸](../../../../docs/framework/xaml-services/x-array-markup-extension.md)。)</span><span class="sxs-lookup"><span data-stu-id="26d77-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../../docs/framework/xaml-services/x-array-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="26d77-240">如果屬性的型別是集合，然後推斷的集合型別不必做為物件元素的標記中指定。</span><span class="sxs-lookup"><span data-stu-id="26d77-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="26d77-241">相反地，即將成為的項目集合中的項目會指定為一或多個屬性項目的子項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="26d77-242">每個這類項目物件評估在載入期間，以及加入至集合，藉由呼叫`Add`默示集合的方法。</span><span class="sxs-lookup"><span data-stu-id="26d77-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="26d77-243">例如，<xref:System.Windows.Style.Triggers%2A>屬性<xref:System.Windows.Style>採用特製化的集合型別<xref:System.Windows.TriggerCollection>，它會實作<xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="26d77-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="26d77-244">不需要具現化<xref:System.Windows.TriggerCollection>物件標記中的項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="26d77-245">相反地，您指定一個或多個<xref:System.Windows.Trigger>做為項目內的項目`Style.Triggers`屬性項目，其中<xref:System.Windows.Trigger>（或衍生的類別） 是預期的項目類型的強型別和隱含的類型<xref:System.Windows.TriggerCollection>。</span><span class="sxs-lookup"><span data-stu-id="26d77-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="26d77-246">屬性可以是集合型別以及該類型的 XAML 內容屬性，並且衍生型別，本主題的下一節中討論。</span><span class="sxs-lookup"><span data-stu-id="26d77-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="26d77-247">隱含的集合項目邏輯樹狀結構表示法中建立的成員，即使它不會顯示為元素標記中。</span><span class="sxs-lookup"><span data-stu-id="26d77-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="26d77-248">父類型的建構函式通常會為集合的其中一個內容中，執行具現化，一開始是空的集合會成為物件樹狀結構的一部分。</span><span class="sxs-lookup"><span data-stu-id="26d77-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="26d77-249">泛型清單和字典介面 (<xref:System.Collections.Generic.IList%601>和<xref:System.Collections.Generic.IDictionary%602>) 不支援集合偵測。</span><span class="sxs-lookup"><span data-stu-id="26d77-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="26d77-250">不過，您可以使用<xref:System.Collections.Generic.List%601>類別做為基底類別，因為它實作<xref:System.Collections.IList>直接或<xref:System.Collections.Generic.Dictionary%602>做為基底類別，因為它實作<xref:System.Collections.IDictionary>直接。</span><span class="sxs-lookup"><span data-stu-id="26d77-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="26d77-251">在 集合類型的.NET 參考頁集合的物件項目在故意省略與這個語法是偶爾 XAML 語法 」 一節中標示為隱含的集合語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="26d77-252">除了以外的根項目，為另一個元素的子元素會巢狀的 XAML 檔案中的每個物件項目都是真正的項目是一或兩個下列情況下： 其父項目的已隱含的集合屬性的成員或指定的父項目 (XAML 內容屬性將在後續的章節中討論) 的 XAML 內容屬性值的項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="26d77-253">換句話說，關聯性的父項目和標記頁面中的子項目實際上是單一物件的根目錄，而且根目錄下的每個物件項目為提供的父代，屬性值的單一執行個體或其中一個資料行內的項目lection，同時也是父系的集合型別屬性值。</span><span class="sxs-lookup"><span data-stu-id="26d77-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="26d77-254">此單一根目錄概念是常見的 XML，並經常加強的 Api，例如載入 XAML 行為中<xref:System.Windows.Markup.XamlReader.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="26d77-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="26d77-255">下列範例是集合的物件項目語法 (<xref:System.Windows.Media.GradientStopCollection>) 明確地指定。</span><span class="sxs-lookup"><span data-stu-id="26d77-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="26d77-256">請注意，它不一定可以明確宣告集合。</span><span class="sxs-lookup"><span data-stu-id="26d77-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="26d77-257">例如，嘗試宣告<xref:System.Windows.TriggerCollection>明確中先前所示<xref:System.Windows.Style.Triggers%2A>範例將會失敗。</span><span class="sxs-lookup"><span data-stu-id="26d77-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="26d77-258">集合類別必須支援的預設建構函式，明確宣告集合需要和<xref:System.Windows.TriggerCollection>沒有預設建構函式。</span><span class="sxs-lookup"><span data-stu-id="26d77-258">Explicitly declaring the collection requires that the collection class must support a default constructor, and <xref:System.Windows.TriggerCollection> does not have a default constructor.</span></span>  
  
<a name="xaml_content_properties"></a>   
## <a name="xaml-content-properties"></a><span data-ttu-id="26d77-259">XAML 內容屬性</span><span class="sxs-lookup"><span data-stu-id="26d77-259">XAML Content Properties</span></span>  
 <span data-ttu-id="26d77-260">XAML 內容語法就是在指定的類別才會啟用語法<xref:System.Windows.Markup.ContentPropertyAttribute>做為其類別宣告的一部分。</span><span class="sxs-lookup"><span data-stu-id="26d77-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="26d77-261"><xref:System.Windows.Markup.ContentPropertyAttribute>參考該類型的項目 （包括衍生的類別） 的內容屬性的屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="26d77-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="26d77-262">時由 XAML 處理器所處理，該物件的 XAML 內容屬性的值會指派任何子項目或找到的開頭和結尾標記的物件項目之間的內部文字。</span><span class="sxs-lookup"><span data-stu-id="26d77-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="26d77-263">允許您指定明確的屬性項目之內容的屬性，但這種用法通常不會顯示在 XAML 語法 」 一節中的.NET 參考。</span><span class="sxs-lookup"><span data-stu-id="26d77-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="26d77-264">明確/詳細的資訊技術有偶爾標記的清晰度或的標記樣式的值，但通常內容屬性的目的是簡化標記，以便可以直接巢狀直覺的方式為父子式關聯的項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="26d77-265">屬性項目標記為項目上的其他屬性不被指派為 「 內容 」，每個嚴格的 XAML 語言定義。它們的先前處理 XAML 剖析器的處理順序並不會被視為是 「 內容 」。</span><span class="sxs-lookup"><span data-stu-id="26d77-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="26d77-266">必須是連續的 XAML 內容屬性值</span><span class="sxs-lookup"><span data-stu-id="26d77-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="26d77-267">XAML 內容屬性的值必須完全之前或任何其他屬性項目之後的完全指定該物件項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="26d77-268">XAML 內容屬性的值會指定為字串，或一或多個物件是否也是如此。</span><span class="sxs-lookup"><span data-stu-id="26d77-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="26d77-269">例如，下列標記不會剖析：</span><span class="sxs-lookup"><span data-stu-id="26d77-269">For example, the following markup does not parse:</span></span>  
  
```  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="26d77-270">基本上，這是不合法因為此語法所使用之內容屬性的屬性項目語法進行明確，然後內容屬性會設定兩次：</span><span class="sxs-lookup"><span data-stu-id="26d77-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="26d77-271">類似的不合法的範例為內容屬性是集合，並子項目會穿插屬性項目：</span><span class="sxs-lookup"><span data-stu-id="26d77-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>   
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="26d77-272">內容屬性和集合語法合併</span><span class="sxs-lookup"><span data-stu-id="26d77-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="26d77-273">多個單一物件項目，做為內容，才能接收內容屬性的型別必須特別會是集合型別。</span><span class="sxs-lookup"><span data-stu-id="26d77-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="26d77-274">類似於集合型別的屬性項目語法，XAML 處理器必須識別集合型別的型別。</span><span class="sxs-lookup"><span data-stu-id="26d77-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="26d77-275">如果項目具有 XAML 內容屬性，XAML 內容屬性的型別是集合，然後隱含的集合型別不需要指定為物件項目在標記中並不需要指定為屬性 el XAML 內容屬性ement。</span><span class="sxs-lookup"><span data-stu-id="26d77-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="26d77-276">因此的明顯的內容模型，在標記中現在有一個以上的子元素，指派為內容。</span><span class="sxs-lookup"><span data-stu-id="26d77-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="26d77-277">下列是內容語法<xref:System.Windows.Controls.Panel>衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="26d77-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="26d77-278">所有<xref:System.Windows.Controls.Panel>衍生的類別建立 XAML 內容屬性設為<xref:System.Windows.Controls.Panel.Children%2A>，這需要類型的值<xref:System.Windows.Controls.UIElementCollection>。</span><span class="sxs-lookup"><span data-stu-id="26d77-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="26d77-279">請注意，都沒有的屬性項目<xref:System.Windows.Controls.Panel.Children%2A>的項目也不<xref:System.Windows.Controls.UIElementCollection>需要在標記中。</span><span class="sxs-lookup"><span data-stu-id="26d77-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="26d77-280">這是 XAML 設計功能，以便以遞迴方式包含的項目會定義[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]會更直覺的方式表示的直屬父系-子系項目關聯性，而不插入屬性項目標記與巢狀項目樹狀結構或集合物件。</span><span class="sxs-lookup"><span data-stu-id="26d77-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="26d77-281">事實上，<xref:System.Windows.Controls.UIElementCollection>中不能指定明確標記為物件項目所設計。</span><span class="sxs-lookup"><span data-stu-id="26d77-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="26d77-282">其唯一用途是做為隱含的集合，因為<xref:System.Windows.Controls.UIElementCollection>不會公開公用預設建構函式，因此無法具現化為物件項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public default constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="26d77-283">混合屬性項目和物件具有內容屬性之物件中的項目</span><span class="sxs-lookup"><span data-stu-id="26d77-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="26d77-284">XAML 規格會宣告用來填滿 XAML 物件項目內內容屬性的物件項目必須是連續的並不混合 XAML 處理器可以強制執行。</span><span class="sxs-lookup"><span data-stu-id="26d77-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="26d77-285">針對屬性項目及內容混用這項限制由強制執行[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]XAML 處理器。</span><span class="sxs-lookup"><span data-stu-id="26d77-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="26d77-286">您可以為物件項目內的第一個立即標記的子物件項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="26d77-287">然後您可以引入屬性項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-287">Then you can introduce property elements.</span></span> <span data-ttu-id="26d77-288">或者，您可以指定一或多個屬性項目，然後內容，然後再多個屬性的項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="26d77-289">但是，一旦屬性項目後面的內容，不能進行任何進一步的內容，您只能新增屬性項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="26d77-290">此內容 / 屬性項目的順序要求不適用於做為內容的內部文字。</span><span class="sxs-lookup"><span data-stu-id="26d77-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="26d77-291">不過，它仍然是因為必要的空白字元很難偵測到以視覺化方式在標記中如果屬性項目會穿插內部文字保留內部文字是連續的好的標記樣式。</span><span class="sxs-lookup"><span data-stu-id="26d77-291">However, it is still a good markup style to keep inner text contiguous, because significant whitespace will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>   
## <a name="xaml-namespaces"></a><span data-ttu-id="26d77-292">XAML 命名空間</span><span class="sxs-lookup"><span data-stu-id="26d77-292">XAML Namespaces</span></span>  
 <span data-ttu-id="26d77-293">指定 XAML 命名空間的預設 XAML 命名空間以外任何上述語法範例。</span><span class="sxs-lookup"><span data-stu-id="26d77-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="26d77-294">在一般[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]應用程式，預設 XAML 命名空間指定為[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]命名空間。</span><span class="sxs-lookup"><span data-stu-id="26d77-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="26d77-295">您可以指定非預設 XAML 命名空間的 XAML 命名空間，並仍然使用類似的語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="26d77-296">但是，任何位置類別名為無法存取預設 XAML 命名空間中的類別名稱前面必須有的 XAML 命名空間前置詞對應到對應的 CLR 命名空間。</span><span class="sxs-lookup"><span data-stu-id="26d77-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="26d77-297">例如，`<custom:Example/>`物件具現化的執行個體的項目語法`Example`類別，先前來對應 CLR 命名空間包含該類別 （和可能的外部組件資訊，包含支援的型別）`custom`前置詞。</span><span class="sxs-lookup"><span data-stu-id="26d77-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="26d77-298">如需 XAML 命名空間的詳細資訊，請參閱[XAML 命名空間和 WPF XAML 命名空間對應](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="26d77-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](../../../../docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a><span data-ttu-id="26d77-299">標記延伸</span><span class="sxs-lookup"><span data-stu-id="26d77-299">Markup Extensions</span></span>  
 <span data-ttu-id="26d77-300">XAML 定義標記延伸，以程式設計的實體，可讓從字串屬性值或物件項目，一般 XAML 處理器處理逸出，並會延後至支援類別處理。</span><span class="sxs-lookup"><span data-stu-id="26d77-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="26d77-301">識別標記延伸是 XAML 處理器時，使用屬性語法是左大括號 （{}），後面接著右大括號 （}） 以外的任何字元的字元。</span><span class="sxs-lookup"><span data-stu-id="26d77-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="26d77-302">第一個字串後面的左大括號必須參考類別，提供特定的擴充功能的行為，參考可能會略過子字串"Extension"子字串是否為 true 的類別名稱的一部分。</span><span class="sxs-lookup"><span data-stu-id="26d77-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="26d77-303">因此，可能會出現一個空格，，然後每個後續字元做為輸入的延伸模組實作中，直到遇到右大括號。</span><span class="sxs-lookup"><span data-stu-id="26d77-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="26d77-304">.NET XAML 實作會使用<xref:System.Windows.Markup.MarkupExtension>抽象類別，做為所有支援之標記延伸模組的基礎[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]以及其他架構或技術。</span><span class="sxs-lookup"><span data-stu-id="26d77-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="26d77-305">標記延伸的[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]特別實作通常要提供一種方式來參照其他現有的物件，或為延後將會在執行階段評估的物件參考。</span><span class="sxs-lookup"><span data-stu-id="26d77-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="26d77-306">例如，簡單的 WPF 資料繫結透過指定`{Binding}`來取代，通常會採用特定的屬性值的標記延伸。</span><span class="sxs-lookup"><span data-stu-id="26d77-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="26d77-307">許多 WPF 標記延伸可讓其中屬性的語法不否則可能是屬性的屬性語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="26d77-308">例如，<xref:System.Windows.Style>物件是相當複雜類型，其中包含巢狀的一連串的物件和屬性。</span><span class="sxs-lookup"><span data-stu-id="26d77-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="26d77-309">為中的資源通常會定義 WPF 中的樣式<xref:System.Windows.ResourceDictionary>，然後透過要求資源的兩個 WPF 標記延伸的其中一個參考。</span><span class="sxs-lookup"><span data-stu-id="26d77-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="26d77-310">標記延伸會延後評估的資源查閱的屬性值，並可讓您提供的值<xref:System.Windows.FrameworkElement.Style%2A>屬性，取得型別<xref:System.Windows.Style>，請在屬性語法，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="26d77-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="26d77-311">在這裡，`StaticResource`識別<xref:System.Windows.StaticResourceExtension>提供標記延伸實作類別。</span><span class="sxs-lookup"><span data-stu-id="26d77-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="26d77-312">下一個字串`MyStyle`做為非預設的輸入<xref:System.Windows.StaticResourceExtension>建構函式，從擴充字串的參數會要求宣告<xref:System.Windows.ResourceKey>。</span><span class="sxs-lookup"><span data-stu-id="26d77-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="26d77-313">`MyStyle`必須是[X:key](../../../../docs/framework/xaml-services/x-key-directive.md)值<xref:System.Windows.Style>定義為資源。</span><span class="sxs-lookup"><span data-stu-id="26d77-313">`MyStyle` is expected to be the [x:Key](../../../../docs/framework/xaml-services/x-key-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="26d77-314">[StaticResource 標記延伸](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md)使用量要求資源用來提供<xref:System.Windows.Style>透過靜態資源查閱邏輯，在載入時間屬性值。</span><span class="sxs-lookup"><span data-stu-id="26d77-314">The [StaticResource Markup Extension](../../../../docs/framework/wpf/advanced/staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="26d77-315">如需標記延伸的詳細資訊，請參閱[標記延伸和 WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="26d77-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](../../../../docs/framework/wpf/advanced/markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="26d77-316">如需參考的標記延伸和其他 XAML 程式設計的一般的.NET XAML 實作中啟用的功能，請參閱[XAML 命名空間 （x:）語言功能](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md)。</span><span class="sxs-lookup"><span data-stu-id="26d77-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md).</span></span> <span data-ttu-id="26d77-317">WPF 專屬標記延伸，請參閱[WPF XAML 延伸](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="26d77-317">For WPF-specific markup extensions, see [WPF XAML Extensions](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>   
## <a name="attached-properties"></a><span data-ttu-id="26d77-318">附加屬性</span><span class="sxs-lookup"><span data-stu-id="26d77-318">Attached Properties</span></span>  
 <span data-ttu-id="26d77-319">附加的屬性是屬性可以讓擁有和特定的類型，所定義的 XAML 中引進的程式設計概念但設定為屬性或屬性項目上的任何項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="26d77-320">主要案例附加的屬性用來為啟用標記結構要報告其資訊的父項目中的子項目，而不需要廣泛共用的物件模型之間的所有項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="26d77-321">相反地，附加的屬性可由子元素的報表資訊的父項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="26d77-322">如需附加的屬性，以及如何建立您自己的目的附加屬性，請參閱 <<c0> [ 附加屬性概觀](../../../../docs/framework/wpf/advanced/attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="26d77-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](../../../../docs/framework/wpf/advanced/attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="26d77-323">附加的屬性會使用表面上類似於屬性的項目語法的語法，您也指定*typeName*。*propertyName*組合。</span><span class="sxs-lookup"><span data-stu-id="26d77-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="26d77-324">有兩個重大差異：</span><span class="sxs-lookup"><span data-stu-id="26d77-324">There are two important differences:</span></span>  
  
-   <span data-ttu-id="26d77-325">您可以使用*typeName*。*propertyName*即使設定透過屬性語法附加的屬性的組合。</span><span class="sxs-lookup"><span data-stu-id="26d77-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="26d77-326">附加的屬性會唯一情況的限定屬性名稱是屬性語法的需求。</span><span class="sxs-lookup"><span data-stu-id="26d77-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
-   <span data-ttu-id="26d77-327">您也可以使用屬性項目語法為附加屬性。</span><span class="sxs-lookup"><span data-stu-id="26d77-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="26d77-328">不過，對於典型的屬性項目語法， *typeName*您指定的物件項目，其中包含屬性的項目。</span><span class="sxs-lookup"><span data-stu-id="26d77-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="26d77-329">如果您參照到附加的屬性，則*typeName*是附加的屬性，而不包含的物件項目會定義的類別。</span><span class="sxs-lookup"><span data-stu-id="26d77-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>   
## <a name="attached-events"></a><span data-ttu-id="26d77-330">附加事件</span><span class="sxs-lookup"><span data-stu-id="26d77-330">Attached Events</span></span>  
 <span data-ttu-id="26d77-331">附加的事件的另一個 XAML 可以透過特定的類型，定義事件，但可能會處理常式附加的任何物件項目中引進的程式設計概念。</span><span class="sxs-lookup"><span data-stu-id="26d77-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="26d77-332">在 WOF 實作中，定義附加的事件的型別通常是靜態的型別定義服務，而且有時候這些附加的事件公開路由的事件的別名中公開服務的類型。</span><span class="sxs-lookup"><span data-stu-id="26d77-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="26d77-333">附加事件的處理常式會指定透過屬性的語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="26d77-334">因為附加的事件，以允許附加事件的擴充屬性語法*typeName*。*eventName*使用方式，其中*typeName*是提供的類別，`Add`和`Remove`附加的事件基礎結構的事件處理常式存取子和*eventName*事件名稱。</span><span class="sxs-lookup"><span data-stu-id="26d77-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>   
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="26d77-335">XAML 根項目結構</span><span class="sxs-lookup"><span data-stu-id="26d77-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="26d77-336">下表顯示一般 XAML 根項目細分，顯示的特定屬性的根項目：</span><span class="sxs-lookup"><span data-stu-id="26d77-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="26d77-337">開啟物件的根元素的項目</span><span class="sxs-lookup"><span data-stu-id="26d77-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="26d77-338">預設值 ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML 命名空間</span><span class="sxs-lookup"><span data-stu-id="26d77-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="26d77-339">在 XAML 語言 XAML 命名空間</span><span class="sxs-lookup"><span data-stu-id="26d77-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="26d77-340">標記連接到任何程式碼後置的部分類別宣告為部分類別定義</span><span class="sxs-lookup"><span data-stu-id="26d77-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="26d77-341">根物件項目結尾。</span><span class="sxs-lookup"><span data-stu-id="26d77-341">End of object element for the root.</span></span> <span data-ttu-id="26d77-342">物件尚未關閉因為項目包含子項目</span><span class="sxs-lookup"><span data-stu-id="26d77-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>   
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="26d77-343">選擇性的非建議的 Xaml</span><span class="sxs-lookup"><span data-stu-id="26d77-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="26d77-344">下列章節說明 XAML 用法技術上來說由 XAML 處理器支援，但會產生詳細等級或剩餘人類看得懂的時機的 XAML 檔案會干擾其他美觀問題您開發包含 XAML 來源的應用程式.</span><span class="sxs-lookup"><span data-stu-id="26d77-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when your develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="26d77-345">選擇性的屬性項目使用方式</span><span class="sxs-lookup"><span data-stu-id="26d77-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="26d77-346">選擇性的屬性項目使用方式包含明確寫出項目內容的屬性，XAML 處理器會將視為隱含。</span><span class="sxs-lookup"><span data-stu-id="26d77-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="26d77-347">例如，當您宣告的內容<xref:System.Windows.Controls.Menu>，您可以選擇明確宣告<xref:System.Windows.Controls.ItemsControl.Items%2A>集合<xref:System.Windows.Controls.Menu>為`<Menu.Items>`屬性項目標記，以及發生每個<xref:System.Windows.Controls.MenuItem>內`<Menu.Items>`，而不是比使用隱含 XAML 處理器的行為，所有子項目的<xref:System.Windows.Controls.Menu>必須<xref:System.Windows.Controls.MenuItem>並放置於<xref:System.Windows.Controls.ItemsControl.Items%2A>集合。</span><span class="sxs-lookup"><span data-stu-id="26d77-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="26d77-348">有時候以視覺化方式在標記中所示，釐清物件結構的選擇性的使用方式可以幫助。</span><span class="sxs-lookup"><span data-stu-id="26d77-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="26d77-349">或明確的屬性項目用法有時可以避免技術上正常運作，但以視覺化方式令人困惑，例如巢狀的標記延伸模組屬性值內的標記。</span><span class="sxs-lookup"><span data-stu-id="26d77-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="26d77-350">完整限定的 typeName.memberName 屬性</span><span class="sxs-lookup"><span data-stu-id="26d77-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="26d77-351">*TypeName*。*memberName*形成只路由的事件的大小寫比通用屬性實際運作的。</span><span class="sxs-lookup"><span data-stu-id="26d77-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="26d77-352">但在其他情況下，該表單是多餘，且您應該避免，如果僅基於標記樣式及可讀性。</span><span class="sxs-lookup"><span data-stu-id="26d77-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="26d77-353">在下列範例中，這三個每個參考<xref:System.Windows.Controls.Control.Background%2A>屬性是完全相同：</span><span class="sxs-lookup"><span data-stu-id="26d77-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="26d77-354">`Button.Background`可以運作，因為該屬性的限定的查閱<xref:System.Windows.Controls.Button>成功 (<xref:System.Windows.Controls.Control.Background%2A>繼承自控制項) 和<xref:System.Windows.Controls.Button>物件項目之類別或基底類別。</span><span class="sxs-lookup"><span data-stu-id="26d77-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="26d77-355">`Control.Background`因為<xref:System.Windows.Controls.Control>類別實際定義<xref:System.Windows.Controls.Control.Background%2A>和<xref:System.Windows.Controls.Control>是<xref:System.Windows.Controls.Button>基底類別。</span><span class="sxs-lookup"><span data-stu-id="26d77-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="26d77-356">不過，下列*typeName*。*memberName*表單範例中無法運作，而且會因此顯示加上註解：</span><span class="sxs-lookup"><span data-stu-id="26d77-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="26d77-357"><xref:System.Windows.Controls.Label>是另一個衍生的類別<xref:System.Windows.Controls.Control>，而且如果已指定`Label.Background`內<xref:System.Windows.Controls.Label>物件項目，會處理這種使用方式。</span><span class="sxs-lookup"><span data-stu-id="26d77-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="26d77-358">不過，因為<xref:System.Windows.Controls.Label>不是類別或基底類別<xref:System.Windows.Controls.Button>，在 XAML 處理器的行為是再處理`Label.Background`為附加屬性。</span><span class="sxs-lookup"><span data-stu-id="26d77-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="26d77-359">`Label.Background`不是可用的附加的屬性，而且這種用法會失敗。</span><span class="sxs-lookup"><span data-stu-id="26d77-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="26d77-360">baseTypeName.memberName 屬性項目</span><span class="sxs-lookup"><span data-stu-id="26d77-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="26d77-361">如何以類似方式*typeName*。*memberName*形式的運作方式的屬性語法*產生*。*memberName*語法適用於屬性項目語法。</span><span class="sxs-lookup"><span data-stu-id="26d77-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="26d77-362">例如，下列語法運作方式：</span><span class="sxs-lookup"><span data-stu-id="26d77-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](../../../../samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="26d77-363">屬性項目，指定做為`Control.Background`即使屬性項目所包含之`Button`。</span><span class="sxs-lookup"><span data-stu-id="26d77-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="26d77-364">但就像*typeName*。*memberName*表單的屬性，*產生*。*memberName*是不佳的樣式，在標記中，而且您應該避免這樣。</span><span class="sxs-lookup"><span data-stu-id="26d77-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="26d77-365">另請參閱</span><span class="sxs-lookup"><span data-stu-id="26d77-365">See Also</span></span>  
 [<span data-ttu-id="26d77-366">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="26d77-366">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="26d77-367">XAML 命名空間 (x:) 語言功能</span><span class="sxs-lookup"><span data-stu-id="26d77-367">XAML Namespace (x:) Language Features</span></span>](../../../../docs/framework/xaml-services/xaml-namespace-x-language-features.md)  
 [<span data-ttu-id="26d77-368">WPF XAML 延伸</span><span class="sxs-lookup"><span data-stu-id="26d77-368">WPF XAML Extensions</span></span>](../../../../docs/framework/wpf/advanced/wpf-xaml-extensions.md)  
 [<span data-ttu-id="26d77-369">相依性屬性概觀</span><span class="sxs-lookup"><span data-stu-id="26d77-369">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)  
 [<span data-ttu-id="26d77-370">TypeConverter 和 XAML</span><span class="sxs-lookup"><span data-stu-id="26d77-370">TypeConverters and XAML</span></span>](../../../../docs/framework/wpf/advanced/typeconverters-and-xaml.md)  
 [<span data-ttu-id="26d77-371">WPF 的 XAML 和自訂類別</span><span class="sxs-lookup"><span data-stu-id="26d77-371">XAML and Custom Classes for WPF</span></span>](../../../../docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)
