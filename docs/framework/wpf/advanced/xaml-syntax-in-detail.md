---
title: XAML 語法詳細資料
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: ecea2575503ad8fe4ff8a190a417bae75a7b31f7
ms.sourcegitcommit: 0c48191d6d641ce88d7510e319cf38c0e35697d0
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/05/2019
ms.locfileid: "57367956"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="56610-102">XAML 語法詳細資料</span><span class="sxs-lookup"><span data-stu-id="56610-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="56610-103">本主題定義詞彙，用來說明 XAML 語法的項目。</span><span class="sxs-lookup"><span data-stu-id="56610-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="56610-104">這些詞彙常用的本文件中，WPF 文件的其餘具體來說，並使用 XAML 或啟用 System.Xaml 層級的 XAML 語言支援的基本 XAML 概念的架構。</span><span class="sxs-lookup"><span data-stu-id="56610-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="56610-105">本主題會詳述主題所介紹的基本術語[XAML 概觀 (WPF)](xaml-overview-wpf.md)。</span><span class="sxs-lookup"><span data-stu-id="56610-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](xaml-overview-wpf.md).</span></span>  
  

  
<a name="the_xaml_language_specification"></a>   
## <a name="the-xaml-language-specification"></a><span data-ttu-id="56610-106">XAML 語言規格</span><span class="sxs-lookup"><span data-stu-id="56610-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="56610-107">此處定義的 XAML 語法術語也是定義，或在 XAML 語言規格參考。</span><span class="sxs-lookup"><span data-stu-id="56610-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="56610-108">XAML 是以 XML 為基礎的語言和後續動作，或進一步延伸了 XML 的結構化規則。</span><span class="sxs-lookup"><span data-stu-id="56610-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="56610-109">一些術語所共用，或為基礎時描述 XML 語言或 XML 文件物件模型的常用術語。</span><span class="sxs-lookup"><span data-stu-id="56610-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="56610-110">如需 XAML 語言規格的詳細資訊，請下載[ \[MS XAML\] ](https://go.microsoft.com/fwlink/?LinkId=114525)從 Microsoft 下載中心取得。</span><span class="sxs-lookup"><span data-stu-id="56610-110">For more information about the XAML language specification, download [\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>   
## <a name="xaml-and-clr"></a><span data-ttu-id="56610-111">XAML 和 CLR</span><span class="sxs-lookup"><span data-stu-id="56610-111">XAML and CLR</span></span>  
 <span data-ttu-id="56610-112">XAML 是一種標記語言。</span><span class="sxs-lookup"><span data-stu-id="56610-112">XAML is a markup language.</span></span> <span data-ttu-id="56610-113">[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]、 依其名稱，可讓執行階段執行為隱含。</span><span class="sxs-lookup"><span data-stu-id="56610-113">The [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)], as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="56610-114">XAML 不是單獨使用其中一個通用的語言是直接由 CLR 執行階段。</span><span class="sxs-lookup"><span data-stu-id="56610-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="56610-115">相反地，您可以將 XAML 做為支援它自己的型別系統。</span><span class="sxs-lookup"><span data-stu-id="56610-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="56610-116">特定的 XAML 剖析系統，可由 WPF 的基礎 CLR 和 CLR 型別系統。</span><span class="sxs-lookup"><span data-stu-id="56610-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="56610-117">XAML 類型會對應至 CLR 型別，wpf XAML 剖析時，具現化的執行的階段表示法。</span><span class="sxs-lookup"><span data-stu-id="56610-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="56610-118">基於這個理由，即使在 XAML 語言規格中的對等語法討論不的語法，在這份文件中討論的其餘部分時，會包含 CLR 型別系統中，參考。</span><span class="sxs-lookup"><span data-stu-id="56610-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="56610-119">（每個 XAML 語言規格層級中，XAML 型別無法對應到任何其他型別系統，這不一定要在 CLR 中，但這將需要建立和使用不同的 XAML 剖析器。）</span><span class="sxs-lookup"><span data-stu-id="56610-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="56610-120">類型和類別繼承的成員</span><span class="sxs-lookup"><span data-stu-id="56610-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="56610-121">屬性和事件，因為它們會顯示為 XAML 成員[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]類型通常繼承自基底型別。</span><span class="sxs-lookup"><span data-stu-id="56610-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="56610-122">例如，請考慮這個範例： `<Button Background="Blue" .../>`。</span><span class="sxs-lookup"><span data-stu-id="56610-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="56610-123"><xref:System.Windows.Controls.Control.Background%2A>屬性不是立即宣告的屬性上<xref:System.Windows.Controls.Button>類別，如果您要查看的類別定義、 反映結果或文件。</span><span class="sxs-lookup"><span data-stu-id="56610-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="56610-124">相反地，<xref:System.Windows.Controls.Control.Background%2A>繼承自基底<xref:System.Windows.Controls.Control>類別。</span><span class="sxs-lookup"><span data-stu-id="56610-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="56610-125">類別繼承行為的[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]XAML 項目是大的不同，從 XML 標記的結構描述強制執行解譯。</span><span class="sxs-lookup"><span data-stu-id="56610-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="56610-126">類別繼承會變得複雜，特別是當中繼的基底類別是抽象類別，或涉及介面時。</span><span class="sxs-lookup"><span data-stu-id="56610-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="56610-127">這是其中一個原因的 XAML 項目和其所允許的屬性集很難代表正確且完整地使用結構描述型別通常用於[!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)]程式設計，例如 DTD 或 XSD 格式。</span><span class="sxs-lookup"><span data-stu-id="56610-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for [!INCLUDE[TLA2#tla_xml](../../../../includes/tla2sharptla-xml-md.md)] programming, such as DTD or XSD format.</span></span> <span data-ttu-id="56610-128">另一個原因是該擴充性和類型對應的 XAML 語言功能本身會排除的任何固定的表示法，允許的類型和成員的完整性。</span><span class="sxs-lookup"><span data-stu-id="56610-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>   
## <a name="object-element-syntax"></a><span data-ttu-id="56610-129">物件元素語法</span><span class="sxs-lookup"><span data-stu-id="56610-129">Object Element Syntax</span></span>  
 <span data-ttu-id="56610-130">*物件元素語法*是具現化 CLR 類別或結構宣告的 XML 元素的 XAML 標記語法。</span><span class="sxs-lookup"><span data-stu-id="56610-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="56610-131">此語法類似於其他標記語言，例如 HTML 項目語法。</span><span class="sxs-lookup"><span data-stu-id="56610-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="56610-132">物件元素語法的開頭是左角括號 (\<)，後面的類別或結構所產生的型別名稱。</span><span class="sxs-lookup"><span data-stu-id="56610-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="56610-133">零個以上的空間可以依照類型名稱，以及零個或多個屬性也可以宣告物件項目上有一或多個空格分隔每個屬性名稱 = 「 值 」 配對。</span><span class="sxs-lookup"><span data-stu-id="56610-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="56610-134">最後，下列其中一項必須為真：</span><span class="sxs-lookup"><span data-stu-id="56610-134">Finally, one of the following must be true:</span></span>  
  
-   <span data-ttu-id="56610-135">以正斜線 （/） 後面緊接跟著右角括弧 (>)，必須先關閉的項目和標籤。</span><span class="sxs-lookup"><span data-stu-id="56610-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
-   <span data-ttu-id="56610-136">項目的開頭標記必須完成的右角括號 (>)。</span><span class="sxs-lookup"><span data-stu-id="56610-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="56610-137">其他物件項目、 屬性項目或內部文字，可以依照項目的開頭標記。</span><span class="sxs-lookup"><span data-stu-id="56610-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="56610-138">確切內容可能包含此處通常受到物件模型的項目。</span><span class="sxs-lookup"><span data-stu-id="56610-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="56610-139">對等項目結尾標記的物件項目也必須存在，在適當的巢狀結構，並且及其他的開頭和結尾標記組之間取得平衡。</span><span class="sxs-lookup"><span data-stu-id="56610-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="56610-140">XAML 由.NET 實作有一組規則，將物件項目對應至型別、 屬性或事件，和 CLR 命名空間加上組件的 XAML 命名空間的屬性。</span><span class="sxs-lookup"><span data-stu-id="56610-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="56610-141">如需 WPF 和.NET Framework，XAML 物件項目對應至[!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)]中所定義的類型參考的組件，和屬性會對應至這些類型的成員。</span><span class="sxs-lookup"><span data-stu-id="56610-141">For WPF and the .NET Framework, XAML object elements map to [!INCLUDE[TLA#tla_net](../../../../includes/tlasharptla-net-md.md)] types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="56610-142">當您參考的 CLR 型別，在 XAML 中時，您會有該型別繼承成員的存取權。</span><span class="sxs-lookup"><span data-stu-id="56610-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="56610-143">比方說，下列範例會具現化的新執行個體的物件元素語法<xref:System.Windows.Controls.Button>類別，而且也會指定<xref:System.Windows.FrameworkElement.Name%2A>屬性以及該屬性的值：</span><span class="sxs-lookup"><span data-stu-id="56610-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="56610-144">下列範例是物件元素語法，其中也包含 XAML 內容屬性語法。</span><span class="sxs-lookup"><span data-stu-id="56610-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="56610-145">內含的內部文字會用以設定<xref:System.Windows.Controls.TextBox>XAML 內容屬性， <xref:System.Windows.Controls.TextBox.Text%2A>。</span><span class="sxs-lookup"><span data-stu-id="56610-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="56610-146">內容模型</span><span class="sxs-lookup"><span data-stu-id="56610-146">Content Models</span></span>  
 <span data-ttu-id="56610-147">類別可能會為 XAML 物件元素語法，以支援使用方式，但是該項目將只有正常運作中應用程式或頁面時它會放置在整體內容的模型或項目樹狀結構的預期位置。</span><span class="sxs-lookup"><span data-stu-id="56610-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="56610-148">例如，<xref:System.Windows.Controls.MenuItem>應該通常只會做為子系<xref:System.Windows.Controls.Primitives.MenuBase>衍生類別，例如<xref:System.Windows.Controls.Menu>。</span><span class="sxs-lookup"><span data-stu-id="56610-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="56610-149">內容模型的特定項目會記載為部分控制項和其他的類別頁面上的 < 備註 >[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]類別，可用作 XAML 項目。</span><span class="sxs-lookup"><span data-stu-id="56610-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>   
## <a name="properties-of-object-elements"></a><span data-ttu-id="56610-150">物件元素的屬性</span><span class="sxs-lookup"><span data-stu-id="56610-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="56610-151">在 XAML 中的屬性會設定各種不同的可能語法。</span><span class="sxs-lookup"><span data-stu-id="56610-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="56610-152">哪種語法可用於特定的屬性而異，根據您要設定屬性的基礎類型系統特性。</span><span class="sxs-lookup"><span data-stu-id="56610-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="56610-153">藉由設定屬性的值，您加入功能或特性物件存在於執行的階段物件圖形中。</span><span class="sxs-lookup"><span data-stu-id="56610-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="56610-154">從物件項目所建立物件的初始狀態為基礎的預設建構函式行為。</span><span class="sxs-lookup"><span data-stu-id="56610-154">The initial state of the created object from a object element is based on the default constructor behavior.</span></span> <span data-ttu-id="56610-155">一般而言，您的應用程式會使用完全預設執行任何的個體指定物件以外的項目。</span><span class="sxs-lookup"><span data-stu-id="56610-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>   
## <a name="attribute-syntax-properties"></a><span data-ttu-id="56610-156">屬性 (Attribute) 語法 (屬性(Property))</span><span class="sxs-lookup"><span data-stu-id="56610-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="56610-157">屬性語法是藉由在現有的物件項目上宣告屬性設定屬性值的 XAML 標記語法。</span><span class="sxs-lookup"><span data-stu-id="56610-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="56610-158">屬性名稱必須符合 CLR 成員名稱的備份相關的物件項目類別的屬性。</span><span class="sxs-lookup"><span data-stu-id="56610-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="56610-159">指派運算子 （=） 後面的屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="56610-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="56610-160">屬性值必須以引號括住的字串。</span><span class="sxs-lookup"><span data-stu-id="56610-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="56610-161">您可以使用替代的引號將常值引號內的屬性。</span><span class="sxs-lookup"><span data-stu-id="56610-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="56610-162">比方說您可以使用單引號做為宣告包含在其中的雙引號字元的字串。</span><span class="sxs-lookup"><span data-stu-id="56610-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="56610-163">不論您使用單引號或雙引號時，您應該使用相符的配對，來開啟和關閉的屬性值的字串。</span><span class="sxs-lookup"><span data-stu-id="56610-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="56610-164">也有逸出序列或其他技術可用於解決任何特定的 XAML 語法所加諸的字元限制。</span><span class="sxs-lookup"><span data-stu-id="56610-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="56610-165">請參閱[XML 字元實體和 XAML](../../xaml-services/xml-character-entities-and-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="56610-165">See [XML Character Entities and XAML](../../xaml-services/xml-character-entities-and-xaml.md).</span></span>  
  
 <span data-ttu-id="56610-166">若要設定透過屬性語法，屬性必須是公用的因此必須要能寫入。</span><span class="sxs-lookup"><span data-stu-id="56610-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="56610-167">在支援型別系統中屬性的值必須是實值類型，或必須可具現化或存取相關時，XAML 處理器所參考的參考型別支援型別。</span><span class="sxs-lookup"><span data-stu-id="56610-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="56610-168">WPF XAML 事件物件，參考為屬性名稱必須是公用的並具有公用委派。</span><span class="sxs-lookup"><span data-stu-id="56610-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="56610-169">屬性或事件必須是類別或結構所包含的物件項目具現化的成員。</span><span class="sxs-lookup"><span data-stu-id="56610-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="56610-170">屬性值的處理</span><span class="sxs-lookup"><span data-stu-id="56610-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="56610-171">由 XAML 處理器處理內含的開頭和結尾引號的字串值。</span><span class="sxs-lookup"><span data-stu-id="56610-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="56610-172">屬性，預設的處理行為是由基礎的 CLR 屬性的型別決定。</span><span class="sxs-lookup"><span data-stu-id="56610-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="56610-173">下列步驟，其中一個會填入的屬性值使用此處理順序：</span><span class="sxs-lookup"><span data-stu-id="56610-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1.  <span data-ttu-id="56610-174">如果 XAML 處理器遇到大括號或物件項目衍生自<xref:System.Windows.Markup.MarkupExtension>、 然後參考的標記延伸模組會先評估而不是處理字串形式的值和標記延伸模組所傳回的物件做為值。</span><span class="sxs-lookup"><span data-stu-id="56610-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="56610-175">在許多情況下的標記延伸模組所傳回的物件會參考現有的物件或評估延後到執行階段，並不是新具現化的物件的運算式。</span><span class="sxs-lookup"><span data-stu-id="56610-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2.  <span data-ttu-id="56610-176">如果未宣告的屬性與屬性化<xref:System.ComponentModel.TypeConverter>，或實值型別，該屬性的宣告與屬性化<xref:System.ComponentModel.TypeConverter>、 屬性的字串值提交給型別轉換子，為轉換的輸入，並轉換子會傳回新的物件執行個體。</span><span class="sxs-lookup"><span data-stu-id="56610-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3.  <span data-ttu-id="56610-177">如果沒有任何<xref:System.ComponentModel.TypeConverter>，嘗試直接轉換成屬性型別。</span><span class="sxs-lookup"><span data-stu-id="56610-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="56610-178">此最後一個層級是在 XAML 語言基本類型或在列舉型別 （剖析器再存取相符的值） 中的具名常數的名稱檢查之間的剖析器原生值直接轉換。</span><span class="sxs-lookup"><span data-stu-id="56610-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="56610-179">列舉型別屬性值</span><span class="sxs-lookup"><span data-stu-id="56610-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="56610-180">列舉型別在 XAML 中的處理的本質 XAML 剖析器，以及藉由指定的其中一個列舉的具名常數的字串名稱應指定列舉的成員。</span><span class="sxs-lookup"><span data-stu-id="56610-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="56610-181">（attribute） 的列舉值，原生的行為是處理屬性值的字串，並解析為其中一個列舉值。</span><span class="sxs-lookup"><span data-stu-id="56610-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="56610-182">您未指定格式的列舉型別*列舉型別*。*值*，就像您在程式碼中一樣。</span><span class="sxs-lookup"><span data-stu-id="56610-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="56610-183">相反地，只指定*值*，並*列舉*由您要設定屬性的型別推斷。</span><span class="sxs-lookup"><span data-stu-id="56610-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="56610-184">如果您指定的屬性*列舉型別*。*值*表單，它將不會解析正確。</span><span class="sxs-lookup"><span data-stu-id="56610-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="56610-185">旗標型列舉，行為會根據<xref:System.Enum.Parse%2A?displayProperty=nameWithType>方法。</span><span class="sxs-lookup"><span data-stu-id="56610-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="56610-186">您可以指定多個旗標型列舉的值，以逗號分隔每個值。</span><span class="sxs-lookup"><span data-stu-id="56610-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="56610-187">不過，您無法合併不旗標式的列舉值。</span><span class="sxs-lookup"><span data-stu-id="56610-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="56610-188">比方說，您無法使用逗點語法，以嘗試建立<xref:System.Windows.Trigger>，處理程式碼 （attribute） 列舉型別的多個條件：</span><span class="sxs-lookup"><span data-stu-id="56610-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="56610-189">支援可在 XAML 中可設定屬性的旗標型列舉很少在 WPF 中的。</span><span class="sxs-lookup"><span data-stu-id="56610-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="56610-190">不過，一個這類列舉型別是<xref:System.Windows.Media.StyleSimulations>。</span><span class="sxs-lookup"><span data-stu-id="56610-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="56610-191">您比方說，可以使用逗號分隔的旗標型屬性語法來修改提供的範例中的 < 備註 ><xref:System.Windows.Documents.Glyphs>類別;`StyleSimulations = "BoldSimulation"`可能會變得`StyleSimulations = "BoldSimulation,ItalicSimulation"`。</span><span class="sxs-lookup"><span data-stu-id="56610-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="56610-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> 是另一個屬性可以在其中指定一個以上的列舉值。</span><span class="sxs-lookup"><span data-stu-id="56610-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="56610-193">不過，這個屬性是特殊的情況下，因為<xref:System.Windows.Input.ModifierKeys>列舉可支援它自己的型別轉換子。</span><span class="sxs-lookup"><span data-stu-id="56610-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="56610-194">修飾詞的類型轉換器會使用加號 （+），做為分隔符號，而不是逗號 （，）。</span><span class="sxs-lookup"><span data-stu-id="56610-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="56610-195">這項轉換支援更傳統的語法，來代表在 Microsoft Windows 程式設計中，例如"Ctrl + Alt"的索引鍵組合。</span><span class="sxs-lookup"><span data-stu-id="56610-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="56610-196">屬性和事件成員名稱參考</span><span class="sxs-lookup"><span data-stu-id="56610-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="56610-197">在指定的屬性時，您可以參考任何屬性或以您在包含的物件項目的具現化的 CLR 型別成員的形式存在的事件。</span><span class="sxs-lookup"><span data-stu-id="56610-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="56610-198">或者，您可以參考附加的屬性，或附加事件，獨立於包含的物件項目。</span><span class="sxs-lookup"><span data-stu-id="56610-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="56610-199">（附加的屬性會在後續章節中討論）。</span><span class="sxs-lookup"><span data-stu-id="56610-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="56610-200">您也可以將名稱從使用預設命名空間可存取的任何物件的任何事件*typeName*。*事件*部分限定的名稱; 此附加路由事件的處理常式的支援，處理常式的目的是要處理從子元素，但父項目路由事件也沒有該事件成員資料表中的語法。</span><span class="sxs-lookup"><span data-stu-id="56610-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="56610-201">此語法類似於附加的事件語法，但這裡的事件就不會，則為 true 的附加的事件。</span><span class="sxs-lookup"><span data-stu-id="56610-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="56610-202">相反地，您會參考具有限定名稱的事件。</span><span class="sxs-lookup"><span data-stu-id="56610-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="56610-203">如需詳細資訊，請參閱 <<c0> [ 路由事件概觀](routed-events-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="56610-203">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="56610-204">某些情況下，有時會提供屬性名稱做為屬性 (attribute)，而不是屬性名稱的值。</span><span class="sxs-lookup"><span data-stu-id="56610-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="56610-205">該屬性名稱也可以包含辨識符號，例如在表單中指定的屬性*ownerType*。*dependencyPropertyName*。</span><span class="sxs-lookup"><span data-stu-id="56610-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="56610-206">在 XAML 中撰寫樣式或範本時，常會使用此案例。</span><span class="sxs-lookup"><span data-stu-id="56610-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="56610-207">提供做為屬性值的屬性名稱的處理規則不同，而且受到所設定之屬性的類型或特定 WPF 子系統的行為。</span><span class="sxs-lookup"><span data-stu-id="56610-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="56610-208">如需詳細資訊，請參閱 <<c0> [ 設定樣式和範本](../controls/styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="56610-208">For details, see [Styling and Templating](../controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="56610-209">屬性名稱的另一個使用方式時，屬性值描述屬性]-[屬性關聯性。</span><span class="sxs-lookup"><span data-stu-id="56610-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="56610-210">這項功能用於資料繫結，以及分鏡腳本目標，而且會啟用<xref:System.Windows.PropertyPath>類別和其型別轉換子。</span><span class="sxs-lookup"><span data-stu-id="56610-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="56610-211">查閱語意的更完整說明，請參閱[PropertyPath XAML 語法](propertypath-xaml-syntax.md)。</span><span class="sxs-lookup"><span data-stu-id="56610-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>   
## <a name="property-element-syntax"></a><span data-ttu-id="56610-212">屬性元素語法</span><span class="sxs-lookup"><span data-stu-id="56610-212">Property Element Syntax</span></span>  
 <span data-ttu-id="56610-213">*屬性元素語法*稍有基本的 XML 語法規則的項目分出來，這樣的語法。</span><span class="sxs-lookup"><span data-stu-id="56610-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="56610-214">在 XML 中，屬性的值是實際的字串，唯一可能的變化正在使用哪一種字串的編碼格式。</span><span class="sxs-lookup"><span data-stu-id="56610-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="56610-215">在 XAML 中，您可以指派其他物件項目是屬性的值。</span><span class="sxs-lookup"><span data-stu-id="56610-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="56610-216">這項功能會啟用屬性元素語法。</span><span class="sxs-lookup"><span data-stu-id="56610-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="56610-217">而不是指定為元素標記中之屬性的屬性，指定的屬性是使用 開啟項目在標記*elementTypeName*。*propertyName*表單內，指定屬性的值，然後關閉屬性項目。</span><span class="sxs-lookup"><span data-stu-id="56610-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="56610-218">具體來說，語法開頭是左角括號 (\<)，後面的類別或結構內包含屬性項目語法的型別名稱。</span><span class="sxs-lookup"><span data-stu-id="56610-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="56610-219">這後面緊接跟著單一點 （.），然後依名稱的屬性，然後由右角括弧 (>)。</span><span class="sxs-lookup"><span data-stu-id="56610-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="56610-220">如同屬性語法，該屬性必須存在於指定的型別宣告的公用成員。</span><span class="sxs-lookup"><span data-stu-id="56610-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="56610-221">要指派給屬性的值會包含在屬性項目。</span><span class="sxs-lookup"><span data-stu-id="56610-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="56610-222">一般而言，指定為一個或多個 object 元素的值，指定做為值的物件是此案例因為該屬性元素語法是位址。</span><span class="sxs-lookup"><span data-stu-id="56610-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="56610-223">最後，指定相同的對等的結尾標記*elementTypeName*。*propertyName*組合中必須提供，適當的巢狀結構和與其他項目標記的平衡。</span><span class="sxs-lookup"><span data-stu-id="56610-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="56610-224">例如，以下是屬性的項目語法<xref:System.Windows.FrameworkElement.ContextMenu%2A>屬性<xref:System.Windows.Controls.Button>。</span><span class="sxs-lookup"><span data-stu-id="56610-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="56610-225">Property 項目內的值也指定為內部的文字，萬一其中所指定的屬性型別是基本值類型，例如<xref:System.String>，或列舉型別在指定的名稱。</span><span class="sxs-lookup"><span data-stu-id="56610-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="56610-226">這些兩種用法是有點不常見，因為每個案例也可以使用更簡單的屬性語法。</span><span class="sxs-lookup"><span data-stu-id="56610-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="56610-227">填入屬性項目使用字串的其中一個案例是針對不是 XAML 內容屬性，但是仍然用於 UI 文字表示法的屬性，才會出現在該 UI 文字所需的特定的泛空白字元項目，例如換行字元。</span><span class="sxs-lookup"><span data-stu-id="56610-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="56610-228">屬性語法無法保留換行符號，但屬性元素語法可以只要顯著泛空白字元的保留是作用中 (如需詳細資訊，請參閱 <<c0> [ 處理在 XAML 中的泛空白字元](../../xaml-services/whitespace-processing-in-xaml.md))。</span><span class="sxs-lookup"><span data-stu-id="56610-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../xaml-services/whitespace-processing-in-xaml.md)).</span></span> <span data-ttu-id="56610-229">另一個案例是讓[X:uid 指示詞](../../xaml-services/x-uid-directive.md)可以套用至 property 項目，並應該當地語系化 WPF 中的值輸出 BAML 或其他技術，因此將標記內的值。</span><span class="sxs-lookup"><span data-stu-id="56610-229">Another scenario is so that [x:Uid Directive](../../xaml-services/x-uid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="56610-230">WPF 的邏輯樹狀結構中未表示的屬性項目。</span><span class="sxs-lookup"><span data-stu-id="56610-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="56610-231">Property 項目是只設定屬性，一個特定語法，而且不具有執行個體或物件支援它的項目。</span><span class="sxs-lookup"><span data-stu-id="56610-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="56610-232">(如需邏輯樹狀結構概念的詳細資訊，請參閱[WPF 中的樹狀結構](trees-in-wpf.md)。)</span><span class="sxs-lookup"><span data-stu-id="56610-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="56610-233">對於受到屬性和屬性的項目語法的屬性，兩種語法通常會有相同的結果，即使微妙之處，例如泛空白字元處理可以語法之間稍有不同。</span><span class="sxs-lookup"><span data-stu-id="56610-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>   
## <a name="collection-syntax"></a><span data-ttu-id="56610-234">集合語法</span><span class="sxs-lookup"><span data-stu-id="56610-234">Collection Syntax</span></span>  
 <span data-ttu-id="56610-235">XAML 規格要求 XAML 處理器實作識別其中的實值型別是集合的屬性。</span><span class="sxs-lookup"><span data-stu-id="56610-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="56610-236">在.NET 中的一般 XAML 處理器實作根據 managed 程式碼與 CLR，用來識別集合型別，透過下列其中一項：</span><span class="sxs-lookup"><span data-stu-id="56610-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
-   <span data-ttu-id="56610-237">型別會實作<xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="56610-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
-   <span data-ttu-id="56610-238">型別會實作<xref:System.Collections.IDictionary>。</span><span class="sxs-lookup"><span data-stu-id="56610-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
-   <span data-ttu-id="56610-239">型別衍生自<xref:System.Array>(如需 XAML 中陣列的詳細資訊，請參閱[X:array 標記延伸](../../xaml-services/x-array-markup-extension.md)。)</span><span class="sxs-lookup"><span data-stu-id="56610-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../xaml-services/x-array-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="56610-240">如果屬性的型別是集合，然後推斷的集合型別不必做為物件元素標記中指定。</span><span class="sxs-lookup"><span data-stu-id="56610-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="56610-241">相反地，要成為的項目集合中的項目會指定為一或多個屬性項目的子項目。</span><span class="sxs-lookup"><span data-stu-id="56610-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="56610-242">每個這類項目評估的物件，在載入期間，以及藉由呼叫加入至集合`Add`隱含集合的方法。</span><span class="sxs-lookup"><span data-stu-id="56610-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="56610-243">例如，<xref:System.Windows.Style.Triggers%2A>屬性<xref:System.Windows.Style>採用特製化的集合型別<xref:System.Windows.TriggerCollection>，它會實作<xref:System.Collections.IList>。</span><span class="sxs-lookup"><span data-stu-id="56610-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="56610-244">您不需要具現化<xref:System.Windows.TriggerCollection>在標記中的物件項目。</span><span class="sxs-lookup"><span data-stu-id="56610-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="56610-245">相反地，您指定一或多個<xref:System.Windows.Trigger>做為項目內的項目`Style.Triggers`property 項目，其中<xref:System.Windows.Trigger>（或衍生的類別） 為的型別做為項目類型的強型別和隱含<xref:System.Windows.TriggerCollection>。</span><span class="sxs-lookup"><span data-stu-id="56610-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="56610-246">屬性可能是集合型別和該類型的 XAML 內容屬性，衍生型別，本主題的下一節已討論過。</span><span class="sxs-lookup"><span data-stu-id="56610-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="56610-247">隱含的集合項目邏輯樹狀結構表示法中建立的成員，即使它不會出現在為元素標記。</span><span class="sxs-lookup"><span data-stu-id="56610-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="56610-248">父類型的建構函式通常是其屬性，其中的集合執行具現化，一開始是空的集合會成為物件樹狀結構的一部分。</span><span class="sxs-lookup"><span data-stu-id="56610-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="56610-249">List 與 dictionary 的泛型介面 (<xref:System.Collections.Generic.IList%601>和<xref:System.Collections.Generic.IDictionary%602>) 的集合偵測不支援。</span><span class="sxs-lookup"><span data-stu-id="56610-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="56610-250">不過，您可以使用<xref:System.Collections.Generic.List%601>類別做為基底類別，因為它會實作<xref:System.Collections.IList>直接，或是<xref:System.Collections.Generic.Dictionary%602>做為基底類別，因為它會實作<xref:System.Collections.IDictionary>直接。</span><span class="sxs-lookup"><span data-stu-id="56610-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="56610-251">在集合型別的.NET 參考頁面中，此語法，刻意省略的集合物件項目與偶爾中註明 XAML 語法 」 一節做為隱含的集合語法。</span><span class="sxs-lookup"><span data-stu-id="56610-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="56610-252">除了根項目，做為另一個項目的子項目巢狀的 XAML 檔案中的每個物件項目其實是一或兩個下列案例中的項目： 其父項目的隱含集合屬性的成員或指定的父項目 (可透過 XAML 內容屬性將在後續章節中討論) 的 XAML 內容屬性值的項目。</span><span class="sxs-lookup"><span data-stu-id="56610-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="56610-253">換句話說，其實根目錄中，單一物件的父項目和子項目，在 [標記] 頁面中的關聯性。 和根目錄下的每個物件項目會提供其父代的屬性值的單一執行個體，或是其中一個資料行中的項目lection，同時也是父系的集合型別屬性值。</span><span class="sxs-lookup"><span data-stu-id="56610-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="56610-254">這個單一根目錄概念中常見的 XML，並經常會進行的 Api，例如載入 XAML 的行為<xref:System.Windows.Markup.XamlReader.Load%2A>。</span><span class="sxs-lookup"><span data-stu-id="56610-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="56610-255">下列範例是使用集合的物件項目語法 (<xref:System.Windows.Media.GradientStopCollection>) 明確地指定。</span><span class="sxs-lookup"><span data-stu-id="56610-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="56610-256">請注意，它不一定能夠明確宣告集合。</span><span class="sxs-lookup"><span data-stu-id="56610-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="56610-257">比方說，嘗試宣告<xref:System.Windows.TriggerCollection>明確地在先前所示<xref:System.Windows.Style.Triggers%2A>範例將會失敗。</span><span class="sxs-lookup"><span data-stu-id="56610-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="56610-258">明確宣告集合需要集合類別必須支援的預設建構函式，和<xref:System.Windows.TriggerCollection>沒有預設建構函式。</span><span class="sxs-lookup"><span data-stu-id="56610-258">Explicitly declaring the collection requires that the collection class must support a default constructor, and <xref:System.Windows.TriggerCollection> does not have a default constructor.</span></span>  
  
<a name="xaml_content_properties"></a>   
## <a name="xaml-content-properties"></a><span data-ttu-id="56610-259">XAML 內容屬性</span><span class="sxs-lookup"><span data-stu-id="56610-259">XAML Content Properties</span></span>  
 <span data-ttu-id="56610-260">XAML 內容的語法是在指定的類別才會啟用語法<xref:System.Windows.Markup.ContentPropertyAttribute>其類別宣告的一部分。</span><span class="sxs-lookup"><span data-stu-id="56610-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="56610-261"><xref:System.Windows.Markup.ContentPropertyAttribute>參考該類型的項目 （包括衍生的類別） 的內容屬性的屬性名稱。</span><span class="sxs-lookup"><span data-stu-id="56610-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="56610-262">由 XAML 處理器處理時，任何子項目或找到的開頭和結尾標記的物件項目之間的內部文字會指派給該物件的 XAML 內容屬性的值。</span><span class="sxs-lookup"><span data-stu-id="56610-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="56610-263">您可以指定明確的屬性項目之內容的屬性，但這種用法通常不會顯示在 XAML 語法 」 一節中的.NET 參考。</span><span class="sxs-lookup"><span data-stu-id="56610-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="56610-264">明確/詳細的資訊技術有偶爾標記為了清楚起見，或視為標記樣式的值，但通常 content 屬性的目的是要簡化標記，以便為父子式直覺的方式相關的項目可以直接巢狀。</span><span class="sxs-lookup"><span data-stu-id="56610-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="56610-265">未指派項目上的其他屬性的屬性項目標記為 「 內容 」，每個嚴格的 XAML 語言定義;他們先前處理中 XAML 剖析器的處理順序，不被視為 「 內容 」。</span><span class="sxs-lookup"><span data-stu-id="56610-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="56610-266">必須是連續的 XAML 內容屬性值</span><span class="sxs-lookup"><span data-stu-id="56610-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="56610-267">XAML 內容屬性的值必須完全之前或任何其他的屬性項目之後指定該物件元素上。</span><span class="sxs-lookup"><span data-stu-id="56610-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="56610-268">是否將 XAML 內容屬性的值指定為字串，或做為一或多個物件，也是如此。</span><span class="sxs-lookup"><span data-stu-id="56610-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="56610-269">例如，下列標記不會剖析：</span><span class="sxs-lookup"><span data-stu-id="56610-269">For example, the following markup does not parse:</span></span>  
  
```  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="56610-270">基本上，這是不合法因為如果此語法明確使用之內容屬性的屬性元素語法，然後內容屬性會設定兩次：</span><span class="sxs-lookup"><span data-stu-id="56610-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="56610-271">如果內容屬性是集合，而且項目子系會穿插屬性項目，就會是類似的不合法的範例：</span><span class="sxs-lookup"><span data-stu-id="56610-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>   
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="56610-272">內容屬性和集合語法合併</span><span class="sxs-lookup"><span data-stu-id="56610-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="56610-273">多個單一物件項目，做為內容，以接受內容屬性的型別必須特別會是集合型別。</span><span class="sxs-lookup"><span data-stu-id="56610-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="56610-274">類似於屬性集合類型的項目語法，XAML 處理器必須識別集合型別的型別。</span><span class="sxs-lookup"><span data-stu-id="56610-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="56610-275">如果項目都具有 XAML 內容屬性，而 XAML 內容屬性的型別是集合，然後隱含的集合型別不需要指定做為物件元素標記中並不需要指定為屬性 el XAML 內容屬性ement。</span><span class="sxs-lookup"><span data-stu-id="56610-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="56610-276">因此顯而易見的內容模型，在標記中現在可以有一個以上的子元素，指派為內容。</span><span class="sxs-lookup"><span data-stu-id="56610-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="56610-277">以下是內容語法<xref:System.Windows.Controls.Panel>衍生的類別。</span><span class="sxs-lookup"><span data-stu-id="56610-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="56610-278">所有<xref:System.Windows.Controls.Panel>衍生的類別建立 XAML 內容屬性，才能<xref:System.Windows.Controls.Panel.Children%2A>，其需要的值為類型<xref:System.Windows.Controls.UIElementCollection>。</span><span class="sxs-lookup"><span data-stu-id="56610-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="56610-279">請注意，沒有的屬性項目<xref:System.Windows.Controls.Panel.Children%2A>的項目也不<xref:System.Windows.Controls.UIElementCollection>需要在標記中。</span><span class="sxs-lookup"><span data-stu-id="56610-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="56610-280">這是 XAML 設計功能，以便以遞迴方式包含定義的項目[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]會更直覺的方式表示為具有直屬父系-子系項目關聯性，而不需要介入的屬性項目標記的巢狀項目樹狀結構或集合物件。</span><span class="sxs-lookup"><span data-stu-id="56610-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="56610-281">事實上，<xref:System.Windows.Controls.UIElementCollection>不能指定明確標記為物件項目，所設計。</span><span class="sxs-lookup"><span data-stu-id="56610-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="56610-282">因為其唯一用途是隱含的集合，即<xref:System.Windows.Controls.UIElementCollection>不會公開公用預設建構函式，因此無法具現化為物件項目。</span><span class="sxs-lookup"><span data-stu-id="56610-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public default constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="56610-283">混合內容項目和具有內容屬性之物件的物件項目</span><span class="sxs-lookup"><span data-stu-id="56610-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="56610-284">XAML 規格宣告 XAML 處理器可以強制執行的用來填滿 XAML 內容屬性的物件項目內的物件項目必須是連續的，和不能混合。</span><span class="sxs-lookup"><span data-stu-id="56610-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="56610-285">針對混合屬性項目和內容的這項限制會強制執行[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]XAML 處理器。</span><span class="sxs-lookup"><span data-stu-id="56610-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="56610-286">您可以有子物件項目做為物件項目中第一個立即的標記。</span><span class="sxs-lookup"><span data-stu-id="56610-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="56610-287">然後您可以採用屬性元素。</span><span class="sxs-lookup"><span data-stu-id="56610-287">Then you can introduce property elements.</span></span> <span data-ttu-id="56610-288">或者，您可以指定一或多個屬性項目的內容，然後更多的屬性項目。</span><span class="sxs-lookup"><span data-stu-id="56610-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="56610-289">但是，一旦屬性項目後面的內容，您不能引入任何進一步的內容，您只能新增屬性項目。</span><span class="sxs-lookup"><span data-stu-id="56610-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="56610-290">此內容 / 屬性項目順序需求不適用於做為內容的內部文字。</span><span class="sxs-lookup"><span data-stu-id="56610-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="56610-291">不過，它仍然是因為顯著泛空白字元會難以在標記中以視覺化方式偵測，如果屬性項目會穿插內部文字保留內部文字是連續的很好的標記樣式。</span><span class="sxs-lookup"><span data-stu-id="56610-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>   
## <a name="xaml-namespaces"></a><span data-ttu-id="56610-292">XAML 命名空間</span><span class="sxs-lookup"><span data-stu-id="56610-292">XAML Namespaces</span></span>  
 <span data-ttu-id="56610-293">沒有任何上述語法範例會指定預設 XAML 命名空間以外的 XAML 命名空間。</span><span class="sxs-lookup"><span data-stu-id="56610-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="56610-294">在典型[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]應用程式，預設 XAML 命名空間指定為[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]命名空間。</span><span class="sxs-lookup"><span data-stu-id="56610-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="56610-295">您可以指定非預設 XAML 命名空間的 XAML 命名空間，並仍使用類似的語法。</span><span class="sxs-lookup"><span data-stu-id="56610-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="56610-296">但是，然後，任何一處類別名為無法存取預設 XAML 命名空間內的類別名稱前面必須加的 XAML 命名空間前置詞對應至對應的 CLR 命名空間。</span><span class="sxs-lookup"><span data-stu-id="56610-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="56610-297">例如，`<custom:Example/>`具現化的執行個體的物件元素語法`Example`類別，其中包含該類別 （和可能的外部組件資訊，其中包含支援型別） 的 CLR 命名空間先前已對應至`custom`前置詞。</span><span class="sxs-lookup"><span data-stu-id="56610-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="56610-298">如需有關 XAML 命名空間的詳細資訊，請參閱 < [XAML 命名空間和命名空間對應 WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="56610-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a><span data-ttu-id="56610-299">標記延伸</span><span class="sxs-lookup"><span data-stu-id="56610-299">Markup Extensions</span></span>  
 <span data-ttu-id="56610-300">XAML 定義的程式設計實體，可讓一般的 XAML 處理器處理的字串屬性值或物件項目，從逸出，並會延後至支援類別處理的標記延伸模組。</span><span class="sxs-lookup"><span data-stu-id="56610-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="56610-301">識別 XAML 處理器的標記延伸模組時使用屬性語法是左大括號 （{}），後面接著右大括號 （}） 以外的任何字元的字元。</span><span class="sxs-lookup"><span data-stu-id="56610-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="56610-302">下列的左大括弧的第一個字串必須參考類別，提供特定的擴充功能的行為，參考可能會略過子字串"Extension"，如果子字串是真正的類別名稱的一部分。</span><span class="sxs-lookup"><span data-stu-id="56610-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="56610-303">因此，可能會出現一個空格，，然後每個後續字元做為輸入延伸模組實作中，直到遇到右大括號。</span><span class="sxs-lookup"><span data-stu-id="56610-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="56610-304">.NET XAML 實作會使用<xref:System.Windows.Markup.MarkupExtension>抽象類別，做為所有支援之標記延伸模組的基礎[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]以及其他架構或技術。</span><span class="sxs-lookup"><span data-stu-id="56610-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="56610-305">標記延伸，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]特別實作通常要提供方法，以參考其他現有的物件，或是要延後將會在執行階段評估的物件參考。</span><span class="sxs-lookup"><span data-stu-id="56610-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="56610-306">例如，簡單的 WPF 資料繫結藉由指定達成`{Binding}`標記延伸來取代特定的屬性通常會接受的值。</span><span class="sxs-lookup"><span data-stu-id="56610-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="56610-307">許多 WPF 標記延伸模組啟用屬性語法，其中屬性語法所不可能的屬性。</span><span class="sxs-lookup"><span data-stu-id="56610-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="56610-308">比方說，<xref:System.Windows.Style>物件是相當複雜的型別，其中包含巢狀的一連串的物件和屬性。</span><span class="sxs-lookup"><span data-stu-id="56610-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="56610-309">在 WPF 中的樣式通常會定義為在資源<xref:System.Windows.ResourceDictionary>，然後透過其中一種要求資源的兩個 WPF 標記延伸參考。</span><span class="sxs-lookup"><span data-stu-id="56610-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="56610-310">標記延伸會延後評估的資源查閱的屬性值，並可讓您提供的值<xref:System.Windows.FrameworkElement.Style%2A>屬性，採用類型<xref:System.Windows.Style>，請在屬性語法，如下列範例所示：</span><span class="sxs-lookup"><span data-stu-id="56610-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="56610-311">在這裡，`StaticResource`識別<xref:System.Windows.StaticResourceExtension>提供標記延伸實作的類別。</span><span class="sxs-lookup"><span data-stu-id="56610-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="56610-312">下一個字串`MyStyle`做為輸入做為非預設值<xref:System.Windows.StaticResourceExtension>建構函式，因為從延伸模組的字串參數會要求宣告<xref:System.Windows.ResourceKey>。</span><span class="sxs-lookup"><span data-stu-id="56610-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="56610-313">`MyStyle` 預期要[X:key](../../xaml-services/x-key-directive.md)的值<xref:System.Windows.Style>定義為資源。</span><span class="sxs-lookup"><span data-stu-id="56610-313">`MyStyle` is expected to be the [x:Key](../../xaml-services/x-key-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="56610-314">[StaticResource 標記延伸](staticresource-markup-extension.md)使用量要求資源用來提供<xref:System.Windows.Style>透過靜態資源查閱邏輯，在載入時的屬性值。</span><span class="sxs-lookup"><span data-stu-id="56610-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="56610-315">如需標記延伸的詳細資訊，請參閱[標記延伸和 WPF XAML](markup-extensions-and-wpf-xaml.md)。</span><span class="sxs-lookup"><span data-stu-id="56610-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="56610-316">如需參考的標記延伸和其他 XAML 程式設計在一般的.NET XAML 實作中啟用的功能，請參閱[XAML 命名空間 （x:）語言功能](../../xaml-services/xaml-namespace-x-language-features.md)。</span><span class="sxs-lookup"><span data-stu-id="56610-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../xaml-services/xaml-namespace-x-language-features.md).</span></span> <span data-ttu-id="56610-317">WPF 特定標記延伸模組，請參閱[WPF XAML 擴充功能](wpf-xaml-extensions.md)。</span><span class="sxs-lookup"><span data-stu-id="56610-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>   
## <a name="attached-properties"></a><span data-ttu-id="56610-318">附加屬性</span><span class="sxs-lookup"><span data-stu-id="56610-318">Attached Properties</span></span>  
 <span data-ttu-id="56610-319">附加的屬性是一種程式設計概念，藉此屬性可擁有，並定義是以特定類型的 XAML 中導入而設定為屬性或屬性項目上的任何項目。</span><span class="sxs-lookup"><span data-stu-id="56610-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="56610-320">主要案例附加的屬性是針對已啟用標記結構要報告其資訊的父項目中的子元素，而不需要廣泛共用的物件模型，所有項目。</span><span class="sxs-lookup"><span data-stu-id="56610-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="56610-321">相反地，項目子系的報表資訊的父項目可以使用附加的屬性。</span><span class="sxs-lookup"><span data-stu-id="56610-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="56610-322">如需附加的屬性，以及如何建立您自己的目的附加屬性，請參閱 <<c0> [ 附加屬性概觀](attached-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="56610-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="56610-323">附加的屬性使用的語法上類似屬性元素語法，，，您也指定*typeName*。*propertyName*組合。</span><span class="sxs-lookup"><span data-stu-id="56610-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="56610-324">有兩個重大差異：</span><span class="sxs-lookup"><span data-stu-id="56610-324">There are two important differences:</span></span>  
  
-   <span data-ttu-id="56610-325">您可以使用*typeName*。*propertyName*即使設定透過屬性語法的附加的屬性的組合。</span><span class="sxs-lookup"><span data-stu-id="56610-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="56610-326">附加的屬性是唯一的案例，其中限定屬性名稱是屬性語法的需求。</span><span class="sxs-lookup"><span data-stu-id="56610-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
-   <span data-ttu-id="56610-327">您也可以使用附加屬性的屬性元素語法。</span><span class="sxs-lookup"><span data-stu-id="56610-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="56610-328">不過，一般的屬性項目語法，對於*typeName*您指定的物件項目，其中包含屬性項目。</span><span class="sxs-lookup"><span data-stu-id="56610-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="56610-329">如果您指附加屬性，則*typeName*是定義類別，該附加的屬性，而不包含的物件項目。</span><span class="sxs-lookup"><span data-stu-id="56610-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>   
## <a name="attached-events"></a><span data-ttu-id="56610-330">附加事件</span><span class="sxs-lookup"><span data-stu-id="56610-330">Attached Events</span></span>  
 <span data-ttu-id="56610-331">附加的事件是在特定的類型，可以定義事件，但可能在任何物件項目上附加處理常式的 XAML 中引進的另一個程式設計概念。</span><span class="sxs-lookup"><span data-stu-id="56610-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="56610-332">在 WOF 實作中，可定義附加的事件的類型通常是靜態型別定義的服務，並有時候這些附加的事件公開公開服務的型別中路由的事件的別名。</span><span class="sxs-lookup"><span data-stu-id="56610-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="56610-333">附加事件處理常式會透過屬性語法來指定。</span><span class="sxs-lookup"><span data-stu-id="56610-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="56610-334">因為附加事件，透過屬性語法擴充附加事件，以允許*typeName*。*eventName*使用量，其中*typeName*是類別，提供`Add`並`Remove`附加的事件基礎結構的事件處理常式存取子和*eventName*是事件名稱。</span><span class="sxs-lookup"><span data-stu-id="56610-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>   
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="56610-335">XAML 根元素的結構</span><span class="sxs-lookup"><span data-stu-id="56610-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="56610-336">下表顯示典型 XAML 根項目細分，顯示的特定屬性的根項目：</span><span class="sxs-lookup"><span data-stu-id="56610-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="56610-337">開啟物件元素的根項目</span><span class="sxs-lookup"><span data-stu-id="56610-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="56610-338">預設值 ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML 命名空間</span><span class="sxs-lookup"><span data-stu-id="56610-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="56610-339">XAML 語言 XAML 命名空間</span><span class="sxs-lookup"><span data-stu-id="56610-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="56610-340">標記連接到任何程式碼後置的部分類別宣告為部分類別定義</span><span class="sxs-lookup"><span data-stu-id="56610-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="56610-341">根的物件項目的結尾。</span><span class="sxs-lookup"><span data-stu-id="56610-341">End of object element for the root.</span></span> <span data-ttu-id="56610-342">因為項目包含子項目沒有尚未關閉物件</span><span class="sxs-lookup"><span data-stu-id="56610-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>   
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="56610-343">選擇性的而且非建議的 XAML 用法</span><span class="sxs-lookup"><span data-stu-id="56610-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="56610-344">下列各節說明 XAML 用法就技術上而言由 XAML 處理器支援，但會產生詳細資訊或其他美觀的問題可能會影響當您開發包含 XAML 來源應用程式時，剩餘人類看得懂的 XAML 檔案。</span><span class="sxs-lookup"><span data-stu-id="56610-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="56610-345">選擇性的屬性項目使用方式</span><span class="sxs-lookup"><span data-stu-id="56610-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="56610-346">選擇性的屬性項目使用方式包括明確地寫出項目內容的屬性，XAML 處理器會將視為隱含。</span><span class="sxs-lookup"><span data-stu-id="56610-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="56610-347">例如，當您宣告的內容<xref:System.Windows.Controls.Menu>，您可以選擇明確宣告<xref:System.Windows.Controls.ItemsControl.Items%2A>的集合<xref:System.Windows.Controls.Menu>作為`<Menu.Items>`屬性項目標記，以及發生每個<xref:System.Windows.Controls.MenuItem>內`<Menu.Items>`，而不是比使用隱含的 XAML 處理器行為的所有子項目的<xref:System.Windows.Controls.Menu>必須是<xref:System.Windows.Controls.MenuItem>放在<xref:System.Windows.Controls.ItemsControl.Items%2A>集合。</span><span class="sxs-lookup"><span data-stu-id="56610-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="56610-348">有時候以視覺化方式在標記中所示，釐清物件結構的選擇性的使用方式可以幫助。</span><span class="sxs-lookup"><span data-stu-id="56610-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="56610-349">或者，有時明確的屬性項目使用方式可以避免技術上正常運作，但在視覺上令人困惑，例如屬性值內的巢狀的標記延伸的標記。</span><span class="sxs-lookup"><span data-stu-id="56610-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="56610-350">完整限定的 typeName.memberName 屬性</span><span class="sxs-lookup"><span data-stu-id="56610-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="56610-351">*TypeName*。*memberName*形成屬性實際上運作更普遍比只是路由的事件的案例。</span><span class="sxs-lookup"><span data-stu-id="56610-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="56610-352">但是在其他情況下，該表單是多餘，而且您應該避免，如果只基於的標記樣式和可讀性。</span><span class="sxs-lookup"><span data-stu-id="56610-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="56610-353">在下列範例中，每三個參考<xref:System.Windows.Controls.Control.Background%2A>屬性完全相等：</span><span class="sxs-lookup"><span data-stu-id="56610-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="56610-354">`Button.Background` 能夠運作是因為該屬性的限定的查閱<xref:System.Windows.Controls.Button>成功 (<xref:System.Windows.Controls.Control.Background%2A>繼承自控制項) 和<xref:System.Windows.Controls.Button>物件元素的類別或基底類別。</span><span class="sxs-lookup"><span data-stu-id="56610-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="56610-355">`Control.Background` 有效的原因<xref:System.Windows.Controls.Control>類別實際上會定義<xref:System.Windows.Controls.Control.Background%2A>並<xref:System.Windows.Controls.Control>是<xref:System.Windows.Controls.Button>基底類別。</span><span class="sxs-lookup"><span data-stu-id="56610-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="56610-356">不過，下列*typeName*。*memberName*表單範例無法運作，並因此顯示加上註解：</span><span class="sxs-lookup"><span data-stu-id="56610-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="56610-357"><xref:System.Windows.Controls.Label> 另一個衍生類別<xref:System.Windows.Controls.Control>，如果有指定的話`Label.Background`內<xref:System.Windows.Controls.Label>物件項目，會處理這種使用方式。</span><span class="sxs-lookup"><span data-stu-id="56610-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="56610-358">不過，因為<xref:System.Windows.Controls.Label>不是類別或基底類別<xref:System.Windows.Controls.Button>，然後處理為指定的 XAML 處理器行為`Label.Background`為附加屬性。</span><span class="sxs-lookup"><span data-stu-id="56610-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="56610-359">`Label.Background` 不是可用的附加的屬性，且這種用法就會失敗。</span><span class="sxs-lookup"><span data-stu-id="56610-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="56610-360">baseTypeName.memberName 屬性項目</span><span class="sxs-lookup"><span data-stu-id="56610-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="56610-361">如何以類似方式*typeName*。*memberName*形式的運作方式的屬性語法*基*。*memberName*語法適用於屬性元素語法。</span><span class="sxs-lookup"><span data-stu-id="56610-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="56610-362">比方說，適用於下列語法：</span><span class="sxs-lookup"><span data-stu-id="56610-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="56610-363">Property 項目，指定的`Control.Background`即使屬性項目所包含之`Button`。</span><span class="sxs-lookup"><span data-stu-id="56610-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="56610-364">但就像*typeName*。*memberName*的屬性，格式*基*。*memberName*是不佳的樣式，在標記中，而且您應該避免它。</span><span class="sxs-lookup"><span data-stu-id="56610-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="56610-365">另請參閱</span><span class="sxs-lookup"><span data-stu-id="56610-365">See also</span></span>
- [<span data-ttu-id="56610-366">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="56610-366">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="56610-367">XAML 命名空間 （x:）語言功能</span><span class="sxs-lookup"><span data-stu-id="56610-367">XAML Namespace (x:) Language Features</span></span>](../../xaml-services/xaml-namespace-x-language-features.md)
- [<span data-ttu-id="56610-368">WPF XAML 延伸</span><span class="sxs-lookup"><span data-stu-id="56610-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="56610-369">相依性屬性概觀</span><span class="sxs-lookup"><span data-stu-id="56610-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="56610-370">TypeConverter 和 XAML</span><span class="sxs-lookup"><span data-stu-id="56610-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="56610-371">WPF 的 XAML 和自訂類別</span><span class="sxs-lookup"><span data-stu-id="56610-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
