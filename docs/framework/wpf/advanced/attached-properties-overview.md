---
title: "附加屬性概觀"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-wpf
ms.tgt_pltfrm: 
ms.topic: article
dev_langs:
- csharp
- vb
helpviewer_keywords: attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
caps.latest.revision: "28"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 2d1d0eb55e75cd450d55b69aadca9c60e157eb09
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/22/2017
---
# <a name="attached-properties-overview"></a><span data-ttu-id="534b4-102">附加屬性概觀</span><span class="sxs-lookup"><span data-stu-id="534b4-102">Attached Properties Overview</span></span>
<span data-ttu-id="534b4-103">附加屬性是透過 XAML 所定義的概觀。</span><span class="sxs-lookup"><span data-stu-id="534b4-103">An attached property is a concept defined by XAML.</span></span> <span data-ttu-id="534b4-104">附加屬性是要用作可在任何物件上設定的全域屬性類型。</span><span class="sxs-lookup"><span data-stu-id="534b4-104">An attached property is intended to be used as a type of global property that is settable on any object.</span></span> <span data-ttu-id="534b4-105">在 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中，附加屬性一般會定義為沒有傳統屬性「包裝函式」的特殊形式相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-105">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</span></span>  
  
   
<a name="prerequisites"></a>   
## <a name="prerequisites"></a><span data-ttu-id="534b4-106">必要條件</span><span class="sxs-lookup"><span data-stu-id="534b4-106">Prerequisites</span></span>  
 <span data-ttu-id="534b4-107">本主題假設您已從 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 類別的現有相依性屬性消費者角度了解相依性屬性，並已閱讀[相依性屬性概觀](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="534b4-107">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).</span></span> <span data-ttu-id="534b4-108">若要遵循本主題中的範例，您也應該了解 XAML 並知道如何撰寫 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 應用程式。</span><span class="sxs-lookup"><span data-stu-id="534b4-108">To follow the examples in this topic, you should also understand XAML and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>  
  
<a name="attached_properties_usage"></a>   
## <a name="why-use-attached-properties"></a><span data-ttu-id="534b4-109">為何使用附加屬性</span><span class="sxs-lookup"><span data-stu-id="534b4-109">Why Use Attached Properties</span></span>  
 <span data-ttu-id="534b4-110">附加屬性的其中一個用途是允許不同的子項目指定父項目中實際定義的屬性的唯一值。</span><span class="sxs-lookup"><span data-stu-id="534b4-110">One purpose of an attached property is to allow different child elements to specify unique values for a property that is actually defined in a parent element.</span></span> <span data-ttu-id="534b4-111">此情節的特定應用程式可讓子項目通知父項目，有關如何在 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] 中呈現它們。</span><span class="sxs-lookup"><span data-stu-id="534b4-111">A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="534b4-112">其中一個範例是<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-112">One example is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="534b4-113"><xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>因為其設計目的是要在設定內所包含的項目，將會建立為附加屬性的屬性<xref:System.Windows.Controls.DockPanel>，而非在<xref:System.Windows.Controls.DockPanel>本身。</span><span class="sxs-lookup"><span data-stu-id="534b4-113">The <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property is created as an attached property because it is designed to be set on elements that are contained within a <xref:System.Windows.Controls.DockPanel>, rather than on <xref:System.Windows.Controls.DockPanel> itself.</span></span> <span data-ttu-id="534b4-114"><xref:System.Windows.Controls.DockPanel>類別會定義靜態<xref:System.Windows.DependencyProperty>名為欄位<xref:System.Windows.Controls.DockPanel.DockProperty>，然後提供<xref:System.Windows.Controls.DockPanel.GetDock%2A>和<xref:System.Windows.Controls.DockPanel.SetDock%2A>附加屬性的公用存取子方法。</span><span class="sxs-lookup"><span data-stu-id="534b4-114">The <xref:System.Windows.Controls.DockPanel> class defines the static <xref:System.Windows.DependencyProperty> field named <xref:System.Windows.Controls.DockPanel.DockProperty>, and then provides the <xref:System.Windows.Controls.DockPanel.GetDock%2A> and <xref:System.Windows.Controls.DockPanel.SetDock%2A> methods as public accessors for the attached property.</span></span>  
  
<a name="attached_properties_xaml"></a>   
## <a name="attached-properties-in-xaml"></a><span data-ttu-id="534b4-115">XAML 中的附加屬性</span><span class="sxs-lookup"><span data-stu-id="534b4-115">Attached Properties in XAML</span></span>  
 <span data-ttu-id="534b4-116">在 XAML 中，您可以使用 *AttachedPropertyProvider*.<屬性名稱> 語法來設定附加屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-116">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName*</span></span>  
  
 <span data-ttu-id="534b4-117">以下是您可以設定的範例<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>在 XAML 中：</span><span class="sxs-lookup"><span data-stu-id="534b4-117">The following is an example of how you can set <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> in XAML:</span></span>  
  
 [!code-xaml[PropertiesOvwSupport#APBasicUsage](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]  
  
 <span data-ttu-id="534b4-118">請注意，使用類似的靜態屬性;您一律參考型別<xref:System.Windows.Controls.DockPanel>所擁有，且註冊附加的屬性，而不是參考到依名稱指定任何執行個體。</span><span class="sxs-lookup"><span data-stu-id="534b4-118">Note that the usage is somewhat similar to a static property; you always reference the type <xref:System.Windows.Controls.DockPanel> that owns and registers the attached property, rather than referring to any instance specified by name.</span></span>  
  
 <span data-ttu-id="534b4-119">此外，因為 XAML 中的附加屬性是您在標記中設定的屬性，所以只有設定作業才會有任何相關性。</span><span class="sxs-lookup"><span data-stu-id="534b4-119">Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</span></span> <span data-ttu-id="534b4-120">雖然有一些間接機制可比較值 (例如樣式中的觸發程序)，但是您無法在 XAML 中直接取得屬性 (如需詳細資訊，請參閱[設定樣式和範本](../../../../docs/framework/wpf/controls/styling-and-templating.md))。</span><span class="sxs-lookup"><span data-stu-id="534b4-120">You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md)).</span></span>  
  
### <a name="attached-property-implementation-in-wpf"></a><span data-ttu-id="534b4-121">WPF 中的附加屬性實作</span><span class="sxs-lookup"><span data-stu-id="534b4-121">Attached Property Implementation in WPF</span></span>  
 <span data-ttu-id="534b4-122">在 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中，存在於 UI 呈現相關 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 類型的大部分附加屬性都會實作為相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-122">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], most of the attached properties that exist on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] types that are related to UI presentation are implemented as dependency properties.</span></span> <span data-ttu-id="534b4-123">附加屬性是 XAML 概念，而相依性屬性是 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 概念。</span><span class="sxs-lookup"><span data-stu-id="534b4-123">Attached properties are a XAML concept, whereas dependency properties are a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] concept.</span></span> <span data-ttu-id="534b4-124">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 附加屬性是相依性屬性，因此支援屬性中繼資料這類相依性屬性概念，以及從該屬性中繼資料中的預設值。</span><span class="sxs-lookup"><span data-stu-id="534b4-124">Because [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</span></span>  
  
<a name="howused"></a>   
## <a name="how-attached-properties-are-used-by-the-owning-type"></a><span data-ttu-id="534b4-125">擁有者類型如何使用附加屬性</span><span class="sxs-lookup"><span data-stu-id="534b4-125">How Attached Properties Are Used by the Owning Type</span></span>  
 <span data-ttu-id="534b4-126">雖然可在任何物件上設定附加屬性，但是這不自動表示設定屬性就會產生明確結果，或者另一個物件將使用值。</span><span class="sxs-lookup"><span data-stu-id="534b4-126">Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</span></span> <span data-ttu-id="534b4-127">一般而言，會使用附加屬性，讓來自各種可能類別階層或邏輯關聯性的物件都可以報告可定義附加屬性之類型的通用資訊。</span><span class="sxs-lookup"><span data-stu-id="534b4-127">Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</span></span> <span data-ttu-id="534b4-128">可定義附加屬性的類型通常會遵循下列其中一個模型︰</span><span class="sxs-lookup"><span data-stu-id="534b4-128">The type that defines the attached property typically follows one of these models:</span></span>  
  
-   <span data-ttu-id="534b4-129">設計可定義附加屬性的類型，因此它可以是設定附加屬性值之項目的父項目。</span><span class="sxs-lookup"><span data-stu-id="534b4-129">The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</span></span> <span data-ttu-id="534b4-130">類型接著會透過內部邏輯針對某個物件樹狀結構逐一查看其子物件，並取得值，然後以某種方式處理這些值。</span><span class="sxs-lookup"><span data-stu-id="534b4-130">The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</span></span>  
  
-   <span data-ttu-id="534b4-131">可定義附加屬性的類型將會用作各種可能父項目和內容模組的子項目。</span><span class="sxs-lookup"><span data-stu-id="534b4-131">The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</span></span>  
  
-   <span data-ttu-id="534b4-132">可定義附加屬性的類型代表服務。</span><span class="sxs-lookup"><span data-stu-id="534b4-132">The type that defines the attached property represents a service.</span></span> <span data-ttu-id="534b4-133">其他類型設定附加屬性的值。</span><span class="sxs-lookup"><span data-stu-id="534b4-133">Other types set values for the attached property.</span></span> <span data-ttu-id="534b4-134">然後，在服務內容中評估可設定屬性的項目時，會透過服務類別的內部邏輯取得附加屬性值。</span><span class="sxs-lookup"><span data-stu-id="534b4-134">Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</span></span>  
  
### <a name="an-example-of-a-parent-defined-attached-property"></a><span data-ttu-id="534b4-135">父代已定義的附加屬性範例</span><span class="sxs-lookup"><span data-stu-id="534b4-135">An Example of a Parent-Defined Attached Property</span></span>  
 <span data-ttu-id="534b4-136">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 定義附加屬性的最常見情節是父項目支援子項目集合，同時實作會個別報告每個子項目之行為細節的行為。</span><span class="sxs-lookup"><span data-stu-id="534b4-136">The most typical scenario where [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</span></span>  
  
 <span data-ttu-id="534b4-137"><xref:System.Windows.Controls.DockPanel>定義<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>附加屬性，以及<xref:System.Windows.Controls.DockPanel>具有類別層級程式碼做為其呈現邏輯的一部分 (具體而言，<xref:System.Windows.Controls.DockPanel.MeasureOverride%2A>和<xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>)。</span><span class="sxs-lookup"><span data-stu-id="534b4-137"><xref:System.Windows.Controls.DockPanel> defines the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property, and <xref:System.Windows.Controls.DockPanel> has class-level code as part of its rendering logic (specifically, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> and <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span></span> <span data-ttu-id="534b4-138">A<xref:System.Windows.Controls.DockPanel>執行個體一律會檢查以查看是否任一其直屬子系項目已設定的值<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="534b4-138">A <xref:System.Windows.Controls.DockPanel> instance will always check to see whether any of its immediate child elements have set a value for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="534b4-139">如果是這樣，這些值會變成套用至該特定子項目之轉譯邏輯的輸入。</span><span class="sxs-lookup"><span data-stu-id="534b4-139">If so, those values become input for the rendering logic applied to that particular child element.</span></span> <span data-ttu-id="534b4-140">巢狀<xref:System.Windows.Controls.DockPanel>每一個執行個體都將視為自己的當前子系項目集合，但該行為是依實作方式<xref:System.Windows.Controls.DockPanel>處理程序<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>值。</span><span class="sxs-lookup"><span data-stu-id="534b4-140">Nested <xref:System.Windows.Controls.DockPanel> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <xref:System.Windows.Controls.DockPanel> processes <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="534b4-141">理論上，可能會有附加屬性影響直屬父代以外的項目。</span><span class="sxs-lookup"><span data-stu-id="534b4-141">It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</span></span> <span data-ttu-id="534b4-142">如果<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>之中未包含任何項目上設定附加的屬性<xref:System.Windows.Controls.DockPanel>採取它、 任何錯誤或例外狀況的父項目，就會引發。</span><span class="sxs-lookup"><span data-stu-id="534b4-142">If the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property is set on an element that has no <xref:System.Windows.Controls.DockPanel> parent element to act upon it, no error or exception is raised.</span></span> <span data-ttu-id="534b4-143">這只是表示已設定全域屬性值，但它有沒有目前<xref:System.Windows.Controls.DockPanel>無法使用該資訊的父代。</span><span class="sxs-lookup"><span data-stu-id="534b4-143">This simply means that a global property value was set, but it has no current <xref:System.Windows.Controls.DockPanel> parent that could consume the information.</span></span>  
  
<a name="attached_properties_code"></a>   
## <a name="attached-properties-in-code"></a><span data-ttu-id="534b4-144">程式碼中的附加屬性</span><span class="sxs-lookup"><span data-stu-id="534b4-144">Attached Properties in Code</span></span>  
 <span data-ttu-id="534b4-145">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的附加屬性沒有一般 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]「包裝函式」方法可輕鬆進行 get/set 存取。</span><span class="sxs-lookup"><span data-stu-id="534b4-145">Attached properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] do not have the typical [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "wrapper" methods for easy get/set access.</span></span> <span data-ttu-id="534b4-146">這是因為附加屬性不一定屬於已設定屬性之執行個體的 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 命名空間。</span><span class="sxs-lookup"><span data-stu-id="534b4-146">This is because the attached property is not necessarily part of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] namespace for instances where the property is set.</span></span> <span data-ttu-id="534b4-147">不過，XAML 處理器必須可以在剖析 XAML 時設定這些值。</span><span class="sxs-lookup"><span data-stu-id="534b4-147">However, a XAML processor must be able to set those values when XAML is parsed.</span></span> <span data-ttu-id="534b4-148">若要支援有效的附加屬性使用方式，附加屬性的擁有者類型必須在表單 <屬性名稱>`Get` 和 <屬性名稱>`Set` 中實作專用存取子方法。</span><span class="sxs-lookup"><span data-stu-id="534b4-148">To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form `Get`*PropertyName* and `Set`*PropertyName*.</span></span> <span data-ttu-id="534b4-149">這些專用存取子方法也適用於取得或設定程式碼中的附加屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-149">These dedicated accessor methods are also useful to get or set the attached property in code.</span></span> <span data-ttu-id="534b4-150">從程式碼觀點，附加屬性類似具有方法存取子而非屬性存取子的支援欄位，而且該支援欄位可以存在於任何物件，而不需要特別進行定義。</span><span class="sxs-lookup"><span data-stu-id="534b4-150">From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</span></span>  
  
 <span data-ttu-id="534b4-151">下列範例示範如何在程式碼中設定附加屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-151">The following example shows how you can set an attached property in code.</span></span> <span data-ttu-id="534b4-152">在此範例中，`myCheckBox`的執行個體<xref:System.Windows.Controls.CheckBox>類別。</span><span class="sxs-lookup"><span data-stu-id="534b4-152">In this example, `myCheckBox` is an instance of the <xref:System.Windows.Controls.CheckBox> class.</span></span>  
  
 [!code-csharp[PropertiesOvwSupport#APCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
 [!code-vb[PropertiesOvwSupport#APCode](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]  
  
 <span data-ttu-id="534b4-153">XAML 類似情況下，如果`myCheckBox`不已經加入為的子元素`myDockPanel`由程式碼的第三行，第四個一行程式碼不會引發例外狀況，但屬性值都不會互動<xref:System.Windows.Controls.DockPanel>父代，因此會執行任何動作。</span><span class="sxs-lookup"><span data-stu-id="534b4-153">Similar to the XAML case, if `myCheckBox` had not already been added as a child element of `myDockPanel` by the third line of code, the fourth line of code would not raise an exception, but the property value would not interact with a <xref:System.Windows.Controls.DockPanel> parent and thus would do nothing.</span></span> <span data-ttu-id="534b4-154">只有<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>值的設定結合的子項目<xref:System.Windows.Controls.DockPanel>父項目會使得轉譯的應用程式中的有效的行為。</span><span class="sxs-lookup"><span data-stu-id="534b4-154">Only a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> value set on a child element combined with the presence of a <xref:System.Windows.Controls.DockPanel> parent element will cause an effective behavior in the rendered application.</span></span> <span data-ttu-id="534b4-155">(在此情況下，您可以設定附加屬性，然後將其附加至樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="534b4-155">(In this case, you could set the attached property, then attach to the tree.</span></span> <span data-ttu-id="534b4-156">或者，您可以將其附加至樹狀結構，然後設定附加屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-156">Or you could attach to the tree then set the attached property.</span></span> <span data-ttu-id="534b4-157">任一個動作順序都會提供相同的結果)。</span><span class="sxs-lookup"><span data-stu-id="534b4-157">Either action order provides the same result.)</span></span>  
  
<a name="attached_properties_metadata"></a>   
## <a name="attached-property-metadata"></a><span data-ttu-id="534b4-158">附加屬性中繼資料</span><span class="sxs-lookup"><span data-stu-id="534b4-158">Attached Property Metadata</span></span>  
 <span data-ttu-id="534b4-159">註冊屬性時<xref:System.Windows.FrameworkPropertyMetadata>設為指定的屬性，例如的屬性是否會影響轉譯、 度量，以及其他特性。</span><span class="sxs-lookup"><span data-stu-id="534b4-159">When registering the property, <xref:System.Windows.FrameworkPropertyMetadata> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</span></span> <span data-ttu-id="534b4-160">附加屬性的中繼資料一般與相依性屬性並無不同。</span><span class="sxs-lookup"><span data-stu-id="534b4-160">Metadata for an attached property is generally no different than on a dependency property.</span></span> <span data-ttu-id="534b4-161">如果您在附加屬性中繼資料的覆寫中指定預設值，該值會變成覆寫類別執行個體上的隱含附加屬性預設值。</span><span class="sxs-lookup"><span data-stu-id="534b4-161">If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</span></span> <span data-ttu-id="534b4-162">具體而言，如果某個處理序透過該屬性的 `Get` 方法存取子來查詢附加屬性值，並指定已指定中繼資料之類別的執行個體，則會報告預設值，否則不會設定該附加屬性的值。</span><span class="sxs-lookup"><span data-stu-id="534b4-162">Specifically, your default value is reported if some process queries for the value of an attached property through the `Get` method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</span></span>  
  
 <span data-ttu-id="534b4-163">如果您想要啟用屬性的屬性值繼承，則應該使用附加屬性，而不是使用非附加相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-163">If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</span></span> <span data-ttu-id="534b4-164">如需詳細資訊，請參閱[屬性值繼承](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="534b4-164">For details, see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>  
  
<a name="custom"></a>   
## <a name="custom-attached-properties"></a><span data-ttu-id="534b4-165">自訂附加屬性</span><span class="sxs-lookup"><span data-stu-id="534b4-165">Custom Attached Properties</span></span>  
  
<a name="create_attached_properties"></a>   
### <a name="when-to-create-an-attached-property"></a><span data-ttu-id="534b4-166">何時建立附加屬性</span><span class="sxs-lookup"><span data-stu-id="534b4-166">When to Create an Attached Property</span></span>  
 <span data-ttu-id="534b4-167">非定義類別的類別需要有可用的屬性設定機制時，您可以建立附加屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-167">You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</span></span> <span data-ttu-id="534b4-168">最常見的案例是配置。</span><span class="sxs-lookup"><span data-stu-id="534b4-168">The most common scenario for this is layout.</span></span> <span data-ttu-id="534b4-169">現有的版面配置屬性的範例包括<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>， <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>，和<xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="534b4-169">Examples of existing layout properties are <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>, and <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="534b4-170">在這裡啟用的情節是本身為配置控制項目之子項目的項目可以個別表達其配置父項目的配置需求，且各會設定父代定義為附加屬性的屬性值。</span><span class="sxs-lookup"><span data-stu-id="534b4-170">The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</span></span>  
  
 <span data-ttu-id="534b4-171">另一個使用附加屬性的情節是類別代表一項服務，而且想要類別能夠更緊密地整合服務。</span><span class="sxs-lookup"><span data-stu-id="534b4-171">Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</span></span>  
  
 <span data-ttu-id="534b4-172">但另一個情節是獲得 [!INCLUDE[vs_orcas_long](../../../../includes/vs-orcas-long-md.md)] [!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)] 支援，例如 [屬性] 視窗編輯。</span><span class="sxs-lookup"><span data-stu-id="534b4-172">Yet another scenario is to receive [!INCLUDE[vs_orcas_long](../../../../includes/vs-orcas-long-md.md)] [!INCLUDE[wpfdesigner_current_short](../../../../includes/wpfdesigner-current-short-md.md)] support, such as **Properties** window editing.</span></span> <span data-ttu-id="534b4-173">如需詳細資訊，請參閱[控制項撰寫概觀](../../../../docs/framework/wpf/controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="534b4-173">For more information, see [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md).</span></span>  
  
 <span data-ttu-id="534b4-174">如前所述，如果您想要使用屬性值繼承，則應該註冊為附加屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-174">As mentioned before, you should register as an attached property if you want to use property value inheritance.</span></span>  
  
<a name="how_do_i_create_attached_properties"></a>   
### <a name="how-to-create-an-attached-property"></a><span data-ttu-id="534b4-175">如何建立附加屬性</span><span class="sxs-lookup"><span data-stu-id="534b4-175">How to Create an Attached Property</span></span>  
 <span data-ttu-id="534b4-176">如果您的類別會定義使用嚴格的附加的屬性上其他類型，則不需要是衍生自類別<xref:System.Windows.DependencyObject>。</span><span class="sxs-lookup"><span data-stu-id="534b4-176">If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="534b4-177">但您需要以衍生自<xref:System.Windows.DependencyObject>如果遵循整體[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]讓您附加的屬性的模型也是相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-177">But you do need to derive from <xref:System.Windows.DependencyObject> if you follow the overall [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] model of having your attached property also be a dependency property.</span></span>  
  
 <span data-ttu-id="534b4-178">您附加的屬性定義為相依性屬性，藉由宣告`public` `static` `readonly`欄位型別的<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="534b4-178">Define your attached property as a dependency property by declaring a `public` `static` `readonly` field of type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="534b4-179">您使用的傳回值來定義此欄位<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="534b4-179">You define this field by using the return value of the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="534b4-180">欄位名稱必須符合附加 `Property` 字串的附加屬性名稱，以遵循命名識別欄位與其所代表屬性的已建立 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 模式。</span><span class="sxs-lookup"><span data-stu-id="534b4-180">The field name must match the attached property name, appended with the string `Property`, to follow the established [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] pattern of naming the identifying fields versus the properties that they represent.</span></span> <span data-ttu-id="534b4-181">附加屬性提供者也必須提供靜態 `Get`<屬性名稱> 和 `Set`<屬性名稱> 方法作為附加屬性的存取子；無法這麼做會導致屬性系統無法使用您的附加屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-181">The attached property provider must also provide static `Get`*PropertyName* and `Set`*PropertyName* methods as accessors for the attached property; failing to do this will result in the property system being unable to use your attached property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="534b4-182">如果您省略附加屬性的 get 存取子，則屬性的資料繫結無法在設計工具中運作，例如 [!INCLUDE[vsprvs](../../../../includes/vsprvs-md.md)] 和 Expression Blend。</span><span class="sxs-lookup"><span data-stu-id="534b4-182">If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as [!INCLUDE[vsprvs](../../../../includes/vsprvs-md.md)] and Expression Blend.</span></span>  
  
#### <a name="the-get-accessor"></a><span data-ttu-id="534b4-183">Get 存取子</span><span class="sxs-lookup"><span data-stu-id="534b4-183">The Get Accessor</span></span>  
 <span data-ttu-id="534b4-184">`Get`<屬性名稱> 存取子的簽章必須是︰</span><span class="sxs-lookup"><span data-stu-id="534b4-184">The signature for the `Get`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="534b4-185">`public static object Get` <屬性名稱> `(object`  `target` `)`</span><span class="sxs-lookup"><span data-stu-id="534b4-185">`public static object Get` *PropertyName* `(object`  `target` `)`</span></span>  
  
-   <span data-ttu-id="534b4-186">`target` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="534b4-186">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="534b4-187">例如，<xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType>方法類型參數做為<xref:System.Windows.UIElement>，因為附加的屬性只是要在設定<xref:System.Windows.UIElement>執行個體。</span><span class="sxs-lookup"><span data-stu-id="534b4-187">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> method types the parameter as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>  
  
-   <span data-ttu-id="534b4-188">傳回值可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="534b4-188">The return value can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="534b4-189">例如，<xref:System.Windows.Controls.DockPanel.GetDock%2A>方法類型，做為<xref:System.Windows.Controls.Dock>，因為值只可以將該列舉型別。</span><span class="sxs-lookup"><span data-stu-id="534b4-189">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span>  
  
#### <a name="the-set-accessor"></a><span data-ttu-id="534b4-190">Set 存取子</span><span class="sxs-lookup"><span data-stu-id="534b4-190">The Set Accessor</span></span>  
 <span data-ttu-id="534b4-191">`Set`<屬性名稱> 存取子的簽章必須是︰</span><span class="sxs-lookup"><span data-stu-id="534b4-191">The signature for the `Set`*PropertyName* accessor must be:</span></span>  
  
 <span data-ttu-id="534b4-192">`public static void Set` <屬性名稱> `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="534b4-192">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>  
  
-   <span data-ttu-id="534b4-193">`target` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="534b4-193">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="534b4-194">例如，<xref:System.Windows.Controls.DockPanel.SetDock%2A>方法類型，做為<xref:System.Windows.UIElement>，因為附加的屬性只是要在設定<xref:System.Windows.UIElement>執行個體。</span><span class="sxs-lookup"><span data-stu-id="534b4-194">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>  
  
-   <span data-ttu-id="534b4-195">`value` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="534b4-195">The `value` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="534b4-196">例如，<xref:System.Windows.Controls.DockPanel.SetDock%2A>方法類型，做為<xref:System.Windows.Controls.Dock>，因為值只可以將該列舉型別。</span><span class="sxs-lookup"><span data-stu-id="534b4-196">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span> <span data-ttu-id="534b4-197">請記住，當這個方法在標記的附加屬性使用方式中遇到附加屬性時，其值是來自 XAML 載入器的輸入。</span><span class="sxs-lookup"><span data-stu-id="534b4-197">Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</span></span> <span data-ttu-id="534b4-198">該輸入是指定為標記中 XAML 屬性值的值。</span><span class="sxs-lookup"><span data-stu-id="534b4-198">That input is the value specified as a XAML attribute value in markup.</span></span> <span data-ttu-id="534b4-199">因此，您使用的類型必須要有類型轉換、值序列化程式或標記延伸支援，因此，可以從屬性值 (這最後就是一個字串) 建立適當的類型。</span><span class="sxs-lookup"><span data-stu-id="534b4-199">Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</span></span>  
  
 <span data-ttu-id="534b4-200">下列範例示範相依性屬性註冊 (使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法)，並將`Get` *PropertyName*和`Set` *PropertyName*存取子.</span><span class="sxs-lookup"><span data-stu-id="534b4-200">The following example shows the dependency property registration (using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method), as well as the `Get`*PropertyName* and `Set`*PropertyName* accessors.</span></span> <span data-ttu-id="534b4-201">在此範例中，附加屬性名稱為 `IsBubbleSource`。</span><span class="sxs-lookup"><span data-stu-id="534b4-201">In the example, the attached property name is `IsBubbleSource`.</span></span> <span data-ttu-id="534b4-202">因此，存取子必須命名為 `GetIsBubbleSource` 和 `SetIsBubbleSource`。</span><span class="sxs-lookup"><span data-stu-id="534b4-202">Therefore, the accessors must be named `GetIsBubbleSource` and `SetIsBubbleSource`.</span></span>  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]  
  
#### <a name="attached-property-attributes"></a><span data-ttu-id="534b4-203">附加屬性 (property) 的屬性 (attribute)</span><span class="sxs-lookup"><span data-stu-id="534b4-203">Attached Property Attributes</span></span>  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]<span data-ttu-id="534b4-204"> 定義數個 [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)]，以將附加屬性相關資訊提供給反映程序以及一般反映和屬性資訊使用者，例如設計工具。</span><span class="sxs-lookup"><span data-stu-id="534b4-204"> defines several [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</span></span> <span data-ttu-id="534b4-205">因為附加屬性的類型為無限制範圍，所以設計人員需要方法來避免使用 XAML 的特定技術實作中所定義之所有附加屬性的全域清單，讓使用者無所適從。</span><span class="sxs-lookup"><span data-stu-id="534b4-205">Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</span></span> <span data-ttu-id="534b4-206">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 針對附加屬性所定義的 [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] 可以用來限定所指定附加屬性應該顯示在屬性視窗中的情況。</span><span class="sxs-lookup"><span data-stu-id="534b4-206">The [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</span></span> <span data-ttu-id="534b4-207">您也可以考慮針對您自己的自訂附加屬性套用這些屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-207">You might consider applying these attributes for your own custom attached properties also.</span></span> <span data-ttu-id="534b4-208">適當的參考頁面會描述 [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] 的用途和語法：</span><span class="sxs-lookup"><span data-stu-id="534b4-208">The purpose and syntax of the [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] is described on the appropriate reference pages:</span></span>  
  
-   <xref:System.Windows.AttachedPropertyBrowsableAttribute>  
  
-   <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>  
  
-   <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>  
  
-   <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>  
  
<a name="more"></a>   
## <a name="learning-more-about-attached-properties"></a><span data-ttu-id="534b4-209">深入了解附加屬性</span><span class="sxs-lookup"><span data-stu-id="534b4-209">Learning More About Attached Properties</span></span>  
  
-   <span data-ttu-id="534b4-210">如需建立附加屬性的詳細資訊，請參閱[註冊附加屬性](../../../../docs/framework/wpf/advanced/how-to-register-an-attached-property.md)。</span><span class="sxs-lookup"><span data-stu-id="534b4-210">For more information on creating an attached property, see [Register an Attached Property](../../../../docs/framework/wpf/advanced/how-to-register-an-attached-property.md).</span></span>  
  
-   <span data-ttu-id="534b4-211">如需相依性屬性和附加屬性的更進階使用方式情節，請參閱[自訂相依性屬性](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="534b4-211">For more advanced usage scenarios for dependency properties and attached properties, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>  
  
-   <span data-ttu-id="534b4-212">您也可以將屬性註冊為附加屬性和相依性屬性，但仍公開「包裝函式」實作。</span><span class="sxs-lookup"><span data-stu-id="534b4-212">You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</span></span> <span data-ttu-id="534b4-213">在此情況下，可以在該項目上設定屬性，或透過 XAML 附加屬性語法的任何項目上設定屬性。</span><span class="sxs-lookup"><span data-stu-id="534b4-213">In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</span></span> <span data-ttu-id="534b4-214">舉例來說，具有適當的案例來設定標準和附加使用方式的屬性是<xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="534b4-214">An example of a property with an appropriate scenario for both standard and attached usages is <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="534b4-215">請參閱</span><span class="sxs-lookup"><span data-stu-id="534b4-215">See Also</span></span>  
 <xref:System.Windows.DependencyProperty>  
 [<span data-ttu-id="534b4-216">相依性屬性概觀</span><span class="sxs-lookup"><span data-stu-id="534b4-216">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)  
 [<span data-ttu-id="534b4-217">自訂相依性屬性</span><span class="sxs-lookup"><span data-stu-id="534b4-217">Custom Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)  
 [<span data-ttu-id="534b4-218">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="534b4-218">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)  
 [<span data-ttu-id="534b4-219">註冊附加屬性</span><span class="sxs-lookup"><span data-stu-id="534b4-219">Register an Attached Property</span></span>](../../../../docs/framework/wpf/advanced/how-to-register-an-attached-property.md)
