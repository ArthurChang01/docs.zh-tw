---
title: 附加屬性概觀
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: c830a8ac3c8c935aa73974bb5fcee1f2be9c79a3
ms.sourcegitcommit: bd4fa78f5a46133efdead1bc692a9aa2811d7868
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/23/2018
ms.locfileid: "42754660"
---
# <a name="attached-properties-overview"></a><span data-ttu-id="b90ed-102">附加屬性概觀</span><span class="sxs-lookup"><span data-stu-id="b90ed-102">Attached Properties Overview</span></span>

<span data-ttu-id="b90ed-103">附加屬性是透過 XAML 所定義的概觀。</span><span class="sxs-lookup"><span data-stu-id="b90ed-103">An attached property is a concept defined by XAML.</span></span> <span data-ttu-id="b90ed-104">附加屬性是要用作可在任何物件上設定的全域屬性類型。</span><span class="sxs-lookup"><span data-stu-id="b90ed-104">An attached property is intended to be used as a type of global property that is settable on any object.</span></span> <span data-ttu-id="b90ed-105">在 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中，附加屬性一般會定義為沒有傳統屬性「包裝函式」的特殊形式相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-105">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</span></span>

## <span data-ttu-id="b90ed-106">必要條件 <a name="prerequisites"></a></span><span class="sxs-lookup"><span data-stu-id="b90ed-106">Prerequisites <a name="prerequisites"></a></span></span>

<span data-ttu-id="b90ed-107">本主題假設您已從 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 類別的現有相依性屬性消費者角度了解相依性屬性，並已閱讀[相依性屬性概觀](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="b90ed-107">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md).</span></span> <span data-ttu-id="b90ed-108">若要遵循本主題中的範例，您也應該了解 XAML 並知道如何撰寫 WPF 應用程式。</span><span class="sxs-lookup"><span data-stu-id="b90ed-108">To follow the examples in this topic, you should also understand XAML and know how to write WPF applications.</span></span>

## <span data-ttu-id="b90ed-109">為何使用附加的屬性 <a name="attached_properties_usage"></a></span><span class="sxs-lookup"><span data-stu-id="b90ed-109">Why Use Attached Properties <a name="attached_properties_usage"></a></span></span>

<span data-ttu-id="b90ed-110">附加屬性的其中一個用途是允許不同的子項目指定父項目中實際定義的屬性的唯一值。</span><span class="sxs-lookup"><span data-stu-id="b90ed-110">One purpose of an attached property is to allow different child elements to specify unique values for a property that is actually defined in a parent element.</span></span> <span data-ttu-id="b90ed-111">此情節的特定應用程式可讓子項目通知父項目，有關如何在 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] 中呈現它們。</span><span class="sxs-lookup"><span data-stu-id="b90ed-111">A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="b90ed-112">其中一個範例是<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>屬性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-112">One example is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="b90ed-113"><xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>屬性會建立為附加屬性，因為它設計成內所包含的項目上設定<xref:System.Windows.Controls.DockPanel>，而非在<xref:System.Windows.Controls.DockPanel>本身。</span><span class="sxs-lookup"><span data-stu-id="b90ed-113">The <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property is created as an attached property because it is designed to be set on elements that are contained within a <xref:System.Windows.Controls.DockPanel>, rather than on <xref:System.Windows.Controls.DockPanel> itself.</span></span> <span data-ttu-id="b90ed-114"><xref:System.Windows.Controls.DockPanel>類別會定義靜態<xref:System.Windows.DependencyProperty>名為欄位<xref:System.Windows.Controls.DockPanel.DockProperty>，然後提供<xref:System.Windows.Controls.DockPanel.GetDock%2A>和<xref:System.Windows.Controls.DockPanel.SetDock%2A>附加屬性的公用存取子方法。</span><span class="sxs-lookup"><span data-stu-id="b90ed-114">The <xref:System.Windows.Controls.DockPanel> class defines the static <xref:System.Windows.DependencyProperty> field named <xref:System.Windows.Controls.DockPanel.DockProperty>, and then provides the <xref:System.Windows.Controls.DockPanel.GetDock%2A> and <xref:System.Windows.Controls.DockPanel.SetDock%2A> methods as public accessors for the attached property.</span></span>

## <span data-ttu-id="b90ed-115">XAML 中的附加的屬性 <a name="attached_properties_xaml"></a></span><span class="sxs-lookup"><span data-stu-id="b90ed-115">Attached Properties in XAML <a name="attached_properties_xaml"></a></span></span>

<span data-ttu-id="b90ed-116">在 XAML 中，您可以使用 *AttachedPropertyProvider*.<屬性名稱> 語法來設定附加屬性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-116">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName*</span></span>

<span data-ttu-id="b90ed-117">以下是如何您也可以設定的範例<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>在 XAML 中：</span><span class="sxs-lookup"><span data-stu-id="b90ed-117">The following is an example of how you can set <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> in XAML:</span></span>

[!code-xaml[PropertiesOvwSupport#APBasicUsage](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

<span data-ttu-id="b90ed-118">請注意，使用方式有點類似靜態屬性;您永遠參考型別<xref:System.Windows.Controls.DockPanel>所擁有且註冊附加的屬性，而不是參考依名稱指定任何執行個體。</span><span class="sxs-lookup"><span data-stu-id="b90ed-118">Note that the usage is somewhat similar to a static property; you always reference the type <xref:System.Windows.Controls.DockPanel> that owns and registers the attached property, rather than referring to any instance specified by name.</span></span>

<span data-ttu-id="b90ed-119">此外，因為 XAML 中的附加屬性是您在標記中設定的屬性，所以只有設定作業才會有任何相關性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-119">Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</span></span> <span data-ttu-id="b90ed-120">雖然有一些間接機制可比較值 (例如樣式中的觸發程序)，但是您無法在 XAML 中直接取得屬性 (如需詳細資訊，請參閱[設定樣式和範本](../../../../docs/framework/wpf/controls/styling-and-templating.md))。</span><span class="sxs-lookup"><span data-stu-id="b90ed-120">You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see [Styling and Templating](../../../../docs/framework/wpf/controls/styling-and-templating.md)).</span></span>

### <a name="attached-property-implementation-in-wpf"></a><span data-ttu-id="b90ed-121">WPF 中的附加屬性實作</span><span class="sxs-lookup"><span data-stu-id="b90ed-121">Attached Property Implementation in WPF</span></span>

<span data-ttu-id="b90ed-122">在  [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]，大部分的存在於 UI 呈現相關的 WPF 類型的附加屬性都會實作為相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-122">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], most of the attached properties that exist on WPF types that are related to UI presentation are implemented as dependency properties.</span></span> <span data-ttu-id="b90ed-123">附加的屬性是 XAML 概念，而相依性屬性是 WPF 的概念。</span><span class="sxs-lookup"><span data-stu-id="b90ed-123">Attached properties are a XAML concept, whereas dependency properties are a WPF concept.</span></span> <span data-ttu-id="b90ed-124">WPF 附加屬性是相依性屬性，因為它們支援相依性屬性概念，例如屬性中繼資料，並從該屬性中繼資料的預設值。</span><span class="sxs-lookup"><span data-stu-id="b90ed-124">Because WPF attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</span></span>

## <span data-ttu-id="b90ed-125">如何使用附加的屬性的擁有者類型 <a name="howused"></a></span><span class="sxs-lookup"><span data-stu-id="b90ed-125">How Attached Properties Are Used by the Owning Type <a name="howused"></a></span></span>

<span data-ttu-id="b90ed-126">雖然可在任何物件上設定附加屬性，但是這不自動表示設定屬性就會產生明確結果，或者另一個物件將使用值。</span><span class="sxs-lookup"><span data-stu-id="b90ed-126">Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</span></span> <span data-ttu-id="b90ed-127">一般而言，會使用附加屬性，讓來自各種可能類別階層或邏輯關聯性的物件都可以報告可定義附加屬性之類型的通用資訊。</span><span class="sxs-lookup"><span data-stu-id="b90ed-127">Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</span></span> <span data-ttu-id="b90ed-128">可定義附加屬性的類型通常會遵循下列其中一個模型︰</span><span class="sxs-lookup"><span data-stu-id="b90ed-128">The type that defines the attached property typically follows one of these models:</span></span>

-   <span data-ttu-id="b90ed-129">設計可定義附加屬性的類型，因此它可以是設定附加屬性值之項目的父項目。</span><span class="sxs-lookup"><span data-stu-id="b90ed-129">The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</span></span> <span data-ttu-id="b90ed-130">類型接著會透過內部邏輯針對某個物件樹狀結構逐一查看其子物件，並取得值，然後以某種方式處理這些值。</span><span class="sxs-lookup"><span data-stu-id="b90ed-130">The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</span></span>

-   <span data-ttu-id="b90ed-131">可定義附加屬性的類型將會用作各種可能父項目和內容模組的子項目。</span><span class="sxs-lookup"><span data-stu-id="b90ed-131">The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</span></span>

-   <span data-ttu-id="b90ed-132">可定義附加屬性的類型代表服務。</span><span class="sxs-lookup"><span data-stu-id="b90ed-132">The type that defines the attached property represents a service.</span></span> <span data-ttu-id="b90ed-133">其他類型設定附加屬性的值。</span><span class="sxs-lookup"><span data-stu-id="b90ed-133">Other types set values for the attached property.</span></span> <span data-ttu-id="b90ed-134">然後，在服務內容中評估可設定屬性的項目時，會透過服務類別的內部邏輯取得附加屬性值。</span><span class="sxs-lookup"><span data-stu-id="b90ed-134">Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</span></span>

### <a name="an-example-of-a-parent-defined-attached-property"></a><span data-ttu-id="b90ed-135">父代已定義的附加屬性範例</span><span class="sxs-lookup"><span data-stu-id="b90ed-135">An Example of a Parent-Defined Attached Property</span></span>

<span data-ttu-id="b90ed-136">WPF 定義附加的屬性的地方的最常見案例是當父項目支援子項目集合，而且也會實作行為，其中的細節的行為會個別報告每個子項目。</span><span class="sxs-lookup"><span data-stu-id="b90ed-136">The most typical scenario where WPF defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</span></span>

<span data-ttu-id="b90ed-137"><xref:System.Windows.Controls.DockPanel> 定義<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>附加屬性，並<xref:System.Windows.Controls.DockPanel>具有類別層級程式碼作為其轉譯邏輯的一部分 (具體而言，<xref:System.Windows.Controls.DockPanel.MeasureOverride%2A>和<xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>)。</span><span class="sxs-lookup"><span data-stu-id="b90ed-137"><xref:System.Windows.Controls.DockPanel> defines the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property, and <xref:System.Windows.Controls.DockPanel> has class-level code as part of its rendering logic (specifically, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> and <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span></span> <span data-ttu-id="b90ed-138">A<xref:System.Windows.Controls.DockPanel>執行個體一律會檢查以確認是否立即其子元素的任何已設定的值<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b90ed-138">A <xref:System.Windows.Controls.DockPanel> instance will always check to see whether any of its immediate child elements have set a value for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b90ed-139">如果是這樣，這些值會變成套用至該特定子項目之轉譯邏輯的輸入。</span><span class="sxs-lookup"><span data-stu-id="b90ed-139">If so, those values become input for the rendering logic applied to that particular child element.</span></span> <span data-ttu-id="b90ed-140">巢狀<xref:System.Windows.Controls.DockPanel>執行個體都會處理它們自己的直屬子項目集合，但該行為是實作特定如何<xref:System.Windows.Controls.DockPanel>處理程序<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>值。</span><span class="sxs-lookup"><span data-stu-id="b90ed-140">Nested <xref:System.Windows.Controls.DockPanel> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <xref:System.Windows.Controls.DockPanel> processes <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="b90ed-141">理論上，可能會有附加屬性影響直屬父代以外的項目。</span><span class="sxs-lookup"><span data-stu-id="b90ed-141">It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</span></span> <span data-ttu-id="b90ed-142">如果<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>沒有任何項目上設定附加的屬性<xref:System.Windows.Controls.DockPanel>父項目，可處理在它、 任何錯誤或例外狀況時，就會引發。</span><span class="sxs-lookup"><span data-stu-id="b90ed-142">If the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property is set on an element that has no <xref:System.Windows.Controls.DockPanel> parent element to act upon it, no error or exception is raised.</span></span> <span data-ttu-id="b90ed-143">這只是表示已設定全域屬性值，但它有沒有目前<xref:System.Windows.Controls.DockPanel>使用這項資訊的父代。</span><span class="sxs-lookup"><span data-stu-id="b90ed-143">This simply means that a global property value was set, but it has no current <xref:System.Windows.Controls.DockPanel> parent that could consume the information.</span></span>

## <span data-ttu-id="b90ed-144">在程式碼中的附加的屬性 <a name="attached_properties_code"></a></span><span class="sxs-lookup"><span data-stu-id="b90ed-144">Attached Properties in Code <a name="attached_properties_code"></a></span></span>

<span data-ttu-id="b90ed-145">在 WPF 中的附加的屬性沒有一般[!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)]簡單的 get/set 存取的 「 包裝函式 」 方法。</span><span class="sxs-lookup"><span data-stu-id="b90ed-145">Attached properties in WPF do not have the typical [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] "wrapper" methods for easy get/set access.</span></span> <span data-ttu-id="b90ed-146">這是因為附加屬性不一定屬於已設定屬性之執行個體的 [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] 命名空間。</span><span class="sxs-lookup"><span data-stu-id="b90ed-146">This is because the attached property is not necessarily part of the [!INCLUDE[TLA2#tla_clr](../../../../includes/tla2sharptla-clr-md.md)] namespace for instances where the property is set.</span></span> <span data-ttu-id="b90ed-147">不過，XAML 處理器必須可以在剖析 XAML 時設定這些值。</span><span class="sxs-lookup"><span data-stu-id="b90ed-147">However, a XAML processor must be able to set those values when XAML is parsed.</span></span> <span data-ttu-id="b90ed-148">若要支援有效的附加屬性使用方式，附加屬性的擁有者類型必須在表單 <屬性名稱>`Get` 和 <屬性名稱>`Set` 中實作專用存取子方法。</span><span class="sxs-lookup"><span data-stu-id="b90ed-148">To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form `Get`*PropertyName* and `Set`*PropertyName*.</span></span> <span data-ttu-id="b90ed-149">這些專用存取子方法也適用於取得或設定程式碼中的附加屬性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-149">These dedicated accessor methods are also useful to get or set the attached property in code.</span></span> <span data-ttu-id="b90ed-150">從程式碼觀點，附加屬性類似具有方法存取子而非屬性存取子的支援欄位，而且該支援欄位可以存在於任何物件，而不需要特別進行定義。</span><span class="sxs-lookup"><span data-stu-id="b90ed-150">From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</span></span>

<span data-ttu-id="b90ed-151">下列範例示範如何在程式碼中設定附加屬性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-151">The following example shows how you can set an attached property in code.</span></span> <span data-ttu-id="b90ed-152">在此範例中，`myCheckBox`的執行個體<xref:System.Windows.Controls.CheckBox>類別。</span><span class="sxs-lookup"><span data-stu-id="b90ed-152">In this example, `myCheckBox` is an instance of the <xref:System.Windows.Controls.CheckBox> class.</span></span>

[!code-csharp[PropertiesOvwSupport#APCode](../../../../samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

<span data-ttu-id="b90ed-153">類似於 XAML 情況下，如果`myCheckBox`有尚未新增為子元素`myDockPanel`由第三行程式碼，程式碼的第四行不會引發例外狀況，但屬性值不會與互動<xref:System.Windows.Controls.DockPanel>父代，因此會執行任何動作。</span><span class="sxs-lookup"><span data-stu-id="b90ed-153">Similar to the XAML case, if `myCheckBox` had not already been added as a child element of `myDockPanel` by the third line of code, the fourth line of code would not raise an exception, but the property value would not interact with a <xref:System.Windows.Controls.DockPanel> parent and thus would do nothing.</span></span> <span data-ttu-id="b90ed-154">只有<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>值的結合出現與否的子項目設定<xref:System.Windows.Controls.DockPanel>父項目會造成轉譯應用程式的有效的行為。</span><span class="sxs-lookup"><span data-stu-id="b90ed-154">Only a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> value set on a child element combined with the presence of a <xref:System.Windows.Controls.DockPanel> parent element will cause an effective behavior in the rendered application.</span></span> <span data-ttu-id="b90ed-155">(在此情況下，您可以設定附加屬性，然後將其附加至樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="b90ed-155">(In this case, you could set the attached property, then attach to the tree.</span></span> <span data-ttu-id="b90ed-156">或者，您可以將其附加至樹狀結構，然後設定附加屬性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-156">Or you could attach to the tree then set the attached property.</span></span> <span data-ttu-id="b90ed-157">任一個動作順序都會提供相同的結果)。</span><span class="sxs-lookup"><span data-stu-id="b90ed-157">Either action order provides the same result.)</span></span>

## <span data-ttu-id="b90ed-158">附加的屬性中繼資料 <a name="attached_properties_metadata"></a></span><span class="sxs-lookup"><span data-stu-id="b90ed-158">Attached Property Metadata <a name="attached_properties_metadata"></a></span></span>

<span data-ttu-id="b90ed-159">註冊屬性時<xref:System.Windows.FrameworkPropertyMetadata>設為指定的屬性，例如屬性是否影響轉譯、 測量和等等的特性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-159">When registering the property, <xref:System.Windows.FrameworkPropertyMetadata> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</span></span> <span data-ttu-id="b90ed-160">附加屬性的中繼資料一般與相依性屬性並無不同。</span><span class="sxs-lookup"><span data-stu-id="b90ed-160">Metadata for an attached property is generally no different than on a dependency property.</span></span> <span data-ttu-id="b90ed-161">如果您在附加屬性中繼資料的覆寫中指定預設值，該值會變成覆寫類別執行個體上的隱含附加屬性預設值。</span><span class="sxs-lookup"><span data-stu-id="b90ed-161">If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</span></span> <span data-ttu-id="b90ed-162">具體而言，如果某個處理序透過該屬性的 `Get` 方法存取子來查詢附加屬性值，並指定已指定中繼資料之類別的執行個體，則會報告預設值，否則不會設定該附加屬性的值。</span><span class="sxs-lookup"><span data-stu-id="b90ed-162">Specifically, your default value is reported if some process queries for the value of an attached property through the `Get` method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</span></span>

<span data-ttu-id="b90ed-163">如果您想要啟用屬性的屬性值繼承，則應該使用附加屬性，而不是使用非附加相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-163">If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</span></span> <span data-ttu-id="b90ed-164">如需詳細資訊，請參閱[屬性值繼承](../../../../docs/framework/wpf/advanced/property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="b90ed-164">For details, see [Property Value Inheritance](../../../../docs/framework/wpf/advanced/property-value-inheritance.md).</span></span>

## <span data-ttu-id="b90ed-165">自訂附加屬性 <a name="custom"></a></span><span class="sxs-lookup"><span data-stu-id="b90ed-165">Custom Attached Properties <a name="custom"></a></span></span>

### <span data-ttu-id="b90ed-166">何時建立附加的屬性 <a name="create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="b90ed-166">When to Create an Attached Property <a name="create_attached_properties"></a></span></span>

<span data-ttu-id="b90ed-167">非定義類別的類別需要有可用的屬性設定機制時，您可以建立附加屬性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-167">You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</span></span> <span data-ttu-id="b90ed-168">最常見的案例是配置。</span><span class="sxs-lookup"><span data-stu-id="b90ed-168">The most common scenario for this is layout.</span></span> <span data-ttu-id="b90ed-169">現有配置屬性的範例包括<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>， <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>，和<xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b90ed-169">Examples of existing layout properties are <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>, and <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b90ed-170">在這裡啟用的情節是本身為配置控制項目之子項目的項目可以個別表達其配置父項目的配置需求，且各會設定父代定義為附加屬性的屬性值。</span><span class="sxs-lookup"><span data-stu-id="b90ed-170">The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</span></span>

<span data-ttu-id="b90ed-171">另一個使用附加屬性的情節是類別代表一項服務，而且想要類別能夠更緊密地整合服務。</span><span class="sxs-lookup"><span data-stu-id="b90ed-171">Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</span></span>

<span data-ttu-id="b90ed-172">但另一個案例是收到 Visual Studio WPF 設計工具支援，例如**屬性**視窗編輯。</span><span class="sxs-lookup"><span data-stu-id="b90ed-172">Yet another scenario is to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="b90ed-173">如需詳細資訊，請參閱[控制項撰寫概觀](../../../../docs/framework/wpf/controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="b90ed-173">For more information, see [Control Authoring Overview](../../../../docs/framework/wpf/controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="b90ed-174">如前所述，如果您想要使用屬性值繼承，則應該註冊為附加屬性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-174">As mentioned before, you should register as an attached property if you want to use property value inheritance.</span></span>

### <span data-ttu-id="b90ed-175">如何建立附加的屬性 <a name="how_do_i_create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="b90ed-175">How to Create an Attached Property <a name="how_do_i_create_attached_properties"></a></span></span>

<span data-ttu-id="b90ed-176">如果您的類別會定義使用嚴格的附加的屬性上其他類型，則不需要衍生自類別<xref:System.Windows.DependencyObject>。</span><span class="sxs-lookup"><span data-stu-id="b90ed-176">If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="b90ed-177">但您必須衍生自<xref:System.Windows.DependencyObject>如果您遵循將附加的屬性，也相依性屬性的整體 WPF 模型。</span><span class="sxs-lookup"><span data-stu-id="b90ed-177">But you do need to derive from <xref:System.Windows.DependencyObject> if you follow the overall WPF model of having your attached property also be a dependency property.</span></span>

<span data-ttu-id="b90ed-178">將附加的屬性定義為相依性屬性，藉由宣告`public static readonly`型別的欄位<xref:System.Windows.DependencyProperty>。</span><span class="sxs-lookup"><span data-stu-id="b90ed-178">Define your attached property as a dependency property by declaring a `public static readonly` field of type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="b90ed-179">您使用的傳回值來定義此欄位<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法。</span><span class="sxs-lookup"><span data-stu-id="b90ed-179">You define this field by using the return value of the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="b90ed-180">欄位名稱必須符合的附加的屬性名稱，加上字串`Property`，以遵循命名識別欄位，與它們所代表的屬性建立的 WPF 模式。</span><span class="sxs-lookup"><span data-stu-id="b90ed-180">The field name must match the attached property name, appended with the string `Property`, to follow the established WPF pattern of naming the identifying fields versus the properties that they represent.</span></span> <span data-ttu-id="b90ed-181">附加屬性提供者也必須提供靜態 `Get`<屬性名稱> 和 `Set`<屬性名稱> 方法作為附加屬性的存取子；無法這麼做會導致屬性系統無法使用您的附加屬性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-181">The attached property provider must also provide static `Get`*PropertyName* and `Set`*PropertyName* methods as accessors for the attached property; failing to do this will result in the property system being unable to use your attached property.</span></span>

> [!NOTE]
> <span data-ttu-id="b90ed-182">如果您省略附加的屬性的 get 存取子，在屬性上的資料繫結無法在設計工具，例如 Visual Studio 和 Expression Blend。</span><span class="sxs-lookup"><span data-stu-id="b90ed-182">If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as Visual Studio and Expression Blend.</span></span>

#### <a name="the-get-accessor"></a><span data-ttu-id="b90ed-183">Get 存取子</span><span class="sxs-lookup"><span data-stu-id="b90ed-183">The Get Accessor</span></span>

<span data-ttu-id="b90ed-184">`Get`<屬性名稱> 存取子的簽章必須是︰</span><span class="sxs-lookup"><span data-stu-id="b90ed-184">The signature for the `Get`*PropertyName* accessor must be:</span></span>

<span data-ttu-id="b90ed-185">`public static object Get` *PropertyName* `(object target)`</span><span class="sxs-lookup"><span data-stu-id="b90ed-185">`public static object Get` *PropertyName* `(object target)`</span></span>

-   <span data-ttu-id="b90ed-186">`target` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="b90ed-186">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="b90ed-187">例如，<xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType>方法類型參數做為<xref:System.Windows.UIElement>，因為附加的屬性只是要在設定<xref:System.Windows.UIElement>執行個體。</span><span class="sxs-lookup"><span data-stu-id="b90ed-187">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> method types the parameter as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

-   <span data-ttu-id="b90ed-188">傳回值可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="b90ed-188">The return value can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="b90ed-189">例如，<xref:System.Windows.Controls.DockPanel.GetDock%2A>方法型別為<xref:System.Windows.Controls.Dock>，因為值只能設定為該列舉。</span><span class="sxs-lookup"><span data-stu-id="b90ed-189">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span>

#### <a name="the-set-accessor"></a><span data-ttu-id="b90ed-190">Set 存取子</span><span class="sxs-lookup"><span data-stu-id="b90ed-190">The Set Accessor</span></span>

<span data-ttu-id="b90ed-191">`Set`<屬性名稱> 存取子的簽章必須是︰</span><span class="sxs-lookup"><span data-stu-id="b90ed-191">The signature for the `Set`*PropertyName* accessor must be:</span></span>

<span data-ttu-id="b90ed-192">`public static void Set` <屬性名稱> `(object`  `target` `, object`  `value` `)`</span><span class="sxs-lookup"><span data-stu-id="b90ed-192">`public static void Set` *PropertyName* `(object`  `target` `, object`  `value` `)`</span></span>

-   <span data-ttu-id="b90ed-193">`target` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="b90ed-193">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="b90ed-194">例如，<xref:System.Windows.Controls.DockPanel.SetDock%2A>方法型別為<xref:System.Windows.UIElement>，因為附加的屬性只是要在設定<xref:System.Windows.UIElement>執行個體。</span><span class="sxs-lookup"><span data-stu-id="b90ed-194">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

-   <span data-ttu-id="b90ed-195">`value` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="b90ed-195">The `value` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="b90ed-196">例如，<xref:System.Windows.Controls.DockPanel.SetDock%2A>方法型別為<xref:System.Windows.Controls.Dock>，因為值只能設定為該列舉。</span><span class="sxs-lookup"><span data-stu-id="b90ed-196">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span> <span data-ttu-id="b90ed-197">請記住，當這個方法在標記的附加屬性使用方式中遇到附加屬性時，其值是來自 XAML 載入器的輸入。</span><span class="sxs-lookup"><span data-stu-id="b90ed-197">Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</span></span> <span data-ttu-id="b90ed-198">該輸入是指定為標記中 XAML 屬性值的值。</span><span class="sxs-lookup"><span data-stu-id="b90ed-198">That input is the value specified as a XAML attribute value in markup.</span></span> <span data-ttu-id="b90ed-199">因此，您使用的類型必須要有類型轉換、值序列化程式或標記延伸支援，因此，可以從屬性值 (這最後就是一個字串) 建立適當的類型。</span><span class="sxs-lookup"><span data-stu-id="b90ed-199">Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</span></span>

<span data-ttu-id="b90ed-200">下列範例示範相依性屬性註冊 (使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法)，以及`Get` *PropertyName*並`Set` *PropertyName*存取子.</span><span class="sxs-lookup"><span data-stu-id="b90ed-200">The following example shows the dependency property registration (using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method), as well as the `Get`*PropertyName* and `Set`*PropertyName* accessors.</span></span> <span data-ttu-id="b90ed-201">在此範例中，附加屬性名稱為 `IsBubbleSource`。</span><span class="sxs-lookup"><span data-stu-id="b90ed-201">In the example, the attached property name is `IsBubbleSource`.</span></span> <span data-ttu-id="b90ed-202">因此，存取子必須命名為 `GetIsBubbleSource` 和 `SetIsBubbleSource`。</span><span class="sxs-lookup"><span data-stu-id="b90ed-202">Therefore, the accessors must be named `GetIsBubbleSource` and `SetIsBubbleSource`.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](../../../../samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](../../../../samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a><span data-ttu-id="b90ed-203">附加屬性 (property) 的屬性 (attribute)</span><span class="sxs-lookup"><span data-stu-id="b90ed-203">Attached Property Attributes</span></span>

<span data-ttu-id="b90ed-204">WPF 定義數個[!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)]，要提供給反映程序，並反映和屬性的資訊，例如設計工具的一般使用者的附加屬性的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="b90ed-204">WPF defines several [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</span></span> <span data-ttu-id="b90ed-205">因為附加屬性的類型為無限制範圍，所以設計人員需要方法來避免使用 XAML 的特定技術實作中所定義之所有附加屬性的全域清單，讓使用者無所適從。</span><span class="sxs-lookup"><span data-stu-id="b90ed-205">Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</span></span> <span data-ttu-id="b90ed-206">[!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)]該 WPF 定義附加的屬性可以用來限定範圍的情況，其中指定的附加的屬性應該會顯示在 [屬性] 視窗。</span><span class="sxs-lookup"><span data-stu-id="b90ed-206">The [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] that WPF defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</span></span> <span data-ttu-id="b90ed-207">您也可以考慮針對您自己的自訂附加屬性套用這些屬性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-207">You might consider applying these attributes for your own custom attached properties also.</span></span> <span data-ttu-id="b90ed-208">適當的參考頁面會描述 [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] 的用途和語法：</span><span class="sxs-lookup"><span data-stu-id="b90ed-208">The purpose and syntax of the [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] is described on the appropriate reference pages:</span></span>

-   <xref:System.Windows.AttachedPropertyBrowsableAttribute>

-   <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

-   <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

-   <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## <span data-ttu-id="b90ed-209">深入了解附加屬性 <a name="more"></a></span><span class="sxs-lookup"><span data-stu-id="b90ed-209">Learning More About Attached Properties <a name="more"></a></span></span>

-   <span data-ttu-id="b90ed-210">如需建立附加屬性的詳細資訊，請參閱[註冊附加屬性](../../../../docs/framework/wpf/advanced/how-to-register-an-attached-property.md)。</span><span class="sxs-lookup"><span data-stu-id="b90ed-210">For more information on creating an attached property, see [Register an Attached Property](../../../../docs/framework/wpf/advanced/how-to-register-an-attached-property.md).</span></span>

-   <span data-ttu-id="b90ed-211">如需相依性屬性和附加屬性的更進階使用方式情節，請參閱[自訂相依性屬性](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="b90ed-211">For more advanced usage scenarios for dependency properties and attached properties, see [Custom Dependency Properties](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md).</span></span>

-   <span data-ttu-id="b90ed-212">您也可以將屬性註冊為附加屬性和相依性屬性，但仍公開「包裝函式」實作。</span><span class="sxs-lookup"><span data-stu-id="b90ed-212">You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</span></span> <span data-ttu-id="b90ed-213">在此情況下，可以在該項目上設定屬性，或透過 XAML 附加屬性語法的任何項目上設定屬性。</span><span class="sxs-lookup"><span data-stu-id="b90ed-213">In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</span></span> <span data-ttu-id="b90ed-214">舉例來說，標準和附加使用方式之適當情節的屬性是<xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="b90ed-214">An example of a property with an appropriate scenario for both standard and attached usages is <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="b90ed-215">另請參閱</span><span class="sxs-lookup"><span data-stu-id="b90ed-215">See Also</span></span>

- <xref:System.Windows.DependencyProperty>
- [<span data-ttu-id="b90ed-216">相依性屬性概觀</span><span class="sxs-lookup"><span data-stu-id="b90ed-216">Dependency Properties Overview</span></span>](../../../../docs/framework/wpf/advanced/dependency-properties-overview.md)
- [<span data-ttu-id="b90ed-217">自訂相依性屬性</span><span class="sxs-lookup"><span data-stu-id="b90ed-217">Custom Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)
- [<span data-ttu-id="b90ed-218">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="b90ed-218">XAML Overview (WPF)</span></span>](../../../../docs/framework/wpf/advanced/xaml-overview-wpf.md)
- [<span data-ttu-id="b90ed-219">註冊附加屬性</span><span class="sxs-lookup"><span data-stu-id="b90ed-219">Register an Attached Property</span></span>](../../../../docs/framework/wpf/advanced/how-to-register-an-attached-property.md)