---
title: 附加屬性概觀
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: 5086401f4616074d364c1d387b751116120d5969
ms.sourcegitcommit: c91110ef6ee3fedb591f3d628dc17739c4a7071e
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/15/2020
ms.locfileid: "81389005"
---
# <a name="attached-properties-overview"></a><span data-ttu-id="1eee0-102">附加屬性概觀</span><span class="sxs-lookup"><span data-stu-id="1eee0-102">Attached Properties Overview</span></span>

<span data-ttu-id="1eee0-103">附加屬性是透過 XAML 所定義的概觀。</span><span class="sxs-lookup"><span data-stu-id="1eee0-103">An attached property is a concept defined by XAML.</span></span> <span data-ttu-id="1eee0-104">附加屬性是要用作可在任何物件上設定的全域屬性類型。</span><span class="sxs-lookup"><span data-stu-id="1eee0-104">An attached property is intended to be used as a type of global property that is settable on any object.</span></span> <span data-ttu-id="1eee0-105">在 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中，附加屬性一般會定義為沒有傳統屬性「包裝函式」的特殊形式相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-105">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</span></span>

## <a name="prerequisites"></a><span data-ttu-id="1eee0-106">先決條件<a name="prerequisites"></a></span><span class="sxs-lookup"><span data-stu-id="1eee0-106">Prerequisites <a name="prerequisites"></a></span></span>

<span data-ttu-id="1eee0-107">本主題假設您已從 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 類別的現有相依性屬性消費者角度了解相依性屬性，並已閱讀[相依性屬性概觀](dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="1eee0-107">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="1eee0-108">要遵循本主題中的範例,您還應瞭解 XAML 並瞭解如何編寫 WPF 應用程式。</span><span class="sxs-lookup"><span data-stu-id="1eee0-108">To follow the examples in this topic, you should also understand XAML and know how to write WPF applications.</span></span>

## <a name="why-use-attached-properties"></a><span data-ttu-id="1eee0-109">為什麼使用額外屬性<a name="attached_properties_usage"></a></span><span class="sxs-lookup"><span data-stu-id="1eee0-109">Why Use Attached Properties <a name="attached_properties_usage"></a></span></span>

<span data-ttu-id="1eee0-110">附加屬性的其中一個用途是允許不同的子項目指定父項目中實際定義的屬性的唯一值。</span><span class="sxs-lookup"><span data-stu-id="1eee0-110">One purpose of an attached property is to allow different child elements to specify unique values for a property that is actually defined in a parent element.</span></span> <span data-ttu-id="1eee0-111">此情節的特定應用程式可讓子項目通知父項目，有關如何在 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] 中呈現它們。</span><span class="sxs-lookup"><span data-stu-id="1eee0-111">A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="1eee0-112">屬性就是一<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>個示例。</span><span class="sxs-lookup"><span data-stu-id="1eee0-112">One example is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="1eee0-113">該<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>屬性創建為附加屬性,因為它被設計為設置為在中包含<xref:System.Windows.Controls.DockPanel>的 元素上,而不是<xref:System.Windows.Controls.DockPanel>本身。</span><span class="sxs-lookup"><span data-stu-id="1eee0-113">The <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property is created as an attached property because it is designed to be set on elements that are contained within a <xref:System.Windows.Controls.DockPanel>, rather than on <xref:System.Windows.Controls.DockPanel> itself.</span></span> <span data-ttu-id="1eee0-114">類<xref:System.Windows.Controls.DockPanel><xref:System.Windows.DependencyProperty>定義<xref:System.Windows.Controls.DockPanel.DockProperty>名為 的靜態欄位,然後作為附加屬性<xref:System.Windows.Controls.DockPanel.GetDock%2A>的<xref:System.Windows.Controls.DockPanel.SetDock%2A>公共 訪問 器提供 和 方法。</span><span class="sxs-lookup"><span data-stu-id="1eee0-114">The <xref:System.Windows.Controls.DockPanel> class defines the static <xref:System.Windows.DependencyProperty> field named <xref:System.Windows.Controls.DockPanel.DockProperty>, and then provides the <xref:System.Windows.Controls.DockPanel.GetDock%2A> and <xref:System.Windows.Controls.DockPanel.SetDock%2A> methods as public accessors for the attached property.</span></span>

## <a name="attached-properties-in-xaml"></a><span data-ttu-id="1eee0-115">XAML 中的額外屬性<a name="attached_properties_xaml"></a></span><span class="sxs-lookup"><span data-stu-id="1eee0-115">Attached Properties in XAML <a name="attached_properties_xaml"></a></span></span>

<span data-ttu-id="1eee0-116">在 XAML 中，您可以使用 *AttachedPropertyProvider*.<屬性名稱>\*\* 語法來設定附加屬性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-116">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName*</span></span>

<span data-ttu-id="1eee0-117">以下是如何在 XAML<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>中設定 的範例:</span><span class="sxs-lookup"><span data-stu-id="1eee0-117">The following is an example of how you can set <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> in XAML:</span></span>

[!code-xaml[PropertiesOvwSupport#APBasicUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

<span data-ttu-id="1eee0-118">請注意,使用法與靜態屬性有些類似;您始終引用擁有並<xref:System.Windows.Controls.DockPanel>註冊附加屬性的類型,而不是引用名稱指定的任何實例。</span><span class="sxs-lookup"><span data-stu-id="1eee0-118">Note that the usage is somewhat similar to a static property; you always reference the type <xref:System.Windows.Controls.DockPanel> that owns and registers the attached property, rather than referring to any instance specified by name.</span></span>

<span data-ttu-id="1eee0-119">此外，因為 XAML 中的附加屬性是您在標記中設定的屬性，所以只有設定作業才會有任何相關性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-119">Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</span></span> <span data-ttu-id="1eee0-120">雖然有一些間接機制可比較值 (例如樣式中的觸發程序)，但是您無法在 XAML 中直接取得屬性 (如需詳細資訊，請參閱[設定樣式和範本](../controls/styling-and-templating.md))。</span><span class="sxs-lookup"><span data-stu-id="1eee0-120">You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see [Styling and Templating](../controls/styling-and-templating.md)).</span></span>

### <a name="attached-property-implementation-in-wpf"></a><span data-ttu-id="1eee0-121">WPF 中的附加屬性實作</span><span class="sxs-lookup"><span data-stu-id="1eee0-121">Attached Property Implementation in WPF</span></span>

<span data-ttu-id="1eee0-122">在[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]中,WPF 類型中存在的大多數與UI表示相關的附加屬性都作為依賴項屬性實現。</span><span class="sxs-lookup"><span data-stu-id="1eee0-122">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], most of the attached properties that exist on WPF types that are related to UI presentation are implemented as dependency properties.</span></span> <span data-ttu-id="1eee0-123">附加屬性是 XAML 概念,而依賴項屬性是 WPF 概念。</span><span class="sxs-lookup"><span data-stu-id="1eee0-123">Attached properties are a XAML concept, whereas dependency properties are a WPF concept.</span></span> <span data-ttu-id="1eee0-124">由於 WPF 附加屬性是依賴項屬性,因此它們支援依賴項屬性概念,如屬性元數據和來自該屬性元數據的預設值。</span><span class="sxs-lookup"><span data-stu-id="1eee0-124">Because WPF attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</span></span>

## <a name="how-attached-properties-are-used-by-the-owning-type"></a><span data-ttu-id="1eee0-125">擁有類型如何使用額外屬性<a name="howused"></a></span><span class="sxs-lookup"><span data-stu-id="1eee0-125">How Attached Properties Are Used by the Owning Type <a name="howused"></a></span></span>

<span data-ttu-id="1eee0-126">雖然可在任何物件上設定附加屬性，但是這不自動表示設定屬性就會產生明確結果，或者另一個物件將使用值。</span><span class="sxs-lookup"><span data-stu-id="1eee0-126">Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</span></span> <span data-ttu-id="1eee0-127">一般而言，會使用附加屬性，讓來自各種可能類別階層或邏輯關聯性的物件都可以報告可定義附加屬性之類型的通用資訊。</span><span class="sxs-lookup"><span data-stu-id="1eee0-127">Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</span></span> <span data-ttu-id="1eee0-128">可定義附加屬性的類型通常會遵循下列其中一個模型︰</span><span class="sxs-lookup"><span data-stu-id="1eee0-128">The type that defines the attached property typically follows one of these models:</span></span>

- <span data-ttu-id="1eee0-129">設計可定義附加屬性的類型，因此它可以是設定附加屬性值之項目的父項目。</span><span class="sxs-lookup"><span data-stu-id="1eee0-129">The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</span></span> <span data-ttu-id="1eee0-130">類型接著會透過內部邏輯針對某個物件樹狀結構逐一查看其子物件，並取得值，然後以某種方式處理這些值。</span><span class="sxs-lookup"><span data-stu-id="1eee0-130">The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</span></span>

- <span data-ttu-id="1eee0-131">可定義附加屬性的類型將會用作各種可能父項目和內容模組的子項目。</span><span class="sxs-lookup"><span data-stu-id="1eee0-131">The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</span></span>

- <span data-ttu-id="1eee0-132">可定義附加屬性的類型代表服務。</span><span class="sxs-lookup"><span data-stu-id="1eee0-132">The type that defines the attached property represents a service.</span></span> <span data-ttu-id="1eee0-133">其他類型設定附加屬性的值。</span><span class="sxs-lookup"><span data-stu-id="1eee0-133">Other types set values for the attached property.</span></span> <span data-ttu-id="1eee0-134">然後，在服務內容中評估可設定屬性的項目時，會透過服務類別的內部邏輯取得附加屬性值。</span><span class="sxs-lookup"><span data-stu-id="1eee0-134">Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</span></span>

### <a name="an-example-of-a-parent-defined-attached-property"></a><span data-ttu-id="1eee0-135">父代已定義的附加屬性範例</span><span class="sxs-lookup"><span data-stu-id="1eee0-135">An Example of a Parent-Defined Attached Property</span></span>

<span data-ttu-id="1eee0-136">WPF 定義附加屬性的最典型方案是父元素支援子元素集合,並實現一種行為,其中為每個子元素單獨報告行為的特定部分。</span><span class="sxs-lookup"><span data-stu-id="1eee0-136">The most typical scenario where WPF defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</span></span>

<span data-ttu-id="1eee0-137"><xref:System.Windows.Controls.DockPanel>定義<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>附加的屬性,<xref:System.Windows.Controls.DockPanel>並將 類級代碼作為其呈現邏輯的一部分(<xref:System.Windows.Controls.DockPanel.MeasureOverride%2A><xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>特別是和)。</span><span class="sxs-lookup"><span data-stu-id="1eee0-137"><xref:System.Windows.Controls.DockPanel> defines the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property, and <xref:System.Windows.Controls.DockPanel> has class-level code as part of its rendering logic (specifically, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> and <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span></span> <span data-ttu-id="1eee0-138">實例<xref:System.Windows.Controls.DockPanel>將始終檢查其任何直接子元素是否已<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>為 設置值。</span><span class="sxs-lookup"><span data-stu-id="1eee0-138">A <xref:System.Windows.Controls.DockPanel> instance will always check to see whether any of its immediate child elements have set a value for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1eee0-139">如果是這樣，這些值會變成套用至該特定子項目之轉譯邏輯的輸入。</span><span class="sxs-lookup"><span data-stu-id="1eee0-139">If so, those values become input for the rendering logic applied to that particular child element.</span></span> <span data-ttu-id="1eee0-140">嵌套<xref:System.Windows.Controls.DockPanel>實例每個實例都處理其自己的直接子元素集合,但該行為特定於<xref:System.Windows.Controls.DockPanel><xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>流程 值的方式。</span><span class="sxs-lookup"><span data-stu-id="1eee0-140">Nested <xref:System.Windows.Controls.DockPanel> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <xref:System.Windows.Controls.DockPanel> processes <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="1eee0-141">理論上，可能會有附加屬性影響直屬父代以外的項目。</span><span class="sxs-lookup"><span data-stu-id="1eee0-141">It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</span></span> <span data-ttu-id="1eee0-142">如果<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>附加屬性設置在<xref:System.Windows.Controls.DockPanel>沒有 父元素的元素上,則不引發任何錯誤或異常。</span><span class="sxs-lookup"><span data-stu-id="1eee0-142">If the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property is set on an element that has no <xref:System.Windows.Controls.DockPanel> parent element to act upon it, no error or exception is raised.</span></span> <span data-ttu-id="1eee0-143">這僅僅意味著設置了全域屬性值,但它沒有可以使用資訊的當前<xref:System.Windows.Controls.DockPanel>父級。</span><span class="sxs-lookup"><span data-stu-id="1eee0-143">This simply means that a global property value was set, but it has no current <xref:System.Windows.Controls.DockPanel> parent that could consume the information.</span></span>

## <a name="attached-properties-in-code"></a><span data-ttu-id="1eee0-144">程式碼中的額外屬性<a name="attached_properties_code"></a></span><span class="sxs-lookup"><span data-stu-id="1eee0-144">Attached Properties in Code <a name="attached_properties_code"></a></span></span>

<span data-ttu-id="1eee0-145">WPF 中的附加屬性沒有典型的 CLR"包裝器"方法,便於獲取/設置訪問。</span><span class="sxs-lookup"><span data-stu-id="1eee0-145">Attached properties in WPF do not have the typical CLR "wrapper" methods for easy get/set access.</span></span> <span data-ttu-id="1eee0-146">這是因為附加屬性不一定是設置該屬性的實例的 CLR 命名空間的一部分。</span><span class="sxs-lookup"><span data-stu-id="1eee0-146">This is because the attached property is not necessarily part of the CLR namespace for instances where the property is set.</span></span> <span data-ttu-id="1eee0-147">不過，XAML 處理器必須可以在剖析 XAML 時設定這些值。</span><span class="sxs-lookup"><span data-stu-id="1eee0-147">However, a XAML processor must be able to set those values when XAML is parsed.</span></span> <span data-ttu-id="1eee0-148">為了支援有效的附加屬性使用,附加屬性的擁有者類型必須在**Get_PropertyName_** 和**Set_PropertyName_** 的形式實現專用訪問器方法。</span><span class="sxs-lookup"><span data-stu-id="1eee0-148">To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form **Get_PropertyName_** and **Set_PropertyName_**.</span></span> <span data-ttu-id="1eee0-149">這些專用存取子方法也適用於取得或設定程式碼中的附加屬性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-149">These dedicated accessor methods are also useful to get or set the attached property in code.</span></span> <span data-ttu-id="1eee0-150">從程式碼觀點，附加屬性類似具有方法存取子而非屬性存取子的支援欄位，而且該支援欄位可以存在於任何物件，而不需要特別進行定義。</span><span class="sxs-lookup"><span data-stu-id="1eee0-150">From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</span></span>

<span data-ttu-id="1eee0-151">下列範例示範如何在程式碼中設定附加屬性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-151">The following example shows how you can set an attached property in code.</span></span> <span data-ttu-id="1eee0-152">在此範例中,`myCheckBox`是類<xref:System.Windows.Controls.CheckBox>的 實體。</span><span class="sxs-lookup"><span data-stu-id="1eee0-152">In this example, `myCheckBox` is an instance of the <xref:System.Windows.Controls.CheckBox> class.</span></span>

[!code-csharp[PropertiesOvwSupport#APCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

<span data-ttu-id="1eee0-153">與 XAML 案例`myCheckBox`類似, 如果第四行代碼尚未`myDockPanel`添加為子 元素,則第五行代碼不會引發異常,但<xref:System.Windows.Controls.DockPanel>屬性值不會與 父級交互,因此將不執行任何操作。</span><span class="sxs-lookup"><span data-stu-id="1eee0-153">Similar to the XAML case, if `myCheckBox` had not already been added as a child element of `myDockPanel` by the fourth line of code, the fifth line of code would not raise an exception, but the property value would not interact with a <xref:System.Windows.Controls.DockPanel> parent and thus would do nothing.</span></span> <span data-ttu-id="1eee0-154">只有子<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>元素上設置的值<xref:System.Windows.Controls.DockPanel>與 父元素的存在相結合,才會在呈現的應用程式中產生有效的行為。</span><span class="sxs-lookup"><span data-stu-id="1eee0-154">Only a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> value set on a child element combined with the presence of a <xref:System.Windows.Controls.DockPanel> parent element will cause an effective behavior in the rendered application.</span></span> <span data-ttu-id="1eee0-155">(在此情況下，您可以設定附加屬性，然後將其附加至樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="1eee0-155">(In this case, you could set the attached property, then attach to the tree.</span></span> <span data-ttu-id="1eee0-156">或者，您可以將其附加至樹狀結構，然後設定附加屬性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-156">Or you could attach to the tree then set the attached property.</span></span> <span data-ttu-id="1eee0-157">任一個動作順序都會提供相同的結果)。</span><span class="sxs-lookup"><span data-stu-id="1eee0-157">Either action order provides the same result.)</span></span>

## <a name="attached-property-metadata"></a><span data-ttu-id="1eee0-158">附加屬性中繼資料<a name="attached_properties_metadata"></a></span><span class="sxs-lookup"><span data-stu-id="1eee0-158">Attached Property Metadata <a name="attached_properties_metadata"></a></span></span>

<span data-ttu-id="1eee0-159">註冊屬性時,<xref:System.Windows.FrameworkPropertyMetadata>將設置為指定屬性的特徵,例如屬性是否影響渲染、測量等。</span><span class="sxs-lookup"><span data-stu-id="1eee0-159">When registering the property, <xref:System.Windows.FrameworkPropertyMetadata> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</span></span> <span data-ttu-id="1eee0-160">附加屬性的中繼資料一般與相依性屬性並無不同。</span><span class="sxs-lookup"><span data-stu-id="1eee0-160">Metadata for an attached property is generally no different than on a dependency property.</span></span> <span data-ttu-id="1eee0-161">如果您在附加屬性中繼資料的覆寫中指定預設值，該值會變成覆寫類別執行個體上的隱含附加屬性預設值。</span><span class="sxs-lookup"><span data-stu-id="1eee0-161">If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</span></span> <span data-ttu-id="1eee0-162">具體而言，如果某個處理序透過該屬性的 `Get` 方法存取子來查詢附加屬性值，並指定已指定中繼資料之類別的執行個體，則會報告預設值，否則不會設定該附加屬性的值。</span><span class="sxs-lookup"><span data-stu-id="1eee0-162">Specifically, your default value is reported if some process queries for the value of an attached property through the `Get` method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</span></span>

<span data-ttu-id="1eee0-163">如果您想要啟用屬性的屬性值繼承，則應該使用附加屬性，而不是使用非附加相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-163">If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</span></span> <span data-ttu-id="1eee0-164">如需詳細資訊，請參閱[屬性值繼承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="1eee0-164">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

## <a name="custom-attached-properties"></a><span data-ttu-id="1eee0-165">自訂附加屬性<a name="custom"></a></span><span class="sxs-lookup"><span data-stu-id="1eee0-165">Custom Attached Properties <a name="custom"></a></span></span>

### <a name="when-to-create-an-attached-property"></a><span data-ttu-id="1eee0-166">何時建立額外屬性<a name="create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="1eee0-166">When to Create an Attached Property <a name="create_attached_properties"></a></span></span>

<span data-ttu-id="1eee0-167">非定義類別的類別需要有可用的屬性設定機制時，您可以建立附加屬性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-167">You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</span></span> <span data-ttu-id="1eee0-168">最常見的案例是配置。</span><span class="sxs-lookup"><span data-stu-id="1eee0-168">The most common scenario for this is layout.</span></span> <span data-ttu-id="1eee0-169">現有佈局屬性的範例包括<xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType> <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType> 。</span><span class="sxs-lookup"><span data-stu-id="1eee0-169">Examples of existing layout properties are <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>, and <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="1eee0-170">在這裡啟用的情節是本身為配置控制項目之子項目的項目可以個別表達其配置父項目的配置需求，且各會設定父代定義為附加屬性的屬性值。</span><span class="sxs-lookup"><span data-stu-id="1eee0-170">The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</span></span>

<span data-ttu-id="1eee0-171">另一個使用附加屬性的情節是類別代表一項服務，而且想要類別能夠更緊密地整合服務。</span><span class="sxs-lookup"><span data-stu-id="1eee0-171">Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</span></span>

<span data-ttu-id="1eee0-172">另一種方案是接收可視化工作室 WPF 設計器支援,如**屬性**視窗編輯。</span><span class="sxs-lookup"><span data-stu-id="1eee0-172">Yet another scenario is to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="1eee0-173">如需詳細資訊，請參閱[控制項撰寫概觀](../controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="1eee0-173">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="1eee0-174">如前所述，如果您想要使用屬性值繼承，則應該註冊為附加屬性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-174">As mentioned before, you should register as an attached property if you want to use property value inheritance.</span></span>

### <a name="how-to-create-an-attached-property"></a><span data-ttu-id="1eee0-175">如何建立額外屬性<a name="how_do_i_create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="1eee0-175">How to Create an Attached Property <a name="how_do_i_create_attached_properties"></a></span></span>

<span data-ttu-id="1eee0-176">如果類嚴格定義附加屬性以用於其他類型,則類不必派生自<xref:System.Windows.DependencyObject>。</span><span class="sxs-lookup"><span data-stu-id="1eee0-176">If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="1eee0-177">但是,如果遵循具有附加屬性<xref:System.Windows.DependencyObject>也是依賴項屬性的整體 WPF 模型,則需要派生。</span><span class="sxs-lookup"><span data-stu-id="1eee0-177">But you do need to derive from <xref:System.Windows.DependencyObject> if you follow the overall WPF model of having your attached property also be a dependency property.</span></span>

<span data-ttu-id="1eee0-178">通過聲明類型`public static readonly`<xref:System.Windows.DependencyProperty>欄位,將附加屬性定義為依賴項屬性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-178">Define your attached property as a dependency property by declaring a `public static readonly` field of type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="1eee0-179">使用<xref:System.Windows.DependencyProperty.RegisterAttached%2A>方法的返回值定義此欄位。</span><span class="sxs-lookup"><span data-stu-id="1eee0-179">You define this field by using the return value of the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="1eee0-180">欄位名稱必須與附加的屬性名稱(隨字串`Property`一起追加)匹配,才能遵循已建立的 WPF 模式來命名標識欄位和它們表示的屬性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-180">The field name must match the attached property name, appended with the string `Property`, to follow the established WPF pattern of naming the identifying fields versus the properties that they represent.</span></span> <span data-ttu-id="1eee0-181">附加屬性提供程式還必須提供靜態**Get_PropertyName_** 和**Set_PropertyName_** 方法作為附加屬性的訪問器;如果不這樣做,將導致屬性系統無法使用附加屬性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-181">The attached property provider must also provide static **Get_PropertyName_** and **Set_PropertyName_** methods as accessors for the attached property; failing to do this will result in the property system being unable to use your attached property.</span></span>

> [!NOTE]
> <span data-ttu-id="1eee0-182">如果省略附加屬性的 get 訪問器,則屬性上的數據綁定在設計工具中不起作用,例如 Visual Studio 和 Visual Studio 的 Blend。</span><span class="sxs-lookup"><span data-stu-id="1eee0-182">If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as Visual Studio and Blend for Visual Studio.</span></span>

#### <a name="the-get-accessor"></a><span data-ttu-id="1eee0-183">Get 存取子</span><span class="sxs-lookup"><span data-stu-id="1eee0-183">The Get Accessor</span></span>

<span data-ttu-id="1eee0-184">**Get_PropertyName_** 存取器的簽名必須:</span><span class="sxs-lookup"><span data-stu-id="1eee0-184">The signature for the **Get_PropertyName_** accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="1eee0-185">`target` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="1eee0-185">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="1eee0-186">例如,<xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType>該方法將參數類型<xref:System.Windows.UIElement>為 ,因為附加的屬性僅用於在實<xref:System.Windows.UIElement>例上 設置。</span><span class="sxs-lookup"><span data-stu-id="1eee0-186">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> method types the parameter as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="1eee0-187">傳回值可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="1eee0-187">The return value can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="1eee0-188">例如,<xref:System.Windows.Controls.DockPanel.GetDock%2A>方法將其類型<xref:System.Windows.Controls.Dock>為 ,因為該值只能設置為該枚舉。</span><span class="sxs-lookup"><span data-stu-id="1eee0-188">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span>

#### <a name="the-set-accessor"></a><span data-ttu-id="1eee0-189">Set 存取子</span><span class="sxs-lookup"><span data-stu-id="1eee0-189">The Set Accessor</span></span>

<span data-ttu-id="1eee0-190">**Set_PropertyName_** 存取器的簽章必須:</span><span class="sxs-lookup"><span data-stu-id="1eee0-190">The signature for the **Set_PropertyName_** accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="1eee0-191">`target` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="1eee0-191">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="1eee0-192">例如,<xref:System.Windows.Controls.DockPanel.SetDock%2A>該方法將其鍵入<xref:System.Windows.UIElement>為 ,因為附加的屬性僅用於在實<xref:System.Windows.UIElement>例上 設置。</span><span class="sxs-lookup"><span data-stu-id="1eee0-192">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="1eee0-193">`value` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="1eee0-193">The `value` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="1eee0-194">例如,<xref:System.Windows.Controls.DockPanel.SetDock%2A>方法將其類型<xref:System.Windows.Controls.Dock>為 ,因為該值只能設置為該枚舉。</span><span class="sxs-lookup"><span data-stu-id="1eee0-194">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span> <span data-ttu-id="1eee0-195">請記住，當這個方法在標記的附加屬性使用方式中遇到附加屬性時，其值是來自 XAML 載入器的輸入。</span><span class="sxs-lookup"><span data-stu-id="1eee0-195">Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</span></span> <span data-ttu-id="1eee0-196">該輸入是指定為標記中 XAML 屬性值的值。</span><span class="sxs-lookup"><span data-stu-id="1eee0-196">That input is the value specified as a XAML attribute value in markup.</span></span> <span data-ttu-id="1eee0-197">因此，您使用的類型必須要有類型轉換、值序列化程式或標記延伸支援，因此，可以從屬性值 (這最後就是一個字串) 建立適當的類型。</span><span class="sxs-lookup"><span data-stu-id="1eee0-197">Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</span></span>

<span data-ttu-id="1eee0-198">下面的範例顯示依賴項屬性註冊(使用方法<xref:System.Windows.DependencyProperty.RegisterAttached%2A>),以及**Get_PropertyName_** 和**訪問者Set_PropertyName_。**</span><span class="sxs-lookup"><span data-stu-id="1eee0-198">The following example shows the dependency property registration (using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method), as well as the **Get_PropertyName_** and **Set_PropertyName_** accessors.</span></span> <span data-ttu-id="1eee0-199">在此範例中，附加屬性名稱為 `IsBubbleSource`。</span><span class="sxs-lookup"><span data-stu-id="1eee0-199">In the example, the attached property name is `IsBubbleSource`.</span></span> <span data-ttu-id="1eee0-200">因此，存取子必須命名為 `GetIsBubbleSource` 和 `SetIsBubbleSource`。</span><span class="sxs-lookup"><span data-stu-id="1eee0-200">Therefore, the accessors must be named `GetIsBubbleSource` and `SetIsBubbleSource`.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a><span data-ttu-id="1eee0-201">附加屬性 (property) 的屬性 (attribute)</span><span class="sxs-lookup"><span data-stu-id="1eee0-201">Attached Property Attributes</span></span>

<span data-ttu-id="1eee0-202">WPF 定義多個 .NET 屬性,用於提供有關反射進程附加屬性的資訊,以及反射和屬性資訊的典型使用者(如設計器)。</span><span class="sxs-lookup"><span data-stu-id="1eee0-202">WPF defines several .NET attributes that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</span></span> <span data-ttu-id="1eee0-203">因為附加屬性的類型為無限制範圍，所以設計人員需要方法來避免使用 XAML 的特定技術實作中所定義之所有附加屬性的全域清單，讓使用者無所適從。</span><span class="sxs-lookup"><span data-stu-id="1eee0-203">Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</span></span> <span data-ttu-id="1eee0-204">WPF 為附加屬性定義的 .NET 屬性可用於限定給定附加屬性應在屬性視窗中顯示的情況。</span><span class="sxs-lookup"><span data-stu-id="1eee0-204">The .NET attributes that WPF defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</span></span> <span data-ttu-id="1eee0-205">您也可以考慮針對您自己的自訂附加屬性套用這些屬性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-205">You might consider applying these attributes for your own custom attached properties also.</span></span> <span data-ttu-id="1eee0-206">.NET 屬性的用途和語法在相應的參考頁上描述:</span><span class="sxs-lookup"><span data-stu-id="1eee0-206">The purpose and syntax of the .NET attributes is described on the appropriate reference pages:</span></span>

- <xref:System.Windows.AttachedPropertyBrowsableAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## <a name="learning-more-about-attached-properties"></a><span data-ttu-id="1eee0-207">瞭解有關額外屬性的更多<a name="more"></a></span><span class="sxs-lookup"><span data-stu-id="1eee0-207">Learning More About Attached Properties <a name="more"></a></span></span>

- <span data-ttu-id="1eee0-208">如需建立附加屬性的詳細資訊，請參閱[註冊附加屬性](how-to-register-an-attached-property.md)。</span><span class="sxs-lookup"><span data-stu-id="1eee0-208">For more information on creating an attached property, see [Register an Attached Property](how-to-register-an-attached-property.md).</span></span>

- <span data-ttu-id="1eee0-209">如需相依性屬性和附加屬性的更進階使用方式情節，請參閱[自訂相依性屬性](custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="1eee0-209">For more advanced usage scenarios for dependency properties and attached properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>

- <span data-ttu-id="1eee0-210">您也可以將屬性註冊為附加屬性和相依性屬性，但仍公開「包裝函式」實作。</span><span class="sxs-lookup"><span data-stu-id="1eee0-210">You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</span></span> <span data-ttu-id="1eee0-211">在此情況下，可以在該項目上設定屬性，或透過 XAML 附加屬性語法的任何項目上設定屬性。</span><span class="sxs-lookup"><span data-stu-id="1eee0-211">In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</span></span> <span data-ttu-id="1eee0-212">具有適用於標準和附加用法的相應機制的屬性的範例是<xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="1eee0-212">An example of a property with an appropriate scenario for both standard and attached usages is <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="1eee0-213">另請參閱</span><span class="sxs-lookup"><span data-stu-id="1eee0-213">See also</span></span>

- <xref:System.Windows.DependencyProperty>
- [<span data-ttu-id="1eee0-214">相依性屬性概觀</span><span class="sxs-lookup"><span data-stu-id="1eee0-214">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="1eee0-215">自訂相依性屬性</span><span class="sxs-lookup"><span data-stu-id="1eee0-215">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="1eee0-216">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="1eee0-216">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="1eee0-217">註冊附加屬性</span><span class="sxs-lookup"><span data-stu-id="1eee0-217">Register an Attached Property</span></span>](how-to-register-an-attached-property.md)
