---
title: 附加屬性概觀
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- attached properties [WPF Designer]
ms.assetid: 75928354-dc01-47e8-a018-8409aec1f32d
ms.openlocfilehash: cee80ca0880e046870f699f45624df61ee507a47
ms.sourcegitcommit: 82f94a44ad5c64a399df2a03fa842db308185a76
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/25/2019
ms.locfileid: "72919854"
---
# <a name="attached-properties-overview"></a><span data-ttu-id="268e3-102">附加屬性概觀</span><span class="sxs-lookup"><span data-stu-id="268e3-102">Attached Properties Overview</span></span>

<span data-ttu-id="268e3-103">附加屬性是透過 XAML 所定義的概觀。</span><span class="sxs-lookup"><span data-stu-id="268e3-103">An attached property is a concept defined by XAML.</span></span> <span data-ttu-id="268e3-104">附加屬性是要用作可在任何物件上設定的全域屬性類型。</span><span class="sxs-lookup"><span data-stu-id="268e3-104">An attached property is intended to be used as a type of global property that is settable on any object.</span></span> <span data-ttu-id="268e3-105">在 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 中，附加屬性一般會定義為沒有傳統屬性「包裝函式」的特殊形式相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-105">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], attached properties are typically defined as a specialized form of dependency property that does not have the conventional property "wrapper".</span></span>

## <span data-ttu-id="268e3-106">要求<a name="prerequisites"></a></span><span class="sxs-lookup"><span data-stu-id="268e3-106">Prerequisites <a name="prerequisites"></a></span></span>

<span data-ttu-id="268e3-107">本主題假設您已從 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 類別的現有相依性屬性消費者角度了解相依性屬性，並已閱讀[相依性屬性概觀](dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="268e3-107">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md).</span></span> <span data-ttu-id="268e3-108">若要遵循本主題中的範例，您也應該瞭解 XAML 並知道如何撰寫 WPF 應用程式。</span><span class="sxs-lookup"><span data-stu-id="268e3-108">To follow the examples in this topic, you should also understand XAML and know how to write WPF applications.</span></span>

## <span data-ttu-id="268e3-109">為何要使用附加屬性<a name="attached_properties_usage"></a></span><span class="sxs-lookup"><span data-stu-id="268e3-109">Why Use Attached Properties <a name="attached_properties_usage"></a></span></span>

<span data-ttu-id="268e3-110">附加屬性的其中一個用途是允許不同的子項目指定父項目中實際定義的屬性的唯一值。</span><span class="sxs-lookup"><span data-stu-id="268e3-110">One purpose of an attached property is to allow different child elements to specify unique values for a property that is actually defined in a parent element.</span></span> <span data-ttu-id="268e3-111">此情節的特定應用程式可讓子項目通知父項目，有關如何在 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)] 中呈現它們。</span><span class="sxs-lookup"><span data-stu-id="268e3-111">A specific application of this scenario is having child elements inform the parent element of how they are to be presented in the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="268e3-112">其中一個範例是 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 的屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-112">One example is the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="268e3-113"><xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 屬性會建立為附加屬性，因為它是設計來在包含于 <xref:System.Windows.Controls.DockPanel>中的元素上設定，而不是在 <xref:System.Windows.Controls.DockPanel> 本身。</span><span class="sxs-lookup"><span data-stu-id="268e3-113">The <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> property is created as an attached property because it is designed to be set on elements that are contained within a <xref:System.Windows.Controls.DockPanel>, rather than on <xref:System.Windows.Controls.DockPanel> itself.</span></span> <span data-ttu-id="268e3-114"><xref:System.Windows.Controls.DockPanel> 類別會定義名為 <xref:System.Windows.Controls.DockPanel.DockProperty>的靜態 <xref:System.Windows.DependencyProperty> 欄位，然後提供 <xref:System.Windows.Controls.DockPanel.GetDock%2A> 和 <xref:System.Windows.Controls.DockPanel.SetDock%2A> 方法做為附加屬性的公用存取子。</span><span class="sxs-lookup"><span data-stu-id="268e3-114">The <xref:System.Windows.Controls.DockPanel> class defines the static <xref:System.Windows.DependencyProperty> field named <xref:System.Windows.Controls.DockPanel.DockProperty>, and then provides the <xref:System.Windows.Controls.DockPanel.GetDock%2A> and <xref:System.Windows.Controls.DockPanel.SetDock%2A> methods as public accessors for the attached property.</span></span>

## <span data-ttu-id="268e3-115">XAML 中的附加屬性<a name="attached_properties_xaml"></a></span><span class="sxs-lookup"><span data-stu-id="268e3-115">Attached Properties in XAML <a name="attached_properties_xaml"></a></span></span>

<span data-ttu-id="268e3-116">在 XAML 中，您可以使用 *AttachedPropertyProvider*.<屬性名稱> 語法來設定附加屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-116">In XAML, you set attached properties by using the syntax *AttachedPropertyProvider*.*PropertyName*</span></span>

<span data-ttu-id="268e3-117">以下是您可以如何在 XAML 中設定 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 的範例：</span><span class="sxs-lookup"><span data-stu-id="268e3-117">The following is an example of how you can set <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> in XAML:</span></span>

[!code-xaml[PropertiesOvwSupport#APBasicUsage](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml#apbasicusage)]

<span data-ttu-id="268e3-118">請注意，使用方式與靜態屬性有點類似;您一律會參考擁有和註冊附加屬性 <xref:System.Windows.Controls.DockPanel> 的類型，而不是參照依名稱指定的任何實例。</span><span class="sxs-lookup"><span data-stu-id="268e3-118">Note that the usage is somewhat similar to a static property; you always reference the type <xref:System.Windows.Controls.DockPanel> that owns and registers the attached property, rather than referring to any instance specified by name.</span></span>

<span data-ttu-id="268e3-119">此外，因為 XAML 中的附加屬性是您在標記中設定的屬性，所以只有設定作業才會有任何相關性。</span><span class="sxs-lookup"><span data-stu-id="268e3-119">Also, because an attached property in XAML is an attribute that you set in markup, only the set operation has any relevance.</span></span> <span data-ttu-id="268e3-120">雖然有一些間接機制可比較值 (例如樣式中的觸發程序)，但是您無法在 XAML 中直接取得屬性 (如需詳細資訊，請參閱[設定樣式和範本](../controls/styling-and-templating.md))。</span><span class="sxs-lookup"><span data-stu-id="268e3-120">You cannot directly get a property in XAML, although there are some indirect mechanisms for comparing values, such as triggers in styles (for details, see [Styling and Templating](../controls/styling-and-templating.md)).</span></span>

### <a name="attached-property-implementation-in-wpf"></a><span data-ttu-id="268e3-121">WPF 中的附加屬性實作</span><span class="sxs-lookup"><span data-stu-id="268e3-121">Attached Property Implementation in WPF</span></span>

<span data-ttu-id="268e3-122">在 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)]中，存在於與 UI 呈現相關的 WPF 類型上的大部分附加屬性都會實作為相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-122">In [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)], most of the attached properties that exist on WPF types that are related to UI presentation are implemented as dependency properties.</span></span> <span data-ttu-id="268e3-123">附加屬性是 XAML 概念，而相依性屬性則是 WPF 概念。</span><span class="sxs-lookup"><span data-stu-id="268e3-123">Attached properties are a XAML concept, whereas dependency properties are a WPF concept.</span></span> <span data-ttu-id="268e3-124">由於 WPF 附加屬性是相依性屬性，因此支援相依性屬性概念，例如屬性中繼資料，以及來自該屬性中繼資料的預設值。</span><span class="sxs-lookup"><span data-stu-id="268e3-124">Because WPF attached properties are dependency properties, they support dependency property concepts such as property metadata, and default values from that property metadata.</span></span>

## <span data-ttu-id="268e3-125">擁有類型如何使用附加屬性<a name="howused"></a></span><span class="sxs-lookup"><span data-stu-id="268e3-125">How Attached Properties Are Used by the Owning Type <a name="howused"></a></span></span>

<span data-ttu-id="268e3-126">雖然可在任何物件上設定附加屬性，但是這不自動表示設定屬性就會產生明確結果，或者另一個物件將使用值。</span><span class="sxs-lookup"><span data-stu-id="268e3-126">Although attached properties are settable on any object, that does not automatically mean that setting the property will produce a tangible result, or that the value will ever be used by another object.</span></span> <span data-ttu-id="268e3-127">一般而言，會使用附加屬性，讓來自各種可能類別階層或邏輯關聯性的物件都可以報告可定義附加屬性之類型的通用資訊。</span><span class="sxs-lookup"><span data-stu-id="268e3-127">Generally, attached properties are intended so that objects coming from a wide variety of possible class hierarchies or logical relationships can each report common information to the type that defines the attached property.</span></span> <span data-ttu-id="268e3-128">可定義附加屬性的類型通常會遵循下列其中一個模型︰</span><span class="sxs-lookup"><span data-stu-id="268e3-128">The type that defines the attached property typically follows one of these models:</span></span>

- <span data-ttu-id="268e3-129">設計可定義附加屬性的類型，因此它可以是設定附加屬性值之項目的父項目。</span><span class="sxs-lookup"><span data-stu-id="268e3-129">The type that defines the attached property is designed so that it can be the parent element of the elements that will set values for the attached property.</span></span> <span data-ttu-id="268e3-130">類型接著會透過內部邏輯針對某個物件樹狀結構逐一查看其子物件，並取得值，然後以某種方式處理這些值。</span><span class="sxs-lookup"><span data-stu-id="268e3-130">The type then iterates its child objects through internal logic against some object tree structure, obtains the values, and acts on those values in some manner.</span></span>

- <span data-ttu-id="268e3-131">可定義附加屬性的類型將會用作各種可能父項目和內容模組的子項目。</span><span class="sxs-lookup"><span data-stu-id="268e3-131">The type that defines the attached property will be used as the child element for a variety of possible parent elements and content models.</span></span>

- <span data-ttu-id="268e3-132">可定義附加屬性的類型代表服務。</span><span class="sxs-lookup"><span data-stu-id="268e3-132">The type that defines the attached property represents a service.</span></span> <span data-ttu-id="268e3-133">其他類型設定附加屬性的值。</span><span class="sxs-lookup"><span data-stu-id="268e3-133">Other types set values for the attached property.</span></span> <span data-ttu-id="268e3-134">然後，在服務內容中評估可設定屬性的項目時，會透過服務類別的內部邏輯取得附加屬性值。</span><span class="sxs-lookup"><span data-stu-id="268e3-134">Then, when the element that set the property is evaluated in the context of the service, the attached property values are obtained through internal logic of the service class.</span></span>

### <a name="an-example-of-a-parent-defined-attached-property"></a><span data-ttu-id="268e3-135">父代已定義的附加屬性範例</span><span class="sxs-lookup"><span data-stu-id="268e3-135">An Example of a Parent-Defined Attached Property</span></span>

<span data-ttu-id="268e3-136">WPF 定義附加屬性的最常見案例是當父元素支援子專案集合時，也會執行行為，其中會針對每個子專案個別報告行為的細節。</span><span class="sxs-lookup"><span data-stu-id="268e3-136">The most typical scenario where WPF defines an attached property is when a parent element supports a child element collection, and also implements a behavior where the specifics of the behavior are reported individually for each child element.</span></span>

<span data-ttu-id="268e3-137"><xref:System.Windows.Controls.DockPanel> 定義 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 附加屬性，而且 <xref:System.Windows.Controls.DockPanel> 具有類別層級程式碼作為其轉譯邏輯的一部分（具體而言，<xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> 和 <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>）。</span><span class="sxs-lookup"><span data-stu-id="268e3-137"><xref:System.Windows.Controls.DockPanel> defines the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property, and <xref:System.Windows.Controls.DockPanel> has class-level code as part of its rendering logic (specifically, <xref:System.Windows.Controls.DockPanel.MeasureOverride%2A> and <xref:System.Windows.Controls.DockPanel.ArrangeOverride%2A>).</span></span> <span data-ttu-id="268e3-138"><xref:System.Windows.Controls.DockPanel> 實例一律會檢查是否有任何直屬子專案已設定 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>的值。</span><span class="sxs-lookup"><span data-stu-id="268e3-138">A <xref:System.Windows.Controls.DockPanel> instance will always check to see whether any of its immediate child elements have set a value for <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="268e3-139">如果是這樣，這些值會變成套用至該特定子項目之轉譯邏輯的輸入。</span><span class="sxs-lookup"><span data-stu-id="268e3-139">If so, those values become input for the rendering logic applied to that particular child element.</span></span> <span data-ttu-id="268e3-140">嵌套的 <xref:System.Windows.Controls.DockPanel> 實例分別會處理自己的直屬子專案集合，但該行為會因 <xref:System.Windows.Controls.DockPanel> 處理 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 值的方式而異。</span><span class="sxs-lookup"><span data-stu-id="268e3-140">Nested <xref:System.Windows.Controls.DockPanel> instances each treat their own immediate child element collections, but that behavior is implementation-specific to how <xref:System.Windows.Controls.DockPanel> processes <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> values.</span></span> <span data-ttu-id="268e3-141">理論上，可能會有附加屬性影響直屬父代以外的項目。</span><span class="sxs-lookup"><span data-stu-id="268e3-141">It is theoretically possible to have attached properties that influence elements beyond the immediate parent.</span></span> <span data-ttu-id="268e3-142">如果在沒有 <xref:System.Windows.Controls.DockPanel> 父元素的元素上設定 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 附加屬性來對它採取動作，則不會引發錯誤或例外狀況。</span><span class="sxs-lookup"><span data-stu-id="268e3-142">If the <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> attached property is set on an element that has no <xref:System.Windows.Controls.DockPanel> parent element to act upon it, no error or exception is raised.</span></span> <span data-ttu-id="268e3-143">這只是表示已設定全域屬性值，但目前沒有任何可能會耗用資訊的 <xref:System.Windows.Controls.DockPanel> 父系。</span><span class="sxs-lookup"><span data-stu-id="268e3-143">This simply means that a global property value was set, but it has no current <xref:System.Windows.Controls.DockPanel> parent that could consume the information.</span></span>

## <span data-ttu-id="268e3-144">程式碼中的附加屬性<a name="attached_properties_code"></a></span><span class="sxs-lookup"><span data-stu-id="268e3-144">Attached Properties in Code <a name="attached_properties_code"></a></span></span>

<span data-ttu-id="268e3-145">WPF 中附加的屬性沒有一般的 CLR 「包裝函式」方法，可輕鬆取得/設定存取。</span><span class="sxs-lookup"><span data-stu-id="268e3-145">Attached properties in WPF do not have the typical CLR "wrapper" methods for easy get/set access.</span></span> <span data-ttu-id="268e3-146">這是因為附加屬性不一定是設定屬性之實例的 CLR 命名空間的一部分。</span><span class="sxs-lookup"><span data-stu-id="268e3-146">This is because the attached property is not necessarily part of the CLR namespace for instances where the property is set.</span></span> <span data-ttu-id="268e3-147">不過，XAML 處理器必須可以在剖析 XAML 時設定這些值。</span><span class="sxs-lookup"><span data-stu-id="268e3-147">However, a XAML processor must be able to set those values when XAML is parsed.</span></span> <span data-ttu-id="268e3-148">若要支援有效的附加屬性使用方式，附加屬性的擁有者類型必須以**Get_PropertyName_** 和**Set_PropertyName_** 格式來實作為專用存取子方法。</span><span class="sxs-lookup"><span data-stu-id="268e3-148">To support an effective attached property usage, the owner type of the attached property must implement dedicated accessor methods in the form **Get_PropertyName_** and **Set_PropertyName_**.</span></span> <span data-ttu-id="268e3-149">這些專用存取子方法也適用於取得或設定程式碼中的附加屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-149">These dedicated accessor methods are also useful to get or set the attached property in code.</span></span> <span data-ttu-id="268e3-150">從程式碼觀點，附加屬性類似具有方法存取子而非屬性存取子的支援欄位，而且該支援欄位可以存在於任何物件，而不需要特別進行定義。</span><span class="sxs-lookup"><span data-stu-id="268e3-150">From a code perspective, an attached property is similar to a backing field that has method accessors instead of property accessors, and that backing field can exist on any object rather than needing to be specifically defined.</span></span>

<span data-ttu-id="268e3-151">下列範例示範如何在程式碼中設定附加屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-151">The following example shows how you can set an attached property in code.</span></span> <span data-ttu-id="268e3-152">在此範例中，`myCheckBox` 是 <xref:System.Windows.Controls.CheckBox> 類別的實例。</span><span class="sxs-lookup"><span data-stu-id="268e3-152">In this example, `myCheckBox` is an instance of the <xref:System.Windows.Controls.CheckBox> class.</span></span>

[!code-csharp[PropertiesOvwSupport#APCode](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page4.xaml.cs#apcode)]
[!code-vb[PropertiesOvwSupport#APCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page4.xaml.vb#apcode)]

<span data-ttu-id="268e3-153">類似于 XAML 案例，如果 `myCheckBox` 尚未新增為第三行程式碼所 `myDockPanel` 的子項目，則第四行程式碼不會引發例外狀況，但屬性值不會與 <xref:System.Windows.Controls.DockPanel> 父系互動，因此會執行這裡.</span><span class="sxs-lookup"><span data-stu-id="268e3-153">Similar to the XAML case, if `myCheckBox` had not already been added as a child element of `myDockPanel` by the third line of code, the fourth line of code would not raise an exception, but the property value would not interact with a <xref:System.Windows.Controls.DockPanel> parent and thus would do nothing.</span></span> <span data-ttu-id="268e3-154">只有在子項目上設定的 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> 值與 <xref:System.Windows.Controls.DockPanel> 父元素的存在結合，才會在轉譯的應用程式中造成有效的行為。</span><span class="sxs-lookup"><span data-stu-id="268e3-154">Only a <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> value set on a child element combined with the presence of a <xref:System.Windows.Controls.DockPanel> parent element will cause an effective behavior in the rendered application.</span></span> <span data-ttu-id="268e3-155">(在此情況下，您可以設定附加屬性，然後將其附加至樹狀結構。</span><span class="sxs-lookup"><span data-stu-id="268e3-155">(In this case, you could set the attached property, then attach to the tree.</span></span> <span data-ttu-id="268e3-156">或者，您可以將其附加至樹狀結構，然後設定附加屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-156">Or you could attach to the tree then set the attached property.</span></span> <span data-ttu-id="268e3-157">任一個動作順序都會提供相同的結果)。</span><span class="sxs-lookup"><span data-stu-id="268e3-157">Either action order provides the same result.)</span></span>

## <span data-ttu-id="268e3-158">附加屬性中繼資料<a name="attached_properties_metadata"></a></span><span class="sxs-lookup"><span data-stu-id="268e3-158">Attached Property Metadata <a name="attached_properties_metadata"></a></span></span>

<span data-ttu-id="268e3-159">註冊屬性時，<xref:System.Windows.FrameworkPropertyMetadata> 設定為指定屬性的特性，例如屬性是否會影響轉譯、測量等等。</span><span class="sxs-lookup"><span data-stu-id="268e3-159">When registering the property, <xref:System.Windows.FrameworkPropertyMetadata> is set to specify characteristics of the property, such as whether the property affects rendering, measurement, and so on.</span></span> <span data-ttu-id="268e3-160">附加屬性的中繼資料一般與相依性屬性並無不同。</span><span class="sxs-lookup"><span data-stu-id="268e3-160">Metadata for an attached property is generally no different than on a dependency property.</span></span> <span data-ttu-id="268e3-161">如果您在附加屬性中繼資料的覆寫中指定預設值，該值會變成覆寫類別執行個體上的隱含附加屬性預設值。</span><span class="sxs-lookup"><span data-stu-id="268e3-161">If you specify a default value in an override to attached property metadata, that value becomes the default value of the implicit attached property on instances of the overriding class.</span></span> <span data-ttu-id="268e3-162">具體而言，如果某個處理序透過該屬性的 `Get` 方法存取子來查詢附加屬性值，並指定已指定中繼資料之類別的執行個體，則會報告預設值，否則不會設定該附加屬性的值。</span><span class="sxs-lookup"><span data-stu-id="268e3-162">Specifically, your default value is reported if some process queries for the value of an attached property through the `Get` method accessor for that property, specifying an instance of the class where you specified the metadata, and the value for that attached property was otherwise not set.</span></span>

<span data-ttu-id="268e3-163">如果您想要啟用屬性的屬性值繼承，則應該使用附加屬性，而不是使用非附加相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-163">If you want to enable property value inheritance on a property, you should use attached properties rather than non-attached dependency properties.</span></span> <span data-ttu-id="268e3-164">如需詳細資訊，請參閱[屬性值繼承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="268e3-164">For details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

## <span data-ttu-id="268e3-165">自訂附加屬性<a name="custom"></a></span><span class="sxs-lookup"><span data-stu-id="268e3-165">Custom Attached Properties <a name="custom"></a></span></span>

### <span data-ttu-id="268e3-166">建立附加屬性的時機<a name="create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="268e3-166">When to Create an Attached Property <a name="create_attached_properties"></a></span></span>

<span data-ttu-id="268e3-167">非定義類別的類別需要有可用的屬性設定機制時，您可以建立附加屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-167">You might create an attached property when there is a reason to have a property setting mechanism available for classes other than the defining class.</span></span> <span data-ttu-id="268e3-168">最常見的案例是配置。</span><span class="sxs-lookup"><span data-stu-id="268e3-168">The most common scenario for this is layout.</span></span> <span data-ttu-id="268e3-169">現有版面配置屬性的範例包括 <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>、<xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>和 <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="268e3-169">Examples of existing layout properties are <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType>, <xref:System.Windows.Controls.Panel.ZIndex%2A?displayProperty=nameWithType>, and <xref:System.Windows.Controls.Canvas.Top%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="268e3-170">在這裡啟用的情節是本身為配置控制項目之子項目的項目可以個別表達其配置父項目的配置需求，且各會設定父代定義為附加屬性的屬性值。</span><span class="sxs-lookup"><span data-stu-id="268e3-170">The scenario enabled here is that elements that exist as child elements to layout-controlling elements are able to express layout requirements to their layout parent elements individually, each setting a property value that the parent defined as an attached property.</span></span>

<span data-ttu-id="268e3-171">另一個使用附加屬性的情節是類別代表一項服務，而且想要類別能夠更緊密地整合服務。</span><span class="sxs-lookup"><span data-stu-id="268e3-171">Another scenario for using an attached property is when your class represents a service, and you want classes to be able to integrate the service more transparently.</span></span>

<span data-ttu-id="268e3-172">另一種情況是接收 Visual Studio WPF 設計工具支援，例如 [**屬性**] 視窗編輯。</span><span class="sxs-lookup"><span data-stu-id="268e3-172">Yet another scenario is to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="268e3-173">如需詳細資訊，請參閱[控制項撰寫概觀](../controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="268e3-173">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="268e3-174">如前所述，如果您想要使用屬性值繼承，則應該註冊為附加屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-174">As mentioned before, you should register as an attached property if you want to use property value inheritance.</span></span>

### <span data-ttu-id="268e3-175">如何建立附加屬性<a name="how_do_i_create_attached_properties"></a></span><span class="sxs-lookup"><span data-stu-id="268e3-175">How to Create an Attached Property <a name="how_do_i_create_attached_properties"></a></span></span>

<span data-ttu-id="268e3-176">如果您的類別是嚴格定義附加屬性以用於其他類型，則類別不需要衍生自 <xref:System.Windows.DependencyObject>。</span><span class="sxs-lookup"><span data-stu-id="268e3-176">If your class is defining the attached property strictly for use on other types, then the class does not have to derive from <xref:System.Windows.DependencyObject>.</span></span> <span data-ttu-id="268e3-177">但是，如果您遵循整體 WPF 模型讓附加屬性也是相依性屬性，則需要從 <xref:System.Windows.DependencyObject> 衍生。</span><span class="sxs-lookup"><span data-stu-id="268e3-177">But you do need to derive from <xref:System.Windows.DependencyObject> if you follow the overall WPF model of having your attached property also be a dependency property.</span></span>

<span data-ttu-id="268e3-178">藉由宣告 <xref:System.Windows.DependencyProperty>類型的 `public static readonly` 欄位，將附加屬性定義為相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-178">Define your attached property as a dependency property by declaring a `public static readonly` field of type <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="268e3-179">您可以使用 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 方法的傳回值來定義此欄位。</span><span class="sxs-lookup"><span data-stu-id="268e3-179">You define this field by using the return value of the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method.</span></span> <span data-ttu-id="268e3-180">功能變數名稱必須符合附加屬性名稱（附加字串 `Property`），才能遵循已建立的 WPF 模式來命名識別欄位與它們所代表的屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-180">The field name must match the attached property name, appended with the string `Property`, to follow the established WPF pattern of naming the identifying fields versus the properties that they represent.</span></span> <span data-ttu-id="268e3-181">附加屬性提供者也必須提供靜態**Get_PropertyName_** 和**Set_PropertyName_** 方法，做為附加屬性的存取子;如果無法這麼做，就會導致屬性系統無法使用您的附加屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-181">The attached property provider must also provide static **Get_PropertyName_** and **Set_PropertyName_** methods as accessors for the attached property; failing to do this will result in the property system being unable to use your attached property.</span></span>

> [!NOTE]
> <span data-ttu-id="268e3-182">如果您省略附加屬性的 get 存取子，屬性上的資料系結將無法在設計工具中使用，例如 Visual Studio 和 Blend for Visual Studio。</span><span class="sxs-lookup"><span data-stu-id="268e3-182">If you omit the attached property's get accessor, data binding on the property will not work in design tools, such as Visual Studio and Blend for Visual Studio.</span></span>

#### <a name="the-get-accessor"></a><span data-ttu-id="268e3-183">Get 存取子</span><span class="sxs-lookup"><span data-stu-id="268e3-183">The Get Accessor</span></span>

<span data-ttu-id="268e3-184">**Get_PropertyName_** 存取子的簽章必須是：</span><span class="sxs-lookup"><span data-stu-id="268e3-184">The signature for the **Get_PropertyName_** accessor must be:</span></span>

`public static object GetPropertyName(object target)`

- <span data-ttu-id="268e3-185">`target` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="268e3-185">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="268e3-186">例如，<xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> 方法會將參數當做 <xref:System.Windows.UIElement>輸入，因為附加屬性僅適用于 <xref:System.Windows.UIElement> 實例上設定。</span><span class="sxs-lookup"><span data-stu-id="268e3-186">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A?displayProperty=nameWithType> method types the parameter as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="268e3-187">傳回值可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="268e3-187">The return value can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="268e3-188">例如，<xref:System.Windows.Controls.DockPanel.GetDock%2A> 方法會將其輸入 <xref:System.Windows.Controls.Dock>，因為該值只能設定為該列舉。</span><span class="sxs-lookup"><span data-stu-id="268e3-188">For example, the <xref:System.Windows.Controls.DockPanel.GetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span>

#### <a name="the-set-accessor"></a><span data-ttu-id="268e3-189">Set 存取子</span><span class="sxs-lookup"><span data-stu-id="268e3-189">The Set Accessor</span></span>

<span data-ttu-id="268e3-190">**Set_PropertyName_** 存取子的簽章必須是：</span><span class="sxs-lookup"><span data-stu-id="268e3-190">The signature for the **Set_PropertyName_** accessor must be:</span></span>

`public static void SetPropertyName(object target, object value)`

- <span data-ttu-id="268e3-191">`target` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="268e3-191">The `target` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="268e3-192">例如，<xref:System.Windows.Controls.DockPanel.SetDock%2A> 方法會將其輸入 <xref:System.Windows.UIElement>，因為附加屬性僅適用于 <xref:System.Windows.UIElement> 實例上設定。</span><span class="sxs-lookup"><span data-stu-id="268e3-192">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.UIElement>, because the attached property is only intended to be set on <xref:System.Windows.UIElement> instances.</span></span>

- <span data-ttu-id="268e3-193">`value` 物件可以指定為實作中的更特定類型。</span><span class="sxs-lookup"><span data-stu-id="268e3-193">The `value` object can be specified as a more specific type in your implementation.</span></span> <span data-ttu-id="268e3-194">例如，<xref:System.Windows.Controls.DockPanel.SetDock%2A> 方法會將其輸入 <xref:System.Windows.Controls.Dock>，因為該值只能設定為該列舉。</span><span class="sxs-lookup"><span data-stu-id="268e3-194">For example, the <xref:System.Windows.Controls.DockPanel.SetDock%2A> method types it as <xref:System.Windows.Controls.Dock>, because the value can only be set to that enumeration.</span></span> <span data-ttu-id="268e3-195">請記住，當這個方法在標記的附加屬性使用方式中遇到附加屬性時，其值是來自 XAML 載入器的輸入。</span><span class="sxs-lookup"><span data-stu-id="268e3-195">Remember that the value for this method is the input coming from the XAML loader when it encounters your attached property in an attached property usage in markup.</span></span> <span data-ttu-id="268e3-196">該輸入是指定為標記中 XAML 屬性值的值。</span><span class="sxs-lookup"><span data-stu-id="268e3-196">That input is the value specified as a XAML attribute value in markup.</span></span> <span data-ttu-id="268e3-197">因此，您使用的類型必須要有類型轉換、值序列化程式或標記延伸支援，因此，可以從屬性值 (這最後就是一個字串) 建立適當的類型。</span><span class="sxs-lookup"><span data-stu-id="268e3-197">Therefore there must be type conversion, value serializer, or markup extension support for the type you use, such that the appropriate type can be created from the attribute value (which is ultimately just a string).</span></span>

<span data-ttu-id="268e3-198">下列範例顯示相依性屬性註冊（使用 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 方法），以及**Get_PropertyName_** 和**Set_PropertyName_** 存取子。</span><span class="sxs-lookup"><span data-stu-id="268e3-198">The following example shows the dependency property registration (using the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method), as well as the **Get_PropertyName_** and **Set_PropertyName_** accessors.</span></span> <span data-ttu-id="268e3-199">在此範例中，附加屬性名稱為 `IsBubbleSource`。</span><span class="sxs-lookup"><span data-stu-id="268e3-199">In the example, the attached property name is `IsBubbleSource`.</span></span> <span data-ttu-id="268e3-200">因此，存取子必須命名為 `GetIsBubbleSource` 和 `SetIsBubbleSource`。</span><span class="sxs-lookup"><span data-stu-id="268e3-200">Therefore, the accessors must be named `GetIsBubbleSource` and `SetIsBubbleSource`.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler)]
[!code-vb[WPFAquariumSln#RegisterAttachedBubbler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler)]

#### <a name="attached-property-attributes"></a><span data-ttu-id="268e3-201">附加屬性 (property) 的屬性 (attribute)</span><span class="sxs-lookup"><span data-stu-id="268e3-201">Attached Property Attributes</span></span>

<span data-ttu-id="268e3-202">WPF 會定義數個 [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)]，以便將附加屬性的相關資訊提供給反映進程，以及反映的一般使用者和屬性資訊（例如設計工具）。</span><span class="sxs-lookup"><span data-stu-id="268e3-202">WPF defines several [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] that are intended to provide information about attached properties to reflection processes, and to typical users of reflection and property information such as designers.</span></span> <span data-ttu-id="268e3-203">因為附加屬性的類型為無限制範圍，所以設計人員需要方法來避免使用 XAML 的特定技術實作中所定義之所有附加屬性的全域清單，讓使用者無所適從。</span><span class="sxs-lookup"><span data-stu-id="268e3-203">Because attached properties have a type of unlimited scope, designers need a way to avoid overwhelming users with a global list of all the attached properties that are defined in a particular technology implementation that uses XAML.</span></span> <span data-ttu-id="268e3-204">WPF 為附加屬性所定義的 [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)]，可以用來限定給定附加屬性應該顯示在 [屬性] 視窗中的情況。</span><span class="sxs-lookup"><span data-stu-id="268e3-204">The [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] that WPF defines for attached properties can be used to scope the situations where a given attached property should be shown in a properties window.</span></span> <span data-ttu-id="268e3-205">您也可以考慮針對您自己的自訂附加屬性套用這些屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-205">You might consider applying these attributes for your own custom attached properties also.</span></span> <span data-ttu-id="268e3-206">適當的參考頁面會描述 [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] 的用途和語法：</span><span class="sxs-lookup"><span data-stu-id="268e3-206">The purpose and syntax of the [!INCLUDE[TLA2#tla_netframewkattr#plural](../../../../includes/tla2sharptla-netframewkattrsharpplural-md.md)] is described on the appropriate reference pages:</span></span>

- <xref:System.Windows.AttachedPropertyBrowsableAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForChildrenAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableForTypeAttribute>

- <xref:System.Windows.AttachedPropertyBrowsableWhenAttributePresentAttribute>

## <span data-ttu-id="268e3-207">深入瞭解附加屬性<a name="more"></a></span><span class="sxs-lookup"><span data-stu-id="268e3-207">Learning More About Attached Properties <a name="more"></a></span></span>

- <span data-ttu-id="268e3-208">如需建立附加屬性的詳細資訊，請參閱[註冊附加屬性](how-to-register-an-attached-property.md)。</span><span class="sxs-lookup"><span data-stu-id="268e3-208">For more information on creating an attached property, see [Register an Attached Property](how-to-register-an-attached-property.md).</span></span>

- <span data-ttu-id="268e3-209">如需相依性屬性和附加屬性的更進階使用方式情節，請參閱[自訂相依性屬性](custom-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="268e3-209">For more advanced usage scenarios for dependency properties and attached properties, see [Custom Dependency Properties](custom-dependency-properties.md).</span></span>

- <span data-ttu-id="268e3-210">您也可以將屬性註冊為附加屬性和相依性屬性，但仍公開「包裝函式」實作。</span><span class="sxs-lookup"><span data-stu-id="268e3-210">You can also register a property as an attached property, and as a dependency property, but then still expose "wrapper" implementations.</span></span> <span data-ttu-id="268e3-211">在此情況下，可以在該項目上設定屬性，或透過 XAML 附加屬性語法的任何項目上設定屬性。</span><span class="sxs-lookup"><span data-stu-id="268e3-211">In this case, the property can be set either on that element, or on any element through the XAML attached property syntax.</span></span> <span data-ttu-id="268e3-212">具有適用于標準和附加用法之適當案例的屬性範例是 <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="268e3-212">An example of a property with an appropriate scenario for both standard and attached usages is <xref:System.Windows.FrameworkElement.FlowDirection%2A?displayProperty=nameWithType>.</span></span>

## <a name="see-also"></a><span data-ttu-id="268e3-213">請參閱</span><span class="sxs-lookup"><span data-stu-id="268e3-213">See also</span></span>

- <xref:System.Windows.DependencyProperty>
- [<span data-ttu-id="268e3-214">相依性屬性概觀</span><span class="sxs-lookup"><span data-stu-id="268e3-214">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="268e3-215">自訂相依性屬性</span><span class="sxs-lookup"><span data-stu-id="268e3-215">Custom Dependency Properties</span></span>](custom-dependency-properties.md)
- [<span data-ttu-id="268e3-216">XAML 概觀 (WPF)</span><span class="sxs-lookup"><span data-stu-id="268e3-216">XAML Overview (WPF)</span></span>](xaml-overview-wpf.md)
- [<span data-ttu-id="268e3-217">註冊附加屬性</span><span class="sxs-lookup"><span data-stu-id="268e3-217">Register an Attached Property</span></span>](how-to-register-an-attached-property.md)
