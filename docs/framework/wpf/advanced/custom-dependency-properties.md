---
title: 自訂相依性屬性
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- implementing [WPF], wrappers
- registering properties [WPF]
- properties [WPF], metadata
- metadata [WPF], for properties
- custom dependency properties [WPF]
- properties [WPF], registering
- wrappers [WPF], implementing
- dependency properties [WPF], custom
ms.assetid: e6bfcfac-b10d-4f58-9f77-a864c2a2938f
ms.openlocfilehash: 8e3ac7207a5ef05b94e97f005ecd17d5078669a4
ms.sourcegitcommit: 22be09204266253d45ece46f51cc6f080f2b3fd6
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 11/07/2019
ms.locfileid: "73740894"
---
# <a name="custom-dependency-properties"></a><span data-ttu-id="69d15-102">自訂相依性屬性</span><span class="sxs-lookup"><span data-stu-id="69d15-102">Custom Dependency Properties</span></span>

<span data-ttu-id="69d15-103">本主題會說明 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 應用程式開發人員和元件作者可能想要建立自訂相依性屬性的原因，並說明實作步驟以及某些可以改善屬性的效能、可用性或多功能的實作選項。</span><span class="sxs-lookup"><span data-stu-id="69d15-103">This topic describes the reasons that [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application developers and component authors might want to create custom dependency property, and describes the implementation steps as well as some implementation options that can improve performance, usability, or versatility of the property.</span></span>

<a name="prerequisites"></a>

## <a name="prerequisites"></a><span data-ttu-id="69d15-104">Prerequisites</span><span class="sxs-lookup"><span data-stu-id="69d15-104">Prerequisites</span></span>

<span data-ttu-id="69d15-105">本主題假設您已從 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 類別的現有相依性屬性消費者角度了解相依性屬性，並已閱讀[相依性屬性概觀](dependency-properties-overview.md)主題。</span><span class="sxs-lookup"><span data-stu-id="69d15-105">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md) topic.</span></span> <span data-ttu-id="69d15-106">為了解本主題中的範例，您也應該了解 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] 並知道如何撰寫 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 應用程式。</span><span class="sxs-lookup"><span data-stu-id="69d15-106">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>

<a name="whatis"></a>

## <a name="what-is-a-dependency-property"></a><span data-ttu-id="69d15-107">什麼是相依性屬性？</span><span class="sxs-lookup"><span data-stu-id="69d15-107">What Is a Dependency Property?</span></span>

<span data-ttu-id="69d15-108">您可以啟用通用語言執行平臺（CLR）屬性，以支援樣式、資料系結、繼承、動畫和預設值，方法是將其實作為相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="69d15-108">You can enable what would otherwise be a common language runtime (CLR) property to support styling, data binding, inheritance, animations, and default values by implementing it as a dependency property.</span></span> <span data-ttu-id="69d15-109">相依性屬性是藉由呼叫 <xref:System.Windows.DependencyProperty.Register%2A> 方法（或 <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>），並由 <xref:System.Windows.DependencyProperty> 識別碼欄位支援的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 屬性系統註冊的屬性。</span><span class="sxs-lookup"><span data-stu-id="69d15-109">Dependency properties are properties that are registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system by calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>), and that are backed by a <xref:System.Windows.DependencyProperty> identifier field.</span></span> <span data-ttu-id="69d15-110">相依性屬性只能由 <xref:System.Windows.DependencyObject> 類型使用，但 <xref:System.Windows.DependencyObject> 在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 類別階層中相當高，因此 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中提供的大部分類別都可以支援相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="69d15-110">Dependency properties can be used only by <xref:System.Windows.DependencyObject> types, but <xref:System.Windows.DependencyObject> is quite high in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class hierarchy, so the majority of classes available in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can support dependency properties.</span></span> <span data-ttu-id="69d15-111">如需相依性屬性以及在此 SDK 中用來描述它們的一些術語和慣例的詳細資訊，請參閱相依性[屬性總覽](dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-111">For more information about dependency properties and some of the terminology and conventions used for describing them in this SDK, see [Dependency Properties Overview](dependency-properties-overview.md).</span></span>

<a name="example_dp"></a>

## <a name="examples-of-dependency-properties"></a><span data-ttu-id="69d15-112">相依性屬性範例</span><span class="sxs-lookup"><span data-stu-id="69d15-112">Examples of Dependency Properties</span></span>

<span data-ttu-id="69d15-113">在 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 類別上實作為相依性屬性的範例包括 <xref:System.Windows.Controls.Control.Background%2A> 屬性、<xref:System.Windows.FrameworkElement.Width%2A> 屬性和 <xref:System.Windows.Controls.TextBox.Text%2A> 屬性等許多其他專案。</span><span class="sxs-lookup"><span data-stu-id="69d15-113">Examples of dependency properties that are implemented on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes include the <xref:System.Windows.Controls.Control.Background%2A> property, the <xref:System.Windows.FrameworkElement.Width%2A> property, and the <xref:System.Windows.Controls.TextBox.Text%2A> property, among many others.</span></span> <span data-ttu-id="69d15-114">類別所公開的每個相依性屬性都有一個類型的對應公用靜態欄位，<xref:System.Windows.DependencyProperty> 公開于相同的類別上。</span><span class="sxs-lookup"><span data-stu-id="69d15-114">Each dependency property exposed by a class has a corresponding public static field of type <xref:System.Windows.DependencyProperty> exposed on that same class.</span></span> <span data-ttu-id="69d15-115">這是相依性屬性的識別碼。</span><span class="sxs-lookup"><span data-stu-id="69d15-115">This is the identifier for the dependency property.</span></span> <span data-ttu-id="69d15-116">識別碼依慣例命名︰相依性屬性的名稱後綴字串 `Property`。</span><span class="sxs-lookup"><span data-stu-id="69d15-116">The identifier is named using a convention: the name of the dependency property with the string `Property` appended to it.</span></span> <span data-ttu-id="69d15-117">例如，<xref:System.Windows.Controls.Control.Background%2A> 屬性的對應 <xref:System.Windows.DependencyProperty> 識別碼欄位是 <xref:System.Windows.Controls.Control.BackgroundProperty>。</span><span class="sxs-lookup"><span data-stu-id="69d15-117">For example, the corresponding <xref:System.Windows.DependencyProperty> identifier field for the <xref:System.Windows.Controls.Control.Background%2A> property is <xref:System.Windows.Controls.Control.BackgroundProperty>.</span></span> <span data-ttu-id="69d15-118">識別碼會儲存已註冊之相依性屬性的相關資訊，稍後會使用此識別碼進行相依性屬性的其他作業，例如呼叫 <xref:System.Windows.DependencyObject.SetValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="69d15-118">The identifier stores the information about the dependency property as it was registered, and the identifier is then used later for other operations involving the dependency property, such as calling <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span>

<span data-ttu-id="69d15-119">如相依性[屬性總覽](dependency-properties-overview.md)中所述，[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 中的所有相依性屬性（大部分的附加屬性除外）也是 CLR 屬性，因為「包裝函式」的執行。</span><span class="sxs-lookup"><span data-stu-id="69d15-119">As mentioned in the [Dependency Properties Overview](dependency-properties-overview.md), all dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (except most attached properties) are also CLR properties because of the "wrapper" implementation.</span></span> <span data-ttu-id="69d15-120">因此，在程式碼中，您可以藉由呼叫 CLR 存取子來取得或設定相依性屬性，方法是以您使用其他 CLR 屬性的相同方式來定義包裝函式。</span><span class="sxs-lookup"><span data-stu-id="69d15-120">Therefore, from code, you can get or set dependency properties by calling CLR accessors that define the wrappers in the same manner that you would use other CLR properties.</span></span> <span data-ttu-id="69d15-121">做為已建立相依性屬性的取用者，您通常不會使用 <xref:System.Windows.DependencyObject.GetValue%2A> 和 <xref:System.Windows.DependencyObject.SetValue%2A>的 <xref:System.Windows.DependencyObject> 方法，這是基礎屬性系統的連接點。</span><span class="sxs-lookup"><span data-stu-id="69d15-121">As a consumer of established dependency properties, you do not typically use the <xref:System.Windows.DependencyObject> methods <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A>, which are the connection point to the underlying property system.</span></span> <span data-ttu-id="69d15-122">相反地，現有的 CLR 屬性的執行已經被呼叫 <xref:System.Windows.DependencyObject.GetValue%2A>，而且在屬性的 `get` 和 `set` 的包裝函式內，會適當使用 identifier 欄位來 <xref:System.Windows.DependencyObject.SetValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="69d15-122">Rather, the existing implementation of the CLR properties will have already called <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> within the `get` and `set` wrapper implementations of the property, using the identifier field appropriately.</span></span> <span data-ttu-id="69d15-123">如果您要自行實作自訂的相依性屬性，則會以類似的方式定義包裝函式。</span><span class="sxs-lookup"><span data-stu-id="69d15-123">If you are implementing a custom dependency property yourself, then you will be defining the wrapper in a similar way.</span></span>

<a name="backing_with_dp"></a>

## <a name="when-should-you-implement-a-dependency-property"></a><span data-ttu-id="69d15-124">您應於何時實作相依性屬性？</span><span class="sxs-lookup"><span data-stu-id="69d15-124">When Should You Implement a Dependency Property?</span></span>

<span data-ttu-id="69d15-125">當您在類別上執行屬性時，只要您的類別衍生自 <xref:System.Windows.DependencyObject>，就可以選擇使用 <xref:System.Windows.DependencyProperty> 識別碼來備份您的屬性，進而使其成為相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="69d15-125">When you implement a property on a class, so long as your class derives from <xref:System.Windows.DependencyObject>, you have the option to back your property with a <xref:System.Windows.DependencyProperty> identifier and thus to make it a dependency property.</span></span> <span data-ttu-id="69d15-126">讓您的屬性成為相依性屬性並非絕對必要或合適，視案例需求而定。</span><span class="sxs-lookup"><span data-stu-id="69d15-126">Having your property be a dependency property is not always necessary or appropriate, and will depend on your scenario needs.</span></span> <span data-ttu-id="69d15-127">有時候，支援有私用欄位的屬性，一般的技巧即已足夠。</span><span class="sxs-lookup"><span data-stu-id="69d15-127">Sometimes, the typical technique of backing your property with a private field is adequate.</span></span> <span data-ttu-id="69d15-128">但只要您希望屬性支援下列一或多項 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 功能，就應該將屬性實作為相依性屬性：</span><span class="sxs-lookup"><span data-stu-id="69d15-128">However, you should implement your property as a dependency property whenever you want your property to support one or more of the following [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] capabilities:</span></span>

- <span data-ttu-id="69d15-129">您希望屬性在樣式中是可設定的。</span><span class="sxs-lookup"><span data-stu-id="69d15-129">You want your property to be settable in a style.</span></span> <span data-ttu-id="69d15-130">如需詳細資訊，請參閱 [設定樣式和範本](../controls/styling-and-templating.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-130">For more information, see [Styling and Templating](../controls/styling-and-templating.md).</span></span>

- <span data-ttu-id="69d15-131">您希望屬性支援資料繫結。</span><span class="sxs-lookup"><span data-stu-id="69d15-131">You want your property to support data binding.</span></span> <span data-ttu-id="69d15-132">如需資料繫結相依性屬性的詳細資訊，請參閱[繫結兩個控制項的屬性](../data/how-to-bind-the-properties-of-two-controls.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-132">For more information about data binding dependency properties, see [Bind the Properties of Two Controls](../data/how-to-bind-the-properties-of-two-controls.md).</span></span>

- <span data-ttu-id="69d15-133">您希望屬性可使用動態資源參考來設定。</span><span class="sxs-lookup"><span data-stu-id="69d15-133">You want your property to be settable with a dynamic resource reference.</span></span> <span data-ttu-id="69d15-134">如需詳細資訊，請參閱 [XAML 資源](../../../desktop-wpf/fundamentals/xaml-resources-define.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-134">For more information, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>

- <span data-ttu-id="69d15-135">您想要自動繼承項目樹狀結構父項目的屬性值。</span><span class="sxs-lookup"><span data-stu-id="69d15-135">You want to inherit a property value automatically from a parent element in the element tree.</span></span> <span data-ttu-id="69d15-136">在此情況下，請使用 <xref:System.Windows.DependencyProperty.RegisterAttached%2A> 方法進行註冊，即使您也建立了 CLR 存取的屬性包裝函式也一樣。</span><span class="sxs-lookup"><span data-stu-id="69d15-136">In this case, register with the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, even if you also create a property wrapper for CLR access.</span></span> <span data-ttu-id="69d15-137">如需詳細資訊，請參閱[屬性值繼承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-137">For more information, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="69d15-138">您希望屬性可製成動畫。</span><span class="sxs-lookup"><span data-stu-id="69d15-138">You want your property to be animatable.</span></span> <span data-ttu-id="69d15-139">如需詳細資訊，請參閱 [動畫概觀](../graphics-multimedia/animation-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-139">For more information, see [Animation Overview](../graphics-multimedia/animation-overview.md).</span></span>

- <span data-ttu-id="69d15-140">當屬性系統、環境或使用者所採取的動作，或讀取和使用樣式變更了先前的屬性值時，您希望屬性系統能夠回報。</span><span class="sxs-lookup"><span data-stu-id="69d15-140">You want the property system to report when the previous value of the property has been changed by actions taken by the property system, the environment, or the user, or by reading and using styles.</span></span> <span data-ttu-id="69d15-141">使用屬性中繼資料，您的屬性可以指定每次屬性系統判定屬性值變更時都會叫用回呼方法。</span><span class="sxs-lookup"><span data-stu-id="69d15-141">By using property metadata, your property can specify a callback method that will be invoked each time the property system determines that your property value was definitively changed.</span></span> <span data-ttu-id="69d15-142">相關的概念是屬性值強制型轉。</span><span class="sxs-lookup"><span data-stu-id="69d15-142">A related concept is property value coercion.</span></span> <span data-ttu-id="69d15-143">如需詳細資訊，請參閱[相依性屬性回呼和驗證](dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-143">For more information, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>

- <span data-ttu-id="69d15-144">您想要使用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 程序也使用的已建立中繼資料慣例，例如報告變更屬性值是否應該需要配置系統重新撰寫項目的視覺效果。</span><span class="sxs-lookup"><span data-stu-id="69d15-144">You want to use established metadata conventions that are also used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processes, such as reporting whether changing a property value should require the layout system to recompose the visuals for an element.</span></span> <span data-ttu-id="69d15-145">或者您想要能夠使用中繼資料覆寫，以便衍生類別可以變更中繼資料型的特性，例如預設值。</span><span class="sxs-lookup"><span data-stu-id="69d15-145">Or you want to be able to use metadata overrides so that derived classes can change metadata-based characteristics such as the default value.</span></span>

- <span data-ttu-id="69d15-146">您想要自訂控制項的屬性，以接收 Visual Studio WPF 設計工具支援，例如 [**屬性**] 視窗編輯。</span><span class="sxs-lookup"><span data-stu-id="69d15-146">You want properties of a custom control to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="69d15-147">如需詳細資訊，請參閱[控制項撰寫概觀](../controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-147">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="69d15-148">當您檢查這些案例時，您也應該考慮是否能夠以覆寫現有相依性屬性中繼資料的方式完成您的案例，而不是實作全新的屬性。</span><span class="sxs-lookup"><span data-stu-id="69d15-148">When you examine these scenarios, you should also consider whether you can achieve your scenario by overriding the metadata of an existing dependency property, rather than implementing a completely new property.</span></span> <span data-ttu-id="69d15-149">中繼資料覆寫是否實際可行，取決於您的案例，以及該案例與現有 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 相依性屬性和類別實作的類似程度。</span><span class="sxs-lookup"><span data-stu-id="69d15-149">Whether a metadata override is practical depends on your scenario and how closely that scenario resembles the implementation in existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dependency properties and classes.</span></span> <span data-ttu-id="69d15-150">如需覆寫現有屬性中繼資料的詳細資訊，請參閱[相依性屬性中繼資料](dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-150">For more information about overriding metadata on existing properties, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<a name="checklist"></a>

## <a name="checklist-for-defining-a-dependency-property"></a><span data-ttu-id="69d15-151">定義相依性屬性所使用的檢查清單</span><span class="sxs-lookup"><span data-stu-id="69d15-151">Checklist for Defining a Dependency Property</span></span>

<span data-ttu-id="69d15-152">定義相依性屬性包含四個不同的概念。</span><span class="sxs-lookup"><span data-stu-id="69d15-152">Defining a dependency property consists of four distinct concepts.</span></span> <span data-ttu-id="69d15-153">這些概念不一定得是嚴苛的程序步驟，因為其中有些最後會結合為實作中的單一段程式碼︰</span><span class="sxs-lookup"><span data-stu-id="69d15-153">These concepts are not necessarily strict procedural steps, because some of these end up being combined as single lines of code in the implementation:</span></span>

- <span data-ttu-id="69d15-154">(選擇性) 建立相依性屬性的屬性中繼資料。</span><span class="sxs-lookup"><span data-stu-id="69d15-154">(Optional) Create property metadata for the dependency property.</span></span>

- <span data-ttu-id="69d15-155">向屬性系統登錄屬性名稱，指定擁有者類型和屬性值類型。</span><span class="sxs-lookup"><span data-stu-id="69d15-155">Register the property name with the property system, specifying an owner type and the type of the property value.</span></span> <span data-ttu-id="69d15-156">如經使用，也指定屬性中繼資料。</span><span class="sxs-lookup"><span data-stu-id="69d15-156">Also specify the property metadata, if used.</span></span>

- <span data-ttu-id="69d15-157">在擁有者類型上，將 <xref:System.Windows.DependencyProperty> 識別碼定義為 `public` `static` `readonly` 欄位。</span><span class="sxs-lookup"><span data-stu-id="69d15-157">Define a <xref:System.Windows.DependencyProperty> identifier as a `public` `static` `readonly` field on the owner type.</span></span>

- <span data-ttu-id="69d15-158">定義 CLR "包裝函式" 屬性，其名稱符合相依性屬性的名稱。</span><span class="sxs-lookup"><span data-stu-id="69d15-158">Define a CLR "wrapper" property whose name matches the name of the dependency property.</span></span> <span data-ttu-id="69d15-159">執行 CLR 「包裝函式」屬性的 `get`，並 `set` 存取子來與支援它的相依性屬性連接。</span><span class="sxs-lookup"><span data-stu-id="69d15-159">Implement the CLR "wrapper" property's `get` and `set` accessors to connect with the dependency property that backs it.</span></span>

<a name="registering"></a>

### <a name="registering-the-property-with-the-property-system"></a><span data-ttu-id="69d15-160">向屬性系統登錄屬性</span><span class="sxs-lookup"><span data-stu-id="69d15-160">Registering the Property with the Property System</span></span>

<span data-ttu-id="69d15-161">為使屬性成為相依性屬性，您必須將該屬性登錄到屬性系統維護的資料表中，並給它唯一識別碼用為後續屬性系統作業的限定詞。</span><span class="sxs-lookup"><span data-stu-id="69d15-161">In order for your property to be a dependency property, you must register that property into a table maintained by the property system, and give it a unique identifier that is used as the qualifier for later property system operations.</span></span> <span data-ttu-id="69d15-162">這些作業可能是內部作業，或您自己的程式碼呼叫屬性系統 Api。</span><span class="sxs-lookup"><span data-stu-id="69d15-162">These operations might be internal operations, or your own code calling property system APIs.</span></span> <span data-ttu-id="69d15-163">若要註冊屬性，請在類別主體中呼叫 <xref:System.Windows.DependencyProperty.Register%2A> 方法（在類別中，但在任何成員定義之外）。</span><span class="sxs-lookup"><span data-stu-id="69d15-163">To register the property, you call the <xref:System.Windows.DependencyProperty.Register%2A> method within the body of your class (inside the class, but outside of any member definitions).</span></span> <span data-ttu-id="69d15-164">[識別碼] 欄位也是由 <xref:System.Windows.DependencyProperty.Register%2A> 方法呼叫所提供，做為傳回值。</span><span class="sxs-lookup"><span data-stu-id="69d15-164">The identifier field is also provided by the <xref:System.Windows.DependencyProperty.Register%2A> method call, as the return value.</span></span> <span data-ttu-id="69d15-165"><xref:System.Windows.DependencyProperty.Register%2A> 呼叫是在其他成員定義以外完成的原因，是因為您使用此傳回值來指派和建立 `public` `static` `readonly` 欄位，做為類別的一部分 <xref:System.Windows.DependencyProperty> 類型。</span><span class="sxs-lookup"><span data-stu-id="69d15-165">The reason that the <xref:System.Windows.DependencyProperty.Register%2A> call is done outside of other member definitions is because you use this return value to assign and create a `public` `static` `readonly` field of type <xref:System.Windows.DependencyProperty> as part of your class.</span></span> <span data-ttu-id="69d15-166">此欄位會變成您相依性屬性的識別碼。</span><span class="sxs-lookup"><span data-stu-id="69d15-166">This field becomes the identifier for your dependency property.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAG](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)]
[!code-vb[WPFAquariumSln#RegisterAG](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)]

<a name="nameconventions"></a>

### <a name="dependency-property-name-conventions"></a><span data-ttu-id="69d15-167">相依性屬性命名慣例</span><span class="sxs-lookup"><span data-stu-id="69d15-167">Dependency Property Name Conventions</span></span>

<span data-ttu-id="69d15-168">相依性屬性有已建立的命名慣例，除非例外情況，否則必須遵循。</span><span class="sxs-lookup"><span data-stu-id="69d15-168">There are established naming conventions regarding dependency properties that you must follow in all but exceptional circumstances.</span></span>

<span data-ttu-id="69d15-169">相依性屬性本身會有基本名稱 "AquariumGraphic"，如下列範例所示，它會指定為 <xref:System.Windows.DependencyProperty.Register%2A>的第一個參數。</span><span class="sxs-lookup"><span data-stu-id="69d15-169">The dependency property itself will have a basic name, "AquariumGraphic" as in this example, which is given as the first parameter of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="69d15-170">該名稱在每個登錄類型中都必須是唯一的。</span><span class="sxs-lookup"><span data-stu-id="69d15-170">That name must be unique within each registering type.</span></span> <span data-ttu-id="69d15-171">透過基底類型繼承的相依性屬性視為登錄類型的一部分，已繼承屬性的名稱無法再次登錄。</span><span class="sxs-lookup"><span data-stu-id="69d15-171">Dependency properties inherited through base types are considered to be already part of the registering type; names of inherited properties cannot be registered again.</span></span> <span data-ttu-id="69d15-172">不過，即使不能繼承該相依性屬性，還有一種技巧可將類別新增為相依性屬性的擁有者；如需詳細資訊，請參閱[相依性屬性中繼資料](dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-172">However, there is a technique for adding a class as owner of a dependency property even when that dependency property is not inherited; for details, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<span data-ttu-id="69d15-173">當您建立識別碼欄位時，請以登錄屬性時所用名稱命名此欄位，再加上尾碼 `Property`。</span><span class="sxs-lookup"><span data-stu-id="69d15-173">When you create the identifier field, name this field by the name of the property as you registered it, plus the suffix `Property`.</span></span> <span data-ttu-id="69d15-174">此欄位是相依性屬性的識別碼，稍後將用來做為 <xref:System.Windows.DependencyObject.SetValue%2A> 的輸入，以及您將在包裝函式中進行的 <xref:System.Windows.DependencyObject.GetValue%2A> 呼叫，由您自己的程式碼對屬性的任何其他程式碼存取，由屬性系統所允許的任何外部程式碼存取，而且可能會 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 處理器。</span><span class="sxs-lookup"><span data-stu-id="69d15-174">This field is your identifier for the dependency property, and it will be used later as an input for the <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.GetValue%2A> calls you will make in the wrappers, by any other code access to the property by your own code, by any external code access you allow, by the property system, and potentially by [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processors.</span></span>

> [!NOTE]
> <span data-ttu-id="69d15-175">在類別主體中定義相依性屬性是一般的實作，但也可能在類別靜態建構函式中定義相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="69d15-175">Defining the dependency property in the class body is the typical implementation, but it is also possible to define a dependency property in the class static constructor.</span></span> <span data-ttu-id="69d15-176">如果您需要多行程式碼來初始化相依性屬性，這個方式可能有意義。</span><span class="sxs-lookup"><span data-stu-id="69d15-176">This approach might make sense if you need more than one line of code to initialize the dependency property.</span></span>

<a name="wrapper1"></a>

### <a name="implementing-the-wrapper"></a><span data-ttu-id="69d15-177">實作 "wrapper"</span><span class="sxs-lookup"><span data-stu-id="69d15-177">Implementing the "Wrapper"</span></span>

<span data-ttu-id="69d15-178">您的包裝函式執行應該會在 `get` 執行中呼叫 <xref:System.Windows.DependencyObject.GetValue%2A>，並在 `set` 的執行中 <xref:System.Windows.DependencyObject.SetValue%2A> （原始註冊呼叫和欄位也會顯示為清楚明瞭）。</span><span class="sxs-lookup"><span data-stu-id="69d15-178">Your wrapper implementation should call <xref:System.Windows.DependencyObject.GetValue%2A> in the `get` implementation, and <xref:System.Windows.DependencyObject.SetValue%2A> in the `set` implementation (the original registration call and field are shown here too for clarity).</span></span>

<span data-ttu-id="69d15-179">除了例外狀況以外，您的包裝函式會分別執行 <xref:System.Windows.DependencyObject.GetValue%2A> 和 <xref:System.Windows.DependencyObject.SetValue%2A> 動作。</span><span class="sxs-lookup"><span data-stu-id="69d15-179">In all but exceptional circumstances, your wrapper implementations should perform only the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> actions, respectively.</span></span> <span data-ttu-id="69d15-180">相關原因討論請參閱 [XAML 載入和相依性屬性](xaml-loading-and-dependency-properties.md)主題。</span><span class="sxs-lookup"><span data-stu-id="69d15-180">The reason for this is discussed in the topic [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<span data-ttu-id="69d15-181">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 類別中提供的所有現有公用相依性屬性都使用這個簡單的包裝函式實作模型，相依性屬性運作方式最複雜的部分或為固有的屬性系統行為，或為透過其他概念予以實行，例如透過屬性中繼資料的強制型轉或屬性變更回呼。</span><span class="sxs-lookup"><span data-stu-id="69d15-181">All existing public dependency properties that are provided on the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes use this simple wrapper implementation model; most of the complexity of how dependency properties work is either inherently a behavior of the property system, or is implemented through other concepts such as coercion or property change callbacks through property metadata.</span></span>

[!code-csharp[WPFAquariumSln#AGWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)]
[!code-vb[WPFAquariumSln#AGWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)]

<span data-ttu-id="69d15-182">同樣地，依照慣例，包裝函式屬性的名稱必須與所選擇的名稱相同，並指定為註冊屬性之 <xref:System.Windows.DependencyProperty.Register%2A> 呼叫的第一個參數。</span><span class="sxs-lookup"><span data-stu-id="69d15-182">Again, by convention, the name of the wrapper property must be the same as the name chosen and given as first parameter of the <xref:System.Windows.DependencyProperty.Register%2A> call that registered the property.</span></span> <span data-ttu-id="69d15-183">如果您的屬性不遵循慣例，不一定會停用所有可能的用途，但您會遇到幾個值得注意的問題︰</span><span class="sxs-lookup"><span data-stu-id="69d15-183">If your property does not follow the convention, this does not necessarily disable all possible uses, but you will encounter several notable issues:</span></span>

- <span data-ttu-id="69d15-184">樣式和範本的某些方面不起作用。</span><span class="sxs-lookup"><span data-stu-id="69d15-184">Certain aspects of styles and templates will not work.</span></span>

- <span data-ttu-id="69d15-185">大部分的工具和設計工具必須依賴命名慣例，才能正確序列化 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]，或依屬性層級提供設計工具環境協助。</span><span class="sxs-lookup"><span data-stu-id="69d15-185">Most tools and designers must rely on the naming conventions to properly serialize [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or to provide designer environment assistance at a per-property level.</span></span>

- <span data-ttu-id="69d15-186">目前的 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)][!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] 載入器實作會略過整個包裝函式，且在處理屬性值時依賴命名慣例。</span><span class="sxs-lookup"><span data-stu-id="69d15-186">The current implementation of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader bypasses the wrappers entirely, and relies on the naming convention when processing attribute values.</span></span> <span data-ttu-id="69d15-187">如需詳細資訊，請參閱 [XAML 相依性屬性](xaml-loading-and-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-187">For more information, see [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<a name="metadata"></a>

### <a name="property-metadata-for-a-new-dependency-property"></a><span data-ttu-id="69d15-188">新相依性屬性的屬性中繼資料</span><span class="sxs-lookup"><span data-stu-id="69d15-188">Property Metadata for a New Dependency Property</span></span>

<span data-ttu-id="69d15-189">當您登錄相依性屬性時，登錄會透過屬性系統建立儲存屬性特性的中繼資料物件。</span><span class="sxs-lookup"><span data-stu-id="69d15-189">When you register a dependency property, the registration through the property system creates a metadata object that stores property characteristics.</span></span> <span data-ttu-id="69d15-190">如果屬性是以 <xref:System.Windows.DependencyProperty.Register%2A>的簡單簽章註冊，則這些特性中有許多都有設定的預設值。</span><span class="sxs-lookup"><span data-stu-id="69d15-190">Many of these characteristics have defaults that are set if the property is registered with the simple signatures of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="69d15-191"><xref:System.Windows.DependencyProperty.Register%2A> 的其他簽章可讓您在註冊屬性時指定您想要的中繼資料。</span><span class="sxs-lookup"><span data-stu-id="69d15-191">Other signatures of <xref:System.Windows.DependencyProperty.Register%2A> allow you to specify the metadata that you want as you register the property.</span></span> <span data-ttu-id="69d15-192">相依性屬性最常指定的中繼資料，是套用在新執行個體的預設值，而新執行個體使用該屬性。</span><span class="sxs-lookup"><span data-stu-id="69d15-192">The most common metadata given for dependency properties is to give them a default value that is applied on new instances that use the property.</span></span>

<span data-ttu-id="69d15-193">如果您要建立存在於 <xref:System.Windows.FrameworkElement>的衍生類別上的相依性屬性，您可以使用更特殊化的中繼資料類別，<xref:System.Windows.FrameworkPropertyMetadata> 而不是基底 <xref:System.Windows.PropertyMetadata> 類別。</span><span class="sxs-lookup"><span data-stu-id="69d15-193">If you are creating a dependency property that exists on a derived class of <xref:System.Windows.FrameworkElement>, you can use the more specialized metadata class <xref:System.Windows.FrameworkPropertyMetadata> rather than the base <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="69d15-194"><xref:System.Windows.FrameworkPropertyMetadata> 類別的構造函式有數個簽章，您可以在其中指定各種中繼資料特性組合。</span><span class="sxs-lookup"><span data-stu-id="69d15-194">The constructor for the <xref:System.Windows.FrameworkPropertyMetadata> class has several signatures where you can specify various metadata characteristics in combination.</span></span> <span data-ttu-id="69d15-195">如果您只想要指定預設值，請使用接受 <xref:System.Object>類型之單一參數的簽章。</span><span class="sxs-lookup"><span data-stu-id="69d15-195">If you want to specify the default value only, use the signature that takes a single parameter of type <xref:System.Object>.</span></span> <span data-ttu-id="69d15-196">傳遞該物件參數作為屬性的類型特定預設值（提供的預設值必須是您在 <xref:System.Windows.DependencyProperty.Register%2A> 呼叫中提供作為 `propertyType` 參數的類型）。</span><span class="sxs-lookup"><span data-stu-id="69d15-196">Pass that object parameter as a type-specific default value for your property (the default value provided must be the type you provided as the `propertyType` parameter in the <xref:System.Windows.DependencyProperty.Register%2A> call).</span></span>

<span data-ttu-id="69d15-197">針對 <xref:System.Windows.FrameworkPropertyMetadata>，您也可以指定屬性的中繼資料選項旗標。</span><span class="sxs-lookup"><span data-stu-id="69d15-197">For <xref:System.Windows.FrameworkPropertyMetadata>, you can also specify metadata option flags for your property.</span></span> <span data-ttu-id="69d15-198">這些旗標在登錄後會轉換成屬性中繼資料中的個別屬性，用以與版面配置引擎等其他處理序溝通特定條件。</span><span class="sxs-lookup"><span data-stu-id="69d15-198">These flags are converted into discrete properties on the property metadata after registration and are used to communicate certain conditionals to other processes such as the layout engine.</span></span>

#### <a name="setting-appropriate-metadata-flags"></a><span data-ttu-id="69d15-199">設定適當的中繼資料旗標</span><span class="sxs-lookup"><span data-stu-id="69d15-199">Setting Appropriate Metadata Flags</span></span>

- <span data-ttu-id="69d15-200">如果您的屬性（或其值的變更）會影響 [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)]，尤其會影響版面配置系統應如何在頁面中調整或轉譯元素的大小，請設定下列一個或多個旗標： <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>、<xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>、<xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>。</span><span class="sxs-lookup"><span data-stu-id="69d15-200">If your property (or changes in its value) affects the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)], and in particular affects how the layout system should size or render your element in a page, set one or more of the following flags: <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>.</span></span>

  - <span data-ttu-id="69d15-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> 指出此屬性的變更需要變更 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 轉譯，其中包含的物件在父系中可能需要更多或較少的空間。</span><span class="sxs-lookup"><span data-stu-id="69d15-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering where the containing object might require more or less space within the parent.</span></span> <span data-ttu-id="69d15-202">例如，"Width" 屬性應該設定此旗標。</span><span class="sxs-lookup"><span data-stu-id="69d15-202">For example, a "Width" property should have this flag set.</span></span>

  - <span data-ttu-id="69d15-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> 指出此屬性的變更需要變更 [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] 轉譯，這通常不需要變更專用空間，而是表示空間中的位置已變更。</span><span class="sxs-lookup"><span data-stu-id="69d15-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering that typically does not require a change in the dedicated space, but does indicate that the positioning within the space has changed.</span></span> <span data-ttu-id="69d15-204">例如，"Alignment" 屬性應該設定此旗標。</span><span class="sxs-lookup"><span data-stu-id="69d15-204">For example, an "Alignment" property should have this flag set.</span></span>

  - <span data-ttu-id="69d15-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> 表示發生一些其他變更，這不會影響配置和量值，但需要另一個呈現。</span><span class="sxs-lookup"><span data-stu-id="69d15-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> indicates that some other change has occurred that will not affect layout and measure, but does require another render.</span></span> <span data-ttu-id="69d15-206">例如可變更現有項目色彩的 "Background" 等屬性。</span><span class="sxs-lookup"><span data-stu-id="69d15-206">An example would be a property that changes a color of an existing element, such as "Background".</span></span>

  - <span data-ttu-id="69d15-207">這些旗標在您自己的屬性系統或配置回呼覆寫實作中，通常用為中繼資料的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="69d15-207">These flags are often used as a protocol in metadata for your own override implementations of property system or layout callbacks.</span></span> <span data-ttu-id="69d15-208">例如，如果實例的任何屬性報告值變更，並在其中繼資料中 <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> 做為 `true`，您可能會有 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> 回呼會呼叫 <xref:System.Windows.UIElement.InvalidateArrange%2A>。</span><span class="sxs-lookup"><span data-stu-id="69d15-208">For instance, you might have an <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> callback that will call <xref:System.Windows.UIElement.InvalidateArrange%2A> if any property of the instance reports a value change and has <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true` in its metadata.</span></span>

- <span data-ttu-id="69d15-209">某些屬性會影響包含父項目的轉譯特性，超過前文所述之所需大小的變更。</span><span class="sxs-lookup"><span data-stu-id="69d15-209">Some properties may affect the rendering characteristics of the containing parent element, in ways above and beyond the changes in required size mentioned above.</span></span> <span data-ttu-id="69d15-210">例如，用於非固定格式檔模型中的 <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> 屬性，其中該屬性的變更可以變更包含該段落之流程檔的整體呈現。</span><span class="sxs-lookup"><span data-stu-id="69d15-210">An example is the <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> property used in the flow document model, where changes to that property can change the overall rendering of the flow document that contains the paragraph.</span></span> <span data-ttu-id="69d15-211">使用 <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> 或 <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure>，在您自己的屬性中識別類似的案例。</span><span class="sxs-lookup"><span data-stu-id="69d15-211">Use <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> or <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> to identify similar cases in your own properties.</span></span>

- <span data-ttu-id="69d15-212">相依性屬性預設支援資料繫結。</span><span class="sxs-lookup"><span data-stu-id="69d15-212">By default, dependency properties support data binding.</span></span> <span data-ttu-id="69d15-213">對於沒有任何實際案例可進行資料繫結的情況，或者大型物件的資料繫結效能認定有問題的情況，您可以故意停用資料繫結。</span><span class="sxs-lookup"><span data-stu-id="69d15-213">You can deliberately disable data binding, for cases where there is no realistic scenario for data binding, or where performance in data binding for a large object is recognized as a problem.</span></span>

- <span data-ttu-id="69d15-214">依預設，相依性屬性 <xref:System.Windows.Data.Binding.Mode%2A> 的資料系結預設為 <xref:System.Windows.Data.BindingMode.OneWay>。</span><span class="sxs-lookup"><span data-stu-id="69d15-214">By default, data binding <xref:System.Windows.Data.Binding.Mode%2A> for dependency properties defaults to <xref:System.Windows.Data.BindingMode.OneWay>.</span></span> <span data-ttu-id="69d15-215">您隨時都可以將系結變更為每個系結實例 <xref:System.Windows.Data.BindingMode.TwoWay>;如需詳細資訊，請參閱指定系結的[方向](../data/how-to-specify-the-direction-of-the-binding.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-215">You can always change the binding to be <xref:System.Windows.Data.BindingMode.TwoWay> per binding instance; for details, see [Specify the Direction of the Binding](../data/how-to-specify-the-direction-of-the-binding.md).</span></span> <span data-ttu-id="69d15-216">但是做為相依性屬性作者，您可以選擇讓屬性預設使用 <xref:System.Windows.Data.BindingMode.TwoWay> 系結模式。</span><span class="sxs-lookup"><span data-stu-id="69d15-216">But as the dependency property author, you can choose to make the property use <xref:System.Windows.Data.BindingMode.TwoWay> binding mode by default.</span></span> <span data-ttu-id="69d15-217"><xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>現有相依性屬性的範例;這個屬性的案例是 <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> 設定邏輯和 <xref:System.Windows.Controls.MenuItem> 的組合會與預設主題樣式互動。</span><span class="sxs-lookup"><span data-stu-id="69d15-217">An example of an existing dependency property is <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>; the scenario for this property is that the <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> setting logic and the compositing of <xref:System.Windows.Controls.MenuItem> interact with the default theme style.</span></span> <span data-ttu-id="69d15-218"><xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> 屬性邏輯會根據其他狀態屬性和方法呼叫，以原生方式使用資料系結來維護屬性的狀態。</span><span class="sxs-lookup"><span data-stu-id="69d15-218">The <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> property logic uses data binding natively to maintain the state of the property in accordance to other state properties and method calls.</span></span> <span data-ttu-id="69d15-219">預設會系結 <xref:System.Windows.Data.BindingMode.TwoWay> 的另一個範例屬性是 <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="69d15-219">Another example property that binds <xref:System.Windows.Data.BindingMode.TwoWay> by default is <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="69d15-220">您也可以藉由設定 <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> 旗標，在自訂相依性屬性中啟用屬性繼承。</span><span class="sxs-lookup"><span data-stu-id="69d15-220">You can also enable property inheritance in a custom dependency property by setting the <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> flag.</span></span> <span data-ttu-id="69d15-221">屬性繼承對父項目和子項目有共同屬性的案例很有用，而且對子項目將特定屬性值設定為和父項目設定的值一樣，才有意義。</span><span class="sxs-lookup"><span data-stu-id="69d15-221">Property inheritance is useful for a scenario where parent elements and child elements have a property in common, and it makes sense for the child elements to have that particular property value set to the same value as the parent set it.</span></span> <span data-ttu-id="69d15-222">範例可繼承屬性為 <xref:System.Windows.FrameworkElement.DataContext%2A>，可用於系結作業，以啟用資料呈現的重要主要詳細案例。</span><span class="sxs-lookup"><span data-stu-id="69d15-222">An example inheritable property is <xref:System.Windows.FrameworkElement.DataContext%2A>, which is used for binding operations to enable the important master-detail scenario for data presentation.</span></span> <span data-ttu-id="69d15-223">藉由讓 <xref:System.Windows.FrameworkElement.DataContext%2A> 可繼承，任何子專案也會繼承該資料內容。</span><span class="sxs-lookup"><span data-stu-id="69d15-223">By making <xref:System.Windows.FrameworkElement.DataContext%2A> inheritable, any child elements inherit that data context also.</span></span> <span data-ttu-id="69d15-224">因為屬性值繼承的緣故，您可以指定位在網頁或應用程式根目錄中的資料內容，不需要重新指定即可繫結所有可能的子項目。</span><span class="sxs-lookup"><span data-stu-id="69d15-224">Because of property value inheritance, you can specify a data context at the page or application root, and do not need to respecify it for bindings in all possible child elements.</span></span> <span data-ttu-id="69d15-225"><xref:System.Windows.FrameworkElement.DataContext%2A> 也是一個很好的範例，可說明繼承會覆寫預設值，但一律可在任何特定子專案的本機上設定;如需詳細資訊，請參閱搭配[階層式資料使用主版-詳細模式](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-225"><xref:System.Windows.FrameworkElement.DataContext%2A> is also a good example to illustrate that inheritance overrides the default value, but it can always be set locally on any particular child element; for details, see [Use the Master-Detail Pattern with Hierarchical Data](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md).</span></span> <span data-ttu-id="69d15-226">屬性值繼承確實有可能的效能成本，因此應謹慎使用。如需詳細資訊，請參閱[屬性值繼承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-226">Property value inheritance does have a possible performance cost, and thus should be used sparingly; for details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="69d15-227">設定 <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> 旗標，以指示導覽日誌服務是否應該偵測或使用相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="69d15-227">Set the <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> flag to indicate if your dependency property should be detected or used by navigation journaling services.</span></span> <span data-ttu-id="69d15-228">其中一個範例是 <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> 屬性;當流覽日誌記錄時，應該保存選取範圍控制項中選取的任何專案。</span><span class="sxs-lookup"><span data-stu-id="69d15-228">An example is the <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> property; any item selected in a selection control should be persisted when the journaling history is navigated.</span></span>

<a name="RODP"></a>

## <a name="read-only-dependency-properties"></a><span data-ttu-id="69d15-229">唯讀相依性屬性</span><span class="sxs-lookup"><span data-stu-id="69d15-229">Read-Only Dependency Properties</span></span>

<span data-ttu-id="69d15-230">您可以定義唯讀的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="69d15-230">You can define a dependency property that is read-only.</span></span> <span data-ttu-id="69d15-231">但您為何可能將屬性定義為唯讀的案例有點不同，和向屬性系統登錄它們並公開識別碼的程序一樣。</span><span class="sxs-lookup"><span data-stu-id="69d15-231">However, the scenarios for why you might define your property as read-only are somewhat different, as is the procedure for registering them with the property system and exposing the identifier.</span></span> <span data-ttu-id="69d15-232">如需詳細資訊，請參閱[唯讀相依性屬性](read-only-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-232">For more information, see [Read-Only Dependency Properties](read-only-dependency-properties.md).</span></span>

<a name="CTDP"></a>

## <a name="collection-type-dependency-properties"></a><span data-ttu-id="69d15-233">集合類型相依性屬性</span><span class="sxs-lookup"><span data-stu-id="69d15-233">Collection-Type Dependency Properties</span></span>

<span data-ttu-id="69d15-234">集合類型相依性屬性要考慮一些其他的實作問題。</span><span class="sxs-lookup"><span data-stu-id="69d15-234">Collection-type dependency properties have some additional implementation issues to consider.</span></span> <span data-ttu-id="69d15-235">如需詳細資訊，請參閱[集合類型相依性屬性](collection-type-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-235">For details, see [Collection-Type Dependency Properties](collection-type-dependency-properties.md).</span></span>

<a name="SecurityC"></a>

## <a name="dependency-property-security-considerations"></a><span data-ttu-id="69d15-236">相依性屬性安全性考量</span><span class="sxs-lookup"><span data-stu-id="69d15-236">Dependency Property Security Considerations</span></span>

<span data-ttu-id="69d15-237">相依性屬性應該宣告為公用屬性。</span><span class="sxs-lookup"><span data-stu-id="69d15-237">Dependency properties should be declared as public properties.</span></span> <span data-ttu-id="69d15-238">相依性屬性識別碼欄位應該宣告為公用靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="69d15-238">Dependency property identifier fields should be declared as public static fields.</span></span> <span data-ttu-id="69d15-239">即使您嘗試宣告其他存取層級（例如受保護），還是可以透過識別碼搭配屬性系統 Api 來存取相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="69d15-239">Even if you attempt to declare other access levels (such as protected), a dependency property can always be accessed through the identifier in combination with the property system APIs.</span></span> <span data-ttu-id="69d15-240">即使是「受保護的識別碼」欄位，也可能因為元資料包告或屬於屬性系統一部分的值判斷 Api （如 <xref:System.Windows.LocalValueEnumerator>）而存取。</span><span class="sxs-lookup"><span data-stu-id="69d15-240">Even a protected identifier field is potentially accessible because of metadata reporting or value determination APIs that are part of the property system, such as <xref:System.Windows.LocalValueEnumerator>.</span></span> <span data-ttu-id="69d15-241">如需詳細資訊，請參閱[相依性屬性的安全性](dependency-property-security.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-241">For more information, see [Dependency Property Security](dependency-property-security.md).</span></span>

<a name="DPCtor"></a>

## <a name="dependency-properties-and-class-constructors"></a><span data-ttu-id="69d15-242">相依性屬性和類別建構函式</span><span class="sxs-lookup"><span data-stu-id="69d15-242">Dependency Properties and Class Constructors</span></span>

<span data-ttu-id="69d15-243">Managed 程式碼程式設計中有項一般原則 (通常由 FxCop 等程式碼分析工具強制執行)，類別建構函式不應該呼叫虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="69d15-243">There is a general principle in managed code programming (often enforced by code analysis tools such as FxCop) that class constructors should not call virtual methods.</span></span> <span data-ttu-id="69d15-244">這是因為建構函式可以呼叫為衍生類別建構函式的基底初始化，而透過建構函式進入虛擬方法，可能會發生在建構中的物件執行個體尚未完全初始化的狀態。</span><span class="sxs-lookup"><span data-stu-id="69d15-244">This is because constructors can be called as base initialization of a derived class constructor, and entering the virtual method through the constructor might occur at an incomplete initialization state of the object instance being constructed.</span></span> <span data-ttu-id="69d15-245">當您從已衍生自 <xref:System.Windows.DependencyObject>的任何類別衍生時，您應該注意屬性系統本身會呼叫並公開內部的虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="69d15-245">When you derive from any class that already derives from <xref:System.Windows.DependencyObject>, you should be aware that the property system itself calls and exposes virtual methods internally.</span></span> <span data-ttu-id="69d15-246">這些虛擬方法都屬於 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 屬性系統服務。</span><span class="sxs-lookup"><span data-stu-id="69d15-246">These virtual methods are part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system services.</span></span> <span data-ttu-id="69d15-247">覆寫方法可讓衍生的類別參與值判斷。</span><span class="sxs-lookup"><span data-stu-id="69d15-247">Overriding the methods enables derived classes to participate in value determination.</span></span> <span data-ttu-id="69d15-248">若要避免執行階段初始化可能發生的問題，您不應該在類別的建構函式中設定相依性屬性值，除非您遵循非常明確的建構函式模式。</span><span class="sxs-lookup"><span data-stu-id="69d15-248">To avoid potential issues with runtime initialization, you should not set dependency property values within constructors of classes, unless you follow a very specific constructor pattern.</span></span> <span data-ttu-id="69d15-249">如需詳細資訊，請參閱 [DependencyObject 的安全建構函式模式](safe-constructor-patterns-for-dependencyobjects.md)。</span><span class="sxs-lookup"><span data-stu-id="69d15-249">For details, see [Safe Constructor Patterns for DependencyObjects](safe-constructor-patterns-for-dependencyobjects.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="69d15-250">請參閱</span><span class="sxs-lookup"><span data-stu-id="69d15-250">See also</span></span>

- [<span data-ttu-id="69d15-251">相依性屬性概觀</span><span class="sxs-lookup"><span data-stu-id="69d15-251">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="69d15-252">相依性屬性中繼資料</span><span class="sxs-lookup"><span data-stu-id="69d15-252">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="69d15-253">控制項撰寫概觀</span><span class="sxs-lookup"><span data-stu-id="69d15-253">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="69d15-254">集合類型的相依性屬性</span><span class="sxs-lookup"><span data-stu-id="69d15-254">Collection-Type Dependency Properties</span></span>](collection-type-dependency-properties.md)
- [<span data-ttu-id="69d15-255">相依性屬性的安全性</span><span class="sxs-lookup"><span data-stu-id="69d15-255">Dependency Property Security</span></span>](dependency-property-security.md)
- [<span data-ttu-id="69d15-256">XAML 載入和相依性屬性</span><span class="sxs-lookup"><span data-stu-id="69d15-256">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
- [<span data-ttu-id="69d15-257">DependencyObject 的安全建構函式模式</span><span class="sxs-lookup"><span data-stu-id="69d15-257">Safe Constructor Patterns for DependencyObjects</span></span>](safe-constructor-patterns-for-dependencyobjects.md)
