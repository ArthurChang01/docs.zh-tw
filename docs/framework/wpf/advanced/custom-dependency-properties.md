---
title: 自訂相依性屬性
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- implementing [WPF], wrappers
- registering properties [WPF]
- properties [WPF], metadata
- metadata [WPF], for properties
- custom dependency properties [WPF]
- properties [WPF], registering
- wrappers [WPF], implementing
- dependency properties [WPF], custom
ms.assetid: e6bfcfac-b10d-4f58-9f77-a864c2a2938f
ms.openlocfilehash: e4117d7add2a34d6d989d9222e7688361cf6b379
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/20/2020
ms.locfileid: "81646360"
---
# <a name="custom-dependency-properties"></a><span data-ttu-id="72440-102">自訂相依性屬性</span><span class="sxs-lookup"><span data-stu-id="72440-102">Custom Dependency Properties</span></span>

<span data-ttu-id="72440-103">本主題會說明 [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 應用程式開發人員和元件作者可能想要建立自訂相依性屬性的原因，並說明實作步驟以及某些可以改善屬性的效能、可用性或多功能的實作選項。</span><span class="sxs-lookup"><span data-stu-id="72440-103">This topic describes the reasons that [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] application developers and component authors might want to create custom dependency property, and describes the implementation steps as well as some implementation options that can improve performance, usability, or versatility of the property.</span></span>

<a name="prerequisites"></a>

## <a name="prerequisites"></a><span data-ttu-id="72440-104">Prerequisites</span><span class="sxs-lookup"><span data-stu-id="72440-104">Prerequisites</span></span>

<span data-ttu-id="72440-105">本主題假設您已從 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 類別的現有相依性屬性消費者角度了解相依性屬性，並已閱讀[相依性屬性概觀](dependency-properties-overview.md)主題。</span><span class="sxs-lookup"><span data-stu-id="72440-105">This topic assumes that you understand dependency properties from the perspective of a consumer of existing dependency properties on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes, and have read the [Dependency Properties Overview](dependency-properties-overview.md) topic.</span></span> <span data-ttu-id="72440-106">為遵循本主題中的範例，您也應該了解 [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] 並知道如何撰寫 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 應用程式。</span><span class="sxs-lookup"><span data-stu-id="72440-106">In order to follow the examples in this topic, you should also understand [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] and know how to write [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications.</span></span>

<a name="whatis"></a>

## <a name="what-is-a-dependency-property"></a><span data-ttu-id="72440-107">什麼是相依性屬性？</span><span class="sxs-lookup"><span data-stu-id="72440-107">What Is a Dependency Property?</span></span>

<span data-ttu-id="72440-108">您可以啟用本來是通用語言運行時 (CLR) 屬性,透過將其作為依賴項屬性實現來支援樣式設置、數據繫結、繼承、動畫和預設值。</span><span class="sxs-lookup"><span data-stu-id="72440-108">You can enable what would otherwise be a common language runtime (CLR) property to support styling, data binding, inheritance, animations, and default values by implementing it as a dependency property.</span></span> <span data-ttu-id="72440-109">依賴項屬性[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]是通過調<xref:System.Windows.DependencyProperty.Register%2A>用 方法<xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>(<xref:System.Windows.DependencyProperty>或) 並在識別字段中備份的屬性在屬性系統中註冊的屬性。</span><span class="sxs-lookup"><span data-stu-id="72440-109">Dependency properties are properties that are registered with the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system by calling the <xref:System.Windows.DependencyProperty.Register%2A> method (or <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A>), and that are backed by a <xref:System.Windows.DependencyProperty> identifier field.</span></span> <span data-ttu-id="72440-110">依賴項屬性只能<xref:System.Windows.DependencyObject>由類型使用,<xref:System.Windows.DependencyObject>[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]但在類層次結構中相當高,因此[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]中大多數可用的類可以支援依賴項屬性。</span><span class="sxs-lookup"><span data-stu-id="72440-110">Dependency properties can be used only by <xref:System.Windows.DependencyObject> types, but <xref:System.Windows.DependencyObject> is quite high in the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class hierarchy, so the majority of classes available in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] can support dependency properties.</span></span> <span data-ttu-id="72440-111">有關相依屬性及用於在此 SDK 描述的一些術語和約定的詳細資訊,請參閱[相依項屬性概述](dependency-properties-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-111">For more information about dependency properties and some of the terminology and conventions used for describing them in this SDK, see [Dependency Properties Overview](dependency-properties-overview.md).</span></span>

<a name="example_dp"></a>

## <a name="examples-of-dependency-properties"></a><span data-ttu-id="72440-112">相依性屬性範例</span><span class="sxs-lookup"><span data-stu-id="72440-112">Examples of Dependency Properties</span></span>

<span data-ttu-id="72440-113">在類[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]上實現的依賴項屬性的範<xref:System.Windows.Controls.Control.Background%2A>例 包括<xref:System.Windows.FrameworkElement.Width%2A>屬性、<xref:System.Windows.Controls.TextBox.Text%2A>屬性和屬性等。</span><span class="sxs-lookup"><span data-stu-id="72440-113">Examples of dependency properties that are implemented on [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes include the <xref:System.Windows.Controls.Control.Background%2A> property, the <xref:System.Windows.FrameworkElement.Width%2A> property, and the <xref:System.Windows.Controls.TextBox.Text%2A> property, among many others.</span></span> <span data-ttu-id="72440-114">類公開的每個依賴項屬性都有在同一類上公開的相應的公共靜態<xref:System.Windows.DependencyProperty>類型欄位。</span><span class="sxs-lookup"><span data-stu-id="72440-114">Each dependency property exposed by a class has a corresponding public static field of type <xref:System.Windows.DependencyProperty> exposed on that same class.</span></span> <span data-ttu-id="72440-115">這是相依性屬性的識別碼。</span><span class="sxs-lookup"><span data-stu-id="72440-115">This is the identifier for the dependency property.</span></span> <span data-ttu-id="72440-116">識別碼依慣例命名︰相依性屬性的名稱後綴字串 `Property`。</span><span class="sxs-lookup"><span data-stu-id="72440-116">The identifier is named using a convention: the name of the dependency property with the string `Property` appended to it.</span></span> <span data-ttu-id="72440-117">例如,屬性的<xref:System.Windows.DependencyProperty><xref:System.Windows.Controls.Control.Background%2A>識別碼字位為<xref:System.Windows.Controls.Control.BackgroundProperty>。</span><span class="sxs-lookup"><span data-stu-id="72440-117">For example, the corresponding <xref:System.Windows.DependencyProperty> identifier field for the <xref:System.Windows.Controls.Control.Background%2A> property is <xref:System.Windows.Controls.Control.BackgroundProperty>.</span></span> <span data-ttu-id="72440-118">識別碼在註冊時儲存有關相依性屬性的資訊,然後識別碼稍後用於涉及相依項屬性的其他操作,<xref:System.Windows.DependencyObject.SetValue%2A>如呼叫 。</span><span class="sxs-lookup"><span data-stu-id="72440-118">The identifier stores the information about the dependency property as it was registered, and the identifier is then used later for other operations involving the dependency property, such as calling <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span>

<span data-ttu-id="72440-119">如[依賴項屬性概述](dependency-properties-overview.md)中所述,由於實現"[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]包裝 ",中的所有依賴項屬性(大多數附加屬性除外)也是 CLR 屬性。</span><span class="sxs-lookup"><span data-stu-id="72440-119">As mentioned in the [Dependency Properties Overview](dependency-properties-overview.md), all dependency properties in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] (except most attached properties) are also CLR properties because of the "wrapper" implementation.</span></span> <span data-ttu-id="72440-120">因此,通過代碼,可以通過調用 CLR 訪問器來獲取或設置依賴項屬性,這些訪問器以與其他 CLR 屬性相同的方式定義包裝器。</span><span class="sxs-lookup"><span data-stu-id="72440-120">Therefore, from code, you can get or set dependency properties by calling CLR accessors that define the wrappers in the same manner that you would use other CLR properties.</span></span> <span data-ttu-id="72440-121">作為已建立的相依性屬性的使用者,您通常不<xref:System.Windows.DependencyObject>使用與基礎屬性<xref:System.Windows.DependencyObject.GetValue%2A>系統的<xref:System.Windows.DependencyObject.SetValue%2A>連接點的方法和 。</span><span class="sxs-lookup"><span data-stu-id="72440-121">As a consumer of established dependency properties, you do not typically use the <xref:System.Windows.DependencyObject> methods <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A>, which are the connection point to the underlying property system.</span></span> <span data-ttu-id="72440-122"><xref:System.Windows.DependencyObject.GetValue%2A>相反,CLR 屬性的現有實現已經調用,<xref:System.Windows.DependencyObject.SetValue%2A>並在`get`屬性`set`的和包裝器實現中,適當地使用標識符欄位。</span><span class="sxs-lookup"><span data-stu-id="72440-122">Rather, the existing implementation of the CLR properties will have already called <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> within the `get` and `set` wrapper implementations of the property, using the identifier field appropriately.</span></span> <span data-ttu-id="72440-123">如果您要自行實作自訂的相依性屬性，則會以類似的方式定義包裝函式。</span><span class="sxs-lookup"><span data-stu-id="72440-123">If you are implementing a custom dependency property yourself, then you will be defining the wrapper in a similar way.</span></span>

<a name="backing_with_dp"></a>

## <a name="when-should-you-implement-a-dependency-property"></a><span data-ttu-id="72440-124">您應於何時實作相依性屬性？</span><span class="sxs-lookup"><span data-stu-id="72440-124">When Should You Implement a Dependency Property?</span></span>

<span data-ttu-id="72440-125">在類上實現屬性時,只要類派生自<xref:System.Windows.DependencyObject>,可以選擇<xref:System.Windows.DependencyProperty>使用 標識符支援屬性,從而使該屬性成為依賴項屬性。</span><span class="sxs-lookup"><span data-stu-id="72440-125">When you implement a property on a class, so long as your class derives from <xref:System.Windows.DependencyObject>, you have the option to back your property with a <xref:System.Windows.DependencyProperty> identifier and thus to make it a dependency property.</span></span> <span data-ttu-id="72440-126">讓您的屬性成為相依性屬性並非絕對必要或合適，視案例需求而定。</span><span class="sxs-lookup"><span data-stu-id="72440-126">Having your property be a dependency property is not always necessary or appropriate, and will depend on your scenario needs.</span></span> <span data-ttu-id="72440-127">有時候，支援有私用欄位的屬性，一般的技巧即已足夠。</span><span class="sxs-lookup"><span data-stu-id="72440-127">Sometimes, the typical technique of backing your property with a private field is adequate.</span></span> <span data-ttu-id="72440-128">但只要您希望屬性支援下列一或多項 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 功能，就應該將屬性實作為相依性屬性：</span><span class="sxs-lookup"><span data-stu-id="72440-128">However, you should implement your property as a dependency property whenever you want your property to support one or more of the following [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] capabilities:</span></span>

- <span data-ttu-id="72440-129">您希望屬性在樣式中是可設定的。</span><span class="sxs-lookup"><span data-stu-id="72440-129">You want your property to be settable in a style.</span></span> <span data-ttu-id="72440-130">有關詳細資訊,請參閱[樣式和範本](../../../desktop-wpf/fundamentals/styles-templates-overview.md)化。</span><span class="sxs-lookup"><span data-stu-id="72440-130">For more information, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>

- <span data-ttu-id="72440-131">您希望屬性支援資料繫結。</span><span class="sxs-lookup"><span data-stu-id="72440-131">You want your property to support data binding.</span></span> <span data-ttu-id="72440-132">如需資料繫結相依性屬性的詳細資訊，請參閱[繫結兩個控制項的屬性](../data/how-to-bind-the-properties-of-two-controls.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-132">For more information about data binding dependency properties, see [Bind the Properties of Two Controls](../data/how-to-bind-the-properties-of-two-controls.md).</span></span>

- <span data-ttu-id="72440-133">您希望屬性可使用動態資源參考來設定。</span><span class="sxs-lookup"><span data-stu-id="72440-133">You want your property to be settable with a dynamic resource reference.</span></span> <span data-ttu-id="72440-134">如需詳細資訊，請參閱 [XAML 資源](../../../desktop-wpf/fundamentals/xaml-resources-define.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-134">For more information, see [XAML Resources](../../../desktop-wpf/fundamentals/xaml-resources-define.md).</span></span>

- <span data-ttu-id="72440-135">您想要自動繼承項目樹狀結構父項目的屬性值。</span><span class="sxs-lookup"><span data-stu-id="72440-135">You want to inherit a property value automatically from a parent element in the element tree.</span></span> <span data-ttu-id="72440-136">在這種情況下,請向方法<xref:System.Windows.DependencyProperty.RegisterAttached%2A>註冊,即使您也為 CLR 訪問創建了屬性包裝器。</span><span class="sxs-lookup"><span data-stu-id="72440-136">In this case, register with the <xref:System.Windows.DependencyProperty.RegisterAttached%2A> method, even if you also create a property wrapper for CLR access.</span></span> <span data-ttu-id="72440-137">如需詳細資訊，請參閱[屬性值繼承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-137">For more information, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="72440-138">您希望屬性可製成動畫。</span><span class="sxs-lookup"><span data-stu-id="72440-138">You want your property to be animatable.</span></span> <span data-ttu-id="72440-139">有關詳細資訊,請參閱[動畫概述](../graphics-multimedia/animation-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-139">For more information, see [Animation Overview](../graphics-multimedia/animation-overview.md).</span></span>

- <span data-ttu-id="72440-140">當屬性系統、環境或使用者所採取的動作，或讀取和使用樣式變更了先前的屬性值時，您希望屬性系統能夠回報。</span><span class="sxs-lookup"><span data-stu-id="72440-140">You want the property system to report when the previous value of the property has been changed by actions taken by the property system, the environment, or the user, or by reading and using styles.</span></span> <span data-ttu-id="72440-141">使用屬性中繼資料，您的屬性可以指定每次屬性系統判定屬性值變更時都會叫用回呼方法。</span><span class="sxs-lookup"><span data-stu-id="72440-141">By using property metadata, your property can specify a callback method that will be invoked each time the property system determines that your property value was definitively changed.</span></span> <span data-ttu-id="72440-142">相關的概念是屬性值強制型轉。</span><span class="sxs-lookup"><span data-stu-id="72440-142">A related concept is property value coercion.</span></span> <span data-ttu-id="72440-143">如需詳細資訊，請參閱[相依性屬性回呼和驗證](dependency-property-callbacks-and-validation.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-143">For more information, see [Dependency Property Callbacks and Validation](dependency-property-callbacks-and-validation.md).</span></span>

- <span data-ttu-id="72440-144">您想要使用 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 程序也使用的已建立中繼資料慣例，例如報告變更屬性值是否應該需要配置系統重新撰寫項目的視覺效果。</span><span class="sxs-lookup"><span data-stu-id="72440-144">You want to use established metadata conventions that are also used by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] processes, such as reporting whether changing a property value should require the layout system to recompose the visuals for an element.</span></span> <span data-ttu-id="72440-145">或者您想要能夠使用中繼資料覆寫，以便衍生類別可以變更中繼資料型的特性，例如預設值。</span><span class="sxs-lookup"><span data-stu-id="72440-145">Or you want to be able to use metadata overrides so that derived classes can change metadata-based characteristics such as the default value.</span></span>

- <span data-ttu-id="72440-146">您希望自定義控制的屬性接收 Visual Studio WPF 設計器支援,例如**屬性**視窗編輯。</span><span class="sxs-lookup"><span data-stu-id="72440-146">You want properties of a custom control to receive Visual Studio WPF Designer support, such as **Properties** window editing.</span></span> <span data-ttu-id="72440-147">如需詳細資訊，請參閱[控制項撰寫概觀](../controls/control-authoring-overview.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-147">For more information, see [Control Authoring Overview](../controls/control-authoring-overview.md).</span></span>

<span data-ttu-id="72440-148">當您檢查這些案例時，您也應該考慮是否能夠以覆寫現有相依性屬性中繼資料的方式完成您的案例，而不是實作全新的屬性。</span><span class="sxs-lookup"><span data-stu-id="72440-148">When you examine these scenarios, you should also consider whether you can achieve your scenario by overriding the metadata of an existing dependency property, rather than implementing a completely new property.</span></span> <span data-ttu-id="72440-149">中繼資料覆寫是否實際可行，取決於您的案例，以及該案例與現有 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 相依性屬性和類別實作的類似程度。</span><span class="sxs-lookup"><span data-stu-id="72440-149">Whether a metadata override is practical depends on your scenario and how closely that scenario resembles the implementation in existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] dependency properties and classes.</span></span> <span data-ttu-id="72440-150">如需覆寫現有屬性中繼資料的詳細資訊，請參閱[相依性屬性中繼資料](dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-150">For more information about overriding metadata on existing properties, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<a name="checklist"></a>

## <a name="checklist-for-defining-a-dependency-property"></a><span data-ttu-id="72440-151">定義相依性屬性所使用的檢查清單</span><span class="sxs-lookup"><span data-stu-id="72440-151">Checklist for Defining a Dependency Property</span></span>

<span data-ttu-id="72440-152">定義相依性屬性包含四個不同的概念。</span><span class="sxs-lookup"><span data-stu-id="72440-152">Defining a dependency property consists of four distinct concepts.</span></span> <span data-ttu-id="72440-153">這些概念不一定得是嚴苛的程序步驟，因為其中有些最後會結合為實作中的單一段程式碼︰</span><span class="sxs-lookup"><span data-stu-id="72440-153">These concepts are not necessarily strict procedural steps, because some of these end up being combined as single lines of code in the implementation:</span></span>

- <span data-ttu-id="72440-154">(選擇性) 建立相依性屬性的屬性中繼資料。</span><span class="sxs-lookup"><span data-stu-id="72440-154">(Optional) Create property metadata for the dependency property.</span></span>

- <span data-ttu-id="72440-155">向屬性系統登錄屬性名稱，指定擁有者類型和屬性值類型。</span><span class="sxs-lookup"><span data-stu-id="72440-155">Register the property name with the property system, specifying an owner type and the type of the property value.</span></span> <span data-ttu-id="72440-156">如經使用，也指定屬性中繼資料。</span><span class="sxs-lookup"><span data-stu-id="72440-156">Also specify the property metadata, if used.</span></span>

- <span data-ttu-id="72440-157">將<xref:System.Windows.DependencyProperty>識別碼定義為`public``static``readonly`所有者類型的欄位。</span><span class="sxs-lookup"><span data-stu-id="72440-157">Define a <xref:System.Windows.DependencyProperty> identifier as a `public` `static` `readonly` field on the owner type.</span></span>

- <span data-ttu-id="72440-158">定義 CLR"包裝器"屬性,其名稱與依賴項屬性的名稱匹配。</span><span class="sxs-lookup"><span data-stu-id="72440-158">Define a CLR "wrapper" property whose name matches the name of the dependency property.</span></span> <span data-ttu-id="72440-159">實現 CLR"包裝器"`get`屬性`set`和存取器,以便與支援它的依賴項屬性連接。</span><span class="sxs-lookup"><span data-stu-id="72440-159">Implement the CLR "wrapper" property's `get` and `set` accessors to connect with the dependency property that backs it.</span></span>

<a name="registering"></a>

### <a name="registering-the-property-with-the-property-system"></a><span data-ttu-id="72440-160">向屬性系統登錄屬性</span><span class="sxs-lookup"><span data-stu-id="72440-160">Registering the Property with the Property System</span></span>

<span data-ttu-id="72440-161">為使屬性成為相依性屬性，您必須將該屬性登錄到屬性系統維護的資料表中，並給它唯一識別碼用為後續屬性系統作業的限定詞。</span><span class="sxs-lookup"><span data-stu-id="72440-161">In order for your property to be a dependency property, you must register that property into a table maintained by the property system, and give it a unique identifier that is used as the qualifier for later property system operations.</span></span> <span data-ttu-id="72440-162">這些操作可能是內部操作,或者您自己的代碼調用屬性系統 API。</span><span class="sxs-lookup"><span data-stu-id="72440-162">These operations might be internal operations, or your own code calling property system APIs.</span></span> <span data-ttu-id="72440-163">要註冊該屬性,請在類正文<xref:System.Windows.DependencyProperty.Register%2A>中調用 方法(類內部,但超出任何成員定義)。</span><span class="sxs-lookup"><span data-stu-id="72440-163">To register the property, you call the <xref:System.Windows.DependencyProperty.Register%2A> method within the body of your class (inside the class, but outside of any member definitions).</span></span> <span data-ttu-id="72440-164">標識符欄位也由<xref:System.Windows.DependencyProperty.Register%2A>方法調用作為返回值提供。</span><span class="sxs-lookup"><span data-stu-id="72440-164">The identifier field is also provided by the <xref:System.Windows.DependencyProperty.Register%2A> method call, as the return value.</span></span> <span data-ttu-id="72440-165"><xref:System.Windows.DependencyProperty.Register%2A>呼叫是在其他成員定義之外完成的,因為您使用此返回值作為類的一`public``static``readonly`部分分配和創建類型<xref:System.Windows.DependencyProperty>欄位。</span><span class="sxs-lookup"><span data-stu-id="72440-165">The reason that the <xref:System.Windows.DependencyProperty.Register%2A> call is done outside of other member definitions is because you use this return value to assign and create a `public` `static` `readonly` field of type <xref:System.Windows.DependencyProperty> as part of your class.</span></span> <span data-ttu-id="72440-166">此欄位會變成您相依性屬性的識別碼。</span><span class="sxs-lookup"><span data-stu-id="72440-166">This field becomes the identifier for your dependency property.</span></span>

[!code-csharp[WPFAquariumSln#RegisterAG](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerag)]
[!code-vb[WPFAquariumSln#RegisterAG](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerag)]

<a name="nameconventions"></a>

### <a name="dependency-property-name-conventions"></a><span data-ttu-id="72440-167">相依性屬性命名慣例</span><span class="sxs-lookup"><span data-stu-id="72440-167">Dependency Property Name Conventions</span></span>

<span data-ttu-id="72440-168">相依性屬性有已建立的命名慣例，除非例外情況，否則必須遵循。</span><span class="sxs-lookup"><span data-stu-id="72440-168">There are established naming conventions regarding dependency properties that you must follow in all but exceptional circumstances.</span></span>

<span data-ttu-id="72440-169">依賴項屬性本身將具有基本名稱"水族館圖",如本示例中所示,該名稱作為<xref:System.Windows.DependencyProperty.Register%2A>的第一個參數給出。</span><span class="sxs-lookup"><span data-stu-id="72440-169">The dependency property itself will have a basic name, "AquariumGraphic" as in this example, which is given as the first parameter of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="72440-170">該名稱在每個登錄類型中都必須是唯一的。</span><span class="sxs-lookup"><span data-stu-id="72440-170">That name must be unique within each registering type.</span></span> <span data-ttu-id="72440-171">透過基底類型繼承的相依性屬性視為登錄類型的一部分，已繼承屬性的名稱無法再次登錄。</span><span class="sxs-lookup"><span data-stu-id="72440-171">Dependency properties inherited through base types are considered to be already part of the registering type; names of inherited properties cannot be registered again.</span></span> <span data-ttu-id="72440-172">不過，即使不能繼承該相依性屬性，還有一種技巧可將類別新增為相依性屬性的擁有者；如需詳細資訊，請參閱[相依性屬性中繼資料](dependency-property-metadata.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-172">However, there is a technique for adding a class as owner of a dependency property even when that dependency property is not inherited; for details, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>

<span data-ttu-id="72440-173">當您建立識別碼欄位時，請以登錄屬性時所用名稱命名此欄位，再加上尾碼 `Property`。</span><span class="sxs-lookup"><span data-stu-id="72440-173">When you create the identifier field, name this field by the name of the property as you registered it, plus the suffix `Property`.</span></span> <span data-ttu-id="72440-174">此欄位是依賴項屬性的標識碼,稍後將用作包裝器中要進行的<xref:System.Windows.DependencyObject.SetValue%2A>和<xref:System.Windows.DependencyObject.GetValue%2A>呼叫的輸入、您自己的代碼對該屬性的任何其他代碼存取、您允許的任何外部代碼存取、屬性系統以及[!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]可能由處理器存取。</span><span class="sxs-lookup"><span data-stu-id="72440-174">This field is your identifier for the dependency property, and it will be used later as an input for the <xref:System.Windows.DependencyObject.SetValue%2A> and <xref:System.Windows.DependencyObject.GetValue%2A> calls you will make in the wrappers, by any other code access to the property by your own code, by any external code access you allow, by the property system, and potentially by [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processors.</span></span>

> [!NOTE]
> <span data-ttu-id="72440-175">在類別主體中定義相依性屬性是一般的實作，但也可能在類別靜態建構函式中定義相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="72440-175">Defining the dependency property in the class body is the typical implementation, but it is also possible to define a dependency property in the class static constructor.</span></span> <span data-ttu-id="72440-176">如果您需要多行程式碼來初始化相依性屬性，這個方式可能有意義。</span><span class="sxs-lookup"><span data-stu-id="72440-176">This approach might make sense if you need more than one line of code to initialize the dependency property.</span></span>

<a name="wrapper1"></a>

### <a name="implementing-the-wrapper"></a><span data-ttu-id="72440-177">實作 "wrapper"</span><span class="sxs-lookup"><span data-stu-id="72440-177">Implementing the "Wrapper"</span></span>

<span data-ttu-id="72440-178">包裝<xref:System.Windows.DependencyObject.GetValue%2A>器實現應在`get`實現<xref:System.Windows.DependencyObject.SetValue%2A>`set`和 實現中調用(此處也顯示原始註冊調用和欄位,以便清楚)。</span><span class="sxs-lookup"><span data-stu-id="72440-178">Your wrapper implementation should call <xref:System.Windows.DependencyObject.GetValue%2A> in the `get` implementation, and <xref:System.Windows.DependencyObject.SetValue%2A> in the `set` implementation (the original registration call and field are shown here too for clarity).</span></span>

<span data-ttu-id="72440-179">在除了特殊情況外,包裝器實現應分別執行和<xref:System.Windows.DependencyObject.GetValue%2A><xref:System.Windows.DependencyObject.SetValue%2A>操作。</span><span class="sxs-lookup"><span data-stu-id="72440-179">In all but exceptional circumstances, your wrapper implementations should perform only the <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> actions, respectively.</span></span> <span data-ttu-id="72440-180">相關原因討論請參閱 [XAML 載入和相依性屬性](xaml-loading-and-dependency-properties.md)主題。</span><span class="sxs-lookup"><span data-stu-id="72440-180">The reason for this is discussed in the topic [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<span data-ttu-id="72440-181">[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 類別中提供的所有現有公用相依性屬性都使用這個簡單的包裝函式實作模型，相依性屬性運作方式最複雜的部分或為固有的屬性系統行為，或為透過其他概念予以實行，例如透過屬性中繼資料的強制型轉或屬性變更回呼。</span><span class="sxs-lookup"><span data-stu-id="72440-181">All existing public dependency properties that are provided on the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes use this simple wrapper implementation model; most of the complexity of how dependency properties work is either inherently a behavior of the property system, or is implemented through other concepts such as coercion or property change callbacks through property metadata.</span></span>

[!code-csharp[WPFAquariumSln#AGWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#agwithwrapper)]
[!code-vb[WPFAquariumSln#AGWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#agwithwrapper)]

<span data-ttu-id="72440-182">同樣,按照慣例,包裝器屬性的名稱必須與選擇的名稱相同,並作為註冊該屬性的<xref:System.Windows.DependencyProperty.Register%2A>調用的第一個參數給出。</span><span class="sxs-lookup"><span data-stu-id="72440-182">Again, by convention, the name of the wrapper property must be the same as the name chosen and given as first parameter of the <xref:System.Windows.DependencyProperty.Register%2A> call that registered the property.</span></span> <span data-ttu-id="72440-183">如果您的屬性不遵循慣例，不一定會停用所有可能的用途，但您會遇到幾個值得注意的問題︰</span><span class="sxs-lookup"><span data-stu-id="72440-183">If your property does not follow the convention, this does not necessarily disable all possible uses, but you will encounter several notable issues:</span></span>

- <span data-ttu-id="72440-184">樣式和範本的某些方面不起作用。</span><span class="sxs-lookup"><span data-stu-id="72440-184">Certain aspects of styles and templates will not work.</span></span>

- <span data-ttu-id="72440-185">大部分的工具和設計工具必須依賴命名慣例，才能正確序列化 [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]，或依屬性層級提供設計工具環境協助。</span><span class="sxs-lookup"><span data-stu-id="72440-185">Most tools and designers must rely on the naming conventions to properly serialize [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)], or to provide designer environment assistance at a per-property level.</span></span>

- <span data-ttu-id="72440-186">載入程式的[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)][!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)]當前實現完全繞過包裝器,在處理屬性值時依賴於命名約定。</span><span class="sxs-lookup"><span data-stu-id="72440-186">The current implementation of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] loader bypasses the wrappers entirely, and relies on the naming convention when processing attribute values.</span></span> <span data-ttu-id="72440-187">如需詳細資訊，請參閱 [XAML 相依性屬性](xaml-loading-and-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-187">For more information, see [XAML Loading and Dependency Properties](xaml-loading-and-dependency-properties.md).</span></span>

<a name="metadata"></a>

### <a name="property-metadata-for-a-new-dependency-property"></a><span data-ttu-id="72440-188">新相依性屬性的屬性中繼資料</span><span class="sxs-lookup"><span data-stu-id="72440-188">Property Metadata for a New Dependency Property</span></span>

<span data-ttu-id="72440-189">當您登錄相依性屬性時，登錄會透過屬性系統建立儲存屬性特性的中繼資料物件。</span><span class="sxs-lookup"><span data-stu-id="72440-189">When you register a dependency property, the registration through the property system creates a metadata object that stores property characteristics.</span></span> <span data-ttu-id="72440-190">如果屬性註冊了<xref:System.Windows.DependencyProperty.Register%2A>的簡單簽名,則這些特徵中有許多具有預設設置。</span><span class="sxs-lookup"><span data-stu-id="72440-190">Many of these characteristics have defaults that are set if the property is registered with the simple signatures of <xref:System.Windows.DependencyProperty.Register%2A>.</span></span> <span data-ttu-id="72440-191">的其他簽名<xref:System.Windows.DependencyProperty.Register%2A>允許您在註冊屬性時指定所需的元數據。</span><span class="sxs-lookup"><span data-stu-id="72440-191">Other signatures of <xref:System.Windows.DependencyProperty.Register%2A> allow you to specify the metadata that you want as you register the property.</span></span> <span data-ttu-id="72440-192">相依性屬性最常指定的中繼資料，是套用在新執行個體的預設值，而新執行個體使用該屬性。</span><span class="sxs-lookup"><span data-stu-id="72440-192">The most common metadata given for dependency properties is to give them a default value that is applied on new instances that use the property.</span></span>

<span data-ttu-id="72440-193">如果要創建存在於 派生類的依賴項屬性,則可以使用更專用<xref:System.Windows.FrameworkElement>的 元<xref:System.Windows.FrameworkPropertyMetadata>數據類<xref:System.Windows.PropertyMetadata>而不是基 類。</span><span class="sxs-lookup"><span data-stu-id="72440-193">If you are creating a dependency property that exists on a derived class of <xref:System.Windows.FrameworkElement>, you can use the more specialized metadata class <xref:System.Windows.FrameworkPropertyMetadata> rather than the base <xref:System.Windows.PropertyMetadata> class.</span></span> <span data-ttu-id="72440-194">類別建<xref:System.Windows.FrameworkPropertyMetadata>構函數具有多個簽名,您可以在其中組合指定各種元資料特徵。</span><span class="sxs-lookup"><span data-stu-id="72440-194">The constructor for the <xref:System.Windows.FrameworkPropertyMetadata> class has several signatures where you can specify various metadata characteristics in combination.</span></span> <span data-ttu-id="72440-195">如果只想指定預設值,請使用採用類型<xref:System.Object>為的單個參數的簽名。</span><span class="sxs-lookup"><span data-stu-id="72440-195">If you want to specify the default value only, use the signature that takes a single parameter of type <xref:System.Object>.</span></span> <span data-ttu-id="72440-196">將該物件參數作為屬性的特定於類型的預設值傳遞(提供的預設值必須是您在`propertyType`<xref:System.Windows.DependencyProperty.Register%2A>調用中作為參數提供的類型)。</span><span class="sxs-lookup"><span data-stu-id="72440-196">Pass that object parameter as a type-specific default value for your property (the default value provided must be the type you provided as the `propertyType` parameter in the <xref:System.Windows.DependencyProperty.Register%2A> call).</span></span>

<span data-ttu-id="72440-197">對於<xref:System.Windows.FrameworkPropertyMetadata>,還可以為屬性指定元數據選項標誌。</span><span class="sxs-lookup"><span data-stu-id="72440-197">For <xref:System.Windows.FrameworkPropertyMetadata>, you can also specify metadata option flags for your property.</span></span> <span data-ttu-id="72440-198">這些旗標在登錄後會轉換成屬性中繼資料中的個別屬性，用以與版面配置引擎等其他處理序溝通特定條件。</span><span class="sxs-lookup"><span data-stu-id="72440-198">These flags are converted into discrete properties on the property metadata after registration and are used to communicate certain conditionals to other processes such as the layout engine.</span></span>

#### <a name="setting-appropriate-metadata-flags"></a><span data-ttu-id="72440-199">設定適當的中繼資料旗標</span><span class="sxs-lookup"><span data-stu-id="72440-199">Setting Appropriate Metadata Flags</span></span>

- <span data-ttu-id="72440-200">如果屬性(或其值的變更)影響[!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)],並且特別影響佈局系統在頁面中的大小或呈現元素的方式,請設定以下一個或多個標誌: <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>。</span><span class="sxs-lookup"><span data-stu-id="72440-200">If your property (or changes in its value) affects the [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)], and in particular affects how the layout system should size or render your element in a page, set one or more of the following flags: <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>, <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>.</span></span>

  - <span data-ttu-id="72440-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure>指示對此屬性的更改需要更改為[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]呈現,其中包含物件可能需要父物件中或多或少的空間。</span><span class="sxs-lookup"><span data-stu-id="72440-201"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsMeasure> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering where the containing object might require more or less space within the parent.</span></span> <span data-ttu-id="72440-202">例如，"Width" 屬性應該設定此旗標。</span><span class="sxs-lookup"><span data-stu-id="72440-202">For example, a "Width" property should have this flag set.</span></span>

  - <span data-ttu-id="72440-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange>指示對此屬性的更改需要更改[!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)]渲染,這通常不需要在專用空間中進行更改,但確實表示空間中的定位已更改。</span><span class="sxs-lookup"><span data-stu-id="72440-203"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsArrange> indicates that a change to this property requires a change to [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] rendering that typically does not require a change in the dedicated space, but does indicate that the positioning within the space has changed.</span></span> <span data-ttu-id="72440-204">例如，"Alignment" 屬性應該設定此旗標。</span><span class="sxs-lookup"><span data-stu-id="72440-204">For example, an "Alignment" property should have this flag set.</span></span>

  - <span data-ttu-id="72440-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender>指示發生了一些其他更改,這些更改不會影響佈局和度量值,但確實需要另一個渲染。</span><span class="sxs-lookup"><span data-stu-id="72440-205"><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsRender> indicates that some other change has occurred that will not affect layout and measure, but does require another render.</span></span> <span data-ttu-id="72440-206">例如可變更現有項目色彩的 "Background" 等屬性。</span><span class="sxs-lookup"><span data-stu-id="72440-206">An example would be a property that changes a color of an existing element, such as "Background".</span></span>

  - <span data-ttu-id="72440-207">這些旗標在您自己的屬性系統或配置回呼覆寫實作中，通常用為中繼資料的通訊協定。</span><span class="sxs-lookup"><span data-stu-id="72440-207">These flags are often used as a protocol in metadata for your own override implementations of property system or layout callbacks.</span></span> <span data-ttu-id="72440-208">例如,如果實例的任何屬性報告<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>值更改且其元<xref:System.Windows.UIElement.InvalidateArrange%2A>數據<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>中`true`具有 , 則可能具有回調。</span><span class="sxs-lookup"><span data-stu-id="72440-208">For instance, you might have an <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> callback that will call <xref:System.Windows.UIElement.InvalidateArrange%2A> if any property of the instance reports a value change and has <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> as `true` in its metadata.</span></span>

- <span data-ttu-id="72440-209">某些屬性會影響包含父項目的轉譯特性，超過前文所述之所需大小的變更。</span><span class="sxs-lookup"><span data-stu-id="72440-209">Some properties may affect the rendering characteristics of the containing parent element, in ways above and beyond the changes in required size mentioned above.</span></span> <span data-ttu-id="72440-210">例如,流文<xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A>檔模型中使用的屬性,其中對該屬性的更改可以更改包含段落的流文檔的總體呈現。</span><span class="sxs-lookup"><span data-stu-id="72440-210">An example is the <xref:System.Windows.Documents.Paragraph.MinOrphanLines%2A> property used in the flow document model, where changes to that property can change the overall rendering of the flow document that contains the paragraph.</span></span> <span data-ttu-id="72440-211">使用<xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange><xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure>或在您自己的屬性中識別類似情況。</span><span class="sxs-lookup"><span data-stu-id="72440-211">Use <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentArrange> or <xref:System.Windows.FrameworkPropertyMetadataOptions.AffectsParentMeasure> to identify similar cases in your own properties.</span></span>

- <span data-ttu-id="72440-212">相依性屬性預設支援資料繫結。</span><span class="sxs-lookup"><span data-stu-id="72440-212">By default, dependency properties support data binding.</span></span> <span data-ttu-id="72440-213">對於沒有任何實際案例可進行資料繫結的情況，或者大型物件的資料繫結效能認定有問題的情況，您可以故意停用資料繫結。</span><span class="sxs-lookup"><span data-stu-id="72440-213">You can deliberately disable data binding, for cases where there is no realistic scenario for data binding, or where performance in data binding for a large object is recognized as a problem.</span></span>

- <span data-ttu-id="72440-214">預設情況下,依賴項目屬性<xref:System.Windows.Data.Binding.Mode%2A>的資料繫結預設<xref:System.Windows.Data.BindingMode.OneWay>為 。</span><span class="sxs-lookup"><span data-stu-id="72440-214">By default, data binding <xref:System.Windows.Data.Binding.Mode%2A> for dependency properties defaults to <xref:System.Windows.Data.BindingMode.OneWay>.</span></span> <span data-ttu-id="72440-215">您可以隨時將綁定更改為<xref:System.Windows.Data.BindingMode.TwoWay>每個綁定實例;因此,您可以將綁定更改為每個綁定實例。有關詳細資訊,請參閱[指定綁定的方向](../data/how-to-specify-the-direction-of-the-binding.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-215">You can always change the binding to be <xref:System.Windows.Data.BindingMode.TwoWay> per binding instance; for details, see [Specify the Direction of the Binding](../data/how-to-specify-the-direction-of-the-binding.md).</span></span> <span data-ttu-id="72440-216">但是,作為依賴項屬性作者,您可以選擇使屬性預設使用<xref:System.Windows.Data.BindingMode.TwoWay>綁定模式。</span><span class="sxs-lookup"><span data-stu-id="72440-216">But as the dependency property author, you can choose to make the property use <xref:System.Windows.Data.BindingMode.TwoWay> binding mode by default.</span></span> <span data-ttu-id="72440-217">現有相依項屬性的範例<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>是 。此屬性的方案是<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A>設置邏輯和組合<xref:System.Windows.Controls.MenuItem>與 預設主題樣式交互。</span><span class="sxs-lookup"><span data-stu-id="72440-217">An example of an existing dependency property is <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A?displayProperty=nameWithType>; the scenario for this property is that the <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> setting logic and the compositing of <xref:System.Windows.Controls.MenuItem> interact with the default theme style.</span></span> <span data-ttu-id="72440-218">屬性<xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A>邏輯使用本機綁定的數據來根據其他狀態屬性和方法調用維護屬性的狀態。</span><span class="sxs-lookup"><span data-stu-id="72440-218">The <xref:System.Windows.Controls.MenuItem.IsSubmenuOpen%2A> property logic uses data binding natively to maintain the state of the property in accordance to other state properties and method calls.</span></span> <span data-ttu-id="72440-219">預設情況下繫結<xref:System.Windows.Data.BindingMode.TwoWay>的另一個範例屬性是<xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="72440-219">Another example property that binds <xref:System.Windows.Data.BindingMode.TwoWay> by default is <xref:System.Windows.Controls.TextBox.Text%2A?displayProperty=nameWithType>.</span></span>

- <span data-ttu-id="72440-220">還可以通過設置<xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits>標誌在自定義依賴項屬性中啟用屬性繼承。</span><span class="sxs-lookup"><span data-stu-id="72440-220">You can also enable property inheritance in a custom dependency property by setting the <xref:System.Windows.FrameworkPropertyMetadataOptions.Inherits> flag.</span></span> <span data-ttu-id="72440-221">屬性繼承對父項目和子項目有共同屬性的案例很有用，而且對子項目將特定屬性值設定為和父項目設定的值一樣，才有意義。</span><span class="sxs-lookup"><span data-stu-id="72440-221">Property inheritance is useful for a scenario where parent elements and child elements have a property in common, and it makes sense for the child elements to have that particular property value set to the same value as the parent set it.</span></span> <span data-ttu-id="72440-222">可繼承屬性的範例為<xref:System.Windows.FrameworkElement.DataContext%2A>,用於綁定操作,以啟用資料表示的重要主詳細資訊方案。</span><span class="sxs-lookup"><span data-stu-id="72440-222">An example inheritable property is <xref:System.Windows.FrameworkElement.DataContext%2A>, which is used for binding operations to enable the important master-detail scenario for data presentation.</span></span> <span data-ttu-id="72440-223">通過使<xref:System.Windows.FrameworkElement.DataContext%2A>可繼承,任何子元素也繼承該數據上下文。</span><span class="sxs-lookup"><span data-stu-id="72440-223">By making <xref:System.Windows.FrameworkElement.DataContext%2A> inheritable, any child elements inherit that data context also.</span></span> <span data-ttu-id="72440-224">因為屬性值繼承的緣故，您可以指定位在網頁或應用程式根目錄中的資料內容，不需要重新指定即可繫結所有可能的子項目。</span><span class="sxs-lookup"><span data-stu-id="72440-224">Because of property value inheritance, you can specify a data context at the page or application root, and do not need to respecify it for bindings in all possible child elements.</span></span> <span data-ttu-id="72440-225"><xref:System.Windows.FrameworkElement.DataContext%2A>也是一個很好的例子,說明繼承重寫預設值,但它始終可以在本地設置在任何特定的子元素上;關於詳細資訊,請參考[使用具有分層資料的主詳細資訊模式](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-225"><xref:System.Windows.FrameworkElement.DataContext%2A> is also a good example to illustrate that inheritance overrides the default value, but it can always be set locally on any particular child element; for details, see [Use the Master-Detail Pattern with Hierarchical Data](../data/how-to-use-the-master-detail-pattern-with-hierarchical-data.md).</span></span> <span data-ttu-id="72440-226">屬性值繼承確實有可能的效能成本，因此應謹慎使用。如需詳細資訊，請參閱[屬性值繼承](property-value-inheritance.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-226">Property value inheritance does have a possible performance cost, and thus should be used sparingly; for details, see [Property Value Inheritance](property-value-inheritance.md).</span></span>

- <span data-ttu-id="72440-227">設置標誌<xref:System.Windows.FrameworkPropertyMetadataOptions.Journal>以指示是否應檢測到依賴項屬性或由導航日記服務使用。</span><span class="sxs-lookup"><span data-stu-id="72440-227">Set the <xref:System.Windows.FrameworkPropertyMetadataOptions.Journal> flag to indicate if your dependency property should be detected or used by navigation journaling services.</span></span> <span data-ttu-id="72440-228">屬性就是一<xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A>個示例;導航日記歷史記錄時,應保留選擇控件中選擇的任何項。</span><span class="sxs-lookup"><span data-stu-id="72440-228">An example is the <xref:System.Windows.Controls.Primitives.Selector.SelectedIndex%2A> property; any item selected in a selection control should be persisted when the journaling history is navigated.</span></span>

<a name="RODP"></a>

## <a name="read-only-dependency-properties"></a><span data-ttu-id="72440-229">唯讀相依性屬性</span><span class="sxs-lookup"><span data-stu-id="72440-229">Read-Only Dependency Properties</span></span>

<span data-ttu-id="72440-230">您可以定義唯讀的相依性屬性。</span><span class="sxs-lookup"><span data-stu-id="72440-230">You can define a dependency property that is read-only.</span></span> <span data-ttu-id="72440-231">但您為何可能將屬性定義為唯讀的案例有點不同，和向屬性系統登錄它們並公開識別碼的程序一樣。</span><span class="sxs-lookup"><span data-stu-id="72440-231">However, the scenarios for why you might define your property as read-only are somewhat different, as is the procedure for registering them with the property system and exposing the identifier.</span></span> <span data-ttu-id="72440-232">如需詳細資訊，請參閱[唯讀相依性屬性](read-only-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-232">For more information, see [Read-Only Dependency Properties](read-only-dependency-properties.md).</span></span>

<a name="CTDP"></a>

## <a name="collection-type-dependency-properties"></a><span data-ttu-id="72440-233">集合類型相依性屬性</span><span class="sxs-lookup"><span data-stu-id="72440-233">Collection-Type Dependency Properties</span></span>

<span data-ttu-id="72440-234">集合類型相依性屬性要考慮一些其他的實作問題。</span><span class="sxs-lookup"><span data-stu-id="72440-234">Collection-type dependency properties have some additional implementation issues to consider.</span></span> <span data-ttu-id="72440-235">如需詳細資訊，請參閱[集合類型相依性屬性](collection-type-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-235">For details, see [Collection-Type Dependency Properties](collection-type-dependency-properties.md).</span></span>

<a name="SecurityC"></a>

## <a name="dependency-property-security-considerations"></a><span data-ttu-id="72440-236">相依性屬性安全性考量</span><span class="sxs-lookup"><span data-stu-id="72440-236">Dependency Property Security Considerations</span></span>

<span data-ttu-id="72440-237">相依性屬性應該宣告為公用屬性。</span><span class="sxs-lookup"><span data-stu-id="72440-237">Dependency properties should be declared as public properties.</span></span> <span data-ttu-id="72440-238">相依性屬性識別碼欄位應該宣告為公用靜態欄位。</span><span class="sxs-lookup"><span data-stu-id="72440-238">Dependency property identifier fields should be declared as public static fields.</span></span> <span data-ttu-id="72440-239">即使您嘗試聲明其他訪問級別(如受保護),也始終可以通過標識符與屬性系統 API 一起訪問依賴項屬性。</span><span class="sxs-lookup"><span data-stu-id="72440-239">Even if you attempt to declare other access levels (such as protected), a dependency property can always be accessed through the identifier in combination with the property system APIs.</span></span> <span data-ttu-id="72440-240">由於中繼報告或作為屬性系統的一部分的值確定 API(<xref:System.Windows.LocalValueEnumerator>如 ),即使受保護的標識符欄位也可能存取。</span><span class="sxs-lookup"><span data-stu-id="72440-240">Even a protected identifier field is potentially accessible because of metadata reporting or value determination APIs that are part of the property system, such as <xref:System.Windows.LocalValueEnumerator>.</span></span> <span data-ttu-id="72440-241">如需詳細資訊，請參閱[相依性屬性的安全性](dependency-property-security.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-241">For more information, see [Dependency Property Security](dependency-property-security.md).</span></span>

<a name="DPCtor"></a>

## <a name="dependency-properties-and-class-constructors"></a><span data-ttu-id="72440-242">相依性屬性和類別建構函式</span><span class="sxs-lookup"><span data-stu-id="72440-242">Dependency Properties and Class Constructors</span></span>

<span data-ttu-id="72440-243">Managed 程式碼程式設計中有項一般原則 (通常由 FxCop 等程式碼分析工具強制執行)，類別建構函式不應該呼叫虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="72440-243">There is a general principle in managed code programming (often enforced by code analysis tools such as FxCop) that class constructors should not call virtual methods.</span></span> <span data-ttu-id="72440-244">這是因為建構函式可以呼叫為衍生類別建構函式的基底初始化，而透過建構函式進入虛擬方法，可能會發生在建構中的物件執行個體尚未完全初始化的狀態。</span><span class="sxs-lookup"><span data-stu-id="72440-244">This is because constructors can be called as base initialization of a derived class constructor, and entering the virtual method through the constructor might occur at an incomplete initialization state of the object instance being constructed.</span></span> <span data-ttu-id="72440-245">當您從已經派生的任何<xref:System.Windows.DependencyObject>類派生時,應注意屬性系統本身在內部調用並公開虛擬方法。</span><span class="sxs-lookup"><span data-stu-id="72440-245">When you derive from any class that already derives from <xref:System.Windows.DependencyObject>, you should be aware that the property system itself calls and exposes virtual methods internally.</span></span> <span data-ttu-id="72440-246">這些虛擬方法都屬於 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] 屬性系統服務。</span><span class="sxs-lookup"><span data-stu-id="72440-246">These virtual methods are part of the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] property system services.</span></span> <span data-ttu-id="72440-247">覆寫方法可讓衍生的類別參與值判斷。</span><span class="sxs-lookup"><span data-stu-id="72440-247">Overriding the methods enables derived classes to participate in value determination.</span></span> <span data-ttu-id="72440-248">若要避免執行階段初始化可能發生的問題，您不應該在類別的建構函式中設定相依性屬性值，除非您遵循非常明確的建構函式模式。</span><span class="sxs-lookup"><span data-stu-id="72440-248">To avoid potential issues with runtime initialization, you should not set dependency property values within constructors of classes, unless you follow a very specific constructor pattern.</span></span> <span data-ttu-id="72440-249">如需詳細資訊，請參閱 [DependencyObject 的安全建構函式模式](safe-constructor-patterns-for-dependencyobjects.md)。</span><span class="sxs-lookup"><span data-stu-id="72440-249">For details, see [Safe Constructor Patterns for DependencyObjects](safe-constructor-patterns-for-dependencyobjects.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="72440-250">另請參閱</span><span class="sxs-lookup"><span data-stu-id="72440-250">See also</span></span>

- [<span data-ttu-id="72440-251">相依性屬性概觀</span><span class="sxs-lookup"><span data-stu-id="72440-251">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="72440-252">相依性屬性中繼資料</span><span class="sxs-lookup"><span data-stu-id="72440-252">Dependency Property Metadata</span></span>](dependency-property-metadata.md)
- [<span data-ttu-id="72440-253">控制項撰寫概觀</span><span class="sxs-lookup"><span data-stu-id="72440-253">Control Authoring Overview</span></span>](../controls/control-authoring-overview.md)
- [<span data-ttu-id="72440-254">集合類型相依性屬性</span><span class="sxs-lookup"><span data-stu-id="72440-254">Collection-Type Dependency Properties</span></span>](collection-type-dependency-properties.md)
- [<span data-ttu-id="72440-255">相依性屬性的安全性</span><span class="sxs-lookup"><span data-stu-id="72440-255">Dependency Property Security</span></span>](dependency-property-security.md)
- [<span data-ttu-id="72440-256">XAML 載入和相依性屬性</span><span class="sxs-lookup"><span data-stu-id="72440-256">XAML Loading and Dependency Properties</span></span>](xaml-loading-and-dependency-properties.md)
- [<span data-ttu-id="72440-257">DependencyObject 的安全建構函式模式</span><span class="sxs-lookup"><span data-stu-id="72440-257">Safe Constructor Patterns for DependencyObjects</span></span>](safe-constructor-patterns-for-dependencyobjects.md)
