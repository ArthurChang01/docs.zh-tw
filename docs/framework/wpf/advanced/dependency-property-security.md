---
title: 相依性屬性的安全性
ms.date: 03/30/2017
helpviewer_keywords:
- wrappers [WPF], access
- wrappers [WPF], security
- dependency properties [WPF], security
- security [WPF], wrappers
- validation [WPF], dependency properties
- dependency properties [WPF], access
- security [WPF], dependency properties
ms.assetid: d10150ec-90c5-4571-8d35-84bafa2429a4
ms.openlocfilehash: 825b2a3dc79300f0cc26514398b8de0abee64fd4
ms.sourcegitcommit: 3d5d33f384eeba41b2dff79d096f47ccc8d8f03d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 05/04/2018
ms.locfileid: "33540500"
---
# <a name="dependency-property-security"></a><span data-ttu-id="1cc35-102">相依性屬性的安全性</span><span class="sxs-lookup"><span data-stu-id="1cc35-102">Dependency Property Security</span></span>
<span data-ttu-id="1cc35-103">相依性屬性通常應該視為公用屬性。</span><span class="sxs-lookup"><span data-stu-id="1cc35-103">Dependency properties should generally be considered to be public properties.</span></span> <span data-ttu-id="1cc35-104">[!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] 屬性系統在本質上會防止進行相依性屬性值的安全性保證。</span><span class="sxs-lookup"><span data-stu-id="1cc35-104">The nature of the [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] property system prevents the ability to make security guarantees about a dependency property value.</span></span>  
  
  
<a name="AccessSecurity"></a>   
## <a name="access-and-security-of-wrappers-and-dependency-properties"></a><span data-ttu-id="1cc35-105">包裝函式和相依性屬性的存取和安全性</span><span class="sxs-lookup"><span data-stu-id="1cc35-105">Access and Security of Wrappers and Dependency Properties</span></span>  
 <span data-ttu-id="1cc35-106">通常，相依性屬性會與「包裝函式」[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] 屬性一起實作，該屬性會簡化對執行個體屬性的取得或設定。</span><span class="sxs-lookup"><span data-stu-id="1cc35-106">Typically, dependency properties are implemented along with "wrapper" [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] properties that simplify getting or setting the property from an instance.</span></span> <span data-ttu-id="1cc35-107">包裝函式，其實就是便利的方法實作的基礎，但是<xref:System.Windows.DependencyObject.GetValue%2A>和<xref:System.Windows.DependencyObject.SetValue%2A>靜態相依性屬性和互動時所使用的呼叫。</span><span class="sxs-lookup"><span data-stu-id="1cc35-107">But the wrappers are really just convenience methods that implement the underlying <xref:System.Windows.DependencyObject.GetValue%2A> and <xref:System.Windows.DependencyObject.SetValue%2A> static calls that are used when interacting with dependency properties.</span></span> <span data-ttu-id="1cc35-108">從另一個方面來思考，這些屬性會公開為剛好受到相依性屬性 (而不是私用欄位) 支援的[!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] 屬性。</span><span class="sxs-lookup"><span data-stu-id="1cc35-108">Thinking of it in another way, the properties are exposed as [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] properties that happen to be backed by a dependency property rather than by a private field.</span></span> <span data-ttu-id="1cc35-109">套用到包裝函式的安全性機制，與屬性系統行為和基礎相依性屬性的存取並不相同。</span><span class="sxs-lookup"><span data-stu-id="1cc35-109">Security mechanisms applied to the wrappers do not parallel the property system behavior and access of the underlying dependency property.</span></span> <span data-ttu-id="1cc35-110">置於包裝函式的安全性要求將不僅可以防止便利的方法的使用方式，但不是會防止呼叫<xref:System.Windows.DependencyObject.GetValue%2A>或<xref:System.Windows.DependencyObject.SetValue%2A>。</span><span class="sxs-lookup"><span data-stu-id="1cc35-110">Placing a security demand on the wrapper will only prevent the usage of the convenience method but will not prevent calls to <xref:System.Windows.DependencyObject.GetValue%2A> or <xref:System.Windows.DependencyObject.SetValue%2A>.</span></span> <span data-ttu-id="1cc35-111">同樣地，對包裝函式設置保護或私用存取層級並不會提供任何有效的安全性防護。</span><span class="sxs-lookup"><span data-stu-id="1cc35-111">Similarly, placing protected or private access level on the wrappers does not provide any effective security.</span></span>  
  
 <span data-ttu-id="1cc35-112">如果您要撰寫您自己的相依性屬性，您應該宣告包裝函式和<xref:System.Windows.DependencyProperty>識別碼欄位，做為公用成員，讓呼叫端沒有未取得容易發生錯誤，該屬性，則為 true 的存取層級的相關資訊 （因為它的存放區正在實作為相依性屬性。）</span><span class="sxs-lookup"><span data-stu-id="1cc35-112">If you are writing your own dependency properties, you should declare the wrappers and the <xref:System.Windows.DependencyProperty> identifier field as public members, so that callers do not get misleading information about the true access level of that property (because of its store being implemented as a dependency property).</span></span>  
  
 <span data-ttu-id="1cc35-113">自訂相依性屬性，您可以註冊您的屬性為唯讀相依性屬性，並防止任何人都不包含的參考設定屬性的有效方法，這提供<xref:System.Windows.DependencyPropertyKey>該屬性。</span><span class="sxs-lookup"><span data-stu-id="1cc35-113">For a custom dependency property, you can register your property as a read-only dependency property, and this does provide an effective means of preventing a property being set by anyone that does not hold a reference to the <xref:System.Windows.DependencyPropertyKey> for that property.</span></span> <span data-ttu-id="1cc35-114">如需詳細資訊，請參閱[唯讀相依性屬性](../../../../docs/framework/wpf/advanced/read-only-dependency-properties.md)。</span><span class="sxs-lookup"><span data-stu-id="1cc35-114">For more information, see [Read-Only Dependency Properties](../../../../docs/framework/wpf/advanced/read-only-dependency-properties.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1cc35-115">宣告<xref:System.Windows.DependencyProperty>不禁止的識別項欄位私用，並有助於減少立即公開的命名空間的自訂類別，可用理論上，但這類屬性不應視為相同的意義上，為 「 私人 」 [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)]語言定義所定義的存取層級下, 一節中所述的原因。</span><span class="sxs-lookup"><span data-stu-id="1cc35-115">Declaring a <xref:System.Windows.DependencyProperty> identifier field private is not forbidden, and it can conceivably be used to help reduce the immediately exposed namespace of a custom class, but such a property should not be considered "private" in the same sense as the [!INCLUDE[TLA#tla_clr](../../../../includes/tlasharptla-clr-md.md)] language definitions define that access level, for reasons described in the next section.</span></span>  
  
<a name="PropertySystemExposure"></a>   
## <a name="property-system-exposure-of-dependency-properties"></a><span data-ttu-id="1cc35-116">相依性屬性的屬性系統公開</span><span class="sxs-lookup"><span data-stu-id="1cc35-116">Property System Exposure of Dependency Properties</span></span>  
 <span data-ttu-id="1cc35-117">不是通常很有用，而且很可能會產生誤導，來宣告<xref:System.Windows.DependencyProperty>任何存取層級而不是公用。</span><span class="sxs-lookup"><span data-stu-id="1cc35-117">It is not generally useful, and it is potentially misleading, to declare a <xref:System.Windows.DependencyProperty> as any access level other than public.</span></span> <span data-ttu-id="1cc35-118">該存取層級設定只能防止使用者取得宣告類別執行個體的參考。</span><span class="sxs-lookup"><span data-stu-id="1cc35-118">That access level setting only prevents someone from being able to get a reference to the instance from the declaring class.</span></span> <span data-ttu-id="1cc35-119">但有幾個層面的屬性系統，將會傳回<xref:System.Windows.DependencyProperty>做為識別特定的屬性，因為它存在於類別的執行個體或衍生的類別執行個體，而且這個識別碼是在仍可使用的方法<xref:System.Windows.DependencyObject.SetValue%2A>即使呼叫如果原始的靜態識別項宣告為 nonpublic。</span><span class="sxs-lookup"><span data-stu-id="1cc35-119">But there are several aspects of the property system that will return a <xref:System.Windows.DependencyProperty> as the means of identifying a particular property as it exists on an instance of a class or a derived class instance, and this identifier is still usable in a <xref:System.Windows.DependencyObject.SetValue%2A> call even if the original static identifier is declared as nonpublic.</span></span> <span data-ttu-id="1cc35-120">此外，<xref:System.Windows.DependencyObject.OnPropertyChanged%2A>虛擬方法都會接收值變更任何現有相依性屬性資訊。</span><span class="sxs-lookup"><span data-stu-id="1cc35-120">Also, <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> virtual methods receive information of any existing dependency property that changed value.</span></span> <span data-ttu-id="1cc35-121">此外，<xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A>方法會傳回任何屬性的識別項執行個體與本機設定值。</span><span class="sxs-lookup"><span data-stu-id="1cc35-121">In addition, the <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> method returns identifiers for any property on instances with a locally set value.</span></span>  
  
### <a name="validation-and-security"></a><span data-ttu-id="1cc35-122">驗證和安全性</span><span class="sxs-lookup"><span data-stu-id="1cc35-122">Validation and Security</span></span>  
 <span data-ttu-id="1cc35-123">套用要求<xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>和預期要求失敗，以防止屬性所設定的驗證失敗不是適當的安全性機制。</span><span class="sxs-lookup"><span data-stu-id="1cc35-123">Applying a demand to a <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> and expecting the validation failure on a demand failure to prevent a property from being set is not an adequate security mechanism.</span></span> <span data-ttu-id="1cc35-124">透過強制執行設定值失效<xref:System.Windows.DependencyProperty.ValidateValueCallback%2A>可能也會歸併被惡意呼叫端，如果應用程式定義域內操作這些呼叫端。</span><span class="sxs-lookup"><span data-stu-id="1cc35-124">Set-value invalidation enforced through <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> could also be suppressed by malicious callers, if those callers are operating within the application domain.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="1cc35-125">另請參閱</span><span class="sxs-lookup"><span data-stu-id="1cc35-125">See Also</span></span>  
 [<span data-ttu-id="1cc35-126">自訂相依性屬性</span><span class="sxs-lookup"><span data-stu-id="1cc35-126">Custom Dependency Properties</span></span>](../../../../docs/framework/wpf/advanced/custom-dependency-properties.md)
