---
title: SOS.dll (SOS 偵錯擴充功能)
ms.date: 03/30/2017
helpviewer_keywords:
- debugging extensions
- SOS debugging extensions
- SOS.dll
ms.assetid: 9ac1b522-77ab-4cdc-852a-20fcdc9ae498
author: mairaw
ms.author: mairaw
ms.openlocfilehash: 0c038b66e4ed62d614a25e717c52fdcc9c5f9a23
ms.sourcegitcommit: 6eac9a01ff5d70c6d18460324c016a3612c5e268
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/17/2018
ms.locfileid: "45615530"
---
# <a name="sosdll-sos-debugging-extension"></a><span data-ttu-id="ce73f-102">SOS.dll (SOS 偵錯擴充功能)</span><span class="sxs-lookup"><span data-stu-id="ce73f-102">SOS.dll (SOS Debugging Extension)</span></span>
<span data-ttu-id="ce73f-103">SOS 偵錯延伸模組副檔名 (SOS.dll) 提供內部 Common Language Runtime (CLR) 環境的相關資訊，以協助您在 Windows 偵錯工具 (WinDbg.exe) 和 Visual Studio 中偵錯受控程式。</span><span class="sxs-lookup"><span data-stu-id="ce73f-103">The SOS Debugging Extension (SOS.dll) helps you debug managed programs in Visual Studio and in the Windows debugger (WinDbg.exe) by providing information about the internal Common Language Runtime (CLR) environment.</span></span> <span data-ttu-id="ce73f-104">這個工具需要您的專案已啟用非 Managed 偵錯。</span><span class="sxs-lookup"><span data-stu-id="ce73f-104">This tool requires your project to have unmanaged debugging enabled.</span></span> <span data-ttu-id="ce73f-105">SOS.dll 會隨著 .NET Framework 自動安裝。</span><span class="sxs-lookup"><span data-stu-id="ce73f-105">SOS.dll is automatically installed with the .NET Framework.</span></span> <span data-ttu-id="ce73f-106">若要在 Visual Studio 中使用 SOS.dll，請安裝 [Windows 驅動程式套件 (WDK)](https://msdn.microsoft.com/windows/hardware/hh852362)。</span><span class="sxs-lookup"><span data-stu-id="ce73f-106">To use SOS.dll in Visual Studio, install the [Windows Driver Kit (WDK)](https://msdn.microsoft.com/windows/hardware/hh852362).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ce73f-107">如果您使用的是 [!INCLUDE[vs_dev12](../../../includes/vs-dev12-md.md)]，Visual Studio 中的 Windows 偵錯工具支援 SOS.dll，但是 Visual Studio 偵錯工具的即時運算視窗中則不支援。</span><span class="sxs-lookup"><span data-stu-id="ce73f-107">If you are using [!INCLUDE[vs_dev12](../../../includes/vs-dev12-md.md)], SOS.dll is supported in the Windows Debugger within Visual Studio, but not in the Immediate window of the Visual Studio debugger.</span></span>  
  
## <a name="syntax"></a><span data-ttu-id="ce73f-108">語法</span><span class="sxs-lookup"><span data-stu-id="ce73f-108">Syntax</span></span>  
  
```  
![command] [options]   
```  
  
## <a name="commands"></a><span data-ttu-id="ce73f-109">命令</span><span class="sxs-lookup"><span data-stu-id="ce73f-109">Commands</span></span>  
  
|<span data-ttu-id="ce73f-110">命令</span><span class="sxs-lookup"><span data-stu-id="ce73f-110">Command</span></span>|<span data-ttu-id="ce73f-111">描述</span><span class="sxs-lookup"><span data-stu-id="ce73f-111">Description</span></span>|  
|-------------|-----------------|  
|<span data-ttu-id="ce73f-112">**AnalyzeOOM** (**ao**)</span><span class="sxs-lookup"><span data-stu-id="ce73f-112">**AnalyzeOOM** (**ao**)</span></span>|<span data-ttu-id="ce73f-113">顯示在記憶體回收堆積的配置要求上，最後發生之 OOM 的資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-113">Displays the information for the last OOM that occurred on an allocation request to the garbage collection heap.</span></span> <span data-ttu-id="ce73f-114">(在伺服器記憶體回收中，它會顯示每個記憶體回收堆積上的 OOM (如果存在))。</span><span class="sxs-lookup"><span data-stu-id="ce73f-114">(In server garbage collection, it displays OOM, if any, on each garbage collection heap.)</span></span>|  
|<span data-ttu-id="ce73f-115">**BPMD** [**-nofuturemodule**] [\<*module name*> \<*method name*>] [**-md** <`MethodDesc`>] **-list** **-clear** \<*pending breakpoint number*> **-clearall**</span><span class="sxs-lookup"><span data-stu-id="ce73f-115">**BPMD** [**-nofuturemodule**] [\<*module name*> \<*method name*>] [**-md** <`MethodDesc`>] **-list** **-clear** \<*pending breakpoint number*> **-clearall**</span></span>|<span data-ttu-id="ce73f-116">在所指定模組中的指定方法上建立中斷點。</span><span class="sxs-lookup"><span data-stu-id="ce73f-116">Creates a breakpoint at the specified method in the specified module.</span></span><br /><br /> <span data-ttu-id="ce73f-117">如果指定的模組和方法尚未載入，這個命令便會在建立中斷點之前，等待已載入模組和已完成 Just-in-Time (JIT) 編譯的通知。</span><span class="sxs-lookup"><span data-stu-id="ce73f-117">If the specified module and method have not been loaded, this command waits for a notification that the module was loaded and just-in-time (JIT) compiled before creating a breakpoint.</span></span><br /><br /> <span data-ttu-id="ce73f-118">您可以使用 **-list**、**-clear** 和 **-clearall** 選項來管理暫止中斷點的清單：</span><span class="sxs-lookup"><span data-stu-id="ce73f-118">You can manage the list of pending breakpoints by using the **-list**, **-clear**, and **-clearall** options:</span></span><br /><br /> <span data-ttu-id="ce73f-119">**-list** 選項會產生所有暫止中斷點的清單。</span><span class="sxs-lookup"><span data-stu-id="ce73f-119">The **-list** option generates a list of all the pending breakpoints.</span></span> <span data-ttu-id="ce73f-120">如果暫止中斷點具有非零的模組 ID，就是該特殊載入模組中函式的特定中斷點。</span><span class="sxs-lookup"><span data-stu-id="ce73f-120">If a pending breakpoint has a non-zero module ID, that breakpoint is specific to a function in that particular loaded module.</span></span> <span data-ttu-id="ce73f-121">如果暫止中斷點具有零模組 ID，該中斷點就會套用至尚未載入的模組。</span><span class="sxs-lookup"><span data-stu-id="ce73f-121">If the pending breakpoint has a zero module ID, that breakpoint applies to modules that have not yet been loaded.</span></span><br /><br /> <span data-ttu-id="ce73f-122">使用 **-clear** 或 **-clearall** 選項可從清單中移除暫止中斷點。</span><span class="sxs-lookup"><span data-stu-id="ce73f-122">Use the **-clear** or **-clearall** option to remove pending breakpoints from the list.</span></span>|  
|<span data-ttu-id="ce73f-123">**CLRStack** [**-a**] [**-l**] [**-p**] [**-n**]</span><span class="sxs-lookup"><span data-stu-id="ce73f-123">**CLRStack** [**-a**] [**-l**] [**-p**] [**-n**]</span></span>|<span data-ttu-id="ce73f-124">僅提供 Managed 程式碼的堆疊追蹤。</span><span class="sxs-lookup"><span data-stu-id="ce73f-124">Provides a stack trace of managed code only.</span></span><br /><br /> <span data-ttu-id="ce73f-125">**-p** 選項會顯示 Managed 函式的引數。</span><span class="sxs-lookup"><span data-stu-id="ce73f-125">The **-p** option shows arguments to the managed function.</span></span><br /><br /> <span data-ttu-id="ce73f-126">**-l** 選項會顯示框架中區域變數的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-126">The **-l** option shows information on local variables in a frame.</span></span> <span data-ttu-id="ce73f-127">SOS 偵錯擴充功能無法擷取區域名稱，因此區域名稱之輸出的格式會是 \<*local address*> **=** \<*value*>。</span><span class="sxs-lookup"><span data-stu-id="ce73f-127">The SOS Debugging Extension cannot retrieve local names, so the output for local names is in the format \<*local address*> **=** \<*value*>.</span></span><br /><br /> <span data-ttu-id="ce73f-128">**-a** (全部) 選項是 **-l** 與 **-p** 組合的捷徑。</span><span class="sxs-lookup"><span data-stu-id="ce73f-128">The **-a**(all) option is a shortcut for **-l** and **-p**combined.</span></span><br /><br /> <span data-ttu-id="ce73f-129">**-n** 選項會停用原始程式檔名稱和行號的顯示。</span><span class="sxs-lookup"><span data-stu-id="ce73f-129">The **-n** option disables the display of source file names and line numbers.</span></span> <span data-ttu-id="ce73f-130">如果偵錯工具有指定 SYMOPT_LOAD_LINES 選項，SOS 將會查詢每個 Managed 框架的符號，而且如果成功，就會顯示對應的原始程式檔名稱和行號。</span><span class="sxs-lookup"><span data-stu-id="ce73f-130">If the debugger has the option SYMOPT_LOAD_LINES specified, SOS will look up the symbols for every managed frame and if successful will display the corresponding source file name and line number.</span></span> <span data-ttu-id="ce73f-131">指定 **-n** (沒有行號) 參數即可停用這種行為。</span><span class="sxs-lookup"><span data-stu-id="ce73f-131">The **-n** (No line numbers) parameter can be specified to disable this behavior.</span></span><br /><br /> <span data-ttu-id="ce73f-132">SOS 偵錯擴充功能不會在 x64 和 IA-64 架構平台上顯示轉換框架。</span><span class="sxs-lookup"><span data-stu-id="ce73f-132">The SOS Debugging Extension does not display transition frames on x64 and IA-64-based platforms.</span></span>|  
|<span data-ttu-id="ce73f-133">**COMState**</span><span class="sxs-lookup"><span data-stu-id="ce73f-133">**COMState**</span></span>|<span data-ttu-id="ce73f-134">列出每個執行緒和 `Context` 指標的 COM Apartment Model (如果有)。</span><span class="sxs-lookup"><span data-stu-id="ce73f-134">Lists the COM apartment model for each thread and a `Context` pointer, if available.</span></span>|  
|<span data-ttu-id="ce73f-135">**DumpArray** [**-start** \<*startIndex*>] [**-length** \<*length*>] [**-details**] [**-nofields**] \<*array object address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-135">**DumpArray** [**-start** \<*startIndex*>] [**-length** \<*length*>] [**-details**] [**-nofields**] \<*array object address*></span></span><br /><br /> <span data-ttu-id="ce73f-136">-或-</span><span class="sxs-lookup"><span data-stu-id="ce73f-136">-or-</span></span><br /><br /> <span data-ttu-id="ce73f-137">**DA** [**-start** \<*startIndex*>] [**-length** \<*length*>] [**-detail**] [**-nofields**] *array object address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-137">**DA** [**-start** \<*startIndex*>] [**-length** \<*length*>] [**-detail**] [**-nofields**] *array object address*></span></span>|<span data-ttu-id="ce73f-138">檢查陣列物件的元素。</span><span class="sxs-lookup"><span data-stu-id="ce73f-138">Examines elements of an array object.</span></span><br /><br /> <span data-ttu-id="ce73f-139">**-start** 選項會指定開始顯示項目的索引。</span><span class="sxs-lookup"><span data-stu-id="ce73f-139">The **-start** option specifies the starting index at which to display elements.</span></span><br /><br /> <span data-ttu-id="ce73f-140">**-length** 選項會指定要顯示多少項目。</span><span class="sxs-lookup"><span data-stu-id="ce73f-140">The **-length** option specifies how many elements to show.</span></span><br /><br /> <span data-ttu-id="ce73f-141">**-details** 選項會使用 **DumpObj** 和 **DumpVC** 格式來顯示項目的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="ce73f-141">The **-details** option displays details of the element using the **DumpObj** and **DumpVC** formats.</span></span><br /><br /> <span data-ttu-id="ce73f-142">**-nofields** 選項會防止陣列顯示。</span><span class="sxs-lookup"><span data-stu-id="ce73f-142">The **-nofields** option prevents arrays from displaying.</span></span> <span data-ttu-id="ce73f-143">這個選項只有在指定 **-detail** 選項時才能使用。</span><span class="sxs-lookup"><span data-stu-id="ce73f-143">This option is available only when the **-detail** option is specified.</span></span>|  
|<span data-ttu-id="ce73f-144">**DumpAssembly** \<*assembly address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-144">**DumpAssembly** \<*assembly address*></span></span>|<span data-ttu-id="ce73f-145">顯示關於組件的資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-145">Displays information about an assembly.</span></span><br /><br /> <span data-ttu-id="ce73f-146">**DumpAssembly** 命令會列出多個模組 (如果這些模組存在)。</span><span class="sxs-lookup"><span data-stu-id="ce73f-146">The **DumpAssembly** command lists multiple modules, if they exist.</span></span><br /><br /> <span data-ttu-id="ce73f-147">您可以使用 **DumpDomain** 命令取得組件位址。</span><span class="sxs-lookup"><span data-stu-id="ce73f-147">You can get an assembly address by using the **DumpDomain** command.</span></span>|  
|<span data-ttu-id="ce73f-148">**DumpClass** \<*EEClass address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-148">**DumpClass** \<*EEClass address*></span></span>|<span data-ttu-id="ce73f-149">顯示與某個類型關聯之 `EEClass` 結構的資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-149">Displays information about the `EEClass` structure associated with a type.</span></span><br /><br /> <span data-ttu-id="ce73f-150">**DumpClass** 命令會顯示靜態欄位值，但不會顯示非靜態欄位值。</span><span class="sxs-lookup"><span data-stu-id="ce73f-150">The **DumpClass** command displays static field values but does not display nonstatic field values.</span></span><br /><br /> <span data-ttu-id="ce73f-151">使用 **DumpMT**、**DumpObj**、**Name2EE** 或 **Token2EE** 命令，以取得 `EEClass` 結構位址。</span><span class="sxs-lookup"><span data-stu-id="ce73f-151">Use the **DumpMT**, **DumpObj**, **Name2EE**, or **Token2EE** command to get an `EEClass` structure address.</span></span>|  
|<span data-ttu-id="ce73f-152">**DumpDomain** [\<*domain address*>]</span><span class="sxs-lookup"><span data-stu-id="ce73f-152">**DumpDomain** [\<*domain address*>]</span></span>|<span data-ttu-id="ce73f-153">列舉載入於所指定 <xref:System.Reflection.Assembly> 物件位址內的每個 <xref:System.AppDomain> 物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-153">Enumerates each <xref:System.Reflection.Assembly> object that is loaded within the specified <xref:System.AppDomain> object address.</span></span>  <span data-ttu-id="ce73f-154">當不使用參數進行呼叫時，**DumpDomain** 命令便會列出處理序中的所有 <xref:System.AppDomain> 物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-154">When called with no parameters, the **DumpDomain** command lists all <xref:System.AppDomain> objects in a process.</span></span>|  
|<span data-ttu-id="ce73f-155">**DumpHeap** [**-stat**] [**-strings**] [**-short**] [**-min** \<*size*>] [**-max** \<*size*>] [**-thinlock**] [**-startAtLowerBound**] [**-mt** \<*MethodTable address*>] [**-type** \<*partial type name*>][*start* [*end*]]</span><span class="sxs-lookup"><span data-stu-id="ce73f-155">**DumpHeap** [**-stat**] [**-strings**] [**-short**] [**-min** \<*size*>] [**-max** \<*size*>] [**-thinlock**] [**-startAtLowerBound**] [**-mt** \<*MethodTable address*>] [**-type** \<*partial type name*>][*start* [*end*]]</span></span>|<span data-ttu-id="ce73f-156">顯示記憶體回收堆積的資訊，以及關於物件的回收統計資料。</span><span class="sxs-lookup"><span data-stu-id="ce73f-156">Displays information about the garbage-collected heap and collection statistics about objects.</span></span><br /><br /> <span data-ttu-id="ce73f-157">**DumpHeap** 命令會在偵測到記憶體回收行程堆積中出現過多分割時顯示警告。</span><span class="sxs-lookup"><span data-stu-id="ce73f-157">The **DumpHeap** command displays a warning if it detects excessive fragmentation in the garbage collector heap.</span></span><br /><br /> <span data-ttu-id="ce73f-158">**-stat** 選項會將輸出限制為統計類型摘要。</span><span class="sxs-lookup"><span data-stu-id="ce73f-158">The **-stat** option restricts the output to the statistical type summary.</span></span><br /><br /> <span data-ttu-id="ce73f-159">**-strings** 選項會將輸出限制為統計字串值摘要。</span><span class="sxs-lookup"><span data-stu-id="ce73f-159">The **-strings** option restricts the output to a statistical string value summary.</span></span><br /><br /> <span data-ttu-id="ce73f-160">**-short** 選項會將輸出限制為每個物件的位址。</span><span class="sxs-lookup"><span data-stu-id="ce73f-160">The **-short** option limits output to just the address of each object.</span></span> <span data-ttu-id="ce73f-161">這可讓您輕鬆地將輸出從命令由管道送到另一個偵錯工具命令以達成自動化。</span><span class="sxs-lookup"><span data-stu-id="ce73f-161">This lets you easily pipe output from the command to another debugger command for automation.</span></span><br /><br /> <span data-ttu-id="ce73f-162">**-min** 選項會忽略小於 `size` 參數的物件 (指定單位為位元組)。</span><span class="sxs-lookup"><span data-stu-id="ce73f-162">The **-min** option ignores objects that are less than the `size` parameter, specified in bytes.</span></span><br /><br /> <span data-ttu-id="ce73f-163">**-max** 選項會忽略大於 `size` 參數的物件 (指定單位為位元組)。</span><span class="sxs-lookup"><span data-stu-id="ce73f-163">The **-max** option ignores objects that are larger than the `size` parameter, specified in bytes.</span></span><br /><br /> <span data-ttu-id="ce73f-164">**-thinlock** 選項會報告 ThinLocks。</span><span class="sxs-lookup"><span data-stu-id="ce73f-164">The **-thinlock** option reports ThinLocks.</span></span>  <span data-ttu-id="ce73f-165">如需詳細資訊，請參閱 **SyncBlk** 命令。</span><span class="sxs-lookup"><span data-stu-id="ce73f-165">For more information, see the **SyncBlk** command.</span></span><br /><br /> <span data-ttu-id="ce73f-166">`-startAtLowerBound` 選項會強制堆積查核從所提供之位址範圍的下限開始。</span><span class="sxs-lookup"><span data-stu-id="ce73f-166">The `-startAtLowerBound` option forces the heap walk to begin at the lower bound of a supplied address range.</span></span> <span data-ttu-id="ce73f-167">在規劃階段期間，因為物件正在移動，通常都無法查核堆積。</span><span class="sxs-lookup"><span data-stu-id="ce73f-167">During the planning phase, the heap is often not walkable because objects are being moved.</span></span> <span data-ttu-id="ce73f-168">這個選項會強制 **DumpHeap** 在指定的下限開始其查核。</span><span class="sxs-lookup"><span data-stu-id="ce73f-168">This option forces **DumpHeap** to begin its walk at the specified lower bound.</span></span> <span data-ttu-id="ce73f-169">您必須提供有效物件的位址，做為讓此選項運作的下限。</span><span class="sxs-lookup"><span data-stu-id="ce73f-169">You must supply the address of a valid object as the lower bound for this option to work.</span></span> <span data-ttu-id="ce73f-170">您可以顯示位於錯誤物件之位址的記憶體，以手動方式找出下一個方法資料表。</span><span class="sxs-lookup"><span data-stu-id="ce73f-170">You can display memory at the address of a bad object to manually find the next method table.</span></span> <span data-ttu-id="ce73f-171">如果記憶體回收目前位於 `memcopy` 的呼叫中，您也可以將大小加到起始位址 (以參數的形式提供)，以尋找下一個物件的位址。</span><span class="sxs-lookup"><span data-stu-id="ce73f-171">If the garbage collection is currently in a call to `memcopy`, you may also be able to find the address of the next object by adding the size to the start address, which is supplied as a parameter.</span></span><br /><br /> <span data-ttu-id="ce73f-172">**-mt** 選項只會列出會對應至所指定 `MethodTable` 結構中的那些物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-172">The **-mt** option lists only those objects that correspond to the specified `MethodTable` structure.</span></span><br /><br /> <span data-ttu-id="ce73f-173">**-type** 選項只會列出其類型名稱即為所指定字串之子字串的物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-173">The **-type** option lists only those objects whose type name is a substring match of the specified string.</span></span><br /><br /> <span data-ttu-id="ce73f-174">`start` 參數會從指定的位址開始列出。</span><span class="sxs-lookup"><span data-stu-id="ce73f-174">The `start` parameter begins listing from the specified address.</span></span><br /><br /> <span data-ttu-id="ce73f-175">`end` 參數會在指定的位址停止列出。</span><span class="sxs-lookup"><span data-stu-id="ce73f-175">The `end` parameter stops listing at the specified address.</span></span>|  
|<span data-ttu-id="ce73f-176">**DumpIL** \<*Managed DynamicMethod object*> &#124;       \<*DynamicMethodDesc pointer*> &#124;        \<*MethodDesc pointer*></span><span class="sxs-lookup"><span data-stu-id="ce73f-176">**DumpIL** \<*Managed DynamicMethod object*> &#124;       \<*DynamicMethodDesc pointer*> &#124;        \<*MethodDesc pointer*></span></span>|<span data-ttu-id="ce73f-177">顯示與 Managed 方法相關聯的 Microsoft 中繼語言 (MSIL)。</span><span class="sxs-lookup"><span data-stu-id="ce73f-177">Displays the Microsoft intermediate language (MSIL) that is associated with a managed method.</span></span><br /><br /> <span data-ttu-id="ce73f-178">請注意，動態 MSIL 的發出方式不同於從組件載入的 MSIL。</span><span class="sxs-lookup"><span data-stu-id="ce73f-178">Note that dynamic MSIL is emitted differently than MSIL that is loaded from an assembly.</span></span> <span data-ttu-id="ce73f-179">動態 MSIL 會參考 Managed 物件陣列中的物件，而非參考中繼資料語彙基元。</span><span class="sxs-lookup"><span data-stu-id="ce73f-179">Dynamic MSIL refers to objects in a managed object array rather than to metadata tokens.</span></span>|  
|<span data-ttu-id="ce73f-180">**DumpLog** [**-addr** \<*addressOfStressLog*>] [<*Filenam*`e`>]</span><span class="sxs-lookup"><span data-stu-id="ce73f-180">**DumpLog** [**-addr** \<*addressOfStressLog*>] [<*Filenam*`e`>]</span></span>|<span data-ttu-id="ce73f-181">將記憶體中壓力記錄檔的內容寫入指定的檔案。</span><span class="sxs-lookup"><span data-stu-id="ce73f-181">Writes the contents of an in-memory stress log to the specified file.</span></span> <span data-ttu-id="ce73f-182">如果沒有指定名稱，此命令便會在目前的目錄中建立名為 StressLog.txt 的檔案。</span><span class="sxs-lookup"><span data-stu-id="ce73f-182">If you do not specify a name, this command creates a file called StressLog.txt in the current directory.</span></span><br /><br /> <span data-ttu-id="ce73f-183">記憶體中的壓力記錄可協助您診斷壓力失敗而不必使用鎖定或 I/O。</span><span class="sxs-lookup"><span data-stu-id="ce73f-183">The in-memory stress log helps you diagnose stress failures without using locks or I/O.</span></span> <span data-ttu-id="ce73f-184">若要啟用壓力記錄檔，請在 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\\.NETFramework 底下設定下列登錄機碼：</span><span class="sxs-lookup"><span data-stu-id="ce73f-184">To enable the stress log, set the following registry keys under HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\\.NETFramework:</span></span><br /><br /> <span data-ttu-id="ce73f-185">(DWORD) StressLog = 1</span><span class="sxs-lookup"><span data-stu-id="ce73f-185">(DWORD) StressLog = 1</span></span><br /><br /> <span data-ttu-id="ce73f-186">(DWORD) LogFacility = 0xffffffff</span><span class="sxs-lookup"><span data-stu-id="ce73f-186">(DWORD) LogFacility = 0xffffffff</span></span><br /><br /> <span data-ttu-id="ce73f-187">(DWORD) StressLogSize = 65536</span><span class="sxs-lookup"><span data-stu-id="ce73f-187">(DWORD) StressLogSize = 65536</span></span><br /><br /> <span data-ttu-id="ce73f-188">選擇性的 `-addr` 選項可讓您指定預設記錄檔以外的壓力記錄檔。</span><span class="sxs-lookup"><span data-stu-id="ce73f-188">The optional `-addr` option lets you specify a stress log other than the default log.</span></span>|  
|<span data-ttu-id="ce73f-189">**DumpMD** \<*MethodDesc address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-189">**DumpMD** \<*MethodDesc address*></span></span>|<span data-ttu-id="ce73f-190">在指定的位址顯示 `MethodDesc` 結構的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-190">Displays information about a `MethodDesc` structure at the specified address.</span></span><br /><br /> <span data-ttu-id="ce73f-191">您可以使用 **IP2MD** 命令，從 Managed 函式取得 `MethodDesc` 結構位址。</span><span class="sxs-lookup"><span data-stu-id="ce73f-191">You can use the **IP2MD** command to get the `MethodDesc` structure address from a managed function.</span></span>|  
|<span data-ttu-id="ce73f-192">**DumpMT** [**-MD**] \<*MethodTable address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-192">**DumpMT** [**-MD**] \<*MethodTable address*></span></span>|<span data-ttu-id="ce73f-193">顯示在所指定位址之方法資料表的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-193">Displays information about a method table at the specified address.</span></span> <span data-ttu-id="ce73f-194">指定 **-MD** 選項，便會顯示與物件一起定義之所有方法的清單。</span><span class="sxs-lookup"><span data-stu-id="ce73f-194">Specifying the **-MD** option displays a list of all methods defined with the object.</span></span><br /><br /> <span data-ttu-id="ce73f-195">每個 Managed 物件都包含一個方法資料表指標。</span><span class="sxs-lookup"><span data-stu-id="ce73f-195">Each managed object contains a method table pointer.</span></span>|  
|<span data-ttu-id="ce73f-196">**DumpMethodSig** \<*sigaddr*> <*moduleadd*`r`></span><span class="sxs-lookup"><span data-stu-id="ce73f-196">**DumpMethodSig** \<*sigaddr*> <*moduleadd*`r`></span></span>|<span data-ttu-id="ce73f-197">在指定的位址顯示 `MethodSig` 結構的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-197">Displays information about a `MethodSig` structure at the specified address.</span></span>|  
|<span data-ttu-id="ce73f-198">**DumpModule** [**-mt**] \<*Module address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-198">**DumpModule** [**-mt**] \<*Module address*></span></span>|<span data-ttu-id="ce73f-199">顯示在所指定位址之模組的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-199">Displays information about a module at the specified address.</span></span> <span data-ttu-id="ce73f-200">**-mt** 選項會顯示定義在模組中的類型，以及由該模組所參考的類型。</span><span class="sxs-lookup"><span data-stu-id="ce73f-200">The **-mt** option displays the types defined in a module and the types referenced by the module</span></span><br /><br /> <span data-ttu-id="ce73f-201">您可以使用 **DumpDomain** 或 **DumpAssembly** 命令來擷取模組的位址。</span><span class="sxs-lookup"><span data-stu-id="ce73f-201">You can use the **DumpDomain** or **DumpAssembly** command to retrieve a module's address.</span></span>|  
|<span data-ttu-id="ce73f-202">**DumpObj** [**-nofields**] \<*object address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-202">**DumpObj** [**-nofields**] \<*object address*></span></span><br /><br /> <span data-ttu-id="ce73f-203">-或-</span><span class="sxs-lookup"><span data-stu-id="ce73f-203">-or-</span></span><br /><br /> <span data-ttu-id="ce73f-204">**DO** \<*object address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-204">**DO** \<*object address*></span></span>|<span data-ttu-id="ce73f-205">顯示在所指定位址之物件的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-205">Displays information about an object at the specified address.</span></span> <span data-ttu-id="ce73f-206">**DumpObj** 命令會顯示欄位、`EEClass` 結構資訊、方法資料表，以及物件的大小。</span><span class="sxs-lookup"><span data-stu-id="ce73f-206">The **DumpObj** command displays the fields, the `EEClass` structure information, the method table, and the size of the object.</span></span><br /><br /> <span data-ttu-id="ce73f-207">您可以使用 **DumpStackObjects** 命令來擷取物件的位址。</span><span class="sxs-lookup"><span data-stu-id="ce73f-207">You can use the **DumpStackObjects** command to retrieve an object's address.</span></span><br /><br /> <span data-ttu-id="ce73f-208">請注意，您可以對 `CLASS` 類型的欄位執行 **DumpObj** 命令，因為這些欄位也是物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-208">Note that you can run the **DumpObj** command on fields of type `CLASS` because they are also objects.</span></span><br /><br /> <span data-ttu-id="ce73f-209">`-`**nofields** 選項可防止物件的欄位顯示，這對像是 String 的物件非常有用。</span><span class="sxs-lookup"><span data-stu-id="ce73f-209">The `-`**nofields** option prevents fields of the object being displayed, it is useful for objects like String.</span></span>|  
|<span data-ttu-id="ce73f-210">**DumpRuntimeTypes**</span><span class="sxs-lookup"><span data-stu-id="ce73f-210">**DumpRuntimeTypes**</span></span>|<span data-ttu-id="ce73f-211">顯示記憶體回收行程堆積中的執行階段類型物件，並列出與其關聯的類型名稱和方法資料表。</span><span class="sxs-lookup"><span data-stu-id="ce73f-211">Displays the runtime type objects in the garbage collector heap and lists their associated type names and method tables.</span></span>|  
|<span data-ttu-id="ce73f-212">**DumpStack** [**-EE**] [**-n**] [`top` *stack* [`bottom` *stac*`k`]]</span><span class="sxs-lookup"><span data-stu-id="ce73f-212">**DumpStack** [**-EE**] [**-n**] [`top` *stack* [`bottom` *stac*`k`]]</span></span>|<span data-ttu-id="ce73f-213">顯示堆疊追蹤。</span><span class="sxs-lookup"><span data-stu-id="ce73f-213">Displays a stack trace.</span></span><br /><br /> <span data-ttu-id="ce73f-214">**-EE** 選項會使 **DumpStack** 命令只顯示 Managed 函式。</span><span class="sxs-lookup"><span data-stu-id="ce73f-214">The **-EE** option causes the **DumpStack** command to display only managed functions.</span></span> <span data-ttu-id="ce73f-215">使用 `top` 和 `bottom` 參數可限制在 x86 平台上顯示的堆疊框架。</span><span class="sxs-lookup"><span data-stu-id="ce73f-215">Use the `top` and `bottom` parameters to limit the stack frames displayed on x86 platforms.</span></span><br /><br /> <span data-ttu-id="ce73f-216">**-n** 選項會停用原始程式檔名稱和行號的顯示。</span><span class="sxs-lookup"><span data-stu-id="ce73f-216">The **-n** option disables the display of source file names and line numbers.</span></span> <span data-ttu-id="ce73f-217">如果偵錯工具有指定 SYMOPT_LOAD_LINES 選項，SOS 將會查詢每個 Managed 框架的符號，而且如果成功，就會顯示對應的原始程式檔名稱和行號。</span><span class="sxs-lookup"><span data-stu-id="ce73f-217">If the debugger has the option SYMOPT_LOAD_LINES specified, SOS will look up the symbols for every managed frame and if successful will display the corresponding source file name and line number.</span></span> <span data-ttu-id="ce73f-218">指定 **-n** (沒有行號) 參數即可停用這種行為。</span><span class="sxs-lookup"><span data-stu-id="ce73f-218">The **-n** (No line numbers) parameter can be specified to disable this behavior.</span></span><br /><br /> <span data-ttu-id="ce73f-219">在 x86 和 x64 平台上，**DumpStack** 命令會建立詳細的堆疊追蹤。</span><span class="sxs-lookup"><span data-stu-id="ce73f-219">On x86 and x64 platforms, the **DumpStack** command creates a verbose stack trace.</span></span><br /><br /> <span data-ttu-id="ce73f-220">在 IA-64 架構平台上，**DumpStack** 命令會模擬偵錯工具的 **K** 命令。</span><span class="sxs-lookup"><span data-stu-id="ce73f-220">On IA-64-based platforms, the **DumpStack** command mimics the debugger's **K** command.</span></span> <span data-ttu-id="ce73f-221">IA-64 架構平台會忽略 `top` 和 `bottom` 參數。</span><span class="sxs-lookup"><span data-stu-id="ce73f-221">The `top` and `bottom` parameters are ignored on IA-64-based platforms.</span></span>|  
|<span data-ttu-id="ce73f-222">**DumpSig** \<*sigaddr*> \<*moduleaddr*></span><span class="sxs-lookup"><span data-stu-id="ce73f-222">**DumpSig** \<*sigaddr*> \<*moduleaddr*></span></span>|<span data-ttu-id="ce73f-223">在指定的位址顯示 `Sig` 結構的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-223">Displays information about a `Sig` structure at the specified address.</span></span>|  
|<span data-ttu-id="ce73f-224">**DumpSigElem** \<*sigaddr*> \<*moduleaddr*></span><span class="sxs-lookup"><span data-stu-id="ce73f-224">**DumpSigElem** \<*sigaddr*> \<*moduleaddr*></span></span>|<span data-ttu-id="ce73f-225">顯示簽章物件的單一項目。</span><span class="sxs-lookup"><span data-stu-id="ce73f-225">Displays a single element of a signature object.</span></span> <span data-ttu-id="ce73f-226">在大多數情況下，您都應該使用 **DumpSig** 來查看個別簽章物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-226">In most cases, you should use **DumpSig** to look at individual signature objects.</span></span> <span data-ttu-id="ce73f-227">不過，如果簽章已經以某種形式損毀，您可以使用 **DumpSigElem** 來讀取它的有效部分。</span><span class="sxs-lookup"><span data-stu-id="ce73f-227">However, if a signature has been corrupted in some way, you can use **DumpSigElem** to read the valid portions of it.</span></span>|  
|<span data-ttu-id="ce73f-228">**DumpStackObjects** [**-verify**] [`top` *stack* [`bottom` *stack*]]</span><span class="sxs-lookup"><span data-stu-id="ce73f-228">**DumpStackObjects** [**-verify**] [`top` *stack* [`bottom` *stack*]]</span></span><br /><br /> <span data-ttu-id="ce73f-229">-或-</span><span class="sxs-lookup"><span data-stu-id="ce73f-229">-or-</span></span><br /><br /> <span data-ttu-id="ce73f-230">**DSO** [**-verify**] [`top` *stack* [`bottom` *stack*]]</span><span class="sxs-lookup"><span data-stu-id="ce73f-230">**DSO** [**-verify**] [`top` *stack* [`bottom` *stack*]]</span></span>|<span data-ttu-id="ce73f-231">顯示可在目前堆疊界限內找到的所有 Managed 物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-231">Displays all managed objects found within the bounds of the current stack.</span></span><br /><br /> <span data-ttu-id="ce73f-232">**-verify** 選項會驗證物件欄位的每個非靜態 `CLASS` 欄位。</span><span class="sxs-lookup"><span data-stu-id="ce73f-232">The **-verify** option validates each non-static `CLASS` field of an object field.</span></span><br /><br /> <span data-ttu-id="ce73f-233">使用 **DumpStackObject** 命令和追蹤命令 (例如 **K** 命令和 **CLRStack** 命令)，即可判斷區域變數和參數的值。</span><span class="sxs-lookup"><span data-stu-id="ce73f-233">Use the **DumpStackObject** command with stack tracing commands such as the **K** command and the **CLRStack** command to determine the values of local variables and parameters.</span></span>|  
|<span data-ttu-id="ce73f-234">**DumpVC** \<*MethodTable address*> \<*Address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-234">**DumpVC** \<*MethodTable address*> \<*Address*></span></span>|<span data-ttu-id="ce73f-235">顯示在所指定位址之實值類別欄位的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-235">Displays information about the fields of a value class at the specified address.</span></span><br /><br /> <span data-ttu-id="ce73f-236">**MethodTable** 參數可讓 **DumpVC** 命令正確地解譯欄位。</span><span class="sxs-lookup"><span data-stu-id="ce73f-236">The **MethodTable** parameter allows the **DumpVC** command to correctly interpret fields.</span></span> <span data-ttu-id="ce73f-237">實值類別並未以方法資料表做為其第一個欄位。</span><span class="sxs-lookup"><span data-stu-id="ce73f-237">Value classes do not have a method table as their first field.</span></span>|  
|<span data-ttu-id="ce73f-238">**EEHeap** [**-gc**] [**-loader**]</span><span class="sxs-lookup"><span data-stu-id="ce73f-238">**EEHeap** [**-gc**] [**-loader**]</span></span>|<span data-ttu-id="ce73f-239">顯示由內部 CLR 資料結構使用的處理序記憶體相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-239">Displays information about process memory consumed by internal CLR data structures.</span></span><br /><br /> <span data-ttu-id="ce73f-240">**-gc** 和 **-loader** 選項會將這個命令的輸出限制為記憶體回收行程或載入器資料結構。</span><span class="sxs-lookup"><span data-stu-id="ce73f-240">The **-gc** and **-loader** options limit the output of this command to garbage collector or loader data structures.</span></span><br /><br /> <span data-ttu-id="ce73f-241">記憶體回收行程的資訊會列出 Managed 堆積中每個區段的範圍。</span><span class="sxs-lookup"><span data-stu-id="ce73f-241">The information for the garbage collector lists the ranges of each segment in the managed heap.</span></span>  <span data-ttu-id="ce73f-242">如果指標位於 **-gc** 所指定的區段範圍內，該指標就是物件指標。</span><span class="sxs-lookup"><span data-stu-id="ce73f-242">If the pointer falls within a segment range given by **-gc**, the pointer is an object pointer.</span></span>|  
|<span data-ttu-id="ce73f-243">**EEStack** [**-short**] [**-EE**]</span><span class="sxs-lookup"><span data-stu-id="ce73f-243">**EEStack** [**-short**] [**-EE**]</span></span>|<span data-ttu-id="ce73f-244">在處理序中的所有執行緒上執行 **DumpStack** 命令。</span><span class="sxs-lookup"><span data-stu-id="ce73f-244">Runs the **DumpStack** command on all threads in the process.</span></span><br /><br /> <span data-ttu-id="ce73f-245">**-EE** 選項會直接傳遞到 **DumpStack** 命令。</span><span class="sxs-lookup"><span data-stu-id="ce73f-245">The **-EE** option is passed directly to the **DumpStack** command.</span></span> <span data-ttu-id="ce73f-246">**-short** 參數會將輸出限制到下列種類的執行緒：</span><span class="sxs-lookup"><span data-stu-id="ce73f-246">The **-short** parameter limits the output to the following kinds of threads:</span></span><br /><br /> <span data-ttu-id="ce73f-247">具有鎖定的執行緒。</span><span class="sxs-lookup"><span data-stu-id="ce73f-247">Threads that have taken a lock.</span></span><br /><br /> <span data-ttu-id="ce73f-248">已經停止以便允許記憶體回收的執行緒。</span><span class="sxs-lookup"><span data-stu-id="ce73f-248">Threads that have been stalled in order to allow a garbage collection.</span></span><br /><br /> <span data-ttu-id="ce73f-249">目前在 Managed 程式碼中的執行緒。</span><span class="sxs-lookup"><span data-stu-id="ce73f-249">Threads that are currently in managed code.</span></span>|  
|<span data-ttu-id="ce73f-250">**EEVersion**</span><span class="sxs-lookup"><span data-stu-id="ce73f-250">**EEVersion**</span></span>|<span data-ttu-id="ce73f-251">顯示 CLR 版本。</span><span class="sxs-lookup"><span data-stu-id="ce73f-251">Displays the CLR version.</span></span>|  
|<span data-ttu-id="ce73f-252">**EHInfo** [\<*MethodDesc address*>] [\<*Code address*>]</span><span class="sxs-lookup"><span data-stu-id="ce73f-252">**EHInfo** [\<*MethodDesc address*>] [\<*Code address*>]</span></span>|<span data-ttu-id="ce73f-253">顯示所指定方法中的例外狀況處理區塊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-253">Displays the exception handling blocks in a specified method.</span></span>  <span data-ttu-id="ce73f-254">這個命令會顯示子句區塊 (`try` 區塊) 和處理常式區塊 (`catch` 區塊) 的程式碼位址和位移。</span><span class="sxs-lookup"><span data-stu-id="ce73f-254">This command displays the code addresses and offsets for the clause block (the `try` block) and the handler block (the `catch` block).</span></span>|  
|<span data-ttu-id="ce73f-255">**常見問題集**</span><span class="sxs-lookup"><span data-stu-id="ce73f-255">**FAQ**</span></span>|<span data-ttu-id="ce73f-256">顯示常見問題集。</span><span class="sxs-lookup"><span data-stu-id="ce73f-256">Displays frequently asked questions.</span></span>|  
|<span data-ttu-id="ce73f-257">**FinalizeQueue** [**-detail**] &#124; [**-allReady**] [**-short**]</span><span class="sxs-lookup"><span data-stu-id="ce73f-257">**FinalizeQueue** [**-detail**] &#124; [**-allReady**] [**-short**]</span></span>|<span data-ttu-id="ce73f-258">顯示所有已註冊為完成項的物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-258">Displays all objects registered for finalization.</span></span><br /><br /> <span data-ttu-id="ce73f-259">**-detail** 選項會顯示需要清除之任何 `SyncBlocks` 的額外資訊，以及等待清除之任何 `RuntimeCallableWrappers` (RCW) 的額外資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-259">The **-detail** option displays extra information about any `SyncBlocks` that need to be cleaned up, and any `RuntimeCallableWrappers` (RCWs) that await cleanup.</span></span> <span data-ttu-id="ce73f-260">當完成項執行緒執行時，便會快取和清除這兩種資料結構。</span><span class="sxs-lookup"><span data-stu-id="ce73f-260">Both of these data structures are cached and cleaned up by the finalizer thread when it runs.</span></span><br /><br /> <span data-ttu-id="ce73f-261">`-allReady` 選項會顯示已準備好進行最終處理的所有物件，無論它們已經由記憶體回收這樣標記，或是將由下一個記憶體回收所標記，都會包括在內。</span><span class="sxs-lookup"><span data-stu-id="ce73f-261">The `-allReady` option displays all objects that are ready for finalization, regardless of whether they are already marked by the garbage collection as such, or will be marked by the next garbage collection.</span></span> <span data-ttu-id="ce73f-262">在「準備最終處理」清單中的物件，也就是不再是根目錄的可最終處理物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-262">The objects that are in the "ready for finalization" list are finalizable objects that are no longer rooted.</span></span> <span data-ttu-id="ce73f-263">這個選項可能非常昂貴，因為它會驗證可最終處理佇列中的所有物件是否依然為根目錄。</span><span class="sxs-lookup"><span data-stu-id="ce73f-263">This option can be very expensive, because it verifies whether all the objects in the finalizable queues are still rooted.</span></span><br /><br /> <span data-ttu-id="ce73f-264">`-short` 選項會將輸出限制為每個物件的位址。</span><span class="sxs-lookup"><span data-stu-id="ce73f-264">The `-short` option limits the output to the address of each object.</span></span> <span data-ttu-id="ce73f-265">如果搭配使用它與 **-allReady**，它就會列舉具有完成項且不再為根目錄的所有物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-265">If it is used in conjunction with **-allReady**, it enumerates all objects that have a finalizer that are no longer rooted.</span></span> <span data-ttu-id="ce73f-266">如果單獨使用，它就會在可進行最終處理和「準備最終處理」的佇列中列出所有物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-266">If it is used independently, it lists all objects in the finalizable and "ready for finalization" queues.</span></span>|  
|<span data-ttu-id="ce73f-267">**FindAppDomain** \<*Object address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-267">**FindAppDomain** \<*Object address*></span></span>|<span data-ttu-id="ce73f-268">判斷在所指定位址之物件的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="ce73f-268">Determines the application domain of an object at the specified address.</span></span>|  
|<span data-ttu-id="ce73f-269">**FindRoots** **-gen** \<*N*> &#124; **-gen any** &#124;\<*object address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-269">**FindRoots** **-gen** \<*N*> &#124; **-gen any** &#124;\<*object address*></span></span>|<span data-ttu-id="ce73f-270">讓偵錯工具在所指定層代的下一個集合上的偵錯項目內中斷。</span><span class="sxs-lookup"><span data-stu-id="ce73f-270">Causes the debugger to break in the debuggee on the next collection of the specified generation.</span></span> <span data-ttu-id="ce73f-271">只要中斷發生，就會立即重設效果。</span><span class="sxs-lookup"><span data-stu-id="ce73f-271">The effect is reset as soon as the break occurs.</span></span> <span data-ttu-id="ce73f-272">若要在下一個集合上中斷，您必須重新發出命令。</span><span class="sxs-lookup"><span data-stu-id="ce73f-272">To break on the next collection, you have to reissue the command.</span></span> <span data-ttu-id="ce73f-273">發生 **-gen** 或 **-gen any** 之後，將會使用這個命令的 *\<object address>* 形式。</span><span class="sxs-lookup"><span data-stu-id="ce73f-273">The *\<object address>* form of this command is used after the break caused by the **-gen** or **-gen any** has occurred.</span></span> <span data-ttu-id="ce73f-274">此時，偵錯項目處於正確的狀態，可讓 **FindRoots** 從目前的不適用層代識別出物件的根。</span><span class="sxs-lookup"><span data-stu-id="ce73f-274">At that time, the debuggee is in the right state for **FindRoots** to identify roots for objects from the current condemned generations.</span></span>|  
|<span data-ttu-id="ce73f-275">**GCHandles** [**-perdomain**]</span><span class="sxs-lookup"><span data-stu-id="ce73f-275">**GCHandles** [**-perdomain**]</span></span>|<span data-ttu-id="ce73f-276">顯示處理序中記憶體回收行程控制代碼的統計資料。</span><span class="sxs-lookup"><span data-stu-id="ce73f-276">Displays statistics about garbage collector handles in the process.</span></span><br /><br /> <span data-ttu-id="ce73f-277">**-perdomain** 選項會依據應用程式定義域來排列統計資料。</span><span class="sxs-lookup"><span data-stu-id="ce73f-277">The **-perdomain** option arranges the statistics by application domain.</span></span><br /><br /> <span data-ttu-id="ce73f-278">使用 **GCHandles** 命令，便可找出由記憶體回收行程控制代碼遺漏造成的記憶體流失。</span><span class="sxs-lookup"><span data-stu-id="ce73f-278">Use the **GCHandles** command to find memory leaks caused by garbage collector handle leaks.</span></span> <span data-ttu-id="ce73f-279">例如，當程式碼保留大型陣列時就會發生記憶體流失，其保留的原因是因為強式記憶體回收行程控制代碼依然指向該陣列，而捨棄控制代碼時卻未釋放陣列。</span><span class="sxs-lookup"><span data-stu-id="ce73f-279">For example, a memory leak occurs when code retains a large array because a strong garbage collector handle still points to it, and the handle is discarded without freeing it.</span></span>|  
|<span data-ttu-id="ce73f-280">**GCHandleLeaks**</span><span class="sxs-lookup"><span data-stu-id="ce73f-280">**GCHandleLeaks**</span></span>|<span data-ttu-id="ce73f-281">在處理序中搜尋強式和 Pin 記憶體回收行程控制代碼之任何參考的記憶體，並顯示結果。</span><span class="sxs-lookup"><span data-stu-id="ce73f-281">Searches memory for any references to strong and pinned garbage collector handles in the process and displays the results.</span></span> <span data-ttu-id="ce73f-282">如果有找到控制代碼，**GCHandleLeaks** 命令便會顯示該參考的位址。</span><span class="sxs-lookup"><span data-stu-id="ce73f-282">If a handle is found, the **GCHandleLeaks** command displays the address of the reference.</span></span> <span data-ttu-id="ce73f-283">如果在記憶體中沒有找到任何控制代碼，這個命令便會顯示通知。</span><span class="sxs-lookup"><span data-stu-id="ce73f-283">If a handle is not found in memory, this command displays a notification.</span></span>|  
|<span data-ttu-id="ce73f-284">**GCInfo** \<*MethodDesc address*>\<*Code address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-284">**GCInfo** \<*MethodDesc address*>\<*Code address*></span></span>|<span data-ttu-id="ce73f-285">顯示指出註冊位置或堆疊位置在何時包含 Managed 物件的資料。</span><span class="sxs-lookup"><span data-stu-id="ce73f-285">Displays data that indicates when registers or stack locations contain managed objects.</span></span> <span data-ttu-id="ce73f-286">進行記憶體回收時，回收行程必須知道物件參考的位置，以便能夠用新的物件指標值來更新這些參考。</span><span class="sxs-lookup"><span data-stu-id="ce73f-286">If a garbage collection occurs, the collector must know the locations of references to objects so it can update them with new object pointer values.</span></span>|  
|<span data-ttu-id="ce73f-287">**GCRoot** [**-nostacks**] \<*Object address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-287">**GCRoot** [**-nostacks**] \<*Object address*></span></span>|<span data-ttu-id="ce73f-288">顯示在所指定位址之物件參考 (或根目錄) 的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-288">Displays information about references (or roots) to an object at the specified address.</span></span><br /><br /> <span data-ttu-id="ce73f-289">**FindRoots** 命令會在整個 Managed 堆積和控制代碼表格中，檢查位於堆疊上之其他物件和控制代碼中的控制代碼。</span><span class="sxs-lookup"><span data-stu-id="ce73f-289">The **GCRoot** command examines the entire managed heap and the handle table for handles within other objects and handles on the stack.</span></span> <span data-ttu-id="ce73f-290">然後，會在每個堆疊上搜尋物件的指標，並會搜尋完成項佇列。</span><span class="sxs-lookup"><span data-stu-id="ce73f-290">Each stack is then searched for pointers to objects, and the finalizer queue is also searched.</span></span><br /><br /> <span data-ttu-id="ce73f-291">這個命令不會判斷堆疊根目錄是否有效或是已遭捨棄。</span><span class="sxs-lookup"><span data-stu-id="ce73f-291">This command does not determine whether a stack root is valid or is discarded.</span></span> <span data-ttu-id="ce73f-292">使用 **CLRStack** 和 **U** 命令，便可分解區域或引數值所屬的框架，以便判斷該堆疊根目錄是否仍在使用中。</span><span class="sxs-lookup"><span data-stu-id="ce73f-292">Use the **CLRStack** and **U** commands to disassemble the frame that the local or argument value belongs to in order to determine if the stack root is still in use.</span></span><br /><br /> <span data-ttu-id="ce73f-293">**-nostacks** 選項會將搜尋限制到記憶體回收行程控制代碼和可能執行的物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-293">The **-nostacks** option restricts the search to garbage collector handles and freachable objects.</span></span>|  
|<span data-ttu-id="ce73f-294">**GCWhere**  *\<object address>*</span><span class="sxs-lookup"><span data-stu-id="ce73f-294">**GCWhere**  *\<object address>*</span></span>|<span data-ttu-id="ce73f-295">顯示傳入之引數的記憶體回收堆積中的位置和大小。</span><span class="sxs-lookup"><span data-stu-id="ce73f-295">Displays the location and size in the garbage collection heap of the argument passed in.</span></span> <span data-ttu-id="ce73f-296">當引數位於 Managed 堆積中，但不是有效的物件位址時，大小就會顯示為 0 (零)。</span><span class="sxs-lookup"><span data-stu-id="ce73f-296">When the argument lies in the managed heap but is not a valid object address, the size is displayed as 0 (zero).</span></span>|  
|<span data-ttu-id="ce73f-297">**help** [\<*command*>] [`faq`]</span><span class="sxs-lookup"><span data-stu-id="ce73f-297">**help** [\<*command*>] [`faq`]</span></span>|<span data-ttu-id="ce73f-298">顯示當未指定任何參數時的所有可用命令，或是顯示所指定命令的詳細說明資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-298">Displays all available commands when no parameter is specified, or displays detailed help information about the specified command.</span></span><br /><br /> <span data-ttu-id="ce73f-299">`faq` 參數會顯示常見問題集的解答。</span><span class="sxs-lookup"><span data-stu-id="ce73f-299">The `faq` parameter displays answers to frequently asked questions.</span></span>|  
|<span data-ttu-id="ce73f-300">**HeapStat** [**-inclUnrooted** &#124; **-iu**]</span><span class="sxs-lookup"><span data-stu-id="ce73f-300">**HeapStat** [**-inclUnrooted** &#124; **-iu**]</span></span>|<span data-ttu-id="ce73f-301">顯示每個堆積的層代大小，以及每個堆積上每個層代中的總可用空間。</span><span class="sxs-lookup"><span data-stu-id="ce73f-301">Displays the generation sizes for each heap and the total free space in each generation on each heap.</span></span> <span data-ttu-id="ce73f-302">如果指定 **-lines** 選項，報告就會包括來自於記憶體回收堆積，且不再為根目錄之 Managed 物件的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-302">If the -**inclUnrooted** option is specified, the report includes information about the managed objects from the garbage collection heap that is no longer rooted.</span></span>|  
|<span data-ttu-id="ce73f-303">**HistClear**</span><span class="sxs-lookup"><span data-stu-id="ce73f-303">**HistClear**</span></span>|<span data-ttu-id="ce73f-304">釋放 `Hist` 命令系列所使用的任何資源。</span><span class="sxs-lookup"><span data-stu-id="ce73f-304">Releases any resources used by the family of `Hist` commands.</span></span><br /><br /> <span data-ttu-id="ce73f-305">通常，您不需要明確地呼叫 `HistClear`，因為每個 `HistInit` 都會清除先前的資源。</span><span class="sxs-lookup"><span data-stu-id="ce73f-305">Generally, you do not have to explicitly call `HistClear`, because each `HistInit` cleans up the previous resources.</span></span>|  
|<span data-ttu-id="ce73f-306">**HistInit**</span><span class="sxs-lookup"><span data-stu-id="ce73f-306">**HistInit**</span></span>|<span data-ttu-id="ce73f-307">初始化在偵錯項目中儲存之壓力記錄檔中的 SOS 結構。</span><span class="sxs-lookup"><span data-stu-id="ce73f-307">Initializes the SOS structures from the stress log saved in the debuggee.</span></span>|  
|<span data-ttu-id="ce73f-308">**HistObj** *<obj_address>*</span><span class="sxs-lookup"><span data-stu-id="ce73f-308">**HistObj** *<obj_address>*</span></span>|<span data-ttu-id="ce73f-309">會檢查所有壓力記錄檔重新配置記錄，並顯示可能會使位址被當做引數傳入之記憶體回收重新配置的鏈結。</span><span class="sxs-lookup"><span data-stu-id="ce73f-309">Examines all stress log relocation records and displays the chain of garbage collection relocations that may have led to the address passed in as an argument.</span></span>|  
|<span data-ttu-id="ce73f-310">**HistObjFind**  *<obj_address>*</span><span class="sxs-lookup"><span data-stu-id="ce73f-310">**HistObjFind**  *<obj_address>*</span></span>|<span data-ttu-id="ce73f-311">顯示參考位於指定位址之物件的所有記錄檔項目。</span><span class="sxs-lookup"><span data-stu-id="ce73f-311">Displays all the log entries that reference an object at the specified address.</span></span>|  
|<span data-ttu-id="ce73f-312">**HistRoot** *\<root>*</span><span class="sxs-lookup"><span data-stu-id="ce73f-312">**HistRoot** *\<root>*</span></span>|<span data-ttu-id="ce73f-313">顯示與指定之根的提升和重新配置都相關的資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-313">Displays information related to both promotions and relocations of the specified root.</span></span><br /><br /> <span data-ttu-id="ce73f-314">根值可以透過記憶體回收，用來追蹤物件的移動。</span><span class="sxs-lookup"><span data-stu-id="ce73f-314">The root value can be used to track the movement of an object through the garbage collections.</span></span>|  
|<span data-ttu-id="ce73f-315">**IP2MD** \<*Code address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-315">**IP2MD** \<*Code address*></span></span>|<span data-ttu-id="ce73f-316">顯示在已進行 JIT 編譯之程式碼中之指定位址的 `MethodDesc` 結構。</span><span class="sxs-lookup"><span data-stu-id="ce73f-316">Displays the `MethodDesc` structure at the specified address in code that has been JIT-compiled.</span></span>|  
|<span data-ttu-id="ce73f-317">`ListNearObj` (`lno`) *<obj_address>*</span><span class="sxs-lookup"><span data-stu-id="ce73f-317">`ListNearObj` (`lno`) *<obj_address>*</span></span>|<span data-ttu-id="ce73f-318">顯示在指定的位址之前與之後的物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-318">Displays the objects preceding and following the specified address.</span></span> <span data-ttu-id="ce73f-319">此命令會在記憶體回收堆積中，尋找看來像是 Managed 物件之有效開頭的位址 (根據有效方法資料表)，以及引數位址的後接物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-319">The command looks for the address in the garbage collection heap that looks like a valid beginning of a managed object (based on a valid method table) and the object following the argument address.</span></span>|  
|<span data-ttu-id="ce73f-320">**MinidumpMode** [**0**] [**1**]</span><span class="sxs-lookup"><span data-stu-id="ce73f-320">**MinidumpMode** [**0**] [**1**]</span></span>|<span data-ttu-id="ce73f-321">防止在使用小型傾印時執行不安全的命令。</span><span class="sxs-lookup"><span data-stu-id="ce73f-321">Prevents running unsafe commands when using a minidump.</span></span><br /><br /> <span data-ttu-id="ce73f-322">傳遞 **0** 便可停用這項功能，而傳遞 **1** 便可啟用這項功能。</span><span class="sxs-lookup"><span data-stu-id="ce73f-322">Pass **0** to disable this feature or **1** to enable this feature.</span></span> <span data-ttu-id="ce73f-323">根據預設，**MinidumpMode** 值會設定為 **0**。</span><span class="sxs-lookup"><span data-stu-id="ce73f-323">By default, the **MinidumpMode** value is set to **0**.</span></span><br /><br /> <span data-ttu-id="ce73f-324">以 **.dump /m** 命令或 **.dump** 命令建立的小型傾印，都具有有限的 CLR 特定資料，並只允許您正確執行 SOS 命令的子集。</span><span class="sxs-lookup"><span data-stu-id="ce73f-324">Minidumps created with the **.dump /m** command or **.dump** command have limited CLR-specific data and allow you to run only a subset of SOS commands correctly.</span></span> <span data-ttu-id="ce73f-325">有些命令可能會因未預期的錯誤而失敗，原因是沒有對應或是只有部分對應到必要的記憶體區域。</span><span class="sxs-lookup"><span data-stu-id="ce73f-325">Some commands may fail with unexpected errors because required areas of memory are not mapped or are only partially mapped.</span></span> <span data-ttu-id="ce73f-326">這個選項可防止您對小型傾印執行不安全的命令。</span><span class="sxs-lookup"><span data-stu-id="ce73f-326">This option protects you from running unsafe commands against minidumps.</span></span>|  
|<span data-ttu-id="ce73f-327">**Name2EE** \<*module name*> \<*type or method name*></span><span class="sxs-lookup"><span data-stu-id="ce73f-327">**Name2EE** \<*module name*> \<*type or method name*></span></span><br /><br /> <span data-ttu-id="ce73f-328">-或-</span><span class="sxs-lookup"><span data-stu-id="ce73f-328">-or-</span></span><br /><br /> <span data-ttu-id="ce73f-329">**Name2EE** \<*module name*>**!**\<*type or method name*></span><span class="sxs-lookup"><span data-stu-id="ce73f-329">**Name2EE** \<*module name*>**!**\<*type or method name*></span></span>|<span data-ttu-id="ce73f-330">顯示所指定模組中之指定類型或方法的 `MethodTable` 結構和 `EEClass` 結構。</span><span class="sxs-lookup"><span data-stu-id="ce73f-330">Displays the `MethodTable` structure and `EEClass` structure for the specified type or method in the specified module.</span></span><br /><br /> <span data-ttu-id="ce73f-331">指定的模組必須載入到處理序。</span><span class="sxs-lookup"><span data-stu-id="ce73f-331">The specified module must be loaded in the process.</span></span><br /><br /> <span data-ttu-id="ce73f-332">若要取得適當的類型名稱，請使用 [Ildasm.exe (IL 反組譯工具)](../../../docs/framework/tools/ildasm-exe-il-disassembler.md) 瀏覽該模組。</span><span class="sxs-lookup"><span data-stu-id="ce73f-332">To get the proper type name, browse the module by using the [Ildasm.exe (IL Disassembler)](../../../docs/framework/tools/ildasm-exe-il-disassembler.md).</span></span> <span data-ttu-id="ce73f-333">您也可以將 `*` 當做模組名稱參數傳遞，以便搜尋所有已載入的 Managed 模組。</span><span class="sxs-lookup"><span data-stu-id="ce73f-333">You can also pass `*` as the module name parameter to search all loaded managed modules.</span></span> <span data-ttu-id="ce73f-334">*module name* 參數也可以是模組的偵錯工具名稱，例如 `mscorlib` 或 `image00400000`。</span><span class="sxs-lookup"><span data-stu-id="ce73f-334">The *module name* parameter can also be the debugger's name for a module, such as `mscorlib` or `image00400000`.</span></span><br /><br /> <span data-ttu-id="ce73f-335">這個命令支援 <`module`>`!`<`type`> 的 Windows 偵錯工具語法。</span><span class="sxs-lookup"><span data-stu-id="ce73f-335">This command supports the Windows debugger syntax of <`module`>`!`<`type`>.</span></span> <span data-ttu-id="ce73f-336">這個類型必須具有完整名稱。</span><span class="sxs-lookup"><span data-stu-id="ce73f-336">The type must be fully qualified.</span></span>|  
|<span data-ttu-id="ce73f-337">**ObjSize** [\<*Object address*>] &#124; [**-aggregate**] [**-stat**]</span><span class="sxs-lookup"><span data-stu-id="ce73f-337">**ObjSize** [\<*Object address*>] &#124; [**-aggregate**] [**-stat**]</span></span>|<span data-ttu-id="ce73f-338">顯示所指定物件的大小。</span><span class="sxs-lookup"><span data-stu-id="ce73f-338">Displays the size of the specified object.</span></span> <span data-ttu-id="ce73f-339">如果未指定任何參數，**ObjSize** 命令會顯示在 Managed 執行緒上找到之所有物件的大小，並會顯示處理序中的所有記憶體回收行程控制代碼，以及這些控制代碼所指向之任何物件的總大小。</span><span class="sxs-lookup"><span data-stu-id="ce73f-339">If you do not specify any parameters, the **ObjSize** command displays the size of all objects found on managed threads, displays all garbage collector handles in the process, and totals the size of any objects pointed to by those handles.</span></span> <span data-ttu-id="ce73f-340">**ObjSize** 命令會包括父代和其他所有子物件的大小。</span><span class="sxs-lookup"><span data-stu-id="ce73f-340">The **ObjSize** command includes the size of all child objects in addition to the parent.</span></span><br /><br /> <span data-ttu-id="ce73f-341">**-aggregate** 選項可搭配使用 **-stat** 引數，以取得依然為根目錄之類型的詳細檢視。</span><span class="sxs-lookup"><span data-stu-id="ce73f-341">The **-aggregate** option can be used in conjunction with the **-stat** argument to get a detailed view of the types that are still rooted.</span></span> <span data-ttu-id="ce73f-342">藉由使用 **!dumpheap -stat** 和 **!objsize -aggregate -stat**，您可以判斷哪些物件不再是根目錄，以及診斷各種記憶體問題。</span><span class="sxs-lookup"><span data-stu-id="ce73f-342">By using **!dumpheap -stat** and **!objsize -aggregate -stat**, you can determine which objects are no longer rooted and diagnose various memory issues.</span></span>|  
|<span data-ttu-id="ce73f-343">**PrintException** [**-nested**] [**-lines**] [\<*Exception object address*>]</span><span class="sxs-lookup"><span data-stu-id="ce73f-343">**PrintException** [**-nested**] [**-lines**] [\<*Exception object address*>]</span></span><br /><br /> <span data-ttu-id="ce73f-344">-或-</span><span class="sxs-lookup"><span data-stu-id="ce73f-344">-or-</span></span><br /><br /> <span data-ttu-id="ce73f-345">**PE** [**-nested**] [\<*Exception object address*>]</span><span class="sxs-lookup"><span data-stu-id="ce73f-345">**PE** [**-nested**] [\<*Exception object address*>]</span></span>|<span data-ttu-id="ce73f-346">顯示並格式化在所指定位址且衍生自 <xref:System.Exception> 類別之任何物件的欄位。</span><span class="sxs-lookup"><span data-stu-id="ce73f-346">Displays and formats fields of any object derived from the <xref:System.Exception> class at the specified address.</span></span> <span data-ttu-id="ce73f-347">如果您未指定位址，**PrintException** 命令便會顯示目前執行緒上最近一次擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ce73f-347">If you do not specify an address, the **PrintException** command displays the last exception thrown on the current thread.</span></span><br /><br /> <span data-ttu-id="ce73f-348">**-nested** 選項會顯示巢狀例外狀況物件的詳細資料。</span><span class="sxs-lookup"><span data-stu-id="ce73f-348">The **-nested** option displays details about nested exception objects.</span></span><br /><br /> <span data-ttu-id="ce73f-349">**-lines** 選項會顯示來源資訊 (如果存在)。</span><span class="sxs-lookup"><span data-stu-id="ce73f-349">The **-lines** option displays source information, if available.</span></span><br /><br /> <span data-ttu-id="ce73f-350">您可以使用這個命令來格式化和檢視 `_stackTrace` 欄位，此欄位屬於二進位陣列。</span><span class="sxs-lookup"><span data-stu-id="ce73f-350">You can use this command to format and view the `_stackTrace` field, which is a binary array.</span></span>|  
|<span data-ttu-id="ce73f-351">**ProcInfo** [**-env**] [**-time**] [**-mem**]</span><span class="sxs-lookup"><span data-stu-id="ce73f-351">**ProcInfo** [**-env**] [**-time**] [**-mem**]</span></span>|<span data-ttu-id="ce73f-352">顯示處理序的環境變數、核心 CPU 時間，以及記憶體使用統計資料。</span><span class="sxs-lookup"><span data-stu-id="ce73f-352">Displays environment variables for the process, kernel CPU time, and memory usage statistics.</span></span>|  
|<span data-ttu-id="ce73f-353">**RCWCleanupList** \<*RCWCleanupList address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-353">**RCWCleanupList** \<*RCWCleanupList address*></span></span>|<span data-ttu-id="ce73f-354">顯示在所指定位址上正在等待清除之執行階段可呼叫包裝函式的清單。</span><span class="sxs-lookup"><span data-stu-id="ce73f-354">Displays the list of runtime callable wrappers at the specified address that are awaiting cleanup.</span></span>|  
|<span data-ttu-id="ce73f-355">**SaveModule** \<*Base address*> \<*Filename*></span><span class="sxs-lookup"><span data-stu-id="ce73f-355">**SaveModule** \<*Base address*> \<*Filename*></span></span>|<span data-ttu-id="ce73f-356">將在所指定位址上已載入記憶體的影像，寫入至指定的檔案。</span><span class="sxs-lookup"><span data-stu-id="ce73f-356">Writes an image, which is loaded in memory at the specified address, to the specified file.</span></span>|  
|<span data-ttu-id="ce73f-357">**SOSFlush**</span><span class="sxs-lookup"><span data-stu-id="ce73f-357">**SOSFlush**</span></span>|<span data-ttu-id="ce73f-358">清除內部 SOS 快取。</span><span class="sxs-lookup"><span data-stu-id="ce73f-358">Flushes an internal SOS cache.</span></span>|  
|<span data-ttu-id="ce73f-359">**StopOnException** [**-derived**] [**-create** &#124; **-create2**] \<*Exception*> \<*Pseudo-register number*></span><span class="sxs-lookup"><span data-stu-id="ce73f-359">**StopOnException** [**-derived**] [**-create** &#124; **-create2**] \<*Exception*> \<*Pseudo-register number*></span></span>|<span data-ttu-id="ce73f-360">導致偵錯工具會在擲回所指定例外狀況時停止，但是在擲回其他例外狀況時會繼續執行。</span><span class="sxs-lookup"><span data-stu-id="ce73f-360">Causes the debugger to stop when the specified exception is thrown, but to continue running when other exceptions are thrown.</span></span><br /><br /> <span data-ttu-id="ce73f-361">**-derived** 選項會攔截所指定的例外狀況，以及從所指定例外狀況衍生的每一個例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ce73f-361">The **-derived** option catches the specified exception and every exception that derives from the specified exception.</span></span>|  
|<span data-ttu-id="ce73f-362">**SyncBlk** [**-all** &#124; \<*syncblk number*>]</span><span class="sxs-lookup"><span data-stu-id="ce73f-362">**SyncBlk** [**-all** &#124; \<*syncblk number*>]</span></span>|<span data-ttu-id="ce73f-363">顯示所指定 `SyncBlock` 結構，或是所有的 `SyncBlock` 結構。</span><span class="sxs-lookup"><span data-stu-id="ce73f-363">Displays the specified `SyncBlock` structure or all `SyncBlock` structures.</span></span>  <span data-ttu-id="ce73f-364">如果您沒有傳遞任何引數，**SyncBlk** 命令便會顯示屬於某執行緒擁有之物件的對應 `SyncBlock` 結構。</span><span class="sxs-lookup"><span data-stu-id="ce73f-364">If you do not pass any arguments, the **SyncBlk** command displays the `SyncBlock` structure corresponding to objects that are owned by a thread.</span></span><br /><br /> <span data-ttu-id="ce73f-365">`SyncBlock` 結構是專門放置並非每一個物件都要建立之額外資訊的容器。</span><span class="sxs-lookup"><span data-stu-id="ce73f-365">A `SyncBlock` structure is a container for extra information that does not need to be created for every object.</span></span> <span data-ttu-id="ce73f-366">其中可以包含 COM Interop 資料、雜湊碼，以及安全執行緒作業的鎖定資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-366">It can hold COM interop data, hash codes, and locking information for thread-safe operations.</span></span>|  
|<span data-ttu-id="ce73f-367">**ThreadPool**</span><span class="sxs-lookup"><span data-stu-id="ce73f-367">**ThreadPool**</span></span>|<span data-ttu-id="ce73f-368">顯示 Managed 執行緒集區的相關資訊，其中包括佇列中工作要求的數目、完成連接埠執行緒的數目，以及計時器的數目。</span><span class="sxs-lookup"><span data-stu-id="ce73f-368">Displays information about the managed thread pool, including the number of work requests in the queue, the number of completion port threads, and the number of timers.</span></span>|  
|<span data-ttu-id="ce73f-369">**Token2EE** \<*module name*> \<*token*></span><span class="sxs-lookup"><span data-stu-id="ce73f-369">**Token2EE** \<*module name*> \<*token*></span></span>|<span data-ttu-id="ce73f-370">將所指定模組中的已指定中繼資料語彙基元轉變成 `MethodTable` 結構或 `MethodDesc` 結構。</span><span class="sxs-lookup"><span data-stu-id="ce73f-370">Turns the specified metadata token in the specified module into a `MethodTable` structure or `MethodDesc` structure.</span></span><br /><br /> <span data-ttu-id="ce73f-371">您可以將 `*` 當做模組名稱參數傳遞，便可了解該語彙基元對應至每一個載入之 Managed 模組中的哪個項目。</span><span class="sxs-lookup"><span data-stu-id="ce73f-371">You can pass `*` for the module name parameter to find what that token maps to in every loaded managed module.</span></span> <span data-ttu-id="ce73f-372">您也可以傳遞模組的偵錯工具名稱，例如 `mscorlib` 或 `image00400000`。</span><span class="sxs-lookup"><span data-stu-id="ce73f-372">You can also pass the debugger's name for a module, such as `mscorlib` or `image00400000`.</span></span>|  
|<span data-ttu-id="ce73f-373">**Threads** [**-live**] [**-special**]</span><span class="sxs-lookup"><span data-stu-id="ce73f-373">**Threads** [**-live**] [**-special**]</span></span>|<span data-ttu-id="ce73f-374">顯示處理序中的所有 Managed 執行緒。</span><span class="sxs-lookup"><span data-stu-id="ce73f-374">Displays all managed threads in the process.</span></span><br /><br /> <span data-ttu-id="ce73f-375">**Threads** 命令會顯示偵錯工具簡略識別碼、CLR 執行緒識別碼，以及作業系統執行緒識別碼。</span><span class="sxs-lookup"><span data-stu-id="ce73f-375">The **Threads** command displays the debugger shorthand ID, the CLR thread ID, and the operating system thread ID.</span></span>  <span data-ttu-id="ce73f-376">此外，**Threads** 命令也會顯示 Domain 資料行、APT 資料行和 Exception 資料行，分別指出執行緒執行所在的應用程式定義域、COM Apartment 模式和執行緒中最近一次擲回的例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ce73f-376">Additionally, the **Threads** command displays a Domain column that indicates the application domain in which a thread is executing, an APT column that displays the COM apartment mode, and an Exception column that displays the last exception thrown in the thread.</span></span><br /><br /> <span data-ttu-id="ce73f-377">**-live** 選項會顯示與運作中執行緒建立關聯的執行緒。</span><span class="sxs-lookup"><span data-stu-id="ce73f-377">The **-live** option displays threads associated with a live thread.</span></span><br /><br /> <span data-ttu-id="ce73f-378">**-special** 選項會顯示由 CLR 建立的所有特殊執行緒。</span><span class="sxs-lookup"><span data-stu-id="ce73f-378">The **-special** option displays all special threads created by the CLR.</span></span> <span data-ttu-id="ce73f-379">特殊執行緒包括記憶體回收執行緒 (在並行和伺服器記憶體回收中)、偵錯工具 Helper 執行緒、完成項執行緒、<xref:System.AppDomain> 卸載執行緒，以及執行緒集區計時器執行緒。</span><span class="sxs-lookup"><span data-stu-id="ce73f-379">Special threads include garbage collection threads (in concurrent and server garbage collection), debugger helper threads, finalizer threads, <xref:System.AppDomain> unload threads, and thread pool timer threads.</span></span>|  
|<span data-ttu-id="ce73f-380">**ThreadState \<** *State value field* **>**</span><span class="sxs-lookup"><span data-stu-id="ce73f-380">**ThreadState \<** *State value field* **>**</span></span>|<span data-ttu-id="ce73f-381">顯示執行緒的狀態。</span><span class="sxs-lookup"><span data-stu-id="ce73f-381">Displays the state of the thread.</span></span> <span data-ttu-id="ce73f-382">`value` 參數為 **Threads** 報告輸出中 `State` 欄位的值。</span><span class="sxs-lookup"><span data-stu-id="ce73f-382">The `value` parameter is the value of the `State` field in the **Threads** report output.</span></span><br /><br /> <span data-ttu-id="ce73f-383">範例：</span><span class="sxs-lookup"><span data-stu-id="ce73f-383">Example:</span></span><br /><br /> `0:003> !Threads     ThreadCount:      2     UnstartedThread:  0     BackgroundThread: 1     PendingThread:    0     DeadThread:       0     Hosted Runtime:   no                                           PreEmptive   GC Alloc           Lock            ID OSID ThreadOBJ    State     GC       Context       Domain   Count APT Exception        0    1  250 0019b068      a020 Disabled 02349668:02349fe8 0015def0     0 MTA        2    2  944 001a6020      b220 Enabled  00000000:00000000 0015def0     0 MTA (Finalizer)     0:003> !ThreadState b220         Legal to Join         Background         CLR Owns         CoInitialized         In Multi Threaded Apartment`|  
|<span data-ttu-id="ce73f-384">**TraverseHeap** [**-xml**] \<*filename*></span><span class="sxs-lookup"><span data-stu-id="ce73f-384">**TraverseHeap** [**-xml**] \<*filename*></span></span>|<span data-ttu-id="ce73f-385">使用 CLR 分析工具可了解的格式，將堆積資訊寫入至指定的檔案。</span><span class="sxs-lookup"><span data-stu-id="ce73f-385">Writes heap information to the specified file in a format understood by the CLR profiler.</span></span> <span data-ttu-id="ce73f-386">**-xml** 選項會使 **TraverseHeap** 命令將檔案的格式設定為 XML。</span><span class="sxs-lookup"><span data-stu-id="ce73f-386">The **-xml** option causes the **TraverseHeap** command to format the file as XML.</span></span><br /><br /> <span data-ttu-id="ce73f-387">您可以從 [Microsoft 下載中心](https://go.microsoft.com/fwlink/?LinkID=67325)下載 CLR 分析工具。</span><span class="sxs-lookup"><span data-stu-id="ce73f-387">You can download the CLR Profiler from the [Microsoft Download Center](https://go.microsoft.com/fwlink/?LinkID=67325).</span></span>|  
|<span data-ttu-id="ce73f-388">**U** [**-gcinfo**] [**-ehinfo**] [**-n**] \<*MethodDesc address*> &#124; \<*Code address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-388">**U** [**-gcinfo**] [**-ehinfo**] [**-n**] \<*MethodDesc address*> &#124; \<*Code address*></span></span>|<span data-ttu-id="ce73f-389">顯示由方法之 `MethodDesc` 結構指標，或是由方法主體內之程式碼位址所指定 Managed 方法的標註反組譯碼。</span><span class="sxs-lookup"><span data-stu-id="ce73f-389">Displays an annotated disassembly of a managed method specified either by a `MethodDesc` structure pointer for the method or by a code address within the method body.</span></span> <span data-ttu-id="ce73f-390">**U** 命令會顯示從開始到結束的整個方法，以及將中繼資料語彙基元轉換成名稱的註釋。</span><span class="sxs-lookup"><span data-stu-id="ce73f-390">The **U** command displays the entire method from start to finish, with annotations that convert metadata tokens to names.</span></span><br /><br /> <span data-ttu-id="ce73f-391">**-gcinfo** 選項會使 **U** 命令顯示方法的 `GCInfo` 結構。</span><span class="sxs-lookup"><span data-stu-id="ce73f-391">The **-gcinfo** option causes the **U** command to display the `GCInfo` structure for the method.</span></span><br /><br /> <span data-ttu-id="ce73f-392">**-ehinfo** 選項會顯示方法的例外狀況資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-392">The **-ehinfo** option displays exception information for the method.</span></span> <span data-ttu-id="ce73f-393">您也可以使用 **EHInfo** 命令取得這項資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-393">You can also obtain this information with the **EHInfo** command.</span></span><br /><br /> <span data-ttu-id="ce73f-394">**-n** 選項會停用原始程式檔名稱和行號的顯示。</span><span class="sxs-lookup"><span data-stu-id="ce73f-394">The **-n** option disables the display of source file names and line numbers.</span></span> <span data-ttu-id="ce73f-395">如果偵錯工具有指定 SYMOPT_LOAD_LINES 選項，SOS 就會查詢每個 Managed 框架的符號，而且如果成功，就會顯示對應的原始程式檔名稱和行號。</span><span class="sxs-lookup"><span data-stu-id="ce73f-395">If the debugger has the option SYMOPT_LOAD_LINES specified, SOS looks up the symbols for every managed frame and, if successful, displays the corresponding source file name and line number.</span></span> <span data-ttu-id="ce73f-396">您可以指定 **-n** 選項以停用這種行為。</span><span class="sxs-lookup"><span data-stu-id="ce73f-396">You can specify the **-n** option to disable this behavior.</span></span>|  
|<span data-ttu-id="ce73f-397">**VerifyHeap**</span><span class="sxs-lookup"><span data-stu-id="ce73f-397">**VerifyHeap**</span></span>|<span data-ttu-id="ce73f-398">檢查記憶體回收行程堆積是否有損毀徵兆，並顯示任何所發現的錯誤。</span><span class="sxs-lookup"><span data-stu-id="ce73f-398">Checks the garbage collector heap for signs of corruption and displays any errors found.</span></span><br /><br /> <span data-ttu-id="ce73f-399">堆積損毀的原因可能是平台叫用架構不正確的呼叫。</span><span class="sxs-lookup"><span data-stu-id="ce73f-399">Heap corruptions can be caused by platform invoke calls that are constructed incorrectly.</span></span>|  
|<span data-ttu-id="ce73f-400">**VerifyObj** \<*object address*></span><span class="sxs-lookup"><span data-stu-id="ce73f-400">**VerifyObj** \<*object address*></span></span>|<span data-ttu-id="ce73f-401">檢查傳遞為引數的物件以找出損毀的症狀。</span><span class="sxs-lookup"><span data-stu-id="ce73f-401">Checks the object that is passed as an argument for signs of corruption.</span></span>|  
|<span data-ttu-id="ce73f-402">**VMMap**</span><span class="sxs-lookup"><span data-stu-id="ce73f-402">**VMMap**</span></span>|<span data-ttu-id="ce73f-403">周遊虛擬位址空間，並顯示每個區域所套用的保護類型。</span><span class="sxs-lookup"><span data-stu-id="ce73f-403">Traverses the virtual address space and displays the type of protection applied to each region.</span></span>|  
|<span data-ttu-id="ce73f-404">**VMStat**</span><span class="sxs-lookup"><span data-stu-id="ce73f-404">**VMStat**</span></span>|<span data-ttu-id="ce73f-405">提供虛擬位址空間的摘要檢視，並依據套用至該記憶體的各種保護類型 (無限制、保留、認可、私用、對應、影像) 進行排列。</span><span class="sxs-lookup"><span data-stu-id="ce73f-405">Provides a summary view of the virtual address space, ordered by each type of protection applied to that memory (free, reserved, committed, private, mapped, image).</span></span> <span data-ttu-id="ce73f-406">TOTAL 資料行會顯示 AVERAGE 資料行乘以 BLK COUNT 資料行的結果。</span><span class="sxs-lookup"><span data-stu-id="ce73f-406">The TOTAL column displays the result of the AVERAGE column multiplied by the BLK COUNT column.</span></span>|  
  
## <a name="remarks"></a><span data-ttu-id="ce73f-407">備註</span><span class="sxs-lookup"><span data-stu-id="ce73f-407">Remarks</span></span>  
 <span data-ttu-id="ce73f-408">SOS 偵錯延伸模組讓您能夠檢視在 CLR 內執行之程式碼的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-408">The SOS Debugging Extension lets you view information about code that is running inside the CLR.</span></span> <span data-ttu-id="ce73f-409">例如，您可以使用 SOS 偵錯擴充功能來顯示 Managed 堆積的相關資訊、尋找堆積損毀、顯示執行階段所使用的內部資料類型，並檢視在執行階段內執行之所有 Managed 程式碼的資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-409">For example, you can use the SOS Debugging Extension to display information about the managed heap, look for heap corruptions, display internal data types used by the runtime, and view information about all managed code running inside the runtime.</span></span>  
  
 <span data-ttu-id="ce73f-410">若要在 Visual Studio 中使用 SOS 偵錯擴充功能，請安裝 [Windows 驅動程式套件 (WDK)](https://msdn.microsoft.com/windows/hardware/hh852362)。</span><span class="sxs-lookup"><span data-stu-id="ce73f-410">To use the SOS Debugging Extension in Visual Studio, install the [Windows Driver Kit (WDK)](https://msdn.microsoft.com/windows/hardware/hh852362).</span></span> <span data-ttu-id="ce73f-411">如需 Visual Studio 的整合式偵錯環境的詳細資訊，請參閱 Windows 開發人員中心內的[Debugging Environments](https://msdn.microsoft.com/library/windows/hardware/hh406268.aspx)(偵錯環境)。</span><span class="sxs-lookup"><span data-stu-id="ce73f-411">For information about the integrated debugging environment in Visual Studio, see [Debugging Environments](https://msdn.microsoft.com/library/windows/hardware/hh406268.aspx) in the Windows Dev Center.</span></span>  
  
 <span data-ttu-id="ce73f-412">您可以將它載入 WinDbg.exe 偵錯工具 (可從 [WDK 和開發人員工具網站](https://go.microsoft.com/fwlink/?LinkId=103787)取得)，以及在 WinDbg.exe 中執行命令，以使用 SOS 偵錯擴充功能。</span><span class="sxs-lookup"><span data-stu-id="ce73f-412">You can also use the SOS Debugging Extension by loading it into the WinDbg.exe debugger, which is available from the [WDK and Developer Tools Web site](https://go.microsoft.com/fwlink/?LinkId=103787), and executing commands within WinDbg.exe.</span></span>  
  
 <span data-ttu-id="ce73f-413">若要將 SOS 偵錯擴充功能載入至 WinDbg.exe 偵錯工具，請在此工具中執行下列命令：</span><span class="sxs-lookup"><span data-stu-id="ce73f-413">To load the SOS Debugging Extension into the WinDbg.exe debugger, run the following command in the tool:</span></span>  
  
```  
.loadby sos clr  
```  
  
 <span data-ttu-id="ce73f-414">WinDbg.exe 和 Visual Studio 都會使用對應於目前使用中之 Mscorwks.dll 版本的 SOS.dll 版本。</span><span class="sxs-lookup"><span data-stu-id="ce73f-414">WinDbg.exe and Visual Studio use a version of SOS.dll that corresponds to the version of Mscorwks.dll currently in use.</span></span> <span data-ttu-id="ce73f-415">在 .NET Framework 的 1.1 和 2.0 版中，SOS.dll 都是安裝在相同於 Mscorwks.dll 的目錄中。</span><span class="sxs-lookup"><span data-stu-id="ce73f-415">In versions 1.1 and 2.0 of the .NET Framework, SOS.dll is installed in the same directory as Mscorwks.dll.</span></span> <span data-ttu-id="ce73f-416">根據預設，您應該使用符合目前 Mscorwks.dll 版本的 SOS.dll 版本。</span><span class="sxs-lookup"><span data-stu-id="ce73f-416">By default, you should use the version of SOS.dll that matches the current version of Mscorwks.dll.</span></span>  
  
 <span data-ttu-id="ce73f-417">若要使用在另一部電腦上建立的傾印檔案，請確定此次安裝所隨附的 Mscorwks.dll 檔案位於您的符號路徑中，然後載入對應的 SOS.dll 版本。</span><span class="sxs-lookup"><span data-stu-id="ce73f-417">To use a dump file created on another computer, make sure that the Mscorwks.dll file that came with that installation is in your symbol path, and load the corresponding version of SOS.dll.</span></span>  
  
 <span data-ttu-id="ce73f-418">若要載入特定的 SOS.dll 版本，請在 Windows 偵錯工具中輸入下列命令：</span><span class="sxs-lookup"><span data-stu-id="ce73f-418">To load a specific version of SOS.dll, type the following command into the Windows Debugger:</span></span>  
  
```  
.load <full path to sos.dll>  
```  
  
## <a name="examples"></a><span data-ttu-id="ce73f-419">範例</span><span class="sxs-lookup"><span data-stu-id="ce73f-419">Examples</span></span>  
 <span data-ttu-id="ce73f-420">下列命令會顯示在位址 `00ad28d0` 之陣列的內容。</span><span class="sxs-lookup"><span data-stu-id="ce73f-420">The following command displays the contents of an array at the address `00ad28d0`.</span></span>  <span data-ttu-id="ce73f-421">顯示會從第二個元素開始，然後連續顯示五個元素。</span><span class="sxs-lookup"><span data-stu-id="ce73f-421">The display starts from the second element and continues for five elements.</span></span>  
  
```  
!dumparray -start 2 -length 5 -detail 00ad28d0   
```  
  
 <span data-ttu-id="ce73f-422">下列命令會顯示在位址 `1ca248` 之組件的內容。</span><span class="sxs-lookup"><span data-stu-id="ce73f-422">The following command displays the contents of an assembly at the address `1ca248`.</span></span>  
  
```  
!dumpassembly 1ca248  
```  
  
 <span data-ttu-id="ce73f-423">下列命令會顯示記憶體回收行程堆積的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-423">The following command displays information about the garbage collector heap.</span></span>  
  
```  
!dumpheap  
```  
  
 <span data-ttu-id="ce73f-424">下列命令會將記憶體中壓力記錄檔的內容，寫入目前目錄中名為 StressLog.txt 的預設檔案。</span><span class="sxs-lookup"><span data-stu-id="ce73f-424">The following command writes the contents of the in-memory stress log to a (default) file called StressLog.txt in the current directory.</span></span>  
  
```  
!DumpLog  
```  
  
 <span data-ttu-id="ce73f-425">下列命令會顯示在位址 `MethodDesc` 的 `902f40` 結構。</span><span class="sxs-lookup"><span data-stu-id="ce73f-425">The following command displays the `MethodDesc` structure at the address `902f40`.</span></span>  
  
```  
!dumpmd 902f40  
```  
  
 <span data-ttu-id="ce73f-426">下列命令會顯示在位址 `1caa50` 之模組的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-426">The following command displays information about a module at the address `1caa50`.</span></span>  
  
```  
!dumpmodule 1caa50  
```  
  
 <span data-ttu-id="ce73f-427">下列命令會顯示在位址 `a79d40` 之物件的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-427">The following command displays information about an object at the address `a79d40`.</span></span>  
  
```  
!DumpObj a79d40  
```  
  
 <span data-ttu-id="ce73f-428">下列命令會使用在位址 `00a79d9c` 的方法資料表，來顯示在位址 `0090320c` 之實值類別的欄位。</span><span class="sxs-lookup"><span data-stu-id="ce73f-428">The following command displays the fields of a value class at the address `00a79d9c` using the method table at the address `0090320c`.</span></span>  
  
```  
!DumpVC 0090320c 00a79d9c  
```  
  
 <span data-ttu-id="ce73f-429">下列命令會顯示記憶體回收行程所使用的處理序記憶體。</span><span class="sxs-lookup"><span data-stu-id="ce73f-429">The following command displays the process memory used by the garbage collector.</span></span>  
  
```  
!eeheap -gc  
```  
  
 <span data-ttu-id="ce73f-430">下列命令會顯示已排程為最終處理的所有物件。</span><span class="sxs-lookup"><span data-stu-id="ce73f-430">The following command displays all objects scheduled for finalization.</span></span>  
  
```  
!finalizequeue  
```  
  
 <span data-ttu-id="ce73f-431">下列命令會判斷在位址 `00a79d98`之物件的應用程式定義域。</span><span class="sxs-lookup"><span data-stu-id="ce73f-431">The following command determines the application domain of an object at the address `00a79d98`.</span></span>  
  
```  
!findappdomain 00a79d98  
```  
  
 <span data-ttu-id="ce73f-432">下列命令會顯示目前處理序中的所有記憶體回收行程控制代碼。</span><span class="sxs-lookup"><span data-stu-id="ce73f-432">The following command displays all garbage collector handles in the current process.</span></span>  
  
```  
!gcinfo 5b68dbb8   
```  
  
 <span data-ttu-id="ce73f-433">下列命令會顯示 `MethodTable` 模組中，`EEClass` 類別之 `Main` 方法的 `MainClass` 和 `unittest.exe` 結構。</span><span class="sxs-lookup"><span data-stu-id="ce73f-433">The following command displays the `MethodTable` and `EEClass` structures for the `Main` method in the class `MainClass` in the module `unittest.exe`.</span></span>  
  
```  
!name2ee unittest.exe MainClass.Main  
```  
  
 <span data-ttu-id="ce73f-434">下列命令會顯示 `02000003` 模組中，在位址 `unittest.exe` 之中繼資料語彙基元的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="ce73f-434">The following command displays information about the metadata token at the address `02000003` in the module `unittest.exe`.</span></span>  
  
```  
!token2ee unittest.exe 02000003  
```  
  
## <a name="see-also"></a><span data-ttu-id="ce73f-435">請參閱</span><span class="sxs-lookup"><span data-stu-id="ce73f-435">See Also</span></span>  
 [<span data-ttu-id="ce73f-436">工具</span><span class="sxs-lookup"><span data-stu-id="ce73f-436">Tools</span></span>](../../../docs/framework/tools/index.md)  
 [<span data-ttu-id="ce73f-437">命令提示字元</span><span class="sxs-lookup"><span data-stu-id="ce73f-437">Command Prompts</span></span>](../../../docs/framework/tools/developer-command-prompt-for-vs.md)
