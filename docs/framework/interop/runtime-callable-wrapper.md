---
title: "執行階段可呼叫包裝函式"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords:
- COM interop, COM wrappers
- RCW
- COM wrappers
- runtime callable wrappers
- interoperation with unmanaged code, COM wrappers
ms.assetid: 7e542583-1e31-4e10-b523-8cf2f29cb4a4
caps.latest.revision: "9"
author: rpetrusha
ms.author: ronpet
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 722a317a01d79f56496810b8727ce041705c8f78
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/22/2017
---
# <a name="runtime-callable-wrapper"></a><span data-ttu-id="0275c-102">執行階段可呼叫包裝函式</span><span class="sxs-lookup"><span data-stu-id="0275c-102">Runtime Callable Wrapper</span></span>
<span data-ttu-id="0275c-103">Common Language Runtime 會透過名為執行階段可呼叫包裝函式 (RCW) 的 Proxy 來公開 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="0275c-103">The common language runtime exposes COM objects through a proxy called the runtime callable wrapper (RCW).</span></span> <span data-ttu-id="0275c-104">雖然 RCW 對 .NET 用戶端似乎是個普通物件，但其主要功能是在 .NET 用戶端與 COM 物件之間封送處理呼叫。</span><span class="sxs-lookup"><span data-stu-id="0275c-104">Although the RCW appears to be an ordinary object to .NET clients, its primary function is to marshal calls between a .NET client and a COM object.</span></span>  
  
 <span data-ttu-id="0275c-105">不論 COM 物件上存在著多少參考，執行階段都會針對每個 COM 物件各建立一個 RCW。</span><span class="sxs-lookup"><span data-stu-id="0275c-105">The runtime creates exactly one RCW for each COM object, regardless of the number of references that exist on that object.</span></span> <span data-ttu-id="0275c-106">執行階段會針對每個物件的每個處理序各維護一個 RCW。</span><span class="sxs-lookup"><span data-stu-id="0275c-106">The runtime maintains a single RCW per process for each object.</span></span>  <span data-ttu-id="0275c-107">如果您在一個應用程式定義域或 Apartment 中建立 RCW，然後將參考傳遞至另一個應用程式定義域或 Apartment，將會使用第一個物件的 Proxy。</span><span class="sxs-lookup"><span data-stu-id="0275c-107">If you create an RCW in one application domain or apartment, and then pass a reference to another application domain or apartment, a proxy to the first object will be used.</span></span>  <span data-ttu-id="0275c-108">如下圖所示，任何數目的 Managed 用戶端都可以保存公開 INew 和 INewer 介面之 COM 物件的參考。</span><span class="sxs-lookup"><span data-stu-id="0275c-108">As the following illustration shows, any number of managed clients can hold a reference to the COM objects that expose INew and INewer interfaces.</span></span>  
  
 <span data-ttu-id="0275c-109">![RCW](../../../docs/framework/interop/media/rcw.gif "rcw")</span><span class="sxs-lookup"><span data-stu-id="0275c-109">![RCW](../../../docs/framework/interop/media/rcw.gif "rcw")</span></span>  
<span data-ttu-id="0275c-110">透過執行階段可呼叫包裝函式來存取 COM 物件</span><span class="sxs-lookup"><span data-stu-id="0275c-110">Accessing COM objects through the runtime callable wrapper</span></span>  
  
 <span data-ttu-id="0275c-111">使用衍生自類型程式庫的中繼資料，執行階段可以建立所呼叫的 COM 物件，以及該物件的包裝函式。</span><span class="sxs-lookup"><span data-stu-id="0275c-111">Using metadata derived from a type library, the runtime creates both the COM object being called and a wrapper for that object.</span></span> <span data-ttu-id="0275c-112">每個 RCW 都會在其包裝的 COM 物件上維護介面指標的快取，當不再需要 RCW 時，就會在 COM 物件上釋出其參考。</span><span class="sxs-lookup"><span data-stu-id="0275c-112">Each RCW maintains a cache of interface pointers on the COM object it wraps and releases its reference on the COM object when the RCW is no longer needed.</span></span> <span data-ttu-id="0275c-113">執行階段會在 RCW 上執行記憶體回收。</span><span class="sxs-lookup"><span data-stu-id="0275c-113">The runtime performs garbage collection on the RCW.</span></span>  
  
 <span data-ttu-id="0275c-114">RCW 有許多活動，其中包括代表所包裝的物件，在 Managed 與 Unmanaged 程式碼之間封送處理資料。</span><span class="sxs-lookup"><span data-stu-id="0275c-114">Among other activities, the RCW marshals data between managed and unmanaged code, on behalf of the wrapped object.</span></span> <span data-ttu-id="0275c-115">具體來說，每當用戶端與伺服器之間，有不同表示方式的資料要傳遞時，RCW 就會針對方法引數和方法傳回值提供封送處理。</span><span class="sxs-lookup"><span data-stu-id="0275c-115">Specifically, the RCW provides marshaling for method arguments and method return values whenever the client and server have different representations of the data passed between them.</span></span>  
  
 <span data-ttu-id="0275c-116">標準包裝函式會強制執行內建的封送處理規則。</span><span class="sxs-lookup"><span data-stu-id="0275c-116">The standard wrapper enforces built-in marshaling rules.</span></span> <span data-ttu-id="0275c-117">例如，當 .NET 用戶端將字串類型當做引數的一部分傳遞至 Unmanaged 物件時，包裝函式會將字串轉換成 BSTR 類型。</span><span class="sxs-lookup"><span data-stu-id="0275c-117">For example, when a .NET client passes a String type as part of an argument to an unmanaged object, the wrapper converts the string to a BSTR type.</span></span> <span data-ttu-id="0275c-118">如果 COM 物件將 BSTR 傳回至其 Managed 呼叫端，該呼叫端會收到一個字串。</span><span class="sxs-lookup"><span data-stu-id="0275c-118">Should the COM object return a BSTR to its managed caller, the caller receives a String.</span></span> <span data-ttu-id="0275c-119">用戶端和伺服器都會傳送及接收其熟悉的資料。</span><span class="sxs-lookup"><span data-stu-id="0275c-119">Both the client and the server send and receive data that is familiar to them.</span></span> <span data-ttu-id="0275c-120">其他類型則不需轉換。</span><span class="sxs-lookup"><span data-stu-id="0275c-120">Other types require no conversion.</span></span> <span data-ttu-id="0275c-121">比方說，標準包裝函式一律會在 Managed 與 Unmanaged 程式碼之間傳遞 4 位元組的整數，而不會轉換類型。</span><span class="sxs-lookup"><span data-stu-id="0275c-121">For instance, a standard wrapper will always pass a 4-byte integer between managed and unmanaged code without converting the type.</span></span>  
  
## <a name="marshaling-selected-interfaces"></a><span data-ttu-id="0275c-122">封送處理選取的介面</span><span class="sxs-lookup"><span data-stu-id="0275c-122">Marshaling selected interfaces</span></span>  
 <span data-ttu-id="0275c-123">[執行階段可呼叫包裝函式](../../../docs/framework/interop/runtime-callable-wrapper.md) (RCW) 的主要目標，是要隱藏 Managed 與 Unmanaged 程式設計模型之間的差異。</span><span class="sxs-lookup"><span data-stu-id="0275c-123">The primary goal of the [runtime callable wrapper](../../../docs/framework/interop/runtime-callable-wrapper.md) (RCW) is to hide the differences between the managed and unmanaged programming models.</span></span> <span data-ttu-id="0275c-124">為了建立無縫轉換，RCW 會使用所選取的 COM 介面，而不會將其公開給 .NET 用戶端，如下圖所示。</span><span class="sxs-lookup"><span data-stu-id="0275c-124">To create a seamless transition, the RCW consumes selected COM interfaces without exposing them to the .NET client, as shown in the following illustration.</span></span>  
  
 <span data-ttu-id="0275c-125">![具有介面的 RCW](../../../docs/framework/interop/media/rcwwithinterfaces.gif "rcwwithinterfaces")</span><span class="sxs-lookup"><span data-stu-id="0275c-125">![RCW With Interfaces](../../../docs/framework/interop/media/rcwwithinterfaces.gif "rcwwithinterfaces")</span></span>  
<span data-ttu-id="0275c-126">COM 介面與執行階段可呼叫包裝函式</span><span class="sxs-lookup"><span data-stu-id="0275c-126">COM interfaces and the runtime callable wrapper</span></span>  
  
 <span data-ttu-id="0275c-127">當 RCW 建立為早期繫結物件時，其為特定類型。</span><span class="sxs-lookup"><span data-stu-id="0275c-127">When created as an early-bound object, the RCW is a specific type.</span></span> <span data-ttu-id="0275c-128">它會實作 COM 物件實作的介面，並從物件的介面公開方法、屬性和事件。</span><span class="sxs-lookup"><span data-stu-id="0275c-128">It implements the interfaces that the COM object implements and exposes the methods, properties, and events from the object's interfaces.</span></span> <span data-ttu-id="0275c-129">在圖例中，RCW 公開 INew 介面，但使用 **IUnknown** 和 **IDispatch** 介面。</span><span class="sxs-lookup"><span data-stu-id="0275c-129">In the illustration, the RCW exposes the INew interface but consumes the **IUnknown** and **IDispatch** interfaces.</span></span> <span data-ttu-id="0275c-130">此外，RCW 也向 .NET 用戶端公開 INew 介面的所有成員。</span><span class="sxs-lookup"><span data-stu-id="0275c-130">Further, the RCW exposes all members of the INew interface to the .NET client.</span></span>  
  
 <span data-ttu-id="0275c-131">RCW 使用下表中列出的介面，其包裝的物件會公開這些介面。</span><span class="sxs-lookup"><span data-stu-id="0275c-131">The RCW consumes the interfaces listed in the following table, which are exposed by the object it wraps.</span></span>  
  
|<span data-ttu-id="0275c-132">介面</span><span class="sxs-lookup"><span data-stu-id="0275c-132">Interface</span></span>|<span data-ttu-id="0275c-133">描述</span><span class="sxs-lookup"><span data-stu-id="0275c-133">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="0275c-134">**IDispatch**</span><span class="sxs-lookup"><span data-stu-id="0275c-134">**IDispatch**</span></span>|<span data-ttu-id="0275c-135">適用於透過反映，晚期繫結至 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="0275c-135">For late binding to COM objects through reflection.</span></span>|  
|<span data-ttu-id="0275c-136">**IErrorInfo**</span><span class="sxs-lookup"><span data-stu-id="0275c-136">**IErrorInfo**</span></span>|<span data-ttu-id="0275c-137">提供錯誤的文字描述、其來源、說明檔、說明內容，以及定義錯誤之介面的 GUID (.NET 類別一律為 **GUID_NULL**)。</span><span class="sxs-lookup"><span data-stu-id="0275c-137">Provides a textual description of the error, its source, a Help file, Help context, and the GUID of the interface that defined the error (always **GUID_NULL** for .NET classes).</span></span>|  
|<span data-ttu-id="0275c-138">**IProvideClassInfo**</span><span class="sxs-lookup"><span data-stu-id="0275c-138">**IProvideClassInfo**</span></span>|<span data-ttu-id="0275c-139">如果所包裝的 COM 物件實作 **IProvideClassInfo**，RCW 會從這個介面擷取類型資訊，以提供更好的類型身分識別。</span><span class="sxs-lookup"><span data-stu-id="0275c-139">If the COM object being wrapped implements **IProvideClassInfo**, the RCW extracts the type information from this interface to provide better type identity.</span></span>|  
|<span data-ttu-id="0275c-140">**IUnknown**</span><span class="sxs-lookup"><span data-stu-id="0275c-140">**IUnknown**</span></span>|<span data-ttu-id="0275c-141">針對物件識別、強制型轉和存留期管理：</span><span class="sxs-lookup"><span data-stu-id="0275c-141">For object identity, type coercion, and lifetime management:</span></span><br /><br /> <span data-ttu-id="0275c-142">-   物件身分識別</span><span class="sxs-lookup"><span data-stu-id="0275c-142">-   Object identity</span></span><br />     <span data-ttu-id="0275c-143">執行階段會比較每個物件的 **IUnknown** 介面值，以區別 COM 物件。</span><span class="sxs-lookup"><span data-stu-id="0275c-143">The runtime distinguishes between COM objects by comparing the value of the **IUnknown** interface for each object.</span></span><br /><span data-ttu-id="0275c-144">-   類型強制型轉</span><span class="sxs-lookup"><span data-stu-id="0275c-144">-   Type coercion</span></span><br />     <span data-ttu-id="0275c-145">RCW 會辨識 **QueryInterface** 方法所執行的動態類型探索。</span><span class="sxs-lookup"><span data-stu-id="0275c-145">The RCW recognizes the dynamic type discovery performed by the **QueryInterface** method.</span></span><br /><span data-ttu-id="0275c-146">-   存留期管理</span><span class="sxs-lookup"><span data-stu-id="0275c-146">-   Lifetime management</span></span><br />     <span data-ttu-id="0275c-147">使用 **QueryInterface** 方法，RCW 可以取得並保存 Unmanaged 物件的參考，直到執行階段在包裝函式上執行記憶體回收，這會釋放 Unmanaged 物件。</span><span class="sxs-lookup"><span data-stu-id="0275c-147">Using the **QueryInterface** method, the RCW gets and holds a reference to an unmanaged object until the runtime performs garbage collection on the wrapper, which releases the unmanaged object.</span></span>|  
  
 <span data-ttu-id="0275c-148">RCW 會選擇性使用下表列出的介面，其包裝的物件會公開這些介面。</span><span class="sxs-lookup"><span data-stu-id="0275c-148">The RCW optionally consumes the interfaces listed in the following table, which are exposed by the object it wraps.</span></span>  
  
|<span data-ttu-id="0275c-149">介面</span><span class="sxs-lookup"><span data-stu-id="0275c-149">Interface</span></span>|<span data-ttu-id="0275c-150">描述</span><span class="sxs-lookup"><span data-stu-id="0275c-150">Description</span></span>|  
|---------------|-----------------|  
|<span data-ttu-id="0275c-151">**IConnectionPoint** 和 **IConnectionPointContainer**</span><span class="sxs-lookup"><span data-stu-id="0275c-151">**IConnectionPoint** and **IConnectionPointContainer**</span></span>|<span data-ttu-id="0275c-152">RCW 會將公開連接點事件樣式的物件，轉換成委派架構的事件。</span><span class="sxs-lookup"><span data-stu-id="0275c-152">The RCW converts objects that expose the connection-point event style to delegate-based events.</span></span>|  
|<span data-ttu-id="0275c-153">**IDispatchEx**</span><span class="sxs-lookup"><span data-stu-id="0275c-153">**IDispatchEx**</span></span>|<span data-ttu-id="0275c-154">如果類別實作 **IDispatchEx**，RCW 就會實作 **IExpando**。</span><span class="sxs-lookup"><span data-stu-id="0275c-154">If the class implements **IDispatchEx**, the RCW implements **IExpando**.</span></span> <span data-ttu-id="0275c-155">**IDispatchEx** 介面是 **IDispatch** 介面的延伸，它不同於 **IDispatch**，可進行成員的列舉、新增、刪除和區分大小寫呼叫。</span><span class="sxs-lookup"><span data-stu-id="0275c-155">The **IDispatchEx** interface is an extension of the **IDispatch** interface that, unlike **IDispatch**, enables enumeration, addition, deletion, and case-sensitive calling of members.</span></span>|  
|<span data-ttu-id="0275c-156">**IEnumVARIANT**</span><span class="sxs-lookup"><span data-stu-id="0275c-156">**IEnumVARIANT**</span></span>|<span data-ttu-id="0275c-157">可讓支援列舉的 COM 類型被視為集合來處理。</span><span class="sxs-lookup"><span data-stu-id="0275c-157">Enables COM types that support enumerations to be treated as collections.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="0275c-158">請參閱</span><span class="sxs-lookup"><span data-stu-id="0275c-158">See Also</span></span>  
 [<span data-ttu-id="0275c-159">COM 包裝函式</span><span class="sxs-lookup"><span data-stu-id="0275c-159">COM Wrappers</span></span>](../../../docs/framework/interop/com-wrappers.md)  
 [<span data-ttu-id="0275c-160">封送處理選取的介面</span><span class="sxs-lookup"><span data-stu-id="0275c-160">Marshaling Selected Interfaces</span></span>](http://msdn.microsoft.com/en-us/fdb97fd0-f694-4832-bf15-a4e7cf413840)  
 [<span data-ttu-id="0275c-161">COM 可呼叫包裝函式</span><span class="sxs-lookup"><span data-stu-id="0275c-161">COM Callable Wrapper</span></span>](../../../docs/framework/interop/com-callable-wrapper.md)  
 [<span data-ttu-id="0275c-162">型別程式庫至組件轉換的摘要</span><span class="sxs-lookup"><span data-stu-id="0275c-162">Type Library to Assembly Conversion Summary</span></span>](http://msdn.microsoft.com/en-us/bf3f90c5-4770-4ab8-895c-3ba1055cc958)  
 [<span data-ttu-id="0275c-163">匯入類型程式庫做為組件</span><span class="sxs-lookup"><span data-stu-id="0275c-163">Importing a Type Library as an Assembly</span></span>](../../../docs/framework/interop/importing-a-type-library-as-an-assembly.md)
