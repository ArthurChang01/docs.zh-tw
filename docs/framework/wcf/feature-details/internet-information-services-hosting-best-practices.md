---
title: 網際網路資訊服務裝載最佳做法
ms.date: 03/30/2017
ms.assetid: 0834768e-9665-46bf-86eb-d4b09ab91af5
ms.openlocfilehash: 119f14df9d46883a33272903558d83128501b293
ms.sourcegitcommit: e8dc507cfdaad504fc9d4c83d28d24569dcef91c
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/03/2018
ms.locfileid: "33495758"
---
# <a name="internet-information-services-hosting-best-practices"></a><span data-ttu-id="0f3d2-102">網際網路資訊服務裝載最佳做法</span><span class="sxs-lookup"><span data-stu-id="0f3d2-102">Internet Information Services Hosting Best Practices</span></span>
<span data-ttu-id="0f3d2-103">本主題概述裝載 Windows Communication Foundation (WCF) 服務的最佳作法。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-103">This topic outlines some best practices for hosting Windows Communication Foundation (WCF) services.</span></span>  
  
## <a name="implementing-wcf-services-as-dlls"></a><span data-ttu-id="0f3d2-104">將 WCF 服務實作為 DLL</span><span class="sxs-lookup"><span data-stu-id="0f3d2-104">Implementing WCF Services as DLLs</span></span>  
 <span data-ttu-id="0f3d2-105">實作 WCF 服務以部署至 Web 應用程式的 \bin 目錄的 DLL，讓您重複使用 Web 應用程式模型中，外部服務，例如在測試環境中可能沒有安裝 Internet Information Services (IIS) 部署。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-105">Implementing a WCF service as a DLL that is deployed to the \bin directory of a Web application allows you reuse the service outside of the Web application model, for example, in a test environment that may not have Internet Information Services (IIS) deployed.</span></span>  
  
## <a name="service-hosts-in-iis-hosted-applications"></a><span data-ttu-id="0f3d2-106">IIS 裝載應用程式中的服務主機</span><span class="sxs-lookup"><span data-stu-id="0f3d2-106">Service Hosts in IIS-Hosted Applications</span></span>  
 <span data-ttu-id="0f3d2-107">請勿使用命令式自我裝載 API 來建立可接聽網路傳輸 (原本並非由 IIS 裝載環境所支援) 的新服務主機 (例如，請勿使用 [!INCLUDE[iis601](../../../../includes/iis601-md.md)] 來裝載 TCP 服務，因為 [!INCLUDE[iis601](../../../../includes/iis601-md.md)] 原本並不支援 TCP 通訊)。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-107">Do not use the imperative self-host APIs to create new service hosts that listen on network transports not natively supported by the IIS hosting environment (For example, [!INCLUDE[iis601](../../../../includes/iis601-md.md)] to host TCP services, because TCP communication is not natively supported on [!INCLUDE[iis601](../../../../includes/iis601-md.md)]).</span></span> <span data-ttu-id="0f3d2-108">我們不建議您使用這個方式。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-108">This approach is not recommended.</span></span> <span data-ttu-id="0f3d2-109">IIS 裝載環境無法辨識以命令式語法建立的服務主機。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-109">Service hosts created imperatively are not known within the IIS hosting environment.</span></span> <span data-ttu-id="0f3d2-110">關鍵在於，當 IIS 判斷裝載應用程式集區是否為閒置時，不會考慮透過命令式語法建立的服務所執行的處理作業。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-110">The critical point is that processing done by imperatively created services is not accounted for by IIS when it determines whether the hosting application pool is idle.</span></span> <span data-ttu-id="0f3d2-111">而且內含此類以命令式語法建立之服務主機的應用程式，會透過 IIS 裝載環境強勢地處理 IIS 裝載處理序。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-111">The result is that applications that have such imperatively created service hosts have an IIS hosting environment that aggressively disposes of IIS host processes.</span></span>  
  
## <a name="uris-and-iis-hosted-endpoints"></a><span data-ttu-id="0f3d2-112">URI 和 IIS 裝載端點</span><span class="sxs-lookup"><span data-stu-id="0f3d2-112">URIs and IIS-Hosted Endpoints</span></span>  
 <span data-ttu-id="0f3d2-113">IIS 裝載服務的端點應該透過相對的統一資源識別元 (URI)，而不是絕對位址來設定。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-113">Endpoints for an IIS-hosted service should be configured using relative Uniform Resource Identifiers (URIs), not absolute addresses.</span></span> <span data-ttu-id="0f3d2-114">這樣可保證端點位址落在屬於裝載應用程式的 URI 位址範圍內，並確保訊息式啟動會如預期般發生。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-114">This guarantees that the endpoint address falls within the set of URI addresses that belong to the hosting application and ensures that message-based activation happens as expected.</span></span>  
  
## <a name="state-management-and-process-recycling"></a><span data-ttu-id="0f3d2-115">狀態管理與處理序回收</span><span class="sxs-lookup"><span data-stu-id="0f3d2-115">State Management and Process Recycling</span></span>  
 <span data-ttu-id="0f3d2-116">IIS 裝載環境已經針對無法在記憶體中保留本機狀態的服務進行最佳化。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-116">The IIS hosting environment is optimized for services that do not maintain local state in memory.</span></span> <span data-ttu-id="0f3d2-117">IIS 會回收主機處理序以回應一系列不同的外部與內部事件，導致任何唯一存在記憶體中的變動性 (Volatile) 狀態遺失。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-117">IIS recycles the host process in response to a variety of external and internal events, causing any volatile state stored exclusively in memory to be lost.</span></span> <span data-ttu-id="0f3d2-118">IIS 裝載的服務應該會將其狀態儲存到處理序外部 (例如，儲存在資料庫中) 或是儲存到記憶體中的快取，以便在發生應用程式回收事件時可以輕易地重新建立。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-118">Services hosted in IIS should store their state external to the process (for example, in a database) or in an in-memory cache that can easily be re-created if an application recycle event occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="0f3d2-119">WCF 會使用訊息層可靠性和安全性所做的通訊協定使用的變動性記憶體中狀態。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-119">The protocols WCF uses for message-layer reliability and security make use of the volatile in-memory state.</span></span> <span data-ttu-id="0f3d2-120">WCF 可靠工作階段與安全性工作階段，則可能會因應用程式回收的緣故而無預警地終止。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-120">WCF reliable sessions and security sessions may terminate unexpectedly due to application recycles.</span></span> <span data-ttu-id="0f3d2-121">IIS 裝載的應用程式，請使用這些通訊協定應該仰賴相互關聯的應用程式層級狀態 （例如，應用程式層級建構或自訂相互關聯標頭） 或停用的 WCF 提供的工作階段金鑰以外的項目IIS 裝載的應用程式回收處理程序。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-121">IIS-hosted applications that make use of these protocols should either depend on something other than the WCF-provided session key for correlating application-layer state (for example, an application-layer construct or custom correlation header) or disable IIS process recycling for the hosted application.</span></span>  
  
## <a name="optimizing-performance-in-middle-tier-scenarios"></a><span data-ttu-id="0f3d2-122">最佳化中介層案例中的效能</span><span class="sxs-lookup"><span data-stu-id="0f3d2-122">Optimizing Performance in Middle-Tier Scenarios</span></span>  
 <span data-ttu-id="0f3d2-123">為了達到最佳效能，在*中介層案例*-呼叫其他服務，以回應傳入訊息的服務，具現化給遠端服務的 WCF 服務用戶端一次，並跨多個連入重複使用要求。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-123">For optimal performance in a *middle-tier scenario*—a service that calls out to other services in response to incoming messages—instantiate the WCF service client to the remote service once and reuse it across multiple incoming requests.</span></span> <span data-ttu-id="0f3d2-124">具現化 WCF 服務用戶端是昂貴的作業，相對於服務呼叫的預先存在的用戶端執行個體，在和中介層案例藉由快取要求之間的遠端用戶端產生獨特的效能。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-124">Instantiating WCF service clients is an expensive operation relative to making a service call on a pre-existing client instance, and middle-tier scenarios produce distinct performance gains by caching remote clients across requests.</span></span> <span data-ttu-id="0f3d2-125">WCF 服務用戶端是安全執行緒，因此不需要跨多個執行緒同步處理到用戶端的存取。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-125">WCF service clients are thread-safe, so it is not necessary to synchronize access to a client across multiple threads.</span></span>  
  
 <span data-ttu-id="0f3d2-126">中介層案例同時會因為使用 `svcutil /a` 選項所產生的非同步 API 而產生一些效能。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-126">Middle-tier scenarios also produce performance gains by using the asynchronous APIs generated by the `svcutil /a` option.</span></span> <span data-ttu-id="0f3d2-127">`/a`選項會使[ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md)產生`BeginXXX/EndXXX`每個服務作業中，會允許遠端服務上的長期執行呼叫的方法背景執行緒。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-127">The `/a` option causes the [ServiceModel Metadata Utility Tool (Svcutil.exe)](../../../../docs/framework/wcf/servicemodel-metadata-utility-tool-svcutil-exe.md) to generate `BeginXXX/EndXXX` methods for each service operation, which allows potentially long-running calls to remote services to be made on background threads.</span></span>  
  
## <a name="wcf-in-multi-homed-or-multi-named-scenarios"></a><span data-ttu-id="0f3d2-128">多重主目錄系統或多重具名案例中的 WCF</span><span class="sxs-lookup"><span data-stu-id="0f3d2-128">WCF in Multi-Homed or Multi-named scenarios</span></span>  
 <span data-ttu-id="0f3d2-129">您可以部署 WCF 服務內的 IIS Web 伺服陣列，其中的一組電腦共用通用外部名稱 (例如http://www.contoso.com)但會個別定址依不同的主機名稱 (比方說，http://www.contoso.com可能會將流量導向至兩個不同的電腦名為http://machine1.internal.contoso.com和http://machine2.internal.contoso.com)。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-129">You can deploy WCF services inside of an IIS Web farm, where a set of computers share a common external name (such as http://www.contoso.com) but are individually addressed by different hostnames (for example, http://www.contoso.com might direct traffic to two different machines named http://machine1.internal.contoso.com and http://machine2.internal.contoso.com).</span></span> <span data-ttu-id="0f3d2-130">此部署案例中透過 WCF，完全支援，但需要特殊組態的裝載服務的中繼資料 （Web 服務描述語言） 中顯示正確的 （外部） 主機名稱的 WCF 服務的 IIS 網站。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-130">This deployment scenario is fully supported by WCF, but requires special configuration of the IIS Web site hosting WCF services to display the correct (external) hostname in the service's metadata (Web Services Description Language).</span></span>  
  
 <span data-ttu-id="0f3d2-131">若要確保正確的主機名稱會出現在產生 WCF 服務中繼資料，請設定裝載 WCF 服務來使用明確的主機名稱的 IIS 網站的預設身分識別。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-131">To ensure that the correct hostname appears in the service metadata WCF generates, configure the default identity for the IIS Web site that hosts WCF services to use an explicit hostname.</span></span> <span data-ttu-id="0f3d2-132">例如，駐留在 www.contoso.com 伺服器陣列的電腦應該使用的 IIS 網站繫結 *:80:www.contoso.com 適用於 HTTP 和\*: 443:www.contoso.com https。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-132">For example, computers that reside inside of the www.contoso.com farm should use an IIS site binding of *:80:www.contoso.com for HTTP and \*:443:www.contoso.com for HTTPS.</span></span>  
  
 <span data-ttu-id="0f3d2-133">您可以使用 IIS Microsoft Management Console (MMC) 嵌入式管理單元來設定 IIS 網站繫結。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-133">You can configure IIS Web site bindings by using the IIS Microsoft Management Console (MMC) snap-in.</span></span>  
  
## <a name="application-pools-running-in-different-user-contexts-overwrite-assemblies-from-other-accounts-in-the-temporary-folder"></a><span data-ttu-id="0f3d2-134">在不同使用者內容中執行的應用程式集區會覆寫來自暫存資料夾裡其他帳戶的組件</span><span class="sxs-lookup"><span data-stu-id="0f3d2-134">Application Pools Running in Different User Contexts Overwrite Assemblies from Other Accounts in the Temporary Folder</span></span>  
 <span data-ttu-id="0f3d2-135">為了確保在不同使用者內容中執行的應用程式集區無法覆寫來自 [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] 暫存檔案資料夾中其他帳戶的組件，請針對不同的應用程式使用不同的身分識別與暫存資料夾。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-135">To ensure that application pools running in different user contexts cannot overwrite assemblies from other accounts in the temporary [!INCLUDE[vstecasp](../../../../includes/vstecasp-md.md)] files folder, use different identities and temporary folders for different applications.</span></span> <span data-ttu-id="0f3d2-136">例如，如果您有兩個虛擬應用程式 (/Application1 和 / Application2)，則可以使用兩個不同的身分識別來建立兩個應用程式集區 (A 和 B)。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-136">For example, if you have two virtual applications /Application1 and / Application2, you can create two Application pools, A and B, with two different identities.</span></span> <span data-ttu-id="0f3d2-137">應用程式集區 A 可以使用某個使用者身分識別 (user1) 來執行，而應用程式集區 B 則可透過另一個使用者身分識別 (user2) 來執行，同時設定 /Application1 來使用 A 並設定 /Application2 來使用 B。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-137">Application pool A can run under one user identity (user1) while application pool B can run under another user identity (user2), and configure /Application1 to use A and /Application2 to use B.</span></span>  
  
 <span data-ttu-id="0f3d2-138">在 Web.config 中，您可以設定暫存資料夾，請使用\< system.web/compilation/@tempFolder>。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-138">In Web.config, you can configure the temporary folder using \<system.web/compilation/@tempFolder>.</span></span> <span data-ttu-id="0f3d2-139">為 application1，它可以是"c:\tempForUser1 」，並對於應用程式 2 中，這可能是 「 c:\tempForUser2"。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-139">For /Application1, it can be "c:\tempForUser1" and for application2 it can be "c:\tempForUser2".</span></span> <span data-ttu-id="0f3d2-140">針對這些資料夾賦予兩個身分識別對應的寫入權限。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-140">Grant corresponding write permission to these folders for the two identities.</span></span>  
  
 <span data-ttu-id="0f3d2-141">這樣一來，user2 將無法變更 /application2 (位於 c:\tempForUser1 底下) 的程式碼產生資料夾。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-141">Then user2 cannot change the code-generation folder for /application2 (under c:\tempForUser1).</span></span>  
  
## <a name="enabling-asynchronous-processing"></a><span data-ttu-id="0f3d2-142">啟用非同步處理</span><span class="sxs-lookup"><span data-stu-id="0f3d2-142">Enabling asynchronous processing</span></span>  
 <span data-ttu-id="0f3d2-143">依預設訊息傳送至裝載在 IIS 6.0 和更早版本的 WCF 服務會以同步方式處理。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-143">By default messages sent to a WCF service hosted under IIS 6.0 and earlier are processed in a synchronous manner.</span></span> <span data-ttu-id="0f3d2-144">ASP.NET 在自己的執行緒 （ASP.NET 背景工作執行緒） 上呼叫 WCF 及 WCF 使用另一個執行緒來處理要求。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-144">ASP.NET calls into WCF on its own thread (the ASP.NET worker thread) and WCF uses another thread to process the request.</span></span> <span data-ttu-id="0f3d2-145">WCF 會暫止 ASP.NET 背景工作執行緒，直到其本身完成處理。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-145">WCF holds onto the ASP.NET worker thread until it completes its processing.</span></span> <span data-ttu-id="0f3d2-146">這將致使同步處理要求。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-146">This leads to synchronous processing of requests.</span></span> <span data-ttu-id="0f3d2-147">以非同步方式處理要求可提高延展性，因為它可以減少處理的要求 – WCF 不會暫止 ASP.NET 執行緒處理要求時所需的執行緒數目。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-147">Processing requests asynchronously enables greater scalability because it reduces the number of threads required to process a request –WCF does not hold on to the ASP.NET thread while processing the request.</span></span> <span data-ttu-id="0f3d2-148">執行 IIS 6.0，因為沒有任何方法可以開啟伺服器的連入要求進行節流的電腦不建議採用非同步*阻絕服務*(DOS) 攻擊。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-148">Use of asynchronous behavior is not recommended for machines running IIS 6.0 because there is no way to throttle incoming requests that open up the server to *Denial Of Service* (DOS) attacks.</span></span> <span data-ttu-id="0f3d2-149">從 IIS 7.0 開始，則已引進了同時並存要求節流閥：`[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ASP.NET\2.0.50727.0]"MaxConcurrentRequestsPerCpu`。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-149">Starting with IIS 7.0, a concurrent request throttle has been introduced: `[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\ASP.NET\2.0.50727.0]"MaxConcurrentRequestsPerCpu`.</span></span> <span data-ttu-id="0f3d2-150">有了這個新的節流閥，便能放心地使用非同步處理。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-150">With this new throttle it is safe to use the asynchronous processing.</span></span>  <span data-ttu-id="0f3d2-151">預設在 IIS 7.0 中，非同步處理常式和模組要經過登錄。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-151">By default in IIS 7.0, the asynchronous handler and module are registered.</span></span> <span data-ttu-id="0f3d2-152">如果這已經遭到關閉，您可以在應用程式的 Web.config 檔案中手動啟用非同步處理要求。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-152">If this has been turned off, you can manually enable asynchronous processing of requests in your application's Web.config file.</span></span> <span data-ttu-id="0f3d2-153">應該使用何種設定，取決於您的 `aspNetCompatibilityEnabled` 設定。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-153">The settings you use depend on your `aspNetCompatibilityEnabled` setting.</span></span> <span data-ttu-id="0f3d2-154">若您已將 `aspNetCompatibilityEnabled` 設定為 `false`，請依下列組態程式碼片段所示，設定 `System.ServiceModel.Activation.ServiceHttpModule`。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-154">If you have `aspNetCompatibilityEnabled` set to `false`, configure the `System.ServiceModel.Activation.ServiceHttpModule` as shown in the following configuration snippet.</span></span>  
  
```xml  
<system.serviceModel>  
    <serviceHostingEnvironment aspNetCompatibilityEnabled="false" />      
  </system.serviceModel>  
  <system.webServer>  
    <modules>  
      <remove name="ServiceModel"/>  
      <add name="ServiceModel"   
           preCondition="integratedMode,runtimeVersionv2.0"   
           type="System.ServiceModel.Activation.ServiceHttpModule, System.ServiceModel,Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>  
    </modules>  
    </system.webServer>  
```  
  
 <span data-ttu-id="0f3d2-155">若您已將 `aspNetCompatibilityEnabled` 設定為 `true`，請依下列組態程式碼片段所示，設定 `System.ServiceModel.Activation.ServiceHttpHandlerFactory`。</span><span class="sxs-lookup"><span data-stu-id="0f3d2-155">If you have `aspNetCompatibilityEnabled` set to `true`, configure the `System.ServiceModel.Activation.ServiceHttpHandlerFactory` as shown in the following config snippet.</span></span>  
  
```xml  
<system.serviceModel>  
    <serviceHostingEnvironment aspNetCompatibilityEnabled="true" />      
  </system.serviceModel>  
  <system.webServer>  
    <handlers>  
          <clear/>  
          <add name="TestAsyncHttpHandler"   
               path="*.svc"   
               verb="*"   
               type="System.ServiceModel.Activation.ServiceHttpHandlerFactory, System.ServiceModel, Version=3.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"           
               />  
    </handlers>      
  </system.webServer>  
```  
  
## <a name="see-also"></a><span data-ttu-id="0f3d2-156">另請參閱</span><span class="sxs-lookup"><span data-stu-id="0f3d2-156">See Also</span></span>  
 [<span data-ttu-id="0f3d2-157">服務裝載範例</span><span class="sxs-lookup"><span data-stu-id="0f3d2-157">Service Hosting Samples</span></span>](http://msdn.microsoft.com/library/f703a3f6-0fba-418a-a92f-7ce75ccfa47e)  
 [<span data-ttu-id="0f3d2-158">Windows Server App Fabric 主控功能</span><span class="sxs-lookup"><span data-stu-id="0f3d2-158">Windows Server App Fabric Hosting Features</span></span>](http://go.microsoft.com/fwlink/?LinkId=201276)
