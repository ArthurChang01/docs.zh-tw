---
title: "Windows Vista、Windows Server 2003 和 Windows XP 之間的佇列功能差異"
ms.custom: 
ms.date: 03/30/2017
ms.prod: .net-framework
ms.reviewer: 
ms.suite: 
ms.technology: dotnet-clr
ms.tgt_pltfrm: 
ms.topic: article
helpviewer_keywords: queues [WCF], differences in operating systems
ms.assetid: aa809d93-d0a3-4ae6-a726-d015cca37c04
caps.latest.revision: "21"
author: dotnet-bot
ms.author: dotnetcontent
manager: wpickett
ms.workload: dotnet
ms.openlocfilehash: 8f30ad7819a570f0149868502261f986f4dd8c0b
ms.sourcegitcommit: 16186c34a957fdd52e5db7294f291f7530ac9d24
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 12/22/2017
---
# <a name="differences-in-queuing-features-in-windows-vista-windows-server-2003-and-windows-xp"></a><span data-ttu-id="36093-102">Windows Vista、Windows Server 2003 和 Windows XP 之間的佇列功能差異</span><span class="sxs-lookup"><span data-stu-id="36093-102">Differences in Queuing Features in Windows Vista, Windows Server 2003, and Windows XP</span></span>
<span data-ttu-id="36093-103">本主題會摘要 [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)]、[!INCLUDE[wv](../../../../includes/wv-md.md)] 和 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 之間的 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 佇列功能差異。</span><span class="sxs-lookup"><span data-stu-id="36093-103">This topic summarizes the differences in the [!INCLUDE[indigo1](../../../../includes/indigo1-md.md)] queues feature between [!INCLUDE[wv](../../../../includes/wv-md.md)], [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
## <a name="application-specific-dead-letter-queue"></a><span data-ttu-id="36093-104">應用程式特定之寄不出的信件佇列</span><span class="sxs-lookup"><span data-stu-id="36093-104">Application-Specific Dead-Letter Queue</span></span>  
 <span data-ttu-id="36093-105">如果接收應用程式沒有及時讀取佇列訊息，則佇列訊息可以無限期保留在佇列中。</span><span class="sxs-lookup"><span data-stu-id="36093-105">Queued messages can remain in the queue indefinitely if the receiving application does not read them in a timely fashion.</span></span> <span data-ttu-id="36093-106">如果是時間緊急的訊息，這個行為並不合適。</span><span class="sxs-lookup"><span data-stu-id="36093-106">This behavior is not advisable if the messages are time-sensitive.</span></span> <span data-ttu-id="36093-107">時間緊急的訊息會在佇列繫結中設定 `TimeToLive` 屬性。</span><span class="sxs-lookup"><span data-stu-id="36093-107">Time-sensitive messages have a `TimeToLive` property set in the queued binding.</span></span> <span data-ttu-id="36093-108">這個屬性指出訊息在到期前可在佇列中停留的時間長度。</span><span class="sxs-lookup"><span data-stu-id="36093-108">This property indicates how long the messages can be in the queue before they expire.</span></span> <span data-ttu-id="36093-109">過期訊息會傳送至稱為「寄不出的信件佇列」的特殊佇列。</span><span class="sxs-lookup"><span data-stu-id="36093-109">Expired messages are sent to a special queue called the dead-letter queue.</span></span> <span data-ttu-id="36093-110">訊息最後也可以因為其他原因而放在寄不出的信件佇列中，例如超過佇列配額或經歷驗證失敗。</span><span class="sxs-lookup"><span data-stu-id="36093-110">A message can also end up in a dead-letter queue for other reasons, such as exceeding a queue quota or experiencing an authentication failure.</span></span>  
  
 <span data-ttu-id="36093-111">一般而言，所有共用佇列管理員的佇列應用程式都有單一整個系統之寄不出的信件佇列。</span><span class="sxs-lookup"><span data-stu-id="36093-111">Typically, a single system-wide dead-letter queue exists for all queued applications that share a queue manager.</span></span> <span data-ttu-id="36093-112">各個應用程式之寄不出的信件佇列都會允許佇列應用程式指定自己應用程式特定之寄不出的信件佇列，讓這些應用程式之間有更好的隔離。</span><span class="sxs-lookup"><span data-stu-id="36093-112">A dead-letter queue for each application enables better isolation between queued applications that share a queue manager by allowing these applications to specify their own application-specific dead-letter queue.</span></span> <span data-ttu-id="36093-113">與其他應用程式共用寄不出的信件佇列之應用程式必須瀏覽佇列，以尋找適用的訊息。</span><span class="sxs-lookup"><span data-stu-id="36093-113">An application that shares a dead-letter queue with other applications has to browse the queue to find messages that are applicable to it.</span></span> <span data-ttu-id="36093-114">使用應用程式特定之寄不出的信件佇列，可以向應用程式保證其寄不出的信件佇列中所有訊息都適用。</span><span class="sxs-lookup"><span data-stu-id="36093-114">With an application-specific dead-letter queue, the application can be assured that all messages in its dead-letter queue are applicable to it.</span></span>  
  
 [!INCLUDE[wv](../../../../includes/wv-md.md)]<span data-ttu-id="36093-115"> 提供應用程式特定之寄不出的信件佇列。</span><span class="sxs-lookup"><span data-stu-id="36093-115"> provides for application-specific dead-letter queues.</span></span> <span data-ttu-id="36093-116">應用程式特定之寄不出的信件佇列無法在 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 中使用，且應用程式必須使用整個系統之寄不出的信件佇列。</span><span class="sxs-lookup"><span data-stu-id="36093-116">Application-specific dead-letter queues are not available in [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)], and applications must use the system-wide dead-letter queue.</span></span>  
  
## <a name="poison-message-handling"></a><span data-ttu-id="36093-117">有害訊息處理</span><span class="sxs-lookup"><span data-stu-id="36093-117">Poison-Message Handling</span></span>  
 <span data-ttu-id="36093-118">有害訊息是超過嘗試傳遞至接收應用程式之次數上限的訊息。</span><span class="sxs-lookup"><span data-stu-id="36093-118">A poison message is a message that has exceeded the maximum number of delivery attempts to the receiving application.</span></span> <span data-ttu-id="36093-119">當從異動式佇列讀取訊息的應用程式因錯誤無法立即處理訊息時，便會引起這種情況。</span><span class="sxs-lookup"><span data-stu-id="36093-119">This situation can arise when an application that reads a message from a transactional queue cannot process the message immediately because of errors.</span></span> <span data-ttu-id="36093-120">如果應用程式中止收到佇列訊息的交易，會將訊息傳回佇列。</span><span class="sxs-lookup"><span data-stu-id="36093-120">If the application aborts the transaction in which the queued message was received, it returns the message to the queue.</span></span> <span data-ttu-id="36093-121">然後應用程式會嘗試在新的異動中再次擷取訊息。</span><span class="sxs-lookup"><span data-stu-id="36093-121">The application then tries to retrieve the message again in a new transaction.</span></span> <span data-ttu-id="36093-122">如果沒有更正造成錯誤的問題，接收應用程式會卡在接收及中止相同訊息的迴圈中，直到超過傳遞嘗試次數上限為止，而形成有害訊息。</span><span class="sxs-lookup"><span data-stu-id="36093-122">If the problem that causes the error is not corrected, the receiving application can get stuck in a loop receiving and aborting the same message until it exceeds the maximum number of delivery attempts, and a poison message results.</span></span>  
  
 <span data-ttu-id="36093-123">在 [!INCLUDE[wv](../../../../includes/wv-md.md)]、[!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 上的訊息佇列 (MSMQ) 之間，與有害處理有關的主要差別包括下列：</span><span class="sxs-lookup"><span data-stu-id="36093-123">The key differences between Message Queuing (MSMQ) on [!INCLUDE[wv](../../../../includes/wv-md.md)], [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)], and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] that are relevant to poison handling include the following:</span></span>  
  
-   <span data-ttu-id="36093-124">[!INCLUDE[wv](../../../../includes/wv-md.md)] 中的 MSMQ 支援子佇列，而 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 不支援子佇列。</span><span class="sxs-lookup"><span data-stu-id="36093-124">MSMQ in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports subqueues, while [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not support subqueues.</span></span> <span data-ttu-id="36093-125">子佇列是在有害訊息處理中使用。</span><span class="sxs-lookup"><span data-stu-id="36093-125">Subqueues are used in poison-message handling.</span></span> <span data-ttu-id="36093-126">重試佇列和有害佇列都是應用程式佇列的子佇列，應用程式佇列是根據有害訊息處理設定而建立的。</span><span class="sxs-lookup"><span data-stu-id="36093-126">The retry queues and the poison queue are subqueues to the application queue that is created based on the poison-message handling settings.</span></span> <span data-ttu-id="36093-127">`MaxRetryCycles` 會指示要建立多少重試子佇列。</span><span class="sxs-lookup"><span data-stu-id="36093-127">The `MaxRetryCycles` dictates how many retry subqueues to create.</span></span> <span data-ttu-id="36093-128">因此，當在 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 或 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 上執行時，會略過 `MaxRetryCycles` 並且不允許 `ReceiveErrorHandling.Move`。</span><span class="sxs-lookup"><span data-stu-id="36093-128">Therefore, when running on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] or [!INCLUDE[wxp](../../../../includes/wxp-md.md)], `MaxRetryCycles` are ignored and `ReceiveErrorHandling.Move` is not allowed.</span></span>  
  
-   <span data-ttu-id="36093-129">[!INCLUDE[wv](../../../../includes/wv-md.md)] 中的 MSMQ 支援負認可，而 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 則否。</span><span class="sxs-lookup"><span data-stu-id="36093-129">MSMQ in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports negative acknowledgment, while [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)] do not.</span></span> <span data-ttu-id="36093-130">來自接收佇列管理員的負認可會造成傳送佇列管理員將拒絕的訊息放在寄不出的信件佇列中。</span><span class="sxs-lookup"><span data-stu-id="36093-130">A negative acknowledgment from the receiving queue manager causes the sending queue manager to place the rejected message in the dead-letter queue.</span></span> <span data-ttu-id="36093-131">因此，`ReceiveErrorHandling.Reject` 和 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 不可使用 [!INCLUDE[wxp](../../../../includes/wxp-md.md)]。</span><span class="sxs-lookup"><span data-stu-id="36093-131">As such, `ReceiveErrorHandling.Reject` is not allowed with [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span>  
  
-   <span data-ttu-id="36093-132">[!INCLUDE[wv](../../../../includes/wv-md.md)] 中的 MSMQ 支援訊息屬性，持續計算嘗試傳遞訊息的次數。</span><span class="sxs-lookup"><span data-stu-id="36093-132">MSMQ in [!INCLUDE[wv](../../../../includes/wv-md.md)] supports a message property that keeps count of the number of times message delivery is attempted.</span></span> <span data-ttu-id="36093-133">這個中止計數屬性無法在 [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] 和 [!INCLUDE[wxp](../../../../includes/wxp-md.md)] 上使用。</span><span class="sxs-lookup"><span data-stu-id="36093-133">This abort count property is not available on [!INCLUDE[ws2003](../../../../includes/ws2003-md.md)] and [!INCLUDE[wxp](../../../../includes/wxp-md.md)].</span></span> <span data-ttu-id="36093-134">由於 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 會在記憶體中維護中止計數，因此當 Web 伺服陣列中超過一個以上的 [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] 服務讀取相同的訊息時，這個屬性可能沒有包含精確的值。</span><span class="sxs-lookup"><span data-stu-id="36093-134">[!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] maintains the abort count in memory, so it is possible that this property may not contain an accurate value when the same message is read by more than one [!INCLUDE[indigo2](../../../../includes/indigo2-md.md)] service in a Web farm.</span></span>  
  
## <a name="remote-transactional-read"></a><span data-ttu-id="36093-135">遠端異動式讀取</span><span class="sxs-lookup"><span data-stu-id="36093-135">Remote Transactional Read</span></span>  
 <span data-ttu-id="36093-136">[!INCLUDE[wv](../../../../includes/wv-md.md)] 上的 MSMQ 支援遠端交易式讀取。</span><span class="sxs-lookup"><span data-stu-id="36093-136">MSMQ on [!INCLUDE[wv](../../../../includes/wv-md.md)] supports remote transactional reads.</span></span> <span data-ttu-id="36093-137">這允許從佇列讀取的應用程式裝載在與裝載佇列不同的電腦上。</span><span class="sxs-lookup"><span data-stu-id="36093-137">This allows an application that is reading from a queue to be hosted on a computer that is different from the computer on which the queue is hosted.</span></span> <span data-ttu-id="36093-138">這可以確保讓服務的伺服陣列從中央佇列讀取的能力，以增加系統的整體輸送量。</span><span class="sxs-lookup"><span data-stu-id="36093-138">This ensures the ability to have a farm of services reading from a central queue, which increases the overall throughput of the system.</span></span> <span data-ttu-id="36093-139">它也可以確保當讀取及處理訊息、異動復原以及訊息保留在佇列中以供日後處理時，是否會發生失敗。</span><span class="sxs-lookup"><span data-stu-id="36093-139">It also ensures that if a failure occurs when reading and processing the message, the transaction rolls back and the message remains in the queue for later processing.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="36093-140">請參閱</span><span class="sxs-lookup"><span data-stu-id="36093-140">See Also</span></span>  
 [<span data-ttu-id="36093-141">使用無效信件佇列來處理訊息傳輸失敗</span><span class="sxs-lookup"><span data-stu-id="36093-141">Using Dead-Letter Queues to Handle Message Transfer Failures</span></span>](../../../../docs/framework/wcf/feature-details/using-dead-letter-queues-to-handle-message-transfer-failures.md)  
 [<span data-ttu-id="36093-142">有害訊息處理</span><span class="sxs-lookup"><span data-stu-id="36093-142">Poison Message Handling</span></span>](../../../../docs/framework/wcf/feature-details/poison-message-handling.md)
