---
title: 操作和慣性概觀
ms.date: 03/30/2017
ms.assetid: dd31b89b-eab6-45a1-8d0b-11e0eb84b234
ms.openlocfilehash: 41c22dc305f8ef653705436544ab2342e55ed02a
ms.sourcegitcommit: 2eceb05f1a5bb261291a1f6a91c5153727ac1c19
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/04/2018
ms.locfileid: "43521235"
---
# <a name="manipulations-and-inertia-overview"></a><span data-ttu-id="9484d-102">操作和慣性概觀</span><span class="sxs-lookup"><span data-stu-id="9484d-102">Manipulations and Inertia Overview</span></span>
<span data-ttu-id="9484d-103">「操作」可讓使用者使用「操作工具」來移動、旋轉和調整使用者介面 (UI) 項目大小。</span><span class="sxs-lookup"><span data-stu-id="9484d-103">*Manipulations* enable users to move, rotate, and resize user interface (UI) elements by using *manipulators*.</span></span> <span data-ttu-id="9484d-104">操作工具代表滑鼠或 (在觸控式的情況下) 手寫筆或手指。</span><span class="sxs-lookup"><span data-stu-id="9484d-104">A manipulator represents a mouse or (in a touch-enabled scenario) a stylus or a finger.</span></span>  
  
 <span data-ttu-id="9484d-105">「慣性」藉由在項目上模擬摩擦力，可模擬移動的 UI 項目在真實世界中的行為。</span><span class="sxs-lookup"><span data-stu-id="9484d-105">*Inertia* emulates real-world behavior for UI elements that are in motion by simulating friction forces on the elements.</span></span> <span data-ttu-id="9484d-106">這可讓項目在停止前逐漸減緩移動 (直線和有角度的方向)。</span><span class="sxs-lookup"><span data-stu-id="9484d-106">This enables elements to gradually slow their movement (both linear and angular) before coming to a stop.</span></span> <span data-ttu-id="9484d-107">本文提供 .NET Framework 操作和慣性的簡介。</span><span class="sxs-lookup"><span data-stu-id="9484d-107">This article provides an introduction to manipulations and inertia for the .NET Framework.</span></span>  
  
## <a name="manipulations"></a><span data-ttu-id="9484d-108">操作</span><span class="sxs-lookup"><span data-stu-id="9484d-108">Manipulations</span></span>  
 <span data-ttu-id="9484d-109">操作視操作工具的集合為複合物件。</span><span class="sxs-lookup"><span data-stu-id="9484d-109">A manipulation treats a collection of manipulators as a composite object.</span></span> <span data-ttu-id="9484d-110">應用程式可以追蹤複合物件的變更，而非個別元件的變更。</span><span class="sxs-lookup"><span data-stu-id="9484d-110">An application can track the changes to the composite object instead of the individual components.</span></span>  
  
 <span data-ttu-id="9484d-111">請考慮下圖中的影像。</span><span class="sxs-lookup"><span data-stu-id="9484d-111">Consider the image in the following illustration.</span></span> <span data-ttu-id="9484d-112">使用者可以使用兩個操作工具來移動、旋轉和縮放影像。</span><span class="sxs-lookup"><span data-stu-id="9484d-112">A user can use two manipulators to move, rotate, and scale the image.</span></span> <span data-ttu-id="9484d-113">對每個操作工具的變更會與其他操作工具一同被解譯。</span><span class="sxs-lookup"><span data-stu-id="9484d-113">The changes to each manipulator are interpreted together with the other manipulators.</span></span>  
  
 <span data-ttu-id="9484d-114">例如，如果您在影像上有兩個操作工具 (1 和 2)，且您以 +Y 方向 (下) 移動操作工具 1，則該影像的變更會取決於操作工具 2 產生的變化。</span><span class="sxs-lookup"><span data-stu-id="9484d-114">For example, if you have two manipulators (1 and 2) on the image, and you move manipulator 1 in a +Y direction (down), the change to the image depends on what happens to manipulator 2.</span></span> <span data-ttu-id="9484d-115">如果操作工具 2 也以 +Y (下) 的方向移動，則該影像就會直接以 +Y 方向移動。</span><span class="sxs-lookup"><span data-stu-id="9484d-115">If manipulator 2 also moves in the +Y direction (down), the image simply moves in the +Y direction.</span></span> <span data-ttu-id="9484d-116">但若操作工具 2 沒有變更，或以 -Y 方向 (上) 移動，則該影像會變小或旋轉。</span><span class="sxs-lookup"><span data-stu-id="9484d-116">But if manipulator 2 does not change, or it moves in a -Y direction (up), the image is made smaller or rotated.</span></span>  
  
 <span data-ttu-id="9484d-117">![兩隻指頭正在操作的虛擬相片。](../../../docs/framework/common-client-technologies/media/manipulation-resize.png "Manipulation_Resize")</span><span class="sxs-lookup"><span data-stu-id="9484d-117">![A virtual photo that two fingers are manipulating.](../../../docs/framework/common-client-technologies/media/manipulation-resize.png "Manipulation_Resize")</span></span>  
  
 <span data-ttu-id="9484d-118">受兩個操作工具所管理的影像</span><span class="sxs-lookup"><span data-stu-id="9484d-118">An image being manipulated by two manipulators</span></span>  
  
 <span data-ttu-id="9484d-119">操作處理可提供監視操作工具子集的架構，並會解譯它們，如同一起動作，而非獨立地動作。</span><span class="sxs-lookup"><span data-stu-id="9484d-119">Manipulation processing provides a framework that monitors a subset of manipulators and interprets them as if they are acting together, instead of independently.</span></span> <span data-ttu-id="9484d-120">您可以同時建立數個操作處理器物件，可在應用程式中操作每個 UI 項目。</span><span class="sxs-lookup"><span data-stu-id="9484d-120">You can create several manipulation processor objects simultaneously, one for each UI element to be manipulated in an application.</span></span> <span data-ttu-id="9484d-121">會通知操作處理器要觀察哪個輸入裝置，並透過 [.NET 事件](https://msdn.microsoft.com/library/17sde2xt.aspx)報告操作。</span><span class="sxs-lookup"><span data-stu-id="9484d-121">A manipulation processor is informed of which input devices to observe and it reports manipulations through [.NET events](https://msdn.microsoft.com/library/17sde2xt.aspx).</span></span>  
  
 <span data-ttu-id="9484d-122">操作處理器沒有受管理之特定項目的資訊。</span><span class="sxs-lookup"><span data-stu-id="9484d-122">A manipulation processor does not have information about the particular element that is being manipulated.</span></span> <span data-ttu-id="9484d-123">應用程式會各自將變更套用至特定應用程式項目。</span><span class="sxs-lookup"><span data-stu-id="9484d-123">An application separately applies the changes to an application-specific element.</span></span> <span data-ttu-id="9484d-124">例如，應用程式將轉換套用至影像或重新繪製，在新的位置以新的大小或方向顯示。</span><span class="sxs-lookup"><span data-stu-id="9484d-124">For example, an application applies transformations to an image or redraws it to display it at its new location or with a new size or orientation.</span></span>  
  
 <span data-ttu-id="9484d-125">操作專為二維 (2-D) [仿射轉換](/windows/desktop/gdiplus/-gdiplus-transformations-use) (affine transformation) 所設計。</span><span class="sxs-lookup"><span data-stu-id="9484d-125">Manipulations are designed for two-dimensional (2-D) [affine transformations](/windows/desktop/gdiplus/-gdiplus-transformations-use).</span></span> <span data-ttu-id="9484d-126">這些轉換包含平移、旋轉和縮放。</span><span class="sxs-lookup"><span data-stu-id="9484d-126">These transformations include translate, rotate, and scale.</span></span>  
  
### <a name="parts-of-a-manipulation"></a><span data-ttu-id="9484d-127">操作的各部分</span><span class="sxs-lookup"><span data-stu-id="9484d-127">Parts of a Manipulation</span></span>  
 <span data-ttu-id="9484d-128">操作是 <xref:System.Windows.Input.Manipulations.Manipulator2D> 物件的集合。</span><span class="sxs-lookup"><span data-stu-id="9484d-128">A manipulation is a collection of <xref:System.Windows.Input.Manipulations.Manipulator2D> objects.</span></span> <span data-ttu-id="9484d-129">此彙總的操作會由原點和橢圓形呈現。</span><span class="sxs-lookup"><span data-stu-id="9484d-129">This aggregate manipulation is represented by an origin point and an ellipse.</span></span> <span data-ttu-id="9484d-130">原點是操控項目的所有操作工具的平均位置。</span><span class="sxs-lookup"><span data-stu-id="9484d-130">The origin point is the average position of all manipulators that are manipulating an element.</span></span> <span data-ttu-id="9484d-131">此橢圓形的半徑為從原點到每個 <xref:System.Windows.Input.Manipulations.Manipulator2D> 物件的平均距離。</span><span class="sxs-lookup"><span data-stu-id="9484d-131">The ellipse has a radius that is the average distance from the origin to each of the <xref:System.Windows.Input.Manipulations.Manipulator2D> objects.</span></span>  
  
 <span data-ttu-id="9484d-132">![操作的各部分。](../../../docs/framework/common-client-technologies/media/manipulation-definition.png "Manipulation_Definition")</span><span class="sxs-lookup"><span data-stu-id="9484d-132">![The parts of a manipulation.](../../../docs/framework/common-client-technologies/media/manipulation-definition.png "Manipulation_Definition")</span></span>  
  
 <span data-ttu-id="9484d-133">兩個操作工具 (1 和 2)、一個原點和一個橢圓形可指定一項操作</span><span class="sxs-lookup"><span data-stu-id="9484d-133">Two manipulators (1 and 2), an origin, and an ellipse specify a manipulation</span></span>  
  
 <span data-ttu-id="9484d-134">加入、移動或移除 UI 項目的操作工具時，應用程式會呼叫 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> 方法來更新 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D> 物件。</span><span class="sxs-lookup"><span data-stu-id="9484d-134">As manipulators are added, moved, or removed for a UI element, an application updates the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D> object by calling the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method.</span></span> <span data-ttu-id="9484d-135">操作第一次開始時，會引發 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Started> 事件。</span><span class="sxs-lookup"><span data-stu-id="9484d-135">When the manipulation first begins, the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Started> event is raised.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9484d-136">在以框架為基礎的更新環境中使用時，操作處理會更有效率。</span><span class="sxs-lookup"><span data-stu-id="9484d-136">Manipulation processing is more efficient when used in a frame-based update environment.</span></span> <span data-ttu-id="9484d-137">當在 Microsoft XNA 應用程式中使用操作處理時，這不成問題，因為 XNA Framework 會使用 [Game.Update](https://msdn.microsoft.com/library/microsoft.xna.framework.game.update.aspx) 方法來提供以框架為基礎的更新。</span><span class="sxs-lookup"><span data-stu-id="9484d-137">When using manipulation processing in a Microsoft XNA application, this is not a concern because the XNA framework provides frame-based updates using the [Game.Update](https://msdn.microsoft.com/library/microsoft.xna.framework.game.update.aspx) method.</span></span> <span data-ttu-id="9484d-138">在另一個環境中 (例如 WinForms)，您可能會需要提供您自己以框架為基礎的邏輯，以收集操作，並定期以批次方式傳送到 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A>。</span><span class="sxs-lookup"><span data-stu-id="9484d-138">In another environment (such as WinForms), you might need to provide your own frame-based logic to collect manipulations and periodically send them to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method as a batch.</span></span>  
  
 <span data-ttu-id="9484d-139">當操作工具或其位置的數目變更時，會引發 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta> 事件。</span><span class="sxs-lookup"><span data-stu-id="9484d-139">As the number of manipulators or their position change, the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta> event is raised.</span></span> <span data-ttu-id="9484d-140">傳遞至 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta> 事件處理常式的 <xref:System.Windows.Input.Manipulations.Manipulation2DDeltaEventArgs> 物件屬性會指定最後一個事件發生後原點、縮放、旋轉和轉譯的變更。</span><span class="sxs-lookup"><span data-stu-id="9484d-140">Properties of the <xref:System.Windows.Input.Manipulations.Manipulation2DDeltaEventArgs> object that is passed to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Delta> event handler specify changes in origin, scale, rotation, and translation that have occurred since the last event.</span></span> <span data-ttu-id="9484d-141">當操作工具移動時，以及當新增或移除操作工具時，就會變更操作的原點。</span><span class="sxs-lookup"><span data-stu-id="9484d-141">The origin of the manipulation changes when manipulators move, and when manipulators are added or removed.</span></span> <span data-ttu-id="9484d-142">轉譯值指定此操作包含多少 X 或 Y 移動。</span><span class="sxs-lookup"><span data-stu-id="9484d-142">Translation values specify how much X or Y movement the manipulation includes.</span></span>  
  
 <span data-ttu-id="9484d-143">應用程式使用新的值來重新繪製 UI 項目。</span><span class="sxs-lookup"><span data-stu-id="9484d-143">Using the new values, an application redraws the UI element.</span></span>  
  
 <span data-ttu-id="9484d-144">![接觸點 A 移動到右邊後的操作。](../../../docs/framework/common-client-technologies/media/manipulation-changed.png "Manipulation_Changed")</span><span class="sxs-lookup"><span data-stu-id="9484d-144">![A manipulation after contact A moved to the right.](../../../docs/framework/common-client-technologies/media/manipulation-changed.png "Manipulation_Changed")</span></span>  
  
 <span data-ttu-id="9484d-145">操作工具 1 移動，並造成原點變更</span><span class="sxs-lookup"><span data-stu-id="9484d-145">Manipulator 1 moves and causes the origin to change</span></span>  
  
 <span data-ttu-id="9484d-146">從 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D> 物件中移除最後一個與操作相關聯的操作工具時，會引發 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed> 事件。</span><span class="sxs-lookup"><span data-stu-id="9484d-146">When the last manipulator that is associated with the manipulation is removed from the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D> object, the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed> event is raised.</span></span>  
  
### <a name="the-manipulation-processing-model"></a><span data-ttu-id="9484d-147">操作處理模型</span><span class="sxs-lookup"><span data-stu-id="9484d-147">The Manipulation Processing Model</span></span>  
 <span data-ttu-id="9484d-148">操作處理器會使用直接使用方式模型。</span><span class="sxs-lookup"><span data-stu-id="9484d-148">A manipulation processor uses a direct-usage model.</span></span> <span data-ttu-id="9484d-149">藉由這個簡單的模型，應用程式必須將任何輸入事件的詳細資料傳遞給操作處理器。</span><span class="sxs-lookup"><span data-stu-id="9484d-149">With this simple model, an application must pass any input event details to the manipulation processor.</span></span> <span data-ttu-id="9484d-150">輸入的事件可能會由任何基本輸入所引發，例如滑鼠裝置、手寫筆或手指。</span><span class="sxs-lookup"><span data-stu-id="9484d-150">An input event might be raised by any input primitive, such as a mouse device, a stylus, or a finger.</span></span> <span data-ttu-id="9484d-151">這個程序提供直接的篩選機制以及簡單的使用模型，讓應用程式在必要時可以批次輸入事件。</span><span class="sxs-lookup"><span data-stu-id="9484d-151">This process provides a direct filtering mechanism and a simple usage model, so the application can batch input events when it is necessary.</span></span>  
  
 <span data-ttu-id="9484d-152">對於要在操作程序中包含基本輸入的應用程式，它會從基本輸入的詳細資料建立 <xref:System.Windows.Input.Manipulations.Manipulator2D> 結構，並使用 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> 方法將結構傳遞給操作處理器。</span><span class="sxs-lookup"><span data-stu-id="9484d-152">For an application to include an input primitive in the manipulation process, it creates a <xref:System.Windows.Input.Manipulations.Manipulator2D> structure from the details of the input primitive, and passes the structure to the manipulation processor using the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.ProcessManipulators%2A> method.</span></span> <span data-ttu-id="9484d-153">操作處理器接著會引發事件，其中應用程式必須適當地處理視覺化元件的更新。</span><span class="sxs-lookup"><span data-stu-id="9484d-153">The manipulation processor then raises events, which the application must handle to update the visual component in an appropriate way.</span></span>  
  
 <span data-ttu-id="9484d-154">![操作直接使用方式模型的流程。](../../../docs/framework/common-client-technologies/media/manipulation-flow.png "Manipulation_Flow")</span><span class="sxs-lookup"><span data-stu-id="9484d-154">![The flow of the manipulations direct&#45;usage model.](../../../docs/framework/common-client-technologies/media/manipulation-flow.png "Manipulation_Flow")</span></span>  
  
 <span data-ttu-id="9484d-155">操作處理模型</span><span class="sxs-lookup"><span data-stu-id="9484d-155">The manipulation processing model</span></span>  
  
## <a name="inertia"></a><span data-ttu-id="9484d-156">慣性</span><span class="sxs-lookup"><span data-stu-id="9484d-156">Inertia</span></span>  
 <span data-ttu-id="9484d-157">慣性處理器可讓應用程式模擬真實世界行為，來外推位置、方向與其他 UI 項目的屬性。</span><span class="sxs-lookup"><span data-stu-id="9484d-157">The inertia processor enables applications to extrapolate location, orientation, and other properties of a UI element by simulating real-world behavior.</span></span>  
  
 <span data-ttu-id="9484d-158">例如，當使用者撥動項目，它可以繼續移動、減速，並慢慢停止。</span><span class="sxs-lookup"><span data-stu-id="9484d-158">For instance, when a user flicks an element, it can continue moving, decelerate, and then slowly stop.</span></span> <span data-ttu-id="9484d-159">慣性處理器會實作此行為，讓仿射 2D 值 (原點、縮放、轉譯和旋轉) 在指定時間內以指定減速速率變更。</span><span class="sxs-lookup"><span data-stu-id="9484d-159">The inertia processor implements this behavior by causing the affine 2-D values (origin, scale, translation, and rotation) to change over a specified time at a specified deceleration rate.</span></span>  
  
 <span data-ttu-id="9484d-160">如同操作處理，慣性處理器並沒有任何特定 UI 項目的相關資訊。</span><span class="sxs-lookup"><span data-stu-id="9484d-160">As with manipulation processing, an inertia processor does not have information about any particular UI element.</span></span> <span data-ttu-id="9484d-161">為了回應 <xref:System.Windows.Input.Manipulations.InertiaProcessor2D> 物件引發的事件，應用程式會分別將變更套用至應用程式特定的項目。</span><span class="sxs-lookup"><span data-stu-id="9484d-161">In response to events that are raised on an <xref:System.Windows.Input.Manipulations.InertiaProcessor2D> object, an application separately applies the changes to an application-specific element.</span></span>  
  
 <span data-ttu-id="9484d-162">慣性處理和操作處理通常一起使用。</span><span class="sxs-lookup"><span data-stu-id="9484d-162">Inertia processing and manipulation processing are often used together.</span></span> <span data-ttu-id="9484d-163">其介面很類似，而且它們所引發的事件 (在某些情況下) 完全相同。</span><span class="sxs-lookup"><span data-stu-id="9484d-163">Their interfaces are similar, and the events that they raise are (in some cases) identical.</span></span> <span data-ttu-id="9484d-164">一般而言，當 UI 項目操作完成時，就會開始慣性處理。</span><span class="sxs-lookup"><span data-stu-id="9484d-164">Generally, inertia processing begins when the manipulation of the UI element is completed.</span></span> <span data-ttu-id="9484d-165">這透過接聽 <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed> 事件和從事件處理常式啟動慣性處理而完成。</span><span class="sxs-lookup"><span data-stu-id="9484d-165">This is accomplished by listening to the <xref:System.Windows.Input.Manipulations.ManipulationProcessor2D.Completed> event and starting the inertia processing from that event handler.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="9484d-166">請參閱</span><span class="sxs-lookup"><span data-stu-id="9484d-166">See Also</span></span>  
 <xref:System.Windows.Input.Manipulations>
