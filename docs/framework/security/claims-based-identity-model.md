---
title: 宣告式身分識別模型
ms.date: 03/30/2017
ms.assetid: 4a96a9af-d980-43be-bf91-341a23401431
author: BrucePerlerMS
ms.openlocfilehash: 3313b2ad36260415d0ac505e01523dd999f85424
ms.sourcegitcommit: 9b552addadfb57fab0b9e7852ed4f1f1b8a42f8e
ms.translationtype: HT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/23/2019
ms.locfileid: "61792807"
---
# <a name="claims-based-identity-model"></a><span data-ttu-id="2a97d-102">宣告式身分識別模型</span><span class="sxs-lookup"><span data-stu-id="2a97d-102">Claims-Based Identity Model</span></span>
<span data-ttu-id="2a97d-103">當您建置宣告感知應用程式時，使用者識別會在應用程式中以一組宣告表示。</span><span class="sxs-lookup"><span data-stu-id="2a97d-103">When you build claims-aware applications, the user identity is represented in your application as a set of claims.</span></span> <span data-ttu-id="2a97d-104">一個宣告可以是使用者的名稱，另一個可能是電子郵件地址。</span><span class="sxs-lookup"><span data-stu-id="2a97d-104">One claim could be the user’s name, another might be an email address.</span></span> <span data-ttu-id="2a97d-105">這個概念是外部識別系統設定為提供應用程式一切必要資訊，使其了解是哪位使用者在提出要求，並且確保會使用密碼編譯您自受信任來源取得的識別資料。</span><span class="sxs-lookup"><span data-stu-id="2a97d-105">The idea is that an external identity system is configured to give your application everything it needs to know about the user with each request she makes, along with cryptographic assurance that the identity data you receive comes from a trusted source.</span></span>  
  
 <span data-ttu-id="2a97d-106">單一登入在這個模型中可以更輕鬆達成，而且應用程式也不必再對下列項目負責：</span><span class="sxs-lookup"><span data-stu-id="2a97d-106">Under this model, single sign-on is much easier to achieve, and your application is no longer responsible for the following:</span></span>  
  
- <span data-ttu-id="2a97d-107">驗證使用者。</span><span class="sxs-lookup"><span data-stu-id="2a97d-107">Authenticating users.</span></span>  
  
- <span data-ttu-id="2a97d-108">儲存使用者帳戶和密碼。</span><span class="sxs-lookup"><span data-stu-id="2a97d-108">Storing user accounts and passwords.</span></span>  
  
- <span data-ttu-id="2a97d-109">呼叫企業目錄以查詢使用者識別詳細資料。</span><span class="sxs-lookup"><span data-stu-id="2a97d-109">Calling to enterprise directories to look up user identity details.</span></span>  
  
- <span data-ttu-id="2a97d-110">與來自其他平台或公司的識別系統整合。</span><span class="sxs-lookup"><span data-stu-id="2a97d-110">Integrating with identity systems from other platforms or companies.</span></span>  
  
 <span data-ttu-id="2a97d-111">在這個模型中，應用程式將根據用來驗證您使用者的系統所提供的宣告，制定與識別相關的決策。</span><span class="sxs-lookup"><span data-stu-id="2a97d-111">Under this model, your application makes identity-related decisions based on claims supplied by the system that authenticated your user.</span></span> <span data-ttu-id="2a97d-112">從利用使用者名字的簡單應用程式個人化，到授權使用者存取應用程式中價值更高的功能和資源，這些決策可以是任何項目。</span><span class="sxs-lookup"><span data-stu-id="2a97d-112">This could be anything from simple application personalization with the user’s first name, to authorizing the user to access higher valued features and resources in your application.</span></span>  
  
 <span data-ttu-id="2a97d-113">本主題提供下列資訊：</span><span class="sxs-lookup"><span data-stu-id="2a97d-113">This topic provides the following information:</span></span>  
  
- [<span data-ttu-id="2a97d-114">宣告式身分識別簡介</span><span class="sxs-lookup"><span data-stu-id="2a97d-114">Introduction to Claims-Based Identity</span></span>](../../../docs/framework/security/claims-based-identity-model.md#BKMK_1)  
  
- [<span data-ttu-id="2a97d-115">宣告式身分識別模型的基本案例</span><span class="sxs-lookup"><span data-stu-id="2a97d-115">Basic Scenario for a Claims-Based Identity Model</span></span>](../../../docs/framework/security/claims-based-identity-model.md#BKMK_2)  
  
<a name="BKMK_1"></a>   
## <a name="introduction-to-claims-based-identity"></a><span data-ttu-id="2a97d-116">宣告型識別簡介</span><span class="sxs-lookup"><span data-stu-id="2a97d-116">Introduction to Claims-Based Identity</span></span>  
 <span data-ttu-id="2a97d-117">下列詞彙和概念有助於了解這個新的識別架構。</span><span class="sxs-lookup"><span data-stu-id="2a97d-117">The following terminology and concepts can help you understand this new architecture for identity.</span></span>  
  
### <a name="identity"></a><span data-ttu-id="2a97d-118">身分識別</span><span class="sxs-lookup"><span data-stu-id="2a97d-118">Identity</span></span>  
 <span data-ttu-id="2a97d-119">為了描述 Windows Identity Foundation (WIF) 中的程式設計模型，我們將使用「身分識別」一詞來表示一組屬性，這組屬性可用來描述要在系統中保護其安全性的使用者或其他某些實體。</span><span class="sxs-lookup"><span data-stu-id="2a97d-119">For the purposes of describing the programming model in Windows Identity Foundation (WIF), we will use the term "identity" to represent a set of attributes that describe a user or some other entity in a system that you want to secure.</span></span>  
  
### <a name="claim"></a><span data-ttu-id="2a97d-120">宣告</span><span class="sxs-lookup"><span data-stu-id="2a97d-120">Claim</span></span>  
 <span data-ttu-id="2a97d-121">將一個宣告當做一項身分識別資訊，例如名稱、 電子郵件地址、 年齡、 「 銷售 」 角色的成員資格。</span><span class="sxs-lookup"><span data-stu-id="2a97d-121">Think of a claim as a piece of identity information such as name, email address, age, membership in the Sales role.</span></span> <span data-ttu-id="2a97d-122">應用程式接收的宣告愈多，也能讓您愈了解使用者。</span><span class="sxs-lookup"><span data-stu-id="2a97d-122">The more claims your application receives, the more you’ll know about your user.</span></span> <span data-ttu-id="2a97d-123">您可能會好奇為什麼要使用「宣告」一詞，而不是像通常用於描述企業目錄的「屬性」一詞。</span><span class="sxs-lookup"><span data-stu-id="2a97d-123">You may be wondering why these are called "claims," rather than "attributes," as is commonly used in describing enterprise directories.</span></span> <span data-ttu-id="2a97d-124">其中原因和傳遞方法有關。</span><span class="sxs-lookup"><span data-stu-id="2a97d-124">The reason has to do with the delivery method.</span></span> <span data-ttu-id="2a97d-125">在這個模型中，應用程式不會在目錄中查詢使用者屬性，</span><span class="sxs-lookup"><span data-stu-id="2a97d-125">In this model, your application doesn’t look up user attributes in a directory.</span></span> <span data-ttu-id="2a97d-126">而是使用者提供宣告給應用程式，然後應用程式再檢查這些宣告。</span><span class="sxs-lookup"><span data-stu-id="2a97d-126">Instead, the user delivers claims to your application, and your application examines them.</span></span> <span data-ttu-id="2a97d-127">每個宣告都是由簽發者發出呈現，而且您信任宣告的程度就如同信任簽發者一樣。</span><span class="sxs-lookup"><span data-stu-id="2a97d-127">Each claim is made by an issuer, and you trust the claim only as much as you trust the issuer.</span></span> <span data-ttu-id="2a97d-128">例如，與使用者本身發出的宣告相比，您更信任公司的網域控制站發出的宣告。</span><span class="sxs-lookup"><span data-stu-id="2a97d-128">For example, you trust a claim made by your company’s domain controller more than you trust a claim made by the user herself.</span></span> <span data-ttu-id="2a97d-129">WIF 表示的宣告都包含 <xref:System.Security.Claims.Claim> 類型，這個類型的 <xref:System.Security.Claims.Claim.Issuer%2A> 屬性可讓您了解宣告的簽發者是誰。</span><span class="sxs-lookup"><span data-stu-id="2a97d-129">WIF represents claims with a <xref:System.Security.Claims.Claim> type, which has an <xref:System.Security.Claims.Claim.Issuer%2A> property that allows you to find out who issued the claim.</span></span>  
  
### <a name="security-token"></a><span data-ttu-id="2a97d-130">安全性權杖</span><span class="sxs-lookup"><span data-stu-id="2a97d-130">Security Token</span></span>  
 <span data-ttu-id="2a97d-131">使用者隨著要求提供一組宣告給應用程式。</span><span class="sxs-lookup"><span data-stu-id="2a97d-131">The user delivers a set of claims to your application along with a request.</span></span> <span data-ttu-id="2a97d-132">在 Web 服務中，這些宣告是位於 SOAP 封套的安全性標頭內進行傳送。</span><span class="sxs-lookup"><span data-stu-id="2a97d-132">In a Web service, these claims are carried in the security header of the SOAP envelope.</span></span> <span data-ttu-id="2a97d-133">在瀏覽器架構 Web 應用程式中，這些宣告則會從使用者的瀏覽器透過 HTTP POST 送出，而且如果工作階段有需要，之後就會被快取在 Cookie 中。</span><span class="sxs-lookup"><span data-stu-id="2a97d-133">In a browser-based Web application, the claims arrive through an HTTP POST from the user’s browser, and may later be cached in a cookie if a session is desired.</span></span> <span data-ttu-id="2a97d-134">無論這些宣告如何抵達，都必須將它們序列化，這也是需要安全性權杖的地方。</span><span class="sxs-lookup"><span data-stu-id="2a97d-134">Regardless of how these claims arrive, they must be serialized, which is where security tokens come in.</span></span> <span data-ttu-id="2a97d-135">安全性權杖是發行單位以數位方式簽署且經過序列化的宣告集合。</span><span class="sxs-lookup"><span data-stu-id="2a97d-135">A security token is a serialized set of claims that is digitally signed by the issuing authority.</span></span> <span data-ttu-id="2a97d-136">簽章重要之處在於，它可以確保使用者不是僅建立一大堆宣告然後就傳送給您。</span><span class="sxs-lookup"><span data-stu-id="2a97d-136">The signature is important: it gives you assurance that the user didn’t just make up a bunch of claims and send them to you.</span></span> <span data-ttu-id="2a97d-137">雖然在不需要加密的低安全性情況下，您可以使用未簽署的權杖，但是這種情況不屬於本主題的說明範圍。</span><span class="sxs-lookup"><span data-stu-id="2a97d-137">In low security situations where cryptography isn’t necessary or desired, you can use unsigned tokens, but that scenario is not described in this topic.</span></span>  
  
 <span data-ttu-id="2a97d-138">WIF 的其中一項核心功能是能夠建立和讀取安全性權杖。</span><span class="sxs-lookup"><span data-stu-id="2a97d-138">One of the core features in WIF is the ability to create and read security tokens.</span></span> <span data-ttu-id="2a97d-139">WIF 和 .NET Framework 會處理所有密碼編譯工作，並且告知應用程式有一組您可以讀取的宣告。</span><span class="sxs-lookup"><span data-stu-id="2a97d-139">WIF and the .NET Framework handle all of the cryptographic work, and present your application with a set of claims that you can read.</span></span>  
  
### <a name="issuing-authority"></a><span data-ttu-id="2a97d-140">發行單位</span><span class="sxs-lookup"><span data-stu-id="2a97d-140">Issuing Authority</span></span>  
 <span data-ttu-id="2a97d-141">發行單位五花八門，從發行 Kerberos 票證的網域控制站到發行 X.509 憑證的憑證授權單位都有，不過本主題所討論的特定類型單位是發行包含宣告的安全性權杖。</span><span class="sxs-lookup"><span data-stu-id="2a97d-141">There are lots of different types of issuing authorities, from domain controllers that issue Kerberos tickets, to certification authorities that issue X.509 certificates, but the specific type of authority discussed in this topic issues security tokens that contain claims.</span></span> <span data-ttu-id="2a97d-142">發行單位是了解如何發行安全性權杖的 Web 應用程式或 Web 服務。</span><span class="sxs-lookup"><span data-stu-id="2a97d-142">This issuing authority is a Web application or Web service that knows how to issue security tokens.</span></span> <span data-ttu-id="2a97d-143">對於信賴憑證者和提出要求的使用者，發行單位必須有足夠的資訊來發行適當的宣告，而且要負責與使用者存放區互動以查詢宣告和驗證使用者。</span><span class="sxs-lookup"><span data-stu-id="2a97d-143">It must have enough knowledge to be able to issue the proper claims given the target relying party and the user making the request, and might be responsible for interacting with user stores to look up claims and authenticate the users themselves.</span></span>  
  
 <span data-ttu-id="2a97d-144">無論您選擇哪個發行單位，該單位在識別解決方案中都扮演著核心角色。</span><span class="sxs-lookup"><span data-stu-id="2a97d-144">Whatever issuing authority you choose, it plays a central role in your identity solution.</span></span> <span data-ttu-id="2a97d-145">藉由信賴宣告的方式將驗證與應用程式分開，表示您要將責任移交給該單位並要求它代替您驗證使用者。</span><span class="sxs-lookup"><span data-stu-id="2a97d-145">When you factor authentication out of your application by relying on claims, you’re passing responsibility to that authority and asking it to authenticate users on your behalf.</span></span>  
  
### <a name="security-token-service-sts"></a><span data-ttu-id="2a97d-146">安全性權杖服務 (STS)</span><span class="sxs-lookup"><span data-stu-id="2a97d-146">Security Token Service (STS)</span></span>  
 <span data-ttu-id="2a97d-147">Security Token Service (STS) 這個服務元件可根據 WS-Trust 和 WS-Federation 通訊協定，建置、簽署和發行安全性權杖。</span><span class="sxs-lookup"><span data-stu-id="2a97d-147">A security token service (STS) is the service component that builds, signs, and issues security tokens according to the WS-Trust and WS-Federation protocols.</span></span> <span data-ttu-id="2a97d-148">實作這些通訊協定是一項大工程，但是 WIF 會為您完成這些工作，讓不熟悉通訊協定領域的人也可以輕易使用和執行 STS。</span><span class="sxs-lookup"><span data-stu-id="2a97d-148">There’s a lot of work that goes into implementing these protocols, but WIF does all of this work for you, making it feasible for someone who isn’t an expert in the protocols to get an STS up and running with very little effort.</span></span> <span data-ttu-id="2a97d-149">您可以使用預先建置的 STS (例如 [Active Directory® Federation Services (AD FS) 2.0](https://go.microsoft.com/fwlink/?LinkID=247516)) 或雲端 STS (例如 [Windows Azure Access Control Service (ACS)](https://go.microsoft.com/fwlink/?LinkID=247517))。或者，如果您要發行自訂權杖或是提供自訂驗證或授權，也可以使用 WIF 建置專屬自訂 STS。</span><span class="sxs-lookup"><span data-stu-id="2a97d-149">You can use a pre-built STS such as [Active Directory® Federation Services (AD FS) 2.0](https://go.microsoft.com/fwlink/?LinkID=247516), a cloud STS such as a [Windows Azure Access Control Service (ACS)](https://go.microsoft.com/fwlink/?LinkID=247517), or, if you want to issue custom tokens or provide custom authentication or authorization, you can build your own custom STS using WIF.</span></span> <span data-ttu-id="2a97d-150">WIF 可讓您輕鬆建置專屬 STS。</span><span class="sxs-lookup"><span data-stu-id="2a97d-150">WIF makes it easy to build your own STS.</span></span>  
  
### <a name="relying-party-application"></a><span data-ttu-id="2a97d-151">信賴憑證者應用程式</span><span class="sxs-lookup"><span data-stu-id="2a97d-151">Relying Party Application</span></span>  
 <span data-ttu-id="2a97d-152">當您建置依賴宣告的應用程式時，表示您建立的是信賴憑證者 (RP) 應用程式。</span><span class="sxs-lookup"><span data-stu-id="2a97d-152">When you build an application that relies on claims, you are building a relying party (RP) application.</span></span> <span data-ttu-id="2a97d-153">RP 的同義字包含「宣告感知應用程式」和「宣告式應用程式」。</span><span class="sxs-lookup"><span data-stu-id="2a97d-153">Synonyms for an RP include "claims-aware application" and "claims-based application".</span></span> <span data-ttu-id="2a97d-154">Web 應用程式和 Web 服務都可以是 RP。</span><span class="sxs-lookup"><span data-stu-id="2a97d-154">Web applications and Web services can both be RPs.</span></span> <span data-ttu-id="2a97d-155">RP 應用程式會使用 STS 發行的權杖，並從權杖擷取宣告方便進行識別相關工作。</span><span class="sxs-lookup"><span data-stu-id="2a97d-155">A RP application consumes the tokens issued by a STS and extracts the claims from tokens to use them for identity related tasks.</span></span> <span data-ttu-id="2a97d-156">WIF 可提供相關功能，協助您建置 RP 應用程式。</span><span class="sxs-lookup"><span data-stu-id="2a97d-156">WIF offers functionalities to help you build RP applications.</span></span>  
  
### <a name="standards"></a><span data-ttu-id="2a97d-157">標準</span><span class="sxs-lookup"><span data-stu-id="2a97d-157">Standards</span></span>  
 <span data-ttu-id="2a97d-158">為了讓上述所有項目互通，前述案例中會使用幾項 WS-\* 標準。</span><span class="sxs-lookup"><span data-stu-id="2a97d-158">In order to make all of this interoperable, several WS-\* standards are used in the previous scenario.</span></span> <span data-ttu-id="2a97d-159">案例中會使用 WS-MetadataExchange 擷取原則，而原則本身的結構是以 WS-Policy 規格為基礎。</span><span class="sxs-lookup"><span data-stu-id="2a97d-159">Policy is retrieved using WS-MetadataExchange, and the policy itself is structured according to the WS-Policy specification.</span></span> <span data-ttu-id="2a97d-160">STS 會公開實作 WS-Trust 規格的端點，以描述如何要求和接收安全性權杖。</span><span class="sxs-lookup"><span data-stu-id="2a97d-160">The STS exposes endpoints that implement the WS-Trust specification, which describes how to request and receive security tokens.</span></span> <span data-ttu-id="2a97d-161">現今大部分 STS 都是使用安全宣示標記語言 (Security Assertion Markup Langauge，SAML) 格式來發行權杖。</span><span class="sxs-lookup"><span data-stu-id="2a97d-161">Most STSs today issue tokens formatted with Security Assertion Markup Langauge (SAML).</span></span> <span data-ttu-id="2a97d-162">SAML 是業界公認的 XML 詞彙，可用來以互通方式表示宣告。</span><span class="sxs-lookup"><span data-stu-id="2a97d-162">SAML is an industry-recognized XML vocabulary that can be used to represent claims in an interoperable way.</span></span> <span data-ttu-id="2a97d-163">或者，這可讓您在多重平台的情況下與完全相異平台上的 STS 溝通，並且無論平台為何，單一登入在您的所有應用程式中都可以達成。</span><span class="sxs-lookup"><span data-stu-id="2a97d-163">Or, in a multi-platform situation, this allows you to communicate with an STS on an entirely different platform and achieve single sign-on across all of your applications, regardless of platform.</span></span>  
  
### <a name="browser-based-applications"></a><span data-ttu-id="2a97d-164">瀏覽器架構應用程式</span><span class="sxs-lookup"><span data-stu-id="2a97d-164">Browser-Based Applications</span></span>  
 <span data-ttu-id="2a97d-165">並非只有智慧型用戶端可以使用宣告型識別模型，</span><span class="sxs-lookup"><span data-stu-id="2a97d-165">Smart clients aren’t the only ones who can use the claims-based identity model.</span></span> <span data-ttu-id="2a97d-166">瀏覽器架構應用程式 (也稱為被動用戶端) 也可以使用。</span><span class="sxs-lookup"><span data-stu-id="2a97d-166">Browser-based applications (also referred to as passive clients) can use it as well.</span></span> <span data-ttu-id="2a97d-167">下列情況將描述這要如何達成。</span><span class="sxs-lookup"><span data-stu-id="2a97d-167">The following scenario describes how this works.</span></span>  
  
 <span data-ttu-id="2a97d-168">首先，使用者將瀏覽器指向一個宣告感知 Web 應用程式 (信賴憑證者應用程式)。</span><span class="sxs-lookup"><span data-stu-id="2a97d-168">First, the user points a browser at a claims-aware Web application (the relying party application).</span></span> <span data-ttu-id="2a97d-169">Web 應用程式會將瀏覽器重新導向至 STS 讓使用者進行驗證。</span><span class="sxs-lookup"><span data-stu-id="2a97d-169">The Web application redirects the browser to the STS so the user can be authenticated.</span></span> <span data-ttu-id="2a97d-170">STS 裝載於簡單的 Web 應用程式中，這個 Web 應用程式可以讀取傳入要求、利用標準 HTTP 機制驗證使用者，然後再建立 SAML 權杖並透過 JavaScript 程式碼讓瀏覽器建立 HTTP POST 以將 SAML 權杖送回 RP。</span><span class="sxs-lookup"><span data-stu-id="2a97d-170">The STS is hosted in a simple web application that reads the incoming request, authenticates the user using standard HTTP mechanisms, and then creates a SAML token and replies with a piece of JavaScript code that causes the browser to initiate an HTTP POST that sends the SAML token back to the RP.</span></span> <span data-ttu-id="2a97d-171">這個 POST 的本文包含 RP 要求的宣告。</span><span class="sxs-lookup"><span data-stu-id="2a97d-171">The body of this POST contains the claims that the RP requested.</span></span> <span data-ttu-id="2a97d-172">此時 RP 通常會將宣告封裝成 Cookie，如此使用者就不必在每次提出要求時，都要經歷重新導向的動作。</span><span class="sxs-lookup"><span data-stu-id="2a97d-172">At this point, it is common for the RP to package the claims into a cookie so that the user doesn’t have to be redirected for each request.</span></span>  
  
<a name="BKMK_2"></a>   
## <a name="basic-scenario-for-a-claims-based-identity-model"></a><span data-ttu-id="2a97d-173">宣告型識別模型的基本案例</span><span class="sxs-lookup"><span data-stu-id="2a97d-173">Basic Scenario for a Claims-Based Identity Model</span></span>  
 <span data-ttu-id="2a97d-174">以下是宣告型系統範例。</span><span class="sxs-lookup"><span data-stu-id="2a97d-174">The following is an example of a claims-based system.</span></span>  
  
 <span data-ttu-id="2a97d-175">![信賴合作夥伴驗證流程](../../../docs/framework/security/media/conc-relying-partner-processc.png "conc_relying_partner_processc")</span><span class="sxs-lookup"><span data-stu-id="2a97d-175">![Relying Partner Authentication Flow](../../../docs/framework/security/media/conc-relying-partner-processc.png "conc_relying_partner_processc")</span></span>  
  
 <span data-ttu-id="2a97d-176">上圖顯示已設定為使用 WIF 進行驗證的網站 (信賴憑證者應用程式，即 RP) 以及要使用該網站的用戶端 (Web 瀏覽器)。</span><span class="sxs-lookup"><span data-stu-id="2a97d-176">This diagram shows a Web site (the relying party application, RP) that has been configured to use WIF for authentication and a client, a web browser, that wants to use that site.</span></span>  
  
1. <span data-ttu-id="2a97d-177">當未驗證的使用者要求網頁時，其瀏覽器重新導向的身分識別提供者 (IdP) 頁面。</span><span class="sxs-lookup"><span data-stu-id="2a97d-177">When an unauthenticated user requests a page, their browser is redirected to the identity provider (IdP) pages.</span></span>  
  
2. <span data-ttu-id="2a97d-178">IdP 會要求使用者出示其認證，例如使用者名稱/密碼或 Kerberos 驗證。</span><span class="sxs-lookup"><span data-stu-id="2a97d-178">The IdP requires the user to present their credentials, such as username/password or Kerberos authentication.</span></span>  
  
3. <span data-ttu-id="2a97d-179">權杖，權杖會傳回到瀏覽器 IdP 問題。</span><span class="sxs-lookup"><span data-stu-id="2a97d-179">The IdP issues a token back to that is returned to the browser.</span></span>  
  
4. <span data-ttu-id="2a97d-180">瀏覽器會重新導向至原本要求的頁面，並且 WIF 會判斷該權杖是否有足夠的權限可以存取該頁面。</span><span class="sxs-lookup"><span data-stu-id="2a97d-180">The browser is now redirected back to the originally requested page where WIF determines if the token satisfies the requirements to access the page.</span></span> <span data-ttu-id="2a97d-181">如果權限沒問題，瀏覽器隨即發行 Cookie 以建立工作階段，因此驗證只需要進行一次，接著就將控制權移交給應用程式。</span><span class="sxs-lookup"><span data-stu-id="2a97d-181">If so a cookie is issued to establish a session so the authentication only needs to occur once, and control is passed to the application.</span></span>
