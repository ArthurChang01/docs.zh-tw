---
title: 使用 WIF 進行宣告式授權
ms.date: 03/30/2017
ms.assetid: e24000a3-8fd8-4c0e-bdf0-39882cc0f6d8
author: BrucePerlerMS
ms.openlocfilehash: ebf4c28bd2a46c21535b596af22d1fa420d20e71
ms.sourcegitcommit: 289e06e904b72f34ac717dbcc5074239b977e707
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 09/17/2019
ms.locfileid: "71045495"
---
# <a name="claims-based-authorization-using-wif"></a><span data-ttu-id="ecc68-102">使用 WIF 進行宣告式授權</span><span class="sxs-lookup"><span data-stu-id="ecc68-102">Claims Based Authorization Using WIF</span></span>
<span data-ttu-id="ecc68-103">在信賴憑證者應用程式中，授權會判斷哪些是已驗證的識別可以存取的資源，以及可以針對這些資源執行哪些作業。</span><span class="sxs-lookup"><span data-stu-id="ecc68-103">In a relying party application, authorization determines what resources an authenticated identity is allowed to access and what operations it is allowed to perform on those resources.</span></span> <span data-ttu-id="ecc68-104">不適當或弱式授權會導致資訊洩露以及資料遭竄改。</span><span class="sxs-lookup"><span data-stu-id="ecc68-104">Improper or weak authorization leads to information disclosure and data tampering.</span></span> <span data-ttu-id="ecc68-105">本主題概述可使用 Windows Identity Foundation (WIF) 和 Security Token Service (STS) (例如 Microsoft Azure Access Control Service (ACS)) 為宣告感知 ASP.NET Web 應用程式和服務實作授權的方式。</span><span class="sxs-lookup"><span data-stu-id="ecc68-105">This topic outlines the available approaches to implementing authorization for claims-aware ASP.NET web applications and services using Windows Identity Foundation (WIF) and a Security Token Service (STS), for example, the Windows Azure Access Control Service (ACS).</span></span>  
  
## <a name="overview"></a><span data-ttu-id="ecc68-106">總覽</span><span class="sxs-lookup"><span data-stu-id="ecc68-106">Overview</span></span>  
 <span data-ttu-id="ecc68-107">從第一版 .NET Framework 開始，就提供了彈性的授權實作機制。</span><span class="sxs-lookup"><span data-stu-id="ecc68-107">Since its first version, the .NET Framework has offered a flexible mechanism for implementing authorization.</span></span> <span data-ttu-id="ecc68-108">這項機制是以 **IPrincipal** 和 **IIdentity** 這兩個簡單的介面為基礎。</span><span class="sxs-lookup"><span data-stu-id="ecc68-108">This mechanism is based on two simple interfaces—**IPrincipal** and **IIdentity**.</span></span> <span data-ttu-id="ecc68-109">**IIdentity** 的具體實作表示已驗證的使用者。</span><span class="sxs-lookup"><span data-stu-id="ecc68-109">Concrete implementations of **IIdentity** represent an authenticated user.</span></span> <span data-ttu-id="ecc68-110">例如，**WindowsIdentity** 實作表示經過 Active Directory 驗證的使用者，而 **GenericIdentity** 則表示身分識別經過自訂驗證程序驗證後的使用者。</span><span class="sxs-lookup"><span data-stu-id="ecc68-110">For example, the **WindowsIdentity** implementation represents a user who is authenticated by Active Directory, and **GenericIdentity** represents a user whose identity is verified via a custom authentication process.</span></span> <span data-ttu-id="ecc68-111">**IPrincipal** 的具體實作可協助使用角色並根據角色存放區來檢查權限。</span><span class="sxs-lookup"><span data-stu-id="ecc68-111">Concrete implementations of **IPrincipal** help to check permissions using roles depending on the role store.</span></span> <span data-ttu-id="ecc68-112">例如，**WindowsPrincipal** 會檢查 **WindowsIdentity** 是否擁有 Active Directory 中各群組的成員資格。</span><span class="sxs-lookup"><span data-stu-id="ecc68-112">For example, **WindowsPrincipal** checks **WindowsIdentity** for membership in Active Directory groups.</span></span> <span data-ttu-id="ecc68-113">這項檢查是透過呼叫 **IPrincipal** 介面的 **IsInRole** 方法來執行。</span><span class="sxs-lookup"><span data-stu-id="ecc68-113">This check is performed by calling the **IsInRole** method on the **IPrincipal** interface.</span></span> <span data-ttu-id="ecc68-114">根據角色來檢查存取權限的做法稱為角色型存取控制 (RBAC)。</span><span class="sxs-lookup"><span data-stu-id="ecc68-114">Checking access based on roles is called Role-Based Access Control (RBAC).</span></span> <span data-ttu-id="ecc68-115">如需詳細資訊，請參閱[角色型存取控制](claims-based-authorization-using-wif.md#BKMK_1)。</span><span class="sxs-lookup"><span data-stu-id="ecc68-115">For more information, see [Role-Based Access Control](claims-based-authorization-using-wif.md#BKMK_1).</span></span>  <span data-ttu-id="ecc68-116">宣告可用來攜帶角色相關資訊，以支援熟悉且以角色為基礎的授權機制。</span><span class="sxs-lookup"><span data-stu-id="ecc68-116">Claims can be used to carry information about roles to support familiar, role-based authorization mechanisms.</span></span>  
  
 <span data-ttu-id="ecc68-117">此外，宣告也可以用來進行角色背後更複雜的授權決策。</span><span class="sxs-lookup"><span data-stu-id="ecc68-117">Claims can also be used to enable more complicated authorization decisions beyond roles.</span></span> <span data-ttu-id="ecc68-118">宣告可以根據幾乎使用者的任何資訊：年齡、郵遞區號、鞋子尺寸等等。根據任意宣告的存取控制機制稱為宣告式授權。</span><span class="sxs-lookup"><span data-stu-id="ecc68-118">Claims can be based on virtually any information about the user - age, zip code, shoe size, etc. An access control mechanism that is based on arbitrary claims is called claims-based authorization.</span></span> <span data-ttu-id="ecc68-119">如需詳細資訊，請參閱[宣告式授權](claims-based-authorization-using-wif.md#BKMK_2)。</span><span class="sxs-lookup"><span data-stu-id="ecc68-119">For more information, see [Claims-based Authorization](claims-based-authorization-using-wif.md#BKMK_2).</span></span>  
  
<a name="BKMK_1"></a>   
## <a name="role-based-access-control"></a><span data-ttu-id="ecc68-120">角色型存取控制</span><span class="sxs-lookup"><span data-stu-id="ecc68-120">Role-Based Access Control</span></span>  
 <span data-ttu-id="ecc68-121">RBAC 是一種授權方式，應用程式會根據使用者角色來管理和落實使用者權限。</span><span class="sxs-lookup"><span data-stu-id="ecc68-121">RBAC is an authorization approach in which user permissions are managed and enforced by an application based on user roles.</span></span> <span data-ttu-id="ecc68-122">如果使用者有執行動作所需的角色，應用程式就會授與存取權限，否則會拒絕存取。</span><span class="sxs-lookup"><span data-stu-id="ecc68-122">If a user has a role that is required to perform an action, the access is granted; otherwise, access is denied.</span></span>  
  
### <a name="iprincipalisinrole-method"></a><span data-ttu-id="ecc68-123">IPrincipal.IsInRole 方法</span><span class="sxs-lookup"><span data-stu-id="ecc68-123">IPrincipal.IsInRole Method</span></span>  
 <span data-ttu-id="ecc68-124">若要在宣告感知應用程式中執行 RBAC 方法，請在**IPrincipal**介面中使用**IsInRole （）** 方法，就如同在非宣告感知應用程式中所做的一樣。</span><span class="sxs-lookup"><span data-stu-id="ecc68-124">To implement the RBAC approach in claims-aware applications, use the **IsInRole()** method in the **IPrincipal** interface, just as you would in non-claims-aware applications.</span></span> <span data-ttu-id="ecc68-125">**IsInRole()** 方法的使用方式有下列幾種：</span><span class="sxs-lookup"><span data-stu-id="ecc68-125">There are several ways of using the **IsInRole()** method:</span></span>  
  
- <span data-ttu-id="ecc68-126">明確呼叫 **IPrincipal.IsInRole("Administrator")** 。</span><span class="sxs-lookup"><span data-stu-id="ecc68-126">Explicitly calling on **IPrincipal.IsInRole("Administrator")**.</span></span> <span data-ttu-id="ecc68-127">如果使用這種方式，結果會是布林值。</span><span class="sxs-lookup"><span data-stu-id="ecc68-127">In this approach, the outcome is a Boolean.</span></span> <span data-ttu-id="ecc68-128">因此，您可以在條件陳述式中使用。</span><span class="sxs-lookup"><span data-stu-id="ecc68-128">Use it in your conditional statements.</span></span> <span data-ttu-id="ecc68-129">使用時，它可以位於程式碼中的任意位置。</span><span class="sxs-lookup"><span data-stu-id="ecc68-129">It can be used arbitrarily any place in your code.</span></span>  
  
- <span data-ttu-id="ecc68-130">使用安全性要求 **PrincipalPermission.Demand()** 。</span><span class="sxs-lookup"><span data-stu-id="ecc68-130">Using the security demand **PrincipalPermission.Demand()**.</span></span> <span data-ttu-id="ecc68-131">使用這種方式時，如果無法滿足要求，結果會發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ecc68-131">In this approach, the outcome is an exception in case the demand is not satisfied.</span></span> <span data-ttu-id="ecc68-132">因此，您可以在例外狀況處理策略中使用這種方式。</span><span class="sxs-lookup"><span data-stu-id="ecc68-132">This should fit your exception handling strategy.</span></span> <span data-ttu-id="ecc68-133">從效能觀點來看，擲回例外狀況與傳回布林值相比，所耗費的效能會多出許多。</span><span class="sxs-lookup"><span data-stu-id="ecc68-133">Throwing exceptions is much more expensive from a performance perspective compared to returning Boolean.</span></span> <span data-ttu-id="ecc68-134">使用時，它可以位於程式碼中的任意位置。</span><span class="sxs-lookup"><span data-stu-id="ecc68-134">This can be used any place in your code.</span></span>  
  
- <span data-ttu-id="ecc68-135">使用宣告式屬性 **[PrincipalPermission(SecurityAction.Demand, Role = "Administrator")]** 。</span><span class="sxs-lookup"><span data-stu-id="ecc68-135">Using the declarative attributes **[PrincipalPermission(SecurityAction.Demand, Role = "Administrator")]**.</span></span> <span data-ttu-id="ecc68-136">這種方式是用來裝飾方法，因此稱為宣告式。</span><span class="sxs-lookup"><span data-stu-id="ecc68-136">This approach is called declarative, because it is used to decorate methods.</span></span> <span data-ttu-id="ecc68-137">它不能在方法實作內的程式碼區塊中使用。</span><span class="sxs-lookup"><span data-stu-id="ecc68-137">It cannot be used in code blocks inside the method’s implementations.</span></span> <span data-ttu-id="ecc68-138">如果無法滿足要求，結果會發生例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ecc68-138">The outcome is an exception in case the demand is not satisfied.</span></span> <span data-ttu-id="ecc68-139">因此，您應該確認可以在例外狀況處理策略中使用這種方式。</span><span class="sxs-lookup"><span data-stu-id="ecc68-139">You should make sure that it fits your exception-handling strategy.</span></span>  
  
- <span data-ttu-id="ecc68-140">使用 URL 授權，使用 **web.config** 中的 **\<authorization>** 區段。如果您是在 URL 層級管理授權，就很適合使用這種方式。</span><span class="sxs-lookup"><span data-stu-id="ecc68-140">Using URL authorization, using the **\<authorization>** section in **web.config**. This approach is suitable when you are managing authorization on a URL level.</span></span> <span data-ttu-id="ecc68-141">與先前提及的方式相比，這種方式是最粗糙的。</span><span class="sxs-lookup"><span data-stu-id="ecc68-141">This is the most coarse level among those previously mentioned.</span></span> <span data-ttu-id="ecc68-142">其優點在於我們只要變更組態檔內容即可，也就是說，我們不必編譯程式碼就可以獲得變更的好處。</span><span class="sxs-lookup"><span data-stu-id="ecc68-142">The advantage of this approach is that changes are made in the configuration file, which means that the code should not be compiled to take advantage of the change.</span></span>  
  
### <a name="expressing-roles-as-claims"></a><span data-ttu-id="ecc68-143">將角色表示為宣告</span><span class="sxs-lookup"><span data-stu-id="ecc68-143">Expressing Roles as Claims</span></span>  
 <span data-ttu-id="ecc68-144">呼叫 **IsInRole()** 方法可以檢查目前的使用者是否具有該角色。</span><span class="sxs-lookup"><span data-stu-id="ecc68-144">When the **IsInRole()** method is called, there is a check made to see if the current user has that role.</span></span> <span data-ttu-id="ecc68-145">在宣告感知應用程式中，角色是依角色宣告類型表示，而該類型可以從權杖中取得。</span><span class="sxs-lookup"><span data-stu-id="ecc68-145">In claims-aware applications, the role is expressed by a role claim type that should be available in the token.</span></span> <span data-ttu-id="ecc68-146">角色宣告類型是使用下列 URI 來表示：</span><span class="sxs-lookup"><span data-stu-id="ecc68-146">The role claim type is expressed using the following URI:</span></span>  
  
 `http://schemas.microsoft.com/ws/2008/06/identity/claims/role`
  
 <span data-ttu-id="ecc68-147">下列幾種方式都可以利用角色宣告類型來增加權杖內容：</span><span class="sxs-lookup"><span data-stu-id="ecc68-147">There are several ways to enrich a token with a role claim type:</span></span>  
  
- <span data-ttu-id="ecc68-148">**在權杖發行期間**。</span><span class="sxs-lookup"><span data-stu-id="ecc68-148">**During token issuance**.</span></span> <span data-ttu-id="ecc68-149">使用者通過驗證之後，身分識別提供者 STS 或同盟提供者 (例如 Microsoft Azure Access Control Service (ACS)) 就會發行角色宣告。</span><span class="sxs-lookup"><span data-stu-id="ecc68-149">When a user is authenticated the role claim can be issued by the identity provider STS or by a federation provider such as the Windows Azure Access Control Service (ACS).</span></span>  
  
- <span data-ttu-id="ecc68-150">**使用 ClaimsAuthenticationManager 將任意宣告轉換為宣告角色類型**。</span><span class="sxs-lookup"><span data-stu-id="ecc68-150">**Transforming arbitrary claims into of claims role type using ClaimsAuthenticationManager**.</span></span> <span data-ttu-id="ecc68-151">ClaimsAuthenticationManager 是隨附於 WIF 的元件，</span><span class="sxs-lookup"><span data-stu-id="ecc68-151">The ClaimsAuthenticationManager is a component that ships as part of WIF.</span></span> <span data-ttu-id="ecc68-152">可允許使用者在啟動應用程式時攔截要求，並且檢查權杖以及利用新增、變更或移除宣告來轉換權杖。</span><span class="sxs-lookup"><span data-stu-id="ecc68-152">It allows requests to be intercepted when they launch an application, inspecting tokens and transforming them by adding, changing, or removing claims.</span></span> <span data-ttu-id="ecc68-153">如需如何使用 ClaimsAuthenticationManager 來轉換宣告的詳細資訊，請[參閱如何：使用 WIF 和 ACS](https://go.microsoft.com/fwlink/?LinkID=247445)在宣告感知 ASP.NET 應用程式中，執行以角色為基礎的存取控制（RBAC）。</span><span class="sxs-lookup"><span data-stu-id="ecc68-153">For more information about how to use ClaimsAuthenticationManager for transforming claims, see [How To: Implement Role Based Access Control (RBAC) in a Claims Aware ASP.NET Application Using WIF and ACS](https://go.microsoft.com/fwlink/?LinkID=247445).</span></span>  
  
- <span data-ttu-id="ecc68-154">**使用 samlSecurityTokenRequirement 組態區段將任意宣告對應至角色類型**：這是一種宣告式做法，可以僅使用組態來轉換宣告，不必撰寫任何程式碼。</span><span class="sxs-lookup"><span data-stu-id="ecc68-154">**Mapping arbitrary claims to a role type using the samlSecurityTokenRequirement configuration section**—A declarative approach where the claims transformation is done using only the configuration and no coding is required.</span></span>  
  
<a name="BKMK_2"></a>   
## <a name="claims-based-authorization"></a><span data-ttu-id="ecc68-155">宣告式授權</span><span class="sxs-lookup"><span data-stu-id="ecc68-155">Claims-based Authorization</span></span>  
 <span data-ttu-id="ecc68-156">宣告式授權這種方式所遵循的邏輯是憑藉宣告中的可用資料，來決定是否要授與存取權限。</span><span class="sxs-lookup"><span data-stu-id="ecc68-156">Claims-based authorization is an approach where the authorization decision to grant or deny access is based on arbitrary logic that uses data available in claims to make the decision.</span></span> <span data-ttu-id="ecc68-157">請回想 RBAC 的情況是將宣告當做角色類型宣告，</span><span class="sxs-lookup"><span data-stu-id="ecc68-157">Recall that in the case of RBAC, the only claim used was role type claim.</span></span> <span data-ttu-id="ecc68-158">並使用角色型別宣告檢查使用者是否屬於特定角色。</span><span class="sxs-lookup"><span data-stu-id="ecc68-158">A role type claim was used to check if the user belongs to specific role or not.</span></span> <span data-ttu-id="ecc68-159">下列步驟示範使用宣告式授權方式的授權決策制定流程：</span><span class="sxs-lookup"><span data-stu-id="ecc68-159">To illustrate the process of making the authorization decisions using claims-based authorization approach, consider the following steps:</span></span>  
  
1. <span data-ttu-id="ecc68-160">應用程式收到必須驗證使用者才能進行的要求。</span><span class="sxs-lookup"><span data-stu-id="ecc68-160">The application receives a request that requires the user is authenticated.</span></span>  
  
2. <span data-ttu-id="ecc68-161">WIF 將使用者重新導向至其識別提供者，當使用者通過驗證之後，應用程式隨即提出要求，其中包含表示使用者的相關安全性權杖，權杖內容則包含與使用者有關的宣告。</span><span class="sxs-lookup"><span data-stu-id="ecc68-161">WIF redirects the user to their identity provider, after they are authenticated the application request is made with an associated security token representing the user containing claims about them.</span></span> <span data-ttu-id="ecc68-162">WIF 將這些宣告與表示使用者的主體產生關聯。</span><span class="sxs-lookup"><span data-stu-id="ecc68-162">WIF associates those claims with the principal that represents the user.</span></span>  
  
3. <span data-ttu-id="ecc68-163">應用程式將宣告傳遞給決策邏輯機制。</span><span class="sxs-lookup"><span data-stu-id="ecc68-163">The application passes the claims to the decision logic mechanism.</span></span> <span data-ttu-id="ecc68-164">決策機制可以是記憶體內部的程式碼、Web 服務呼叫、資料庫查詢、複雜的規則引擎，或是使用 ClaimsAuthorizationManager。</span><span class="sxs-lookup"><span data-stu-id="ecc68-164">It can be in-memory code, a call to a web service, a query to a database, a sophisticated rules engine, or using the ClaimsAuthorizationManager.</span></span>  
  
4. <span data-ttu-id="ecc68-165">決策機制根據宣告計算結果。</span><span class="sxs-lookup"><span data-stu-id="ecc68-165">The decision mechanism calculates the outcome based on the claims.</span></span>  
  
5. <span data-ttu-id="ecc68-166">如果結果為 true 則授與存取權限，如果為 false 則拒絕存取。</span><span class="sxs-lookup"><span data-stu-id="ecc68-166">Access is granted if the outcome is true and denied if it is false.</span></span> <span data-ttu-id="ecc68-167">例如，規則可能是使用者必須年滿 21 歲，並且住在華盛頓州。</span><span class="sxs-lookup"><span data-stu-id="ecc68-167">For example, the rule might be that the user is of age 21 or above and lives in Washington State.</span></span>  
  
 <span data-ttu-id="ecc68-168">如果您希望利用外部的決策邏輯來處理應用程式中的宣告式授權，<xref:System.Security.Claims.ClaimsAuthorizationManager> 就很有用。</span><span class="sxs-lookup"><span data-stu-id="ecc68-168"><xref:System.Security.Claims.ClaimsAuthorizationManager> is useful for externalizing the decision logic for  claims-based authorization in your applications.</span></span> <span data-ttu-id="ecc68-169">ClaimsAuthorizationManager 是隨附於 .NET 4.5 的 WIF 元件，</span><span class="sxs-lookup"><span data-stu-id="ecc68-169">ClaimsAuthorizationManager is a WIF component that ships as part of .NET 4.5.</span></span> <span data-ttu-id="ecc68-170">可讓您擷取傳入要求並實作您選擇的邏輯，根據傳入宣告制定授權決策。</span><span class="sxs-lookup"><span data-stu-id="ecc68-170">ClaimsAuthorizationManager allows you to intercept incoming requests and implement any logic of your choice to make authorization decisions based on the incoming claims.</span></span> <span data-ttu-id="ecc68-171">如果必須變更授權邏輯，這就變得很重要。</span><span class="sxs-lookup"><span data-stu-id="ecc68-171">This becomes important when authorization logic needs to be changed.</span></span> <span data-ttu-id="ecc68-172">在這種情況下，使用 ClaimsAuthorizationManager 既不會影響應用程式的完整性，還可以降低變更結果導致應用程式錯誤的可能性。</span><span class="sxs-lookup"><span data-stu-id="ecc68-172">In that case, using ClaimsAuthorizationManager will not affect the application’s integrity, thereby reducing the likelihood of an application error as a result of the change.</span></span> <span data-ttu-id="ecc68-173">若要深入瞭解如何使用 ClaimsAuthorizationManager 來執行以宣告為基礎的存取控制， [請參閱如何：使用 WIF 和 ACS](https://go.microsoft.com/fwlink/?LinkID=247446)在宣告感知 ASP.NET 應用程式中執行宣告授權。</span><span class="sxs-lookup"><span data-stu-id="ecc68-173">To learn more about how to use ClaimsAuthorizationManager to implement claims-based access control, see [How To: Implement Claims Authorization in a Claims Aware ASP.NET Application Using WIF and ACS](https://go.microsoft.com/fwlink/?LinkID=247446).</span></span>
