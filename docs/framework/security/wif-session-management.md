---
title: WIF 工作階段管理
ms.date: 03/30/2017
ms.assetid: 98bce126-18a9-401b-b20d-67ee462a5f8a
author: BrucePerlerMS
ms.openlocfilehash: 980d0c6dca9b0b5fadf2d4a841e4c95a9acaff52
ms.sourcegitcommit: ea00c05e0995dae928d48ead99ddab6296097b4c
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/02/2018
ms.locfileid: "48035262"
---
# <a name="wif-session-management"></a><span data-ttu-id="ceb93-102">WIF 工作階段管理</span><span class="sxs-lookup"><span data-stu-id="ceb93-102">WIF Session Management</span></span>
<span data-ttu-id="ceb93-103">當用戶端第一次嘗試存取由信賴憑證者裝載的受保護資源時，用戶端必須先向信賴憑證者所信任的安全性權杖服務 (STS) 驗證其本身。</span><span class="sxs-lookup"><span data-stu-id="ceb93-103">When a client first tries to access a protected resource that is hosted by a relying party, the client must first authenticate itself to a security token service (STS) that is trusted by the relying party.</span></span> <span data-ttu-id="ceb93-104">接著，STS 會發出安全性權杖給用戶端。</span><span class="sxs-lookup"><span data-stu-id="ceb93-104">The STS then issues a security token to the client.</span></span> <span data-ttu-id="ceb93-105">用戶端將這個權杖出示給信賴憑證者後，信賴憑證者便可授與用戶端存取受保護資源的權限。</span><span class="sxs-lookup"><span data-stu-id="ceb93-105">The client presents this token to the relying party, which then grants the client access to the protected resource.</span></span> <span data-ttu-id="ceb93-106">不過，您不希望用戶端針對每個要求向 STS 重新進行驗證，特別是因為它還可能與信賴憑證者不在同一部電腦或同一個網域中。</span><span class="sxs-lookup"><span data-stu-id="ceb93-106">However, you don’t want the client to have to re-authenticate to the STS for each request, especially because it might not even be on the same computer or in the same domain as the relying party.</span></span> <span data-ttu-id="ceb93-107">相反地，Windows Identity Foundation (WIF) 會讓用戶端和信賴憑證者建立一個工作階段，用戶端可在其中針對第一個要求之後的所有要求，使用工作階段安全性權杖向信賴憑證者驗證其本身。</span><span class="sxs-lookup"><span data-stu-id="ceb93-107">Instead, Windows Identity Foundation (WIF) has the client and relying party establish a session in which the client uses a session security token to authenticate itself to the relying party for all requests after the first request.</span></span> <span data-ttu-id="ceb93-108">信賴憑證者可以使用儲存在 Cookie 內的這個工作階段安全性權杖，用來重新建構用戶端的 <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="ceb93-108">The relying party can use this session security token, which is stored inside a cookie, to reconstruct the client’s <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ceb93-109">STS 會定義用戶端必須提供的驗證。</span><span class="sxs-lookup"><span data-stu-id="ceb93-109">The STS defines what authentication the client must provide.</span></span> <span data-ttu-id="ceb93-110">不過，用戶端可能會有多個可用來向 STS 驗證其本身的認證。</span><span class="sxs-lookup"><span data-stu-id="ceb93-110">However, the client might have multiple credentials with which it can authenticate itself to the STS.</span></span> <span data-ttu-id="ceb93-111">例如，它可能會有來自 Windows Live 的權杖、使用者名稱和密碼、憑證以及智慧金鑰。</span><span class="sxs-lookup"><span data-stu-id="ceb93-111">For example, it might have a token from Windows Live, a user name and password, a certificate, and a smartkey.</span></span> <span data-ttu-id="ceb93-112">在此情況下，STS 會授與用戶端數個身分識別，其中每個身分識別對應到用戶端出示的其中一個認證。</span><span class="sxs-lookup"><span data-stu-id="ceb93-112">In that case, the STS grants the client several identities, with each identity corresponding to one of the credentials that the client presents.</span></span> <span data-ttu-id="ceb93-113">信賴憑證者決定授與用戶端的存取層級時，可以使用一或多個這些身分識別。</span><span class="sxs-lookup"><span data-stu-id="ceb93-113">The relying party can use one or more of these identities when it decides what level of access to grant the client.</span></span>  
  
 <span data-ttu-id="ceb93-114"><xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType> 用來重新建構用戶端的 <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>，後者包含 <xref:System.Security.Claims.ClaimsPrincipal.Identities%2A> 中的所有用戶端身分識別。</span><span class="sxs-lookup"><span data-stu-id="ceb93-114">The <xref:System.IdentityModel.Tokens.SessionSecurityToken?displayProperty=nameWithType> is used to reconstruct the client’s <xref:System.Security.Claims.ClaimsPrincipal?displayProperty=nameWithType>, which contains all of the client’s identities in <xref:System.Security.Claims.ClaimsPrincipal.Identities%2A>.</span></span> <span data-ttu-id="ceb93-115">集合中的每個 <xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType> 都包含與該身分識別建立關聯的啟動程序權杖。</span><span class="sxs-lookup"><span data-stu-id="ceb93-115">Each <xref:System.Security.Claims.ClaimsIdentity?displayProperty=nameWithType> in the collection contains the bootstrap tokens that are associated with that identity.</span></span>  
  
 <span data-ttu-id="ceb93-116">如果發出新的工作階段權杖時使用原始工作階段權杖的工作階段識別碼，<xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType> 不會更新權杖快取中的工作階段權杖。</span><span class="sxs-lookup"><span data-stu-id="ceb93-116">If a new session token is issued with the session ID of the original session token, <xref:System.IdentityModel.Tokens.SessionSecurityTokenHandler?displayProperty=nameWithType> does not update the session token in the token cache.</span></span> <span data-ttu-id="ceb93-117">將工作階段權杖具現化時，應該一律使用唯一的工作階段識別碼。</span><span class="sxs-lookup"><span data-stu-id="ceb93-117">You should always instantiate a session token with a unique session ID.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ceb93-118">如果 Session.SecurityTokenHandler.ReadToken 收到無效的輸入(比方說，如果包含工作階段權杖的 Cookie 已損毀)，便會擲回 <xref:System.Xml.XmlException> 例外狀況。</span><span class="sxs-lookup"><span data-stu-id="ceb93-118">Session.SecurityTokenHandler.ReadToken throws a <xref:System.Xml.XmlException> exception if it receives invalid input; for example, if the cookie that contains the session token is corrupted.</span></span> <span data-ttu-id="ceb93-119">建議您攔截此例外狀況，並提供特定應用程式行為。</span><span class="sxs-lookup"><span data-stu-id="ceb93-119">We recommend that you catch this exception and provide application-specific behavior.</span></span>  
  
 <span data-ttu-id="ceb93-120">如果受保護的網頁包含同樣也位於受保護網域的大量資源 (例如小型圖形)，用戶端必須向信賴憑證者重新驗證其本身，以便下載這些資源。</span><span class="sxs-lookup"><span data-stu-id="ceb93-120">If a protected Web page contains lots of resources (such as small graphics) that are also in the protected domain, the client must re-authenticate itself to the relying party to download each of those resources.</span></span> <span data-ttu-id="ceb93-121">使用工作階段驗證權杖可避免需要針對每個要求向 STS 進行驗證，但這仍然意味著要傳送許多 Cookie。</span><span class="sxs-lookup"><span data-stu-id="ceb93-121">Use of a session authentication token avoids the need to authenticate to the STS for each request, but it still means that many cookies are being sent over.</span></span> <span data-ttu-id="ceb93-122">您可以設定網頁，讓重要資料和資源儲存在受保護的網域中，同時將次要項目儲存在未受保護的網域，並從主要網頁加以連結。</span><span class="sxs-lookup"><span data-stu-id="ceb93-122">You might want to set up the Web page so that the important data and resources are stored in the protected domain while minor items are stored in an unprotected domain and linked to from the main Web page.</span></span> <span data-ttu-id="ceb93-123">此外，請將 Cookie 路徑設定為只參考受保護的網域。</span><span class="sxs-lookup"><span data-stu-id="ceb93-123">Also, set the cookie path to reference only the protected domain.</span></span>  
  
 <span data-ttu-id="ceb93-124">若要在參考模式中運作，Microsoft 建議您在 **global.asax.cs** 檔案中提供 <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated> 事件的處理常式，並在 <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A> 屬性所傳遞的權杖上設定 **IsReferenceMode** 屬性。</span><span class="sxs-lookup"><span data-stu-id="ceb93-124">To operate in reference mode, Microsoft recommends providing a handler for the <xref:System.IdentityModel.Services.WSFederationAuthenticationModule.SessionSecurityTokenCreated> event in the **global.asax.cs** file and setting the **IsReferenceMode** property on the token passed in the <xref:System.IdentityModel.Services.SessionSecurityTokenCreatedEventArgs.SessionToken%2A> property.</span></span> <span data-ttu-id="ceb93-125">這些更新可確保工作階段權杖會針對每個要求在參考模式中運作，並且只要設定工作階段驗證模組上的 <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> 屬性就能優先使用。</span><span class="sxs-lookup"><span data-stu-id="ceb93-125">These updates will ensure that the session token operates in reference mode for every request and is favored over merely setting the  <xref:System.IdentityModel.Services.SessionAuthenticationModule.IsReferenceMode%2A> property on the Session Authentication Module.</span></span>  
  
## <a name="extensibility"></a><span data-ttu-id="ceb93-126">擴充性</span><span class="sxs-lookup"><span data-stu-id="ceb93-126">Extensibility</span></span>  
 <span data-ttu-id="ceb93-127">您可以擴充工作階段管理機制。</span><span class="sxs-lookup"><span data-stu-id="ceb93-127">You can extend the session management mechanism.</span></span> <span data-ttu-id="ceb93-128">進行此操作的其中一個原因是為了改善效能。</span><span class="sxs-lookup"><span data-stu-id="ceb93-128">One reason for this would be to improve the performance.</span></span> <span data-ttu-id="ceb93-129">例如，您可以建立自訂的 Cookie 處理常式，以便在其記憶體內部狀態與 Cookie 傳入內容之間轉換或最佳化工作階段安全性權杖。</span><span class="sxs-lookup"><span data-stu-id="ceb93-129">For example, you could create a custom cookie handler that transforms or optimizes the session security token between its in-memory state and what goes into the cookie.</span></span> <span data-ttu-id="ceb93-130">若要這樣做，您可以設定 <xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType> 的 <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType> 屬性來使用衍生自 <xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType> 的自訂 Cookie 處理常式。</span><span class="sxs-lookup"><span data-stu-id="ceb93-130">To do so, you can configure the <xref:System.IdentityModel.Services.SessionAuthenticationModule.CookieHandler%2A?displayProperty=nameWithType> property of the <xref:System.IdentityModel.Services.SessionAuthenticationModule?displayProperty=nameWithType> to use a custom cookie handler that derives from <xref:System.IdentityModel.Services.CookieHandler?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ceb93-131">由於 Cookie 超過超文字傳輸通訊協定 (HTTP) 所允許的大小，因此 <xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType> 是預設的 Cookie 處理常式；如果您改為使用自訂的 Cookie 處理常式，則必須實作區塊處理。</span><span class="sxs-lookup"><span data-stu-id="ceb93-131"><xref:System.IdentityModel.Services.ChunkedCookieHandler?displayProperty=nameWithType> is the default cookie handler because the cookies exceed the allowable size for Hypertext Transfer Protocol (HTTP); if you use a custom cookie handler instead, you must implement chunking.</span></span>  
  
 <span data-ttu-id="ceb93-132">如需詳細資訊，請參閱 < [ClaimsAwareWebFarm](https://go.microsoft.com/fwlink/?LinkID=248408)範例。</span><span class="sxs-lookup"><span data-stu-id="ceb93-132">For more information, see [ClaimsAwareWebFarm](https://go.microsoft.com/fwlink/?LinkID=248408) sample.</span></span> <span data-ttu-id="ceb93-133">此範例示範伺服陣列就緒的工作階段快取 (相對於 tokenreplycache)，讓您能夠透過參考使用工作階段，而非交換大型 Cookie；此範例也示範了一種更簡單的方法，用來保護伺服陣列中的 Cookie。</span><span class="sxs-lookup"><span data-stu-id="ceb93-133">This sample shows a farm ready session cache (as opposed to a tokenreplycache) so that you can use sessions by reference instead of exchanging big cookies; this sample also demonstrates an easier way of securing cookies in a farm.</span></span> <span data-ttu-id="ceb93-134">工作階段快取是以 WCF 為基礎。</span><span class="sxs-lookup"><span data-stu-id="ceb93-134">The session cache is WCF-based.</span></span> <span data-ttu-id="ceb93-135">關於工作階段保護，此範例示範了在 WIF 4.5 中根據 MachineKey 進行 Cookie 轉換的新功能，只要在 web.config 中貼上適當的程式碼片段，就能啟用此功能。此範例本身沒有「伺服陣列」，但它會示範要讓應用程式伺服陣列就緒所需執行的作業。</span><span class="sxs-lookup"><span data-stu-id="ceb93-135">With regard to session securing, the sample demonstrates a new capability in WIF 4.5 of a cookie transform based on MachineKey, which can be activated by simply pasting the appropriate snippet in the web.config. The sample itself is not "farmed", but it demonstrates what you need for making your app farm-ready.</span></span>
