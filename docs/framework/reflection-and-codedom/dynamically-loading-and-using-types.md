---
title: 動態載入和使用類型
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
- cpp
helpviewer_keywords:
- late binding, about late binding
- early binding
- dynamically loading and using types
- implicit late binding
- reflection, dynamically using types
ms.assetid: db985bec-5942-40ec-b13a-771ae98623dc
ms.openlocfilehash: 940f334ec6a42c4d8da461d634051ff979b8f98d
ms.sourcegitcommit: 559fcfbe4871636494870a8b716bf7325df34ac5
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/30/2019
ms.locfileid: "73130258"
---
# <a name="dynamically-loading-and-using-types"></a><span data-ttu-id="6bd0f-102">動態載入和使用類型</span><span class="sxs-lookup"><span data-stu-id="6bd0f-102">Dynamically Loading and Using Types</span></span>
<span data-ttu-id="6bd0f-103">反映會提供語言編譯器所使用的基礎結構，以實作隱含晚期繫結。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-103">Reflection provides infrastructure used by language compilers to implement implicit late binding.</span></span> <span data-ttu-id="6bd0f-104">繫結是尋找對應至唯一指定的類型宣告 (也就是實作) 的程序。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-104">Binding is the process of locating the declaration (that is, the implementation) that corresponds to a uniquely specified type.</span></span> <span data-ttu-id="6bd0f-105">當此程序發生在執行階段，而不是在編譯時期時，它稱為晚期繫結。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-105">When this process occurs at run time rather than at compile time, it is called late binding.</span></span> <span data-ttu-id="6bd0f-106">Visual Basic 可讓您在程式碼內使用隱含晚期繫結；Visual Basic 編譯器會呼叫 Helper 方法，它會使用反映來取得物件類型。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-106">Visual Basic allows you to use implicit late binding in your code; the Visual Basic compiler calls a helper method that uses reflection to obtain the object type.</span></span> <span data-ttu-id="6bd0f-107">傳遞至 helper 方法的引數會導致在執行階段叫用適當的方法。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-107">The arguments passed to the helper method cause the appropriate method to be invoked at run time.</span></span> <span data-ttu-id="6bd0f-108">這些引數是在其上叫用方法的執行個體 (物件)、被叫用方法的名稱 (字串)，以及傳遞給被叫用方法的引數 (物件陣列)。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-108">These arguments are the instance (an object) on which to invoke the method, the name of the invoked method (a string), and the arguments passed to the invoked method (an array of objects).</span></span>  
  
 <span data-ttu-id="6bd0f-109">在下列範例中，Visual Basic 編譯器會隱含地使用反映，對一個在編譯階段不知道其類型的物件呼叫方法。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-109">In the following example, the Visual Basic compiler uses reflection implicitly to call a method on an object whose type is not known at compile time.</span></span> <span data-ttu-id="6bd0f-110">**HelloWorld** 類別具有 **PrintHello** 方法，它會列印出 "Hello World" 並串連傳遞給 **PrintHello** 方法的部分文字。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-110">A **HelloWorld** class has a **PrintHello** method that prints out "Hello World" concatenated with some text that is passed to the **PrintHello** method.</span></span> <span data-ttu-id="6bd0f-111">在此範例中呼叫的 **PrintHello** 方法實際上是 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>；Visual Basic 程式碼允許叫用 **PrintHello** 方法，就彷彿已在編譯階段知道物件 (helloObj) 的類型 (早期繫結)，而不是執行階段知道 (晚期繫結)。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-111">The **PrintHello** method called in this example is actually a <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>; the Visual Basic code allows the **PrintHello** method to be invoked as if the type of the object (helloObj) were known at compile time (early binding) rather than at run time (late binding).</span></span>  
  
```vb
Module Hello  
    Sub Main()  
        ' Sets up the variable.  
        Dim helloObj As Object  
        ' Creates the object.  
        helloObj = new HelloWorld()  
        ' Invokes the print method as if it was early bound  
        ' even though it is really late bound.  
        helloObj.PrintHello("Visual Basic Late Bound")  
    End Sub  
End Module  
```  
  
## <a name="custom-binding"></a><span data-ttu-id="6bd0f-112">自訂繫結</span><span class="sxs-lookup"><span data-stu-id="6bd0f-112">Custom Binding</span></span>  
 <span data-ttu-id="6bd0f-113">除了編譯器隱含地用來進行晚期繫結，反映也可明確地用於程式碼，來完成晚期繫結。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-113">In addition to being used implicitly by compilers for late binding, reflection can be used explicitly in code to accomplish late binding.</span></span>  
  
 <span data-ttu-id="6bd0f-114">[Common Language Runtime](../../standard/clr.md) 支援多種程式設計語言，而這些語言的繫結規則不同。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-114">The [common language runtime](../../standard/clr.md) supports multiple programming languages, and the binding rules of these languages differ.</span></span> <span data-ttu-id="6bd0f-115">在早期繫結案例中，程式碼產生器可以完全控制這個繫結。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-115">In the early-bound case, code generators can completely control this binding.</span></span> <span data-ttu-id="6bd0f-116">不過，在透過反映的晚期繫結中，繫結必須受自訂繫結控制。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-116">However, in late binding through reflection, binding must be controlled by customized binding.</span></span> <span data-ttu-id="6bd0f-117"><xref:System.Reflection.Binder> 類別會提供成員選取和叫用的自訂控制。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-117">The <xref:System.Reflection.Binder> class provides custom control of member selection and invocation.</span></span>  
  
 <span data-ttu-id="6bd0f-118">您可以使用自訂繫結，在執行階段載入組件、取得該組件中的類型相關資訊、指定您要的類型，然後對該類型叫用方法或存取欄位或屬性。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-118">Using custom binding, you can load an assembly at run time, obtain information about types in that assembly, specify the type that you want, and then invoke methods or access fields or properties on that type.</span></span> <span data-ttu-id="6bd0f-119">這個技術非常有用，如果您在編譯時期不知道物件的類型，例如當物件類型取決於使用者輸入之時。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-119">This technique is useful if you do not know an object's type at compile time, such as when the object type is dependent on user input.</span></span>  
  
 <span data-ttu-id="6bd0f-120">下列範例將示範簡單的自訂繫結，它不提供任何引數類型轉換。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-120">The following example demonstrates a simple custom binder that provides no argument type conversion.</span></span> <span data-ttu-id="6bd0f-121">`Simple_Type.dll` 的程式碼在主要範例之前。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-121">Code for `Simple_Type.dll` precedes the main example.</span></span> <span data-ttu-id="6bd0f-122">請務必建置 `Simple_Type.dll`，然後在建置階段的專案中包含對它的參考。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-122">Be sure to build `Simple_Type.dll` and then include a reference to it in the project at build time.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#1](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source1.cpp#1)]
 [!code-csharp[Conceptual.Types.Dynamic#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source1.cs#1)]
 [!code-vb[Conceptual.Types.Dynamic#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source1.vb#1)]  
  
### <a name="invokemember-and-createinstance"></a><span data-ttu-id="6bd0f-123">InvokeMember 和 CreateInstance</span><span class="sxs-lookup"><span data-stu-id="6bd0f-123">InvokeMember and CreateInstance</span></span>  
 <span data-ttu-id="6bd0f-124">使用 <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> 來叫用類型的成員。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-124">Use <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> to invoke a member of a type.</span></span> <span data-ttu-id="6bd0f-125">各種類別的 **CreateInstance** 方法，例如 <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>，是 **InvokeMember** 的特殊形式，會建立指定類型的新執行個體。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-125">The **CreateInstance** methods of various classes, such as <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.CreateInstance%2A?displayProperty=nameWithType>, are specialized forms of **InvokeMember** that create new instances of the specified type.</span></span> <span data-ttu-id="6bd0f-126">**Binder** 類別用來在這些方法中進行多載解析和引數強制型轉。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-126">The **Binder** class is used for overload resolution and argument coercion in these methods.</span></span>  
  
 <span data-ttu-id="6bd0f-127">下列範例顯示引數強制型轉 (類型轉換) 和成員選取的三種可能組合。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-127">The following example shows the three possible combinations of argument coercion (type conversion) and member selection.</span></span> <span data-ttu-id="6bd0f-128">案例 1 中不需要任何引數強制型轉或成員選取。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-128">In Case 1, no argument coercion or member selection is needed.</span></span> <span data-ttu-id="6bd0f-129">案例 2 中只需要成員選取。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-129">In Case 2, only member selection is needed.</span></span> <span data-ttu-id="6bd0f-130">案例 3 中只需要引數強制型轉。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-130">In Case 3, only argument coercion is needed.</span></span>  
  
 [!code-cpp[Conceptual.Types.Dynamic#2](../../../samples/snippets/cpp/VS_Snippets_CLR/conceptual.types.dynamic/cpp/source2.cpp#2)]
 [!code-csharp[Conceptual.Types.Dynamic#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.types.dynamic/cs/source2.cs#2)]
 [!code-vb[Conceptual.Types.Dynamic#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.types.dynamic/vb/source2.vb#2)]  
  
 <span data-ttu-id="6bd0f-131">有多個相同名稱的成員可用時，需要多載解析。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-131">Overload resolution is needed when more than one member with the same name is available.</span></span> <span data-ttu-id="6bd0f-132"><xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> 方法用來解析對單一成員的繫結。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-132">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.BindToField%2A?displayProperty=nameWithType> methods are used to resolve binding to a single member.</span></span> <span data-ttu-id="6bd0f-133">**Binder.BindToMethod** 也透過 **get** 和 **set** 屬性存取子提供屬性解析。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-133">**Binder.BindToMethod** also provides property resolution through the **get** and **set** property accessors.</span></span>  
  
 <span data-ttu-id="6bd0f-134">**BindToMethod** 會傳回要叫用的 <xref:System.Reflection.MethodBase>，如果不可能進行這種叫用則傳回 null 參考 (在 Visual Basic 中為 **Nothing**)。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-134">**BindToMethod** returns the <xref:System.Reflection.MethodBase> to invoke, or a null reference (**Nothing** in Visual Basic) if no such invocation is possible.</span></span> <span data-ttu-id="6bd0f-135">**MethodBase** 傳回值不一定要是 *match* 參數中所包含的其中一者，雖然這是常見的情況。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-135">The **MethodBase** return value need not be one of those contained in the *match* parameter, although that is the usual case.</span></span>  
  
 <span data-ttu-id="6bd0f-136">有 ByRef 引數存在時，呼叫端可能會想要取回它們。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-136">When ByRef arguments are present, the caller might want to get them back.</span></span> <span data-ttu-id="6bd0f-137">因此，**Binder** 允許用戶端將引數的陣列對應回其原始形式，如果 **BindToMethod** 已操作引數陣列的話。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-137">Therefore, **Binder** allows a client to map the array of arguments back to its original form if **BindToMethod** has manipulated the argument array.</span></span> <span data-ttu-id="6bd0f-138">若要這樣做，必須向呼叫端保證，引數的順序不變。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-138">In order to do this, the caller must be guaranteed that the order of the arguments is unchanged.</span></span> <span data-ttu-id="6bd0f-139">依名稱傳遞引數時，**Binder** 會重新排列引數陣列，那也是呼叫端看到的情況。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-139">When arguments are passed by name, **Binder** reorders the argument array, and that is what the caller sees.</span></span> <span data-ttu-id="6bd0f-140">如需詳細資訊，請參閱<xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-140">For more information, see <xref:System.Reflection.Binder.ReorderArgumentArray%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="6bd0f-141">可用成員的集合是在類型或任何基底類型中定義的成員。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-141">The set of available members are those members defined in the type or any base type.</span></span> <span data-ttu-id="6bd0f-142">如果指定 <xref:System.Reflection.BindingFlags>，則會在集合中傳回任何存取範圍的成員。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-142">If <xref:System.Reflection.BindingFlags> is specified, members of any accessibility will be returned in the set.</span></span> <span data-ttu-id="6bd0f-143">如果未指定 **BindingFlags.NonPublic**，繫結器必須強制執行存取範圍規則。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-143">If **BindingFlags.NonPublic** is not specified, the binder must enforce accessibility rules.</span></span> <span data-ttu-id="6bd0f-144">指定 **Public** 或 **NonPublic** 繫結旗標時，您也必須指定 **Instance** 或 **Static** 繫結旗標，否則不會傳回任何成員。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-144">When specifying the **Public** or **NonPublic** binding flag, you must also specify the **Instance** or **Static** binding flag, or no members will be returned.</span></span>  
  
 <span data-ttu-id="6bd0f-145">如果指定名稱的成員只有一個，便不需要回呼，會對該方法進行任何繫結。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-145">If there is only one member of the given name, no callback is necessary, and binding is done on that method.</span></span> <span data-ttu-id="6bd0f-146">程式碼範例的案例 1 將說明這一點：只有一個 **PrintBob** 方法可用，因此不需要回呼。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-146">Case 1 of the code example illustrates this point: Only one **PrintBob** method is available, and therefore no callback is needed.</span></span>  
  
 <span data-ttu-id="6bd0f-147">如果可用的集合中有多個成員，這些方法全都會傳遞至 **BindToMethod**，它會選取適當的方法，並傳回它。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-147">If there is more than one member in the available set, all these methods are passed to **BindToMethod**, which selects the appropriate method and returns it.</span></span> <span data-ttu-id="6bd0f-148">在程式碼範例的案例 2 中，有兩個方法，名為 **PrintValue**。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-148">In Case 2 of the code example, there are two methods named **PrintValue**.</span></span> <span data-ttu-id="6bd0f-149">呼叫 **BindToMethod** 會選取適當的方法。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-149">The appropriate method is selected by the call to **BindToMethod**.</span></span>  
  
 <span data-ttu-id="6bd0f-150"><xref:System.Reflection.Binder.ChangeType%2A> 會執行引數強制型轉 (類型轉換)，這會將實際引數轉換為所選方法的正式引數的類型。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-150"><xref:System.Reflection.Binder.ChangeType%2A> performs argument coercion (type conversion), which converts the actual arguments to the type of the formal arguments of the selected method.</span></span> <span data-ttu-id="6bd0f-151">即使類型完全相符，也會為每個引數呼叫 **ChangeType**。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-151">**ChangeType** is called for every argument even if the types match exactly.</span></span>  
  
 <span data-ttu-id="6bd0f-152">程式碼範例的案例 3 中，類型 **String** 的實際引數以及值 "5.5" 會傳遞至具有類型 **Double** 的型式引數的方法。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-152">In Case 3 of the code example, an actual argument of type **String** with a value of "5.5" is passed to a method with a formal argument of type **Double**.</span></span> <span data-ttu-id="6bd0f-153">叫用要成功，字串值 "5.5" 必須轉換為雙精度浮點數值。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-153">For the invocation to succeed, the string value "5.5" must be converted to a double value.</span></span> <span data-ttu-id="6bd0f-154">**ChangeType** 會執行這項轉換。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-154">**ChangeType** performs this conversion.</span></span>  
  
 <span data-ttu-id="6bd0f-155">**ChangeType** 只能執行不失真或[擴展強制型轉](../../standard/base-types/type-conversion.md)，如下表所示。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-155">**ChangeType** performs only lossless or [widening coercions](../../standard/base-types/type-conversion.md), as shown in the following table.</span></span>  
  
|<span data-ttu-id="6bd0f-156">來源類型</span><span class="sxs-lookup"><span data-stu-id="6bd0f-156">Source type</span></span>|<span data-ttu-id="6bd0f-157">目標類型</span><span class="sxs-lookup"><span data-stu-id="6bd0f-157">Target type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="6bd0f-158">任何類型</span><span class="sxs-lookup"><span data-stu-id="6bd0f-158">Any type</span></span>|<span data-ttu-id="6bd0f-159">基底類型</span><span class="sxs-lookup"><span data-stu-id="6bd0f-159">Its base type</span></span>|  
|<span data-ttu-id="6bd0f-160">任何類型</span><span class="sxs-lookup"><span data-stu-id="6bd0f-160">Any type</span></span>|<span data-ttu-id="6bd0f-161">實作的介面</span><span class="sxs-lookup"><span data-stu-id="6bd0f-161">Interface it implements</span></span>|  
|<span data-ttu-id="6bd0f-162">Char</span><span class="sxs-lookup"><span data-stu-id="6bd0f-162">Char</span></span>|<span data-ttu-id="6bd0f-163">UInt16、UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="6bd0f-163">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="6bd0f-164">Byte</span><span class="sxs-lookup"><span data-stu-id="6bd0f-164">Byte</span></span>|<span data-ttu-id="6bd0f-165">Char、UInt16、Int16、UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="6bd0f-165">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="6bd0f-166">SByte</span><span class="sxs-lookup"><span data-stu-id="6bd0f-166">SByte</span></span>|<span data-ttu-id="6bd0f-167">Int16、Int32、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="6bd0f-167">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="6bd0f-168">UInt16</span><span class="sxs-lookup"><span data-stu-id="6bd0f-168">UInt16</span></span>|<span data-ttu-id="6bd0f-169">UInt32、Int32、UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="6bd0f-169">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="6bd0f-170">Int16</span><span class="sxs-lookup"><span data-stu-id="6bd0f-170">Int16</span></span>|<span data-ttu-id="6bd0f-171">Int32、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="6bd0f-171">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="6bd0f-172">UInt32</span><span class="sxs-lookup"><span data-stu-id="6bd0f-172">UInt32</span></span>|<span data-ttu-id="6bd0f-173">UInt64、Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="6bd0f-173">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="6bd0f-174">Int32</span><span class="sxs-lookup"><span data-stu-id="6bd0f-174">Int32</span></span>|<span data-ttu-id="6bd0f-175">Int64、Single、Double</span><span class="sxs-lookup"><span data-stu-id="6bd0f-175">Int64, Single, Double</span></span>|  
|<span data-ttu-id="6bd0f-176">UInt64</span><span class="sxs-lookup"><span data-stu-id="6bd0f-176">UInt64</span></span>|<span data-ttu-id="6bd0f-177">Single、Double</span><span class="sxs-lookup"><span data-stu-id="6bd0f-177">Single, Double</span></span>|  
|<span data-ttu-id="6bd0f-178">Int64</span><span class="sxs-lookup"><span data-stu-id="6bd0f-178">Int64</span></span>|<span data-ttu-id="6bd0f-179">Single、Double</span><span class="sxs-lookup"><span data-stu-id="6bd0f-179">Single, Double</span></span>|  
|<span data-ttu-id="6bd0f-180">Single</span><span class="sxs-lookup"><span data-stu-id="6bd0f-180">Single</span></span>|<span data-ttu-id="6bd0f-181">Double</span><span class="sxs-lookup"><span data-stu-id="6bd0f-181">Double</span></span>|  
|<span data-ttu-id="6bd0f-182">非參考類型</span><span class="sxs-lookup"><span data-stu-id="6bd0f-182">Nonreference type</span></span>|<span data-ttu-id="6bd0f-183">參考型別</span><span class="sxs-lookup"><span data-stu-id="6bd0f-183">Reference type</span></span>|  
  
 <span data-ttu-id="6bd0f-184"><xref:System.Type> 類別具有 **Get** 方法，使用類型 **Binder** 的參數來解析對特定成員的參考。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-184">The <xref:System.Type> class has **Get** methods that use parameters of type **Binder** to resolve references to a particular member.</span></span> <span data-ttu-id="6bd0f-185"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>、<xref:System.Type.GetMethod%2A?displayProperty=nameWithType> 和 <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> 會搜尋目前類型的特定成員，方法是提供該成員的簽章資訊。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-185"><xref:System.Type.GetConstructor%2A?displayProperty=nameWithType>, <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, and <xref:System.Type.GetProperty%2A?displayProperty=nameWithType> search for a particular member of the current type by providing signature information for that member.</span></span> <span data-ttu-id="6bd0f-186">接著回來呼叫 <xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> 和 <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType>，選取適當方法的指定簽章資訊。</span><span class="sxs-lookup"><span data-stu-id="6bd0f-186"><xref:System.Reflection.Binder.SelectMethod%2A?displayProperty=nameWithType> and <xref:System.Reflection.Binder.SelectProperty%2A?displayProperty=nameWithType> are called back on to select the given signature information of the appropriate methods.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="6bd0f-187">請參閱</span><span class="sxs-lookup"><span data-stu-id="6bd0f-187">See also</span></span>

- <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>
- <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>
- [<span data-ttu-id="6bd0f-188">檢視類型資訊</span><span class="sxs-lookup"><span data-stu-id="6bd0f-188">Viewing Type Information</span></span>](viewing-type-information.md)
- [<span data-ttu-id="6bd0f-189">.NET Framework 中的型別轉換</span><span class="sxs-lookup"><span data-stu-id="6bd0f-189">Type Conversion in the .NET Framework</span></span>](../../standard/base-types/type-conversion.md)
